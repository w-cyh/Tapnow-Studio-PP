// 全局屏蔽滚轮事件相关的控制台错误（在 React 渲染之前设置）
(function () {
    const originalError = console.error;
    const originalWarn = console.warn;
    const originalLog = console.log;

    const shouldFilter = (args) => {
        // 检查所有参数，包括字符串、对象、错误等
        for (let arg of args) {
            let msg = '';
            if (typeof arg === 'string') {
                msg = arg;
            } else if (arg && typeof arg === 'object') {
                // 检查错误对象的 message 属性
                if (arg.message) msg = arg.message;
                else if (arg.toString) msg = arg.toString();
                else msg = JSON.stringify(arg);
            } else if (arg != null) {
                msg = String(arg);
            }

            // 精确匹配 passive 事件监听器相关的错误
            if (msg.includes('Unable to preventDefault inside passive event listener') ||
                msg.includes('passive event listener invocation') ||
                (msg.includes('preventDefault') && msg.includes('passive'))) {
                return true;
            }
        }
        return false;
    };

    console.error = function (...args) {
        if (shouldFilter(args)) return;
        originalError.apply(console, args);
    };

    console.warn = function (...args) {
        if (shouldFilter(args)) return;
        originalWarn.apply(console, args);
    };

    console.log = function (...args) {
        if (shouldFilter(args)) return;
        originalLog.apply(console, args);
    };
})();

import React, { useState, useRef, useEffect, useCallback, useMemo, memo } from 'react';
import { createPortal } from 'react-dom';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
// V3.5.20-1: Direct icon imports for better performance (eliminates wrapper overhead)
import {
    Plus, Image as ImageIcon, Video, Settings, X, Play, Layers, MousePointer2, Wand2, Loader2,
    Link as LinkIcon, History, ImagePlus, Trash2, Edit2, CheckCircle2, Square, Circle, Unlink, CopyPlus,
    ArrowRightSquare, MessageSquare, Send, Paperclip, FileText, FileAudio, FileVideo, FileImage,
    ChevronRight, ChevronLeft, MoreHorizontal, Bot, User, Users, GripVertical, Forward, RefreshCw,
    RotateCcw, RotateCw, Split, ChevronsUp, ChevronsDown, Maximize2, Sun, Moon, FileSearch,
    Sparkles, Mic, Mic2, Camera, Code, ClipboardCopy, Edit, LayoutGrid, Check, CheckSquare, Eye,
    Scissors, Layout, Download, Save, FolderOpen, Brush, Undo2, Eraser, HardDrive, ChevronDown, ChevronUp, UploadCloud,
    Monitor,
    Zap, // V3.5.24
    Ban, Clock, Edit3, Pencil // V3.7.24: API management buttons + V3.7.25: Edit icons
} from 'lucide-react';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import i18n from './i18n';

const DEFAULT_VIEW = { x: 0, y: 0, zoom: 1 };
const t = i18n.t.bind(i18n);


// --- MaskVisualFeedback 组件：蒙版视觉反馈层 ---
const MaskVisualFeedback = ({ canvasRef, isDrawing }) => {
    const [maskUrl, setMaskUrl] = useState('');
    const rafRef = useRef(null);

    const updateMask = useCallback(() => {
        if (canvasRef.current) {
            setMaskUrl(canvasRef.current.toDataURL());
        }
    }, [canvasRef]);

    // 初始更新
    useEffect(() => {
        if (!canvasRef.current) return;
        updateMask();
    }, [canvasRef, updateMask]);

    // 仅在绘制时使用 requestAnimationFrame 更新
    useEffect(() => {
        if (!isDrawing) {
            // 绘制结束时更新一次
            updateMask();
            return;
        }

        // 绘制中：使用 requestAnimationFrame 更新
        const animate = () => {
            updateMask();
            if (isDrawing) {
                rafRef.current = requestAnimationFrame(animate);
            }
        };

        rafRef.current = requestAnimationFrame(animate);

        return () => {
            if (rafRef.current) {
                cancelAnimationFrame(rafRef.current);
            }
        };
    }, [isDrawing, updateMask]);

    if (!maskUrl) return null;

    return (
        <div
            className="absolute inset-0 pointer-events-none"
            style={{
                background: 'rgba(255, 0, 0, 0.3)',
                mixBlendMode: 'multiply',
                WebkitMaskImage: `url(${maskUrl})`,
                maskImage: `url(${maskUrl})`,
                WebkitMaskSize: '100% 100%',
                maskSize: '100% 100%',
                WebkitMaskRepeat: 'no-repeat',
                maskRepeat: 'no-repeat',
            }}
        />
    );
};

// --- V3.5.16: LocalImageManager - IndexedDB-based image storage ---
// Replaces localStorage Base64 storage with IndexedDB for better performance and larger capacity
const LocalImageManager = (() => {
    const DB_NAME = 'tapnow_images_db';
    const DB_VERSION = 1;
    const STORE_NAME = 'images';
    let dbInstance = null;
    let dbInitPromise = null;
    const blobUrlCache = new Map(); // Cache: id -> blobUrl

    const initDB = () => {
        if (dbInitPromise) return dbInitPromise;

        dbInitPromise = new Promise((resolve, reject) => {
            if (!window.indexedDB) {
                console.warn('[LocalImageManager] IndexedDB not supported, falling back to memory');
                resolve(null);
                return;
            }

            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onerror = (event) => {
                console.error('[LocalImageManager] IndexedDB init failed:', event.target.error);
                resolve(null);
            };

            request.onsuccess = (event) => {
                dbInstance = event.target.result;
                console.log('[LocalImageManager] IndexedDB initialized');
                resolve(dbInstance);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                    console.log('[LocalImageManager] Object store created');
                }
            };
        });

        return dbInitPromise;
    };

    // Generate unique ID for image
    const generateId = () => `img_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

    // Save image (Base64 or Blob) to IndexedDB
    const saveImage = async (data, existingId = null) => {
        const db = await initDB();
        if (!db) return null;

        const id = existingId || generateId();

        return new Promise((resolve, reject) => {
            try {
                let blob;
                if (typeof data === 'string' && data.startsWith('data:')) {
                    // Convert Base64 to Blob
                    const parts = data.split(',');
                    const mime = parts[0].match(/:(.*?);/)?.[1] || 'image/png';
                    const binaryStr = atob(parts[1]);
                    const bytes = new Uint8Array(binaryStr.length);
                    for (let i = 0; i < binaryStr.length; i++) {
                        bytes[i] = binaryStr.charCodeAt(i);
                    }
                    blob = new Blob([bytes], { type: mime });
                } else if (data instanceof Blob) {
                    blob = data;
                } else {
                    console.warn('[LocalImageManager] Invalid data type for saveImage');
                    resolve(null);
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);

                const record = {
                    id,
                    blob,
                    timestamp: Date.now(),
                    size: blob.size
                };

                const request = store.put(record);

                request.onsuccess = () => {
                    resolve(id);
                };

                request.onerror = (event) => {
                    console.error('[LocalImageManager] Save failed:', event.target.error);
                    resolve(null);
                };
            } catch (err) {
                console.error('[LocalImageManager] Save error:', err);
                resolve(null);
            }
        });
    };

    // Get image as Blob URL from IndexedDB
    const getImage = async (id) => {
        // Check cache first
        if (blobUrlCache.has(id)) {
            return blobUrlCache.get(id);
        }

        const db = await initDB();
        if (!db) return null;

        return new Promise((resolve) => {
            try {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);

                request.onsuccess = () => {
                    const record = request.result;
                    if (record && record.blob) {
                        // V3.7.32 Fix: Use FileReader to return Base64 avoiding blob:null security error in file:// protocol
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            const base64 = reader.result;
                            blobUrlCache.set(id, base64);
                            resolve(base64);
                        };
                        reader.onerror = () => {
                            console.error('[LocalImageManager] Failed to convert blob to base64');
                            resolve(null);
                        };
                        reader.readAsDataURL(record.blob);
                    } else {
                        resolve(null);
                    }
                };

                request.onerror = () => resolve(null);
            } catch (err) {
                console.error('[LocalImageManager] Get error:', err);
                resolve(null);
            }
        });
    };

    // Delete image from IndexedDB
    const deleteImage = async (id) => {
        const db = await initDB();
        if (!db) return false;

        // Revoke cached blob URL (only if it is a blob url)
        if (blobUrlCache.has(id)) {
            const url = blobUrlCache.get(id);
            if (url && url.startsWith('blob:')) {
                URL.revokeObjectURL(url);
            }
            blobUrlCache.delete(id);
        }

        return new Promise((resolve) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.delete(id);
            request.onsuccess = () => resolve(true);
            request.onerror = () => resolve(false);
        });
    };

    // Get storage stats
    const getStats = async () => {
        const db = await initDB();
        if (!db) return { count: 0, totalSize: 0 };

        return new Promise((resolve) => {
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();

            request.onsuccess = () => {
                const records = request.result || [];
                const totalSize = records.reduce((sum, r) => sum + (r.size || 0), 0);
                resolve({ count: records.length, totalSize });
            };

            request.onerror = () => resolve({ count: 0, totalSize: 0 });
        });
    };

    // Check if ID is an image reference
    const isImageId = (str) => typeof str === 'string' && str.startsWith('img_');

    // V3.7.19: Removed auto-init on module load - now lazy-loaded on first use
    // initDB();

    return { saveImage, getImage, deleteImage, getStats, isImageId, initDB };
})();

// Expose for debugging
window.LocalImageManager = LocalImageManager;

const normalizeDataUrl = (value) => {
    if (!value || typeof value !== 'string') return value;
    if (!value.startsWith('data:')) return value;
    const cleaned = value.replace(/\s+/g, '');
    const match = cleaned.match(/^data:([^;,]+)(;base64)?,(.*)$/i);
    if (!match) return cleaned;
    const mime = match[1] || 'application/octet-stream';
    const isBase64 = !!match[2];
    if (!isBase64) return cleaned;
    const payload = normalizeBase64Payload(match[3] || '');
    if (!payload) return cleaned;
    return `data:${mime};base64,${payload}`;
};

const normalizeBase64Payload = (value) => {
    if (!value) return '';
    let cleaned = value.replace(/\s+/g, '');
    if (/%[0-9A-Fa-f]{2}/.test(cleaned)) {
        try {
            cleaned = decodeURIComponent(cleaned);
        } catch (e) {
            // Keep original when decode fails.
        }
    }
    cleaned = cleaned.replace(/-/g, '+').replace(/_/g, '/');
    cleaned = cleaned.replace(/[^A-Za-z0-9+/=]/g, '');
    const pad = cleaned.length % 4;
    if (pad) cleaned += '='.repeat(4 - pad);
    return cleaned;
};

const dataUrlToBlob = (dataUrl) => {
    const normalized = normalizeDataUrl(dataUrl);
    const match = normalized.match(/^data:([^;,]+)(;base64)?,(.*)$/i);
    if (!match) return null;
    const mime = match[1] || 'application/octet-stream';
    const isBase64 = !!match[2];
    let data = match[3] || '';
    if (!isBase64) {
        try {
            return new Blob([decodeURIComponent(data)], { type: mime });
        } catch (e) {
            return new Blob([data], { type: mime });
        }
    }
    data = normalizeBase64Payload(data);
    let binary = '';
    try {
        binary = atob(data);
    } catch (e) {
        return null;
    }
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return new Blob([bytes], { type: mime });
};

const truncateByBytes = (value, maxBytes) => {
    if (!value || !maxBytes || maxBytes <= 0) return value || '';
    const encoder = new TextEncoder();
    let used = 0;
    let output = '';
    for (const ch of value) {
        const size = encoder.encode(ch).length;
        if (used + size > maxBytes) break;
        output += ch;
        used += size;
    }
    if (output.length < value.length) return `${output}...`;
    return output;
};

// --- LazyBase64Image 组件：将 Base64 转换为 Blob URL 的智能图片组件 ---
const LazyBase64Image = ({ src, className, alt, onError, onLoad, ...props }) => {
    const [blobUrl, setBlobUrl] = useState(null);
    const [error, setError] = useState(false);
    const [loading, setLoading] = useState(false); // V3.5.39: Add loading state for IDB images
    const blobUrlRef = useRef(null);

    useEffect(() => {
        let active = true;
        // src 变更时先清空旧图，避免“新图未加载时仍显示上一张”
        if (blobUrlRef.current && blobUrlRef.current.startsWith('blob:')) {
            URL.revokeObjectURL(blobUrlRef.current);
        }
        blobUrlRef.current = null;
        setError(false);
        setBlobUrl(null);
        // 如果已经是 Blob URL 或 HTTP URL，直接使用
        if (!src || src.startsWith('blob:') || src.startsWith('http://') || src.startsWith('https://')) {
            if (active) {
                setBlobUrl(src);
                setLoading(false);
            }
            return () => { active = false; };
        }

        // V3.5.16: If it's an IndexedDB image reference (img_xxx), resolve it
        if (LocalImageManager.isImageId(src)) {
            // V3.5.39: Set loading state to prevent rendering invalid src
            setLoading(true);
            const resolveFromIDB = async () => {
                try {
                    const url = await LocalImageManager.getImage(src);
                    if (!active) return;
                    if (url) {
                        blobUrlRef.current = url;
                        setBlobUrl(url);
                    } else {
                        const fallback = getAssetBundleFallbackById(src);
                        if (fallback) {
                            blobUrlRef.current = fallback;
                            setBlobUrl(fallback);
                        } else {
                            console.warn(`[LazyBase64Image] Image not found in IDB: ${src}`);
                            setError(true);
                        }
                    }
                } catch (err) {
                    if (!active) return;
                    console.error('[LazyBase64Image] IDB resolve failed:', err);
                    setError(true);
                }
                if (active) setLoading(false);
            };
            resolveFromIDB();
            return () => { active = false; };
        }

        // 如果是 Base64 Data URL，优先直用（file:// 下避免 blob: 安全限制）
        if (src.startsWith('data:')) {
            const normalized = normalizeDataUrl(src);
            const isFileProtocol = typeof window !== 'undefined' && window.location?.protocol === 'file:';
            if (isFileProtocol) {
                if (active) {
                    blobUrlRef.current = normalized;
                    setBlobUrl(normalized);
                    setLoading(false);
                }
                return () => { active = false; };
            }
            const convertToBlobUrl = async () => {
                try {
                    const blob = dataUrlToBlob(normalized);
                    if (!active) return;
                    if (!blob) {
                        setError(true);
                        setBlobUrl(null);
                        return;
                    }
                    const url = URL.createObjectURL(blob);
                    blobUrlRef.current = url;
                    setBlobUrl(url);
                } catch (err) {
                    if (!active) return;
                    console.warn('Base64转Blob失败', err);
                    setError(true);
                    setBlobUrl(null);
                }
            };
            convertToBlobUrl();
        } else {
            setBlobUrl(src);
        }

        // 清理函数：组件卸载时释放 Blob URL
        return () => {
            active = false;
            if (blobUrlRef.current && blobUrlRef.current.startsWith('blob:')) {
                URL.revokeObjectURL(blobUrlRef.current);
                blobUrlRef.current = null;
            }
        };
    }, [src]);

    // V3.5.39: Don't render while loading IDB image to prevent 404 on "img_xxx"
    if (loading) {
        return null;
    }

    if (error && !blobUrl) {
        return null;
    }

    // V3.5.39: Only render if blobUrl is valid (not an img_xxx string)
    if (!blobUrl || LocalImageManager.isImageId(blobUrl)) {
        return null;
    }

    return (
        <img
            src={blobUrl}
            className={className}
            alt={alt}
            onError={onError}
            onLoad={onLoad}
            {...props}
        />
    );
};

const ResolvedVideo = ({ src, className, onError, onLoadedMetadata, ...props }) => {
    const [resolvedSrc, setResolvedSrc] = useState('');
    useEffect(() => {
        let active = true;
        setResolvedSrc('');
        if (!src) {
            return () => { active = false; };
        }
        if (LocalImageManager.isImageId(src)) {
            (async () => {
                const dataUrl = await LocalImageManager.getImage(src);
                if (!active) return;
                if (dataUrl) {
                    setResolvedSrc(dataUrl);
                } else {
                    const fallback = getAssetBundleFallbackById(src);
                    setResolvedSrc(fallback || '');
                }
            })();
            return () => { active = false; };
        }
        setResolvedSrc(src);
        return () => { active = false; };
    }, [src]);

    if (!resolvedSrc) return null;

    return (
        <video
            src={resolvedSrc}
            className={className}
            onError={onError}
            onLoadedMetadata={onLoadedMetadata}
            {...props}
        />
    );
};

const HistoryMjImageCell = memo(({
    item,
    idx,
    imgUrl,
    displayImgUrl,
    theme,
    canDrag,
    lightboxItem,
    onImageClick,
    onImageContextMenu,
    onCacheMissing,
    handleDragStart,
    language
}) => {
    const [isLoaded, setIsLoaded] = useState(false);

    useEffect(() => {
        setIsLoaded(false);
    }, [displayImgUrl]);

    const isActive = item.selectedMjImageIndex === idx && lightboxItem && lightboxItem.id === item.id;
    const placeholderClass = theme === 'dark' ? 'text-zinc-500' : 'text-[#616161]';

    return (
        <div
            onClick={(e) => onImageClick && onImageClick(e, item, imgUrl, idx)}
            onContextMenu={(e) => onImageContextMenu && onImageContextMenu(e, item, imgUrl, idx)}
            onDragStart={(e) => {
                if (!canDrag) return;
                e.stopPropagation();
                handleDragStart(e, imgUrl);
            }}
            draggable={canDrag}
            className={`relative w-full h-full cursor-pointer border-2 transition-all overflow-hidden ${isActive
                ? 'border-blue-500 scale-95'
                : 'border-transparent hover:border-blue-500/50'
                }`}
        >
            <LazyBase64Image
                src={displayImgUrl}
                loading="lazy"
                className="w-full h-full object-contain"
                alt=""
                onLoad={() => setIsLoaded(true)}
                onError={(e) => {
                    setIsLoaded(false);
                    console.error(`图片 ${idx + 1} 加载失败`);
                    onCacheMissing && onCacheMissing(item.id, displayImgUrl);
                    e.target.style.display = 'none';
                }}
            />
            {!isLoaded && (
                <div
                    className={`absolute inset-0 flex items-center justify-center text-[12px] ${placeholderClass} pointer-events-none select-none`}
                    style={{ fontFamily: '"Microsoft YaHei","微软雅黑","KaiTi","楷体",serif' }}
                >
                    {t('图片')}{idx + 1}
                </div>
            )}
            {isActive && (
                <div className="absolute top-1 right-1 w-3 h-3 bg-blue-500 rounded-full flex items-center justify-center z-10">
                    <svg className="w-2 h-2 text-white" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                    </svg>
                </div>
            )}
        </div>
    );
});

const TagListEditor = ({
    label,
    values,
    onChange,
    placeholder,
    addLabel = '+',
    formatItem = (value) => value,
    disabled = false,
    inputDisabled = false,
    theme = 'dark',
    allowAll = false,
    allowAllLabel = '',
    onToggleAll = null,
    normalizeItem = (value) => value,
    maxItems = Infinity
}) => {
    const [inputValue, setInputValue] = useState('');
    const list = Array.isArray(values) ? values : [];
    const listDisabled = disabled || inputDisabled;
    const maxCount = Number.isFinite(maxItems) ? maxItems : Infinity;
    const isMaxed = list.length >= maxCount;

    const addValues = () => {
        if (listDisabled) return;
        if (isMaxed) return;
        const raw = inputValue.trim();
        if (!raw) return;
        const parts = raw.split(',').map(part => part.trim()).filter(Boolean);
        if (parts.length === 0) return;
        const next = [...list];
        parts.forEach((part) => {
            const normalized = normalizeItem(part);
            if (next.length >= maxCount) return;
            if (normalized && !next.includes(normalized)) {
                next.push(normalized);
            }
        });
        onChange(next);
        setInputValue('');
    };

    const removeValue = (value) => {
        if (listDisabled) return;
        onChange(list.filter(item => item !== value));
    };

    return (
        <div className="space-y-1">
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                    <label className={`text-[9px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{label}</label>
                    {Number.isFinite(maxCount) && maxCount !== Infinity && (
                        <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>({list.length}/{maxCount})</span>
                    )}
                </div>
                {allowAllLabel && (
                    <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                        <input
                            type="checkbox"
                            checked={!!allowAll}
                            onChange={(e) => onToggleAll && onToggleAll(e.target.checked)}
                            disabled={disabled}
                        />
                        <span>{allowAllLabel}</span>
                    </label>
                )}
            </div>
            <div className="flex flex-wrap gap-1 min-h-[18px]">
                {list.length > 0 ? list.map((item) => (
                    <span
                        key={item}
                        className={`inline-flex items-center gap-1 px-1.5 py-0.5 rounded text-[9px] ${theme === 'dark'
                            ? 'bg-zinc-800 text-zinc-300'
                            : 'bg-zinc-100 text-zinc-600'
                            }`}
                    >
                        {formatItem(item)}
                        {!listDisabled && (
                            <button
                                onClick={() => removeValue(item)}
                                className={`${theme === 'dark' ? 'text-zinc-500 hover:text-red-400' : 'text-zinc-400 hover:text-red-500'}`}
                            >
                                x
                            </button>
                        )}
                    </span>
                )) : (
                    <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'}`}>未设置</span>
                )}
            </div>
            <div className="flex items-center gap-1">
                <input
                    type="text"
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            addValues();
                        }
                    }}
                    placeholder={placeholder}
                    disabled={listDisabled}
                    className={`flex-1 rounded px-2 py-1 text-[10px] outline-none border ${theme === 'dark'
                        ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                        : 'bg-white border-zinc-300 text-zinc-900'
                        }`}
                />
                <button
                    onClick={addValues}
                    disabled={listDisabled || !inputValue.trim() || isMaxed}
                    className={`px-2 py-1 rounded text-[10px] ${listDisabled || !inputValue.trim() || isMaxed
                        ? theme === 'dark'
                            ? 'bg-zinc-800 text-zinc-600 cursor-not-allowed'
                            : 'bg-zinc-100 text-zinc-400 cursor-not-allowed'
                        : theme === 'dark'
                            ? 'bg-zinc-700 text-zinc-200 hover:bg-zinc-600'
                            : 'bg-zinc-200 text-zinc-700 hover:bg-zinc-300'
                        }`}
                >
                    {addLabel}
                </button>
            </div>
        </div>
    );
};

// --- 极简艺术进度条组件 (Centered & Artistic) ---
const ArtisticProgress = ({ visible, progress, status, type }) => {
    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/40 backdrop-blur-[2px] animate-in fade-in duration-300 pointer-events-none select-none">
            <div className="relative bg-[#09090b]/90 border border-white/10 rounded-2xl p-8 shadow-2xl flex flex-col items-center min-w-[300px] backdrop-blur-xl">
                {/* 装饰性光晕 */}
                <div className="absolute -top-10 left-1/2 -translate-x-1/2 w-20 h-20 bg-blue-500/20 blur-[50px] rounded-full pointer-events-none" />

                {/* 标题与百分比 */}
                <div className="flex flex-col items-center gap-1 mb-6 z-10">
                    <span className="font-mono text-[10px] tracking-[0.3em] uppercase text-zinc-500">
                        {type === 'import' ? 'DATA INGESTION' : 'SYSTEM ARCHIVING'}
                    </span>
                    <div className="text-4xl font-bold text-zinc-200 tracking-tighter font-sans">
                        {progress.toFixed(0)}<span className="text-sm text-zinc-500 ml-1">%</span>
                    </div>
                </div>

                {/* 进度条轨道 */}
                <div className="relative w-full h-[2px] bg-zinc-800 rounded-full overflow-hidden mb-4">
                    <div
                        className="absolute top-0 left-0 h-full bg-white shadow-[0_0_10px_rgba(255,255,255,0.5)] transition-all duration-100 ease-linear"
                        style={{ width: `${progress}%` }}
                    />
                </div>

                {/* 状态文本 */}
                <span className="text-[10px] font-mono text-zinc-400 tracking-widest uppercase animate-pulse">
                    {status}
                </span>
            </div>
        </div>
    );
};

// --- HistoryItem 组件：历史记录项，使用 React.memo 优化 ---
const HistoryItem = memo(({
    item,
    theme,
    lightboxItem,
    onDelete,
    onClick,
    onContextMenu,
    onImageClick,
    onImageContextMenu,
    onRefresh,
    onRebuildThumbnail,
    performanceMode, // V2.6.1 Feature
    localServerUrl, // V2.6.1 Feature
    localCacheActive,
    onCacheMissing,
    getHistoryMeta,
    isSelected, // V3.4.16: 选择状态
    onSelect, // V3.4.16: 选择回调
    providers,
    defaultProviders,
    historyLocalCacheMap,
    resolveHistoryUrl,
    isLocalCacheUrlAvailable,
    language
}) => {
    const multiImages = Array.isArray(item.mjImages) && item.mjImages.length > 1
        ? item.mjImages
        : (Array.isArray(item.output_images) && item.output_images.length > 1 ? item.output_images : null);
    const primaryUrl = item.url || item.originalUrl || item.mjOriginalUrl || (multiImages && multiImages.length > 0 ? multiImages[0] : null);
    const mappedCacheUrl = localCacheActive && primaryUrl
        ? (historyLocalCacheMap && historyLocalCacheMap.has(primaryUrl)
            ? historyLocalCacheMap.get(primaryUrl)
            : (item.localCacheMap ? item.localCacheMap[primaryUrl] : null))
        : null;
    const localCacheFallback = mappedCacheUrl || item.localCacheUrl || (item.localCacheMap ? Object.values(item.localCacheMap)[0] : null);
    const hasLocalCache = !!(localCacheActive && localCacheFallback && (!isLocalCacheUrlAvailable || isLocalCacheUrlAvailable(localCacheFallback)));
    const thumbnailUrl = item.thumbnailUrl || null;
    const canDrag = isCompletedLikeStatus(item.status) && (item.type === 'image' || (multiImages && multiImages.length > 0));
    const historyMeta = getHistoryMeta ? getHistoryMeta(item) : null;
    const resolvedModelLabel = historyMeta?.modelLabel;
    const rawModelName = (() => {
        if (resolvedModelLabel) return resolvedModelLabel;
        const fallback = item.apiConfig?.modelId || item.apiConfig?.model || item.model || item.modelName || '未知模型';
        if (item.modelName && item.provider && item.modelName.toLowerCase() === item.provider.toLowerCase()) return fallback;
        return item.modelName || fallback;
    })();
    const displayModelName = truncateByBytes(rawModelName, 15);
    const providerTitle = item.provider || item.apiConfig?.provider || '';
    const modelTooltip = providerTitle ? `${providerTitle} / ${rawModelName}` : rawModelName;
    const getDisplayUrl = (originalUrl) => {
        if (hasLocalCache) return localCacheFallback;
        if (performanceMode !== 'off' && thumbnailUrl) return thumbnailUrl;
        return originalUrl;
    };
    const getResolvedDisplayUrl = (originalUrl) => {
        const raw = getDisplayUrl(originalUrl);
        if (resolveHistoryUrl) return resolveHistoryUrl(item, raw);
        return raw;
    };
    const [videoSrc, setVideoSrc] = useState(null);
    const resolveItemUrl = (specificUrl = null) => {
        if (resolveHistoryUrl) return resolveHistoryUrl(item, specificUrl);
        if (specificUrl) {
            if (localCacheActive && item.localCacheMap && item.localCacheMap[specificUrl]) {
                return item.localCacheMap[specificUrl];
            }
            return specificUrl;
        }
        return item.localCacheUrl || (item.localCacheMap ? Object.values(item.localCacheMap)[0] : '') || item.originalUrl || item.mjOriginalUrl || item.url || '';
    };
    const getDragUrl = (specificUrl = null) => {
        if (specificUrl) return resolveItemUrl(specificUrl);
        if (multiImages && multiImages.length > 0) {
            const index = item.selectedMjImageIndex ?? 0;
            const selected = multiImages[index] || multiImages[0];
            if (selected) return resolveItemUrl(selected);
        }
        return resolveItemUrl();
    };
    const getSelectedDragRawUrl = (specificUrl = null) => {
        if (specificUrl) return specificUrl;
        if (multiImages && multiImages.length > 0) {
            const rawIndex = Number.isInteger(item.selectedMjImageIndex) ? item.selectedMjImageIndex : 0;
            const clampedIndex = Math.max(0, Math.min(rawIndex, multiImages.length - 1));
            return multiImages[clampedIndex] || multiImages[0] || '';
        }
        return item.url || item.originalUrl || item.mjOriginalUrl || '';
    };
    const handleDragStart = (e, specificUrl = null) => {
        const selectedRawUrl = getSelectedDragRawUrl(specificUrl);
        const dragUrl = getDragUrl(selectedRawUrl || specificUrl);
        if (!dragUrl) return;
        const selectedIndex = (() => {
            if (!multiImages || multiImages.length === 0) return 0;
            if (selectedRawUrl) {
                const idx = multiImages.indexOf(selectedRawUrl);
                if (idx >= 0) return idx;
            }
            const rawIndex = Number.isInteger(item.selectedMjImageIndex) ? item.selectedMjImageIndex : 0;
            return Math.max(0, Math.min(rawIndex, multiImages.length - 1));
        })();
        const payload = {
            source: 'history',
            itemId: item.id,
            type: item.type || 'image',
            url: selectedRawUrl || dragUrl,
            originalUrl: item.originalUrl || item.mjOriginalUrl || item.url || dragUrl,
            mjOriginalUrl: item.mjOriginalUrl || item.originalUrl || item.url || dragUrl,
            mjImages: multiImages ? multiImages.slice(0, 12) : null,
            selectedIndex
        };
        e.dataTransfer.effectAllowed = 'copy';
        e.dataTransfer.setData('application/x-tapnow-history', JSON.stringify(payload));
        e.dataTransfer.setData('text/uri-list', dragUrl);
        e.dataTransfer.setData('text/plain', dragUrl);
    };

    useEffect(() => {
        const fallback = item.url || item.originalUrl || item.mjOriginalUrl;
        const nextSrc = hasLocalCache ? localCacheFallback : fallback;
        const resolved = resolveHistoryUrl ? resolveHistoryUrl(item, nextSrc) : nextSrc;
        setVideoSrc(resolved);
    }, [item.url, item.originalUrl, item.mjOriginalUrl, hasLocalCache, localCacheFallback, resolveHistoryUrl]);

    useEffect(() => {
        if (!localCacheActive || !localCacheFallback || !onCacheMissing) return;
        if (isLocalCacheUrlAvailable && !isLocalCacheUrlAvailable(localCacheFallback)) {
            onCacheMissing(item.id, localCacheFallback);
        }
    }, [localCacheActive, localCacheFallback, item.id, onCacheMissing, isLocalCacheUrlAvailable]);

    const ratioLabel = historyMeta?.ratioLabel ?? (item.ratio || item.mjRatio);
    const resolutionLabel = historyMeta?.resolutionLabel ?? (item.resolution || (item.width && item.height ? `${item.width}x${item.height}` : null));
    const durationLabel = historyMeta?.durationLabel ?? ((item.type === 'video' && item.duration) ? `${item.duration}s` : null);
    const customParamLabels = historyMeta?.customParamLabels || [];

    return (
        <div
            className={`group rounded-lg overflow-hidden border relative cursor-pointer transition-colors ${isSelected
                ? 'border-blue-500 ring-2 ring-blue-500/30'
                : theme === 'dark'
                    ? 'bg-zinc-900 border-zinc-800 hover:border-blue-500/50'
                    : theme === 'solarized'
                        ? 'bg-white border-zinc-200 hover:border-blue-500/50'
                        : 'bg-white border-zinc-200 hover:border-blue-500/50'
                }`}
            style={{
                contentVisibility: 'auto',
                containIntrinsicSize: '1px 300px'
            }}
            onClick={onClick}
            onContextMenu={onContextMenu}
            draggable={canDrag}
            onDragStart={canDrag ? (e) => handleDragStart(e) : undefined}
        >
            {/* 性能/本地缓存标识 */}
            {hasLocalCache && (
                <div className={`absolute top-1 left-1 z-10 px-1 py-0.5 rounded text-[8px] bg-black/60 text-green-300`}>
                    {t('本地')}
                </div>
            )}
            {!hasLocalCache && performanceMode !== 'off' && thumbnailUrl && (
                <div className={`absolute top-1 left-1 z-10 px-1 py-0.5 rounded text-[8px] bg-black/60 ${performanceMode === 'ultra' ? 'text-orange-400' : 'text-zinc-400'}`}>
                    {performanceMode === 'ultra' ? t('极速') : t('缩略')}
                </div>
            )}
            {/* V3.5.1: 圆形选择按钮 - 始终可见 */}
            {onSelect && (
                <button
                    onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        onSelect(item.id);
                    }}
                    className={`absolute bottom-2 right-2 z-20 w-6 h-6 rounded-full border-2 flex items-center justify-center transition-all ${isSelected
                        ? 'bg-green-500 border-green-400 opacity-100'
                        : 'border-white/60 bg-black/50 opacity-100 hover:bg-black/70'
                        }`}
                    title={isSelected ? t('取消选择') : t('选择')}
                >
                    {isSelected && <CheckCircle2 size={16} className="text-white" />}
                </button>
            )}
            <div className={`${theme === 'dark' ? 'bg-black' : theme === 'solarized' ? 'bg-[#fafafa]' : 'bg-[#fafafa]'} relative ${((multiImages && multiImages.length > 1) || (item.mjNeedsSplit && item.apiConfig?.modelId?.includes('mj')))
                ? (() => {
                    const ratio = item.mjRatio || '1:1';
                    if (ratio === '16:9') return 'aspect-video';
                    if (ratio === '9:16') return 'aspect-[9/16]';
                    if (ratio === '4:3') return 'aspect-[4/3]';
                    if (ratio === '3:4') return 'aspect-[3/4]';
                    if (ratio === '21:9') return 'aspect-[21/9]';
                    return 'aspect-square';
                })()
                : 'aspect-video'
                }`}>
                {item.status === 'completed' ? (
                    multiImages && multiImages.length > 1 ? (
                        <div className={`w-full h-full grid gap-0.5 p-0.5 ${multiImages.length === 4 ? 'grid-cols-2 grid-rows-2' : 'grid-cols-2'}`}>
                            {multiImages.map((imgUrl, idx) => {
                                const imgInfo = item.mjImageInfo && item.mjImageInfo[idx];
                                const cachedImgUrl = localCacheActive && item.localCacheMap ? item.localCacheMap[imgUrl] : null;
                                const rawDisplayImgUrl = cachedImgUrl
                                    || (performanceMode !== 'off' && item.mjThumbnails && item.mjThumbnails[idx]
                                        ? item.mjThumbnails[idx]
                                        : imgUrl);
                                const displayImgUrl = resolveHistoryUrl
                                    ? resolveHistoryUrl(item, rawDisplayImgUrl)
                                    : rawDisplayImgUrl;
                                return (
                                    <HistoryMjImageCell
                                        key={idx}
                                        item={item}
                                        idx={idx}
                                        imgUrl={imgUrl}
                                        displayImgUrl={displayImgUrl}
                                        theme={theme}
                                        canDrag={canDrag}
                                        lightboxItem={lightboxItem}
                                        language={language}
                                        onImageClick={onImageClick}
                                        onImageContextMenu={onImageContextMenu}
                                        onCacheMissing={onCacheMissing}
                                        handleDragStart={handleDragStart}
                                    />
                                );
                            })}
                        </div>
                    ) : (
                        item.type === 'image' ? (
                            <LazyBase64Image
                                src={getResolvedDisplayUrl(item.url || item.originalUrl || item.mjOriginalUrl)}
                                loading="lazy"
                                className="w-full h-full object-cover"
                                alt={item.prompt || '生成的图片'}
                                onError={(e) => {
                                    const rawUrl = item.url || item.originalUrl || item.mjOriginalUrl;
                                    const resolvedUrl = getResolvedDisplayUrl(rawUrl);
                                    console.error('图片加载失败:', resolvedUrl || rawUrl);
                                    onCacheMissing && onCacheMissing(item.id, resolvedUrl || rawUrl);
                                    e.target.style.display = 'none';
                                }}
                            />
                        ) : (
                            // V2.6.1: 性能模式处理
                            (() => {
                                // 简单处理：直接显示视频，后续可优化
                                return (
                                    <ResolvedVideo
                                        src={videoSrc || item.url || item.originalUrl}
                                        className="w-full h-full object-cover"
                                        muted
                                        loop
                                        playsInline
                                        preload="metadata"
                                        onError={() => {
                                            const fallback = item.url || item.originalUrl || item.mjOriginalUrl;
                                            if (hasLocalCache && fallback && videoSrc === localCacheFallback) {
                                                setVideoSrc(fallback);
                                                onCacheMissing && onCacheMissing(item.id, localCacheFallback);
                                            } else {
                                                console.error('视频加载失败:', fallback);
                                            }
                                        }}
                                    />
                                );
                            })()
                        )
                    )
                ) : (
                    <div className="w-full h-full flex items-center justify-center">
                        <Loader2 className="animate-spin text-zinc-600" />
                    </div>
                )}
                <div className={`absolute bottom-0 left-0 right-0 h-1 ${theme === 'dark' ? 'bg-zinc-800' : theme === 'solarized' ? 'bg-zinc-200' : 'bg-zinc-200'}`}>
                    <div className="h-full bg-blue-500 transition-all" style={{ width: `${item.progress}%` }}></div>
                </div>
            </div>
            {/* 信息区域：合并按钮和文本信息以节省空间 */}
            <div className={`px-3 py-2 text-[11px] ${theme === 'solarized' ? 'bg-[#eee8d5]' : ''}`}>
                {/* 第一行：提示词 + 操作按钮 */}
                <div className="flex justify-between items-start gap-2">
                    <span className={`line-clamp-2 ${theme === 'dark' ? 'text-zinc-300' : theme === 'solarized' ? 'text-black' : 'text-zinc-700'}`}>
                        {item.prompt || 'Untitled'}
                    </span>
                    <div className={`shrink-0 ml-1 ${item.type === 'image' ? 'flex flex-col items-center gap-1' : 'flex items-center gap-1'}`}>
                        {item.type === 'video' && (item.status === 'generating' || item.status === 'failed') && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onRefresh && onRefresh(item);
                                }}
                                className={`shrink-0 p-0.5 ${theme === 'dark'
                                    ? 'text-zinc-500 hover:text-white'
                                    : theme === 'solarized'
                                        ? 'text-black hover:text-zinc-700'
                                        : 'text-zinc-400 hover:text-zinc-900'
                                    }`}
                                title={t('刷新状态')}
                            >
                                <RefreshCw size={12} />
                            </button>
                        )}
                        <button
                            onClick={(e) => { e.stopPropagation(); onDelete && onDelete(item.id); }}
                            className={`shrink-0 p-0.5 ${theme === 'dark'
                                ? 'text-zinc-500 hover:text-red-500'
                                : theme === 'solarized'
                                    ? 'text-black hover:text-red-600'
                                    : 'text-zinc-400 hover:text-red-500'
                                }`}
                            title={t('删除')}
                        >
                            <Trash2 size={12} />
                        </button>
                        {item.type === 'image' && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onRebuildThumbnail && onRebuildThumbnail(item);
                                }}
                                className={`shrink-0 p-0.5 rounded ${theme === 'dark'
                                    ? 'text-blue-300 hover:text-blue-200 hover:bg-blue-500/20'
                                    : 'text-blue-500 hover:text-blue-600 hover:bg-blue-100'
                                    }`}
                                title={t('重建缩略图')}
                            >
                                <RefreshCw size={12} />
                            </button>
                        )}
                    </div>
                </div>

                {/* 状态信息（如果有） */}
                {item.status === 'failed' && item.errorMsg && (
                    <p className="text-[9px] text-red-500 mt-1 break-words whitespace-pre-wrap">
                        {item.errorMsg.split('\n').map((line, idx) => (
                            <span key={idx}>
                                {line}
                                {idx < item.errorMsg.split('\n').length - 1 && <br />}
                            </span>
                        ))}
                    </p>
                )}
                {item.status === 'generating' && (
                    <p className="text-[9px] text-blue-500 mt-1">
                        {item.errorMsg || '生成中...'}
                    </p>
                )}

                {/* 第二行 - 空行 (通过 margin 实现) */}
                <div className="h-1.5"></div>

                {/* 第三行 - 生成类型·比率·分辨率 */}
                <div className="flex flex-col w-full">
                    <span className={theme === 'dark' ? 'text-zinc-500' : theme === 'solarized' ? 'text-black' : 'text-zinc-400'}>
                        {(() => {
                            const hasRefImage = item.hasInputImages === true;
                            const isVideo = item.type === 'video';
                            const genType = isVideo
                                ? (hasRefImage ? '图→视频' : '文→视频')
                                : (hasRefImage ? '图→图' : '文→图');
                            const resDisplay = resolutionLabel;
                            return [
                                genType,
                                ratioLabel,
                                resDisplay,
                                isVideo && durationLabel ? durationLabel : null,
                                ...customParamLabels
                            ].filter(Boolean).join(' · ');
                        })()}
                    </span>

                    {/* 第四行 - 时间·模型·用时 */}
                    <span className={theme === 'dark' ? 'text-zinc-500' : theme === 'solarized' ? 'text-black' : 'text-zinc-400'}>
                        {item.time} · <span title={modelTooltip}>{displayModelName}</span>
                        {typeof item.durationMs === 'number' && item.durationMs > 0 && (
                            <> · {t('用时')} {(item.durationMs / 1000).toFixed(1)}s</>
                        )}
                    </span>
                </div>
            </div>
        </div>
    );
}, (prevProps, nextProps) => {
    // 自定义对比函数：只检查关键属性变化，包括选择状态
    return (
        prevProps.item === nextProps.item &&
        prevProps.theme === nextProps.theme &&
        prevProps.lightboxItem?.id === nextProps.lightboxItem?.id &&
        prevProps.isSelected === nextProps.isSelected &&
        prevProps.performanceMode === nextProps.performanceMode &&
        prevProps.localCacheActive === nextProps.localCacheActive &&
        prevProps.getHistoryMeta === nextProps.getHistoryMeta &&
        prevProps.historyLocalCacheMap === nextProps.historyLocalCacheMap &&
        prevProps.resolveHistoryUrl === nextProps.resolveHistoryUrl &&
        prevProps.isLocalCacheUrlAvailable === nextProps.isLocalCacheUrlAvailable
    );
});

// --- MaskEditor 组件：图片标注/局部重绘 ---
const MaskEditor = ({ nodeId, imageUrl, imageDimensions, isActive, onClose, onSave, theme, view, maskContent, onUpdateNode }) => {
    const canvasRef = useRef(null);
    const ctxRef = useRef(null);
    const lastPointRef = useRef(null); // V3.7.27: 用于平滑绘制
    const [brushSize, setBrushSize] = useState(30);
    const [isDrawing, setIsDrawing] = useState(false);
    const [history, setHistory] = useState([]);
    const [historyIndex, setHistoryIndex] = useState(-1);
    const maxHistory = 10;
    const [resolvedDimensions, setResolvedDimensions] = useState(imageDimensions);

    useEffect(() => {
        if (imageDimensions?.w && imageDimensions?.h) {
            setResolvedDimensions(imageDimensions);
        }
    }, [imageDimensions]);

    useEffect(() => {
        if (!isActive || !imageUrl) return;
        if (imageDimensions?.w && imageDimensions?.h) return;
        let cancelled = false;
        getImageDimensions(imageUrl)
            .then((dims) => {
                if (cancelled) return;
                if (dims?.w && dims?.h) {
                    setResolvedDimensions(dims);
                    if (onUpdateNode) onUpdateNode(nodeId, { dimensions: dims });
                }
            })
            .catch(() => { });
        return () => { cancelled = true; };
    }, [isActive, imageUrl, imageDimensions, nodeId, onUpdateNode]);

    // 初始化 Canvas
    useEffect(() => {
        if (!isActive || !canvasRef.current || !resolvedDimensions) return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        ctxRef.current = ctx;

        // 设置 Canvas 尺寸为图片原始分辨率
        canvas.width = resolvedDimensions.w;
        canvas.height = resolvedDimensions.h;

        // 清空画布（透明背景）
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 如果有保存的蒙版，恢复它
        if (maskContent) {
            const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0);
                saveToHistory();
            };
            img.src = maskContent;
        } else {
            saveToHistory();
        }
    }, [isActive, resolvedDimensions, nodeId, maskContent]);

    // 保存当前状态到历史记录
    const saveToHistory = () => {
        if (!canvasRef.current || !ctxRef.current) return;
        const canvas = canvasRef.current;
        const ctx = ctxRef.current;
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const newHistory = history.slice(0, historyIndex + 1);
        newHistory.push(imageData);
        if (newHistory.length > maxHistory) {
            newHistory.shift();
        }
        setHistory(newHistory);
        setHistoryIndex(newHistory.length - 1);
    };

    // 获取鼠标在 Canvas 上的真实像素坐标
    const getCanvasCoordinates = (e) => {
        if (!canvasRef.current) return null;
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();

        // 使用 getBoundingClientRect 获取 Canvas 在视口中的绝对位置
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // 计算缩放比例（图片原始尺寸 / DOM 显示尺寸）
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // 映射回真实像素坐标
        return {
            x: Math.round(x * scaleX),
            y: Math.round(y * scaleY)
        };
    };

    // 绘制函数 V3.7.27: 使用 lineTo 实现平滑绘制
    const draw = (e) => {
        if (!isDrawing || !canvasRef.current || !ctxRef.current) return;
        const coords = getCanvasCoordinates(e);
        if (!coords) return;

        const ctx = ctxRef.current;
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = '#FFFFFF';
        ctx.fillStyle = '#FFFFFF';
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (lastPointRef.current) {
            // 连接到上一个点
            ctx.beginPath();
            ctx.moveTo(lastPointRef.current.x, lastPointRef.current.y);
            ctx.lineTo(coords.x, coords.y);
            ctx.stroke();
        } else {
            // 第一个点：画一个圆
            ctx.beginPath();
            ctx.arc(coords.x, coords.y, brushSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        lastPointRef.current = coords;
    };

    // 鼠标事件处理
    const handleMouseDown = (e) => {
        if (e.button !== 0) return; // 只处理左键
        e.preventDefault();
        e.stopPropagation();
        lastPointRef.current = null; // V3.7.27: 重置上一个点
        setIsDrawing(true);
        saveToHistory();
        draw(e);
    };

    const handleMouseMove = (e) => {
        if (!isDrawing) return;
        e.preventDefault();
        e.stopPropagation();
        draw(e);
    };

    const handleMouseUp = (e) => {
        if (!isDrawing) return;
        e.preventDefault();
        e.stopPropagation();
        setIsDrawing(false);
        lastPointRef.current = null; // V3.7.27: 清除上一个点
        saveToHistory();
    };

    // 撤销
    const handleUndo = () => {
        if (historyIndex <= 0 || !canvasRef.current || !ctxRef.current) return;
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        const ctx = ctxRef.current;
        ctx.putImageData(history[newIndex], 0, 0);
    };

    // 清空
    const handleClear = () => {
        if (!canvasRef.current || !ctxRef.current) return;
        const ctx = ctxRef.current;
        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
        saveToHistory();
    };

    // 保存蒙版
    const handleSave = () => {
        if (!canvasRef.current) return;
        const canvas = canvasRef.current;
        const maskDataUrl = canvas.toDataURL('image/png');

        // 更新节点状态
        if (onUpdateNode) {
            onUpdateNode(nodeId, { maskContent: maskDataUrl, isMasking: false });
        }

        if (onSave) onSave(maskDataUrl);
        if (onClose) onClose();
    };

    // 键盘快捷键：Ctrl+Z 撤销
    useEffect(() => {
        if (!isActive) return;
        const handleKeyDown = (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                handleUndo();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [isActive, historyIndex, history]);

    if (!isActive || !imageUrl || !resolvedDimensions) return null;

    return (
        <>
            <div
                className="absolute inset-0 z-50 pointer-events-auto"
                style={{
                    mixBlendMode: 'normal',
                }}
                onMouseDown={(e) => e.stopPropagation()}
                onMouseMove={(e) => e.stopPropagation()}
                onMouseUp={(e) => e.stopPropagation()}
            >
                {/* Canvas 层：用于绘制蒙版 */}
                <canvas
                    ref={canvasRef}
                    className="absolute inset-0 w-full h-full"
                    style={{
                        opacity: 0.5,
                        mixBlendMode: 'multiply',
                        cursor: 'crosshair',
                        pointerEvents: 'auto',
                        imageRendering: 'auto'
                    }}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                />

                {/* 视觉反馈层：半透明红色覆盖 - 使用 Canvas 作为 mask */}
                <MaskVisualFeedback canvasRef={canvasRef} isDrawing={isDrawing} />
            </div>

            {/* 工具栏 - 使用 Portal 固定到 Body，避免被 Canvas Transform 影响 */}
            {createPortal(
                <div
                    className={`fixed bottom-4 left-1/2 -translate-x-1/2 flex flex-row items-center gap-4 p-2 rounded-full border backdrop-blur-md shadow-xl z-[9999] ${theme === 'dark'
                        ? 'bg-zinc-900/90 border-zinc-700 text-zinc-200'
                        : 'bg-white/90 border-zinc-300 text-zinc-800'
                        }`}
                    onMouseDown={(e) => e.stopPropagation()}
                >
                    {/* 笔刷粗细 */}
                    <div className="flex items-center gap-2">
                        <span className="text-[10px] font-medium whitespace-nowrap">笔刷</span>
                        <input
                            type="range"
                            min="10"
                            max="150"
                            value={brushSize}
                            onChange={(e) => setBrushSize(Number(e.target.value))}
                            className="w-20"
                            onMouseDown={(e) => e.stopPropagation()}
                        />
                        <span className="text-[10px] w-8 text-right whitespace-nowrap">{brushSize}px</span>
                    </div>

                    {/* 按钮组 */}
                    <div className="flex items-center gap-1">
                        <button
                            onClick={handleUndo}
                            disabled={historyIndex <= 0}
                            className={`p-1.5 rounded-full transition-colors ${theme === 'dark'
                                ? 'hover:bg-zinc-800 disabled:opacity-50 disabled:cursor-not-allowed'
                                : 'hover:bg-zinc-100 disabled:opacity-50 disabled:cursor-not-allowed'
                                }`}
                            title={t('撤销 (Ctrl+Z)')}
                        >
                            <Undo2 size={14} />
                        </button>
                        <button
                            onClick={handleClear}
                            className={`p-1.5 rounded-full transition-colors ${theme === 'dark'
                                ? 'hover:bg-zinc-800'
                                : 'hover:bg-zinc-100'
                                }`}
                            title={t('清空')}
                        >
                            <Eraser size={14} />
                        </button>
                        <button
                            onClick={handleSave}
                            className="p-1.5 rounded-full bg-blue-600 hover:bg-blue-500 text-white transition-colors"
                            title={t('保存/完成')}
                        >
                            <Check size={14} />
                        </button>
                    </div>
                </div>,
                document.body
            )}
        </>
    );
};

// --- 自定义样式 ---
const styles = `
        /* 全局字体渲染优化 */
        * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        :root {
            --canvas-grid-color: #666666;
        }
        .theme-dark {
            --canvas-grid-color: #bfbfbf;
        }
        .theme-solarized {
            --canvas-grid-color: #666666;
        }
        
        /* 画布容器渲染优化 */
        #canvas-bg {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
            background-image: radial-gradient(var(--canvas-grid-color) 6.0px, transparent 6.0px);
            background-size: 24px 24px;
            background-position: 0 0;
        }
        .theme-solarized #canvas-bg {
            box-shadow: inset 0 0 0 1px #eee8d5;
        }

        .theme-solarized button[class*="bg-blue-"],
        .theme-solarized button[class*="bg-green-"] {
            background-color: #616161 !important;
            border-color: #616161 !important;
            color: #fdf6e3 !important;
        }
        .theme-solarized button[class*="bg-blue-"]:hover,
        .theme-solarized button[class*="bg-green-"]:hover {
            background-color: #4b4b4b !important;
        }
        
        /* 画布内容容器优化 */
        #canvas-bg > div[style*="transform"] {
            transform: translateZ(0);
            will-change: transform;
        }
        
        /* 节点容器优化 */
        .node-wrapper {
            transform: translateZ(0);
            backface-visibility: hidden;
            contain: layout style;
            will-change: transform, left, top;
        }
        
        /* 节点内图片渲染优化 - 使用高质量渲染 */
        .node-wrapper img,
        .node-wrapper video {
            image-rendering: auto;
            image-rendering: -webkit-optimize-contrast;
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            pointer-events: none;
        }
        
        /* 连接线优化 */
        svg {
            shape-rendering: geometricPrecision;
            text-rendering: optimizeLegibility;
        }
        
        /* 高性能模式：当节点数量超过阈值时自动启用 */
        .perf-mode .node-wrapper {
            box-shadow: none !important;
            backdrop-filter: none !important;
            border-radius: 0 !important;
            transition: none !important;
        }
        .perf-mode .connection-group {
            opacity: 1 !important;
        }
        
        /* 交互时动态降级：拖拽或缩放时降低渲染质量 */
        .interacting .node-wrapper img {
            image-rendering: pixelated;
        }
        .interacting .connection-group {
            display: none;
            pointer-events: none;
        }
        
        .custom-scrollbar::-webkit-scrollbar { width: 4px; height: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .theme-dark .custom-scrollbar::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 2px; }
        .theme-dark .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #52525b; }
        .theme-light .custom-scrollbar::-webkit-scrollbar-thumb { background: #d4d4d8; border-radius: 2px; }
        .theme-light .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #cbd5e1; }
        .theme-solarized .custom-scrollbar::-webkit-scrollbar-thumb { background: #c9c2a8; border-radius: 2px; }
        .theme-solarized .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #b9b091; }
        .theme-solarized button[class*="bg-blue-"],
        .theme-solarized button[class*="bg-green-"],
        .theme-solarized button[class*="from-blue-"],
        .theme-solarized button[class*="from-green-"],
        .theme-solarized button[class*="to-emerald-"],
        .theme-solarized button[class*="to-indigo-"] {
            background-image: none !important;
            background-color: #616161 !important;
            border-color: #525252 !important;
            color: #fdf6e3 !important;
        }
        .theme-solarized button[class*="bg-blue-"]:hover,
        .theme-solarized button[class*="bg-green-"]:hover,
        .theme-solarized button[class*="from-blue-"]:hover,
        .theme-solarized button[class*="from-green-"]:hover,
        .theme-solarized button[class*="to-emerald-"]:hover,
        .theme-solarized button[class*="to-indigo-"]:hover {
            background-color: #555555 !important;
        }
        .theme-solarized [class*="hover:bg-zinc-100"]:hover {
            background-color: #fdf6e3 !important;
        }
        .theme-solarized [class*="hover:bg-zinc-200"]:hover {
            background-color: #eee8d5 !important;
        }
        .resize-handle { cursor: nwse-resize; opacity: 0; transition: opacity 0.2s; }
        .node-wrapper:hover .resize-handle { opacity: 1; }
        
        /* 连接点样式 */
        .connector { position: absolute; top: 50%; transform: translateY(-50%); width: 0.9rem; height: 0.9rem; background-color: #27272a; border: 1px solid #71717a; color: #a1a1aa; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: crosshair; transition: all 0.2s; z-index: 30; opacity: 0; pointer-events: auto; }
        .node-wrapper:hover .connector { opacity: 1; }
        .connector:hover, .connector.active { background-color: #d4d4d8; border-color: #fff; transform: translateY(-50%) scale(1.2); opacity: 1; color: #000; }
        .connector-right { right: -0.45rem; }
        
        /* 输入点样式 */
        .input-point { position: absolute; top: 50%; transform: translateY(-50%); left: -0.25rem; width: 0.5rem; height: 0.5rem; background-color: #52525b; border-radius: 50%; border: 1px solid #18181b; transition: all 0.2s; z-index: 20; cursor: crosshair; }
        .node-wrapper:hover .input-point { background-color: #a1a1aa; }
        .input-point.connected { background-color: #60a5fa; box-shadow: 0 0 6px #60a5fa; }
        .input-point.active { background-color: #60a5fa; border-color: #fff; transform: translateY(-50%) scale(1.3); box-shadow: 0 0 8px #60a5fa; }

        /* Lightbox & Overlay */
        .lightbox-overlay { background-color: rgba(0, 0, 0, 0.95); backdrop-filter: blur(5px); }
        
        /* Stack Items */
        .thumb-stack-item {
             transition: transform 0.2s, z-index 0.2s;
        }
        .thumb-stack-item:hover {
            transform: scale(1.1) translateY(-2px);
            z-index: 10 !important;
            border-color: #60a5fa;
        }

        /* 连接线删除按钮 */
        .connection-delete {
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: auto; /* 关键：确保鼠标能交互 */
        }
        /* 当鼠标悬停在整个连接组（包含粗透明线）时显示 */
        .connection-group:hover .connection-delete {
            opacity: 1;
        }

        /* 拖放区域样式 */
        .drop-zone {
            border: 2px dashed transparent;
            transition: all 0.3s;
        }
        .drop-zone.drag-over {
            border-color: #60a5fa;
            background-color: rgba(96, 165, 250, 0.1);
        }

        /* Markdown Styles for Chat */
        .markdown-body { font-size: 13px; line-height: 1.5; color: #e4e4e7; word-wrap: break-word; user-select: text !important; cursor: text; }
        .markdown-body * { user-select: text !important; cursor: text; }
        .markdown-body pre { background: #27272a; padding: 10px; border-radius: 6px; overflow-x: auto; margin: 8px 0; white-space: pre-wrap; word-wrap: break-word; user-select: text !important; cursor: text; }
        .markdown-body code { font-family: monospace; background: #3f3f46; padding: 2px 4px; border-radius: 4px; font-size: 12px; user-select: text !important; cursor: text; }
        .markdown-body pre code { background: transparent; padding: 0; color: #a1a1aa; user-select: text !important; cursor: text; }
        .markdown-body p { margin-bottom: 8px; user-select: text !important; cursor: text; }
        .markdown-body ul, .markdown-body ol { margin-left: 20px; margin-bottom: 8px; list-style: disc; user-select: text !important; cursor: text; }
        .markdown-body li { user-select: text !important; cursor: text; }
        .markdown-body video { max-width: 100%; border-radius: 0.5rem; margin-top: 0.5rem; }
        .markdown-body table { border-collapse: collapse; width: 100%; margin: 12px 0; }
        .markdown-body table th, .markdown-body table td { border: 1px solid #3f3f46; padding: 8px 12px; text-align: left; }
        .markdown-body table th { background-color: #3f3f46; font-weight: 600; }
        .markdown-body table tr:nth-child(even) { background-color: #27272a; }
        .theme-light .markdown-body table th, .theme-light .markdown-body table td { border-color: #d4d4d8; }
        .theme-light .markdown-body table th { background-color: #e4e4e7; }
        .theme-light .markdown-body table tr:nth-child(even) { background-color: #f4f4f5; }
        .theme-light .markdown-body { color: #18181b; }
        .theme-light .markdown-body pre { background: #f4f4f5; color: #18181b; }
        .theme-light .markdown-body code { background: #e4e4e7; color: #18181b; }
        .theme-light .markdown-body pre code { color: #18181b; }
        .theme-solarized .markdown-body table th, .theme-solarized .markdown-body table td { border-color: #d7cfb2; }
        .theme-solarized .markdown-body table th { background-color: #ddddc1; }
        .theme-solarized .markdown-body table tr:nth-child(even) { background-color: #eee8d5; }
        .theme-solarized .markdown-body { color: #586e75; }
        .theme-solarized .markdown-body pre { background: #ddddc1; color: #586e75; }
        .theme-solarized .markdown-body code { background: #ddddc1; color: #586e75; }
        .theme-solarized .markdown-body pre code { color: #586e75; }
        `;

// --- 虚拟画布尺寸 ---
const VIRTUAL_CANVAS_WIDTH = 4000;
const VIRTUAL_CANVAS_HEIGHT = 4000;
const IMAGE_TASK_TIMEOUT_MS = 60 * 1000;
const VIDEO_TASK_TIMEOUT_MS = 5 * 60 * 1000;

// --- 默认配置 ---
const DEFAULT_BASE_URL = 'https://ai.comfly.chat';

// 即梦API配置（代理地址，默认本地5100端口）
const JIMENG_API_BASE_URL = 'http://localhost:5100';
const JIMENG_SESSION_ID = '7a16459fbd65d9c87b4ea44d3318f5fa';

// V3.6.0: 供应商配置（简化版 - 无 name 字段，直接用 key 作为显示名）
const DEFAULT_PROVIDERS = {
    'openai': { key: '', url: DEFAULT_BASE_URL, apiType: 'openai', useProxy: false, forceAsync: false },
    'google': { key: '', url: DEFAULT_BASE_URL, apiType: 'openai', useProxy: false, forceAsync: false },
    'deepseek': { key: '', url: DEFAULT_BASE_URL, apiType: 'openai', useProxy: false, forceAsync: false },
    'midjourney': { key: '', url: 'https://api.midjourney.com', apiType: 'openai', useProxy: false, forceAsync: false },
    'jimeng': { key: '', url: JIMENG_API_BASE_URL, apiType: 'openai', useProxy: false, forceAsync: false },
    'grok': { key: '', url: 'https://ai.t8star.cn', apiType: 'openai', useProxy: false, forceAsync: false },
    'yunwu': { key: '', url: 'https://yunwu.ai', apiType: 'gemini', useProxy: false, forceAsync: false },
};

// V3.6.0: 模型配置（简化版 - id 即 modelName，无 displayName）
const DEFAULT_API_CONFIGS = [
    // Chat Models
    { id: 'gpt-5.1', provider: 'openai', type: 'Chat' },
    { id: 'gpt-5.2', provider: 'openai', type: 'Chat' },
    { id: 'gpt-4o', provider: 'openai', type: 'Chat' },
    { id: 'deepseek-v3-1-250821', provider: 'deepseek', type: 'Chat' },
    { id: 'gemini-3-pro-preview', provider: 'google', type: 'Chat' },

    // Image Models
    { id: 'MJ V6', provider: 'midjourney', type: 'Image' },
    { id: 'gpt-4o-image', provider: 'openai', type: 'Image' },
    { id: 'gemini-3-pro-image-preview', provider: 'yunwu', type: 'Image' },
    { id: 'jimeng-4.5', provider: 'jimeng', type: 'Image' },
    { id: 'jimeng-4.1', provider: 'jimeng', type: 'Image' },
    { id: 'jimeng-4.0', provider: 'jimeng', type: 'Image' },
    { id: 'jimeng-3.1', provider: 'jimeng', type: 'Image' },
    { id: 'jimeng-3.0', provider: 'jimeng', type: 'Image' },
    { id: 'jimeng-2.1', provider: 'jimeng', type: 'Image' },
    { id: 'jimeng-xl-pro', provider: 'jimeng', type: 'Image' },
    { id: 'nanobananapro', provider: 'jimeng', type: 'Image' },
    { id: 'nanobanana', provider: 'jimeng', type: 'Image' },

    // Video Models
    { id: 'sora-2', provider: 'openai', type: 'Video', durations: ['5s', '10s'] },
    { id: 'sora-2-pro', provider: 'openai', type: 'Video', durations: ['15s', '25s'] },
    { id: 'jimeng-video-3.5-pro', provider: 'jimeng', type: 'Video', durations: ['5s', '10s'] },
    { id: 'jimeng-video-veo3', provider: 'jimeng', type: 'Video', durations: ['8s'] },
    { id: 'jimeng-video-veo3.1', provider: 'jimeng', type: 'Video', durations: ['8s'] },
    { id: 'jimeng-video-sora2', provider: 'jimeng', type: 'Video', durations: ['4s', '8s', '12s'] },
    { id: 'jimeng-video-3.0-pro', provider: 'jimeng', type: 'Video', durations: ['5s', '10s'] },
    { id: 'jimeng-video-3.0', provider: 'jimeng', type: 'Video', durations: ['5s', '10s'] },
    { id: 'jimeng-video-3.0-fast', provider: 'jimeng', type: 'Video', durations: ['5s', '10s'] },
    { id: 'jimeng-video-2.0-pro', provider: 'jimeng', type: 'Video', durations: ['5s', '10s'] },
    { id: 'jimeng-video-2.0', provider: 'jimeng', type: 'Video', durations: ['5s', '10s'] },
    { id: 'grok-video-3', provider: 'grok', type: 'Video', durations: ['8s', '5s'] },
];

const RATIOS = ['Auto', '1:1', '16:9', '9:16', '4:3', '3:4', '21:9', '3:2', '2:3'];
const GROK_VIDEO_RATIOS = ['3:2', '2:3', '1:1'];
const VIDEO_RES_OPTIONS = ['1080P', '720P'];
const PROMPT_LIBRARY_KEY = 'tapnow_prompt_library';
const GRID_PROMPT_TEXT = `基于我上传的这张参考图，生成一张九宫格（3x3 grid）布局的分镜脚本。请严格保持角色与参考图一致（Keep character strictly consistent），但在9个格子中展示该角色不同的动作、表情和拍摄角度（如正面、侧面、背面、特写等）。要求风格高度统一，形成一张完整的角色动态表（Character Sheet）。`;
const UPSCALE_PROMPT_TEXT = `请对参考图片进行无损高清放大（Upscale）。请严格保持原图的构图、色彩、光影和所有细节元素不变，不要进行任何创造性的重绘或添加新内容。仅专注于提升分辨率、锐化边缘（Sharpening）和去除噪点（Denoising），实现像素级的高清修复。Best quality, 8k, masterpiece, highres, ultra detailed, sharp focus, image restoration, upscale, faithful to original.`;
const STORYBOARD_PROMPT_TEXT = `you are a veteran Hollywood storyboard artist with years of experience. You have the ability to accurately analyze character features and scene characteristics based on images. Provide me with the most suitable camera angles and storyboards. Strictly base this on the uploaded character and scene images, while maintaining a consistent visual style.

MANDATORY LAYOUT: Create a precise 3x3 GRID containing exactly 9 distinct panels.

- The output image MUST be a single image divided into a 3 (rows) by 3 (columns) matrix.
- There must be EXACTLY 3 horizontal rows and 3 vertical columns.
- Each panel must be completely separated by a thin, distinct, solid black line.
- DO NOT create a collage. DO NOT overlap images. DO NOT create random sizes. 
- The grid structure must be perfectly aligned for slicing.

Subject Content: "[在此处填充你对故事的描述]"

Styling Instructions:
- Each panel shows the SAME subject/scene from a DIFFERENT angle (e.g., Front, Side, Back, Action, Close-up).
- Maintain perfect consistency of the character/object across all panels.
- Cinematic lighting, high fidelity, 8k resolution.

Negative Constraints:
- No text, no captions, no UI elements.
- No watermarks.
- No broken grid lines.`;

const CHARACTER_SHEET_PROMPT_TEXT = `(strictly mimic source image art style:1.5), (same visual style:1.4),
score_9, score_8_up, masterpiece, best quality, (character sheet:1.4), (reference sheet:1.3), (consistent art style:1.3), matching visual style, 

[Structure & General Annotations]:
multiple views, full body central figure, clean background, 
(heavy annotation:1.4), (text labels with arrows:1.3), handwriting, data readout,

[SPECIAL CHARACTER DESCRIPTION AREA]:
(prominent character profile text box:1.6), (dedicated biography section:1.5), large descriptive text block,
[在此处填写特殊角色说明，例如：姓名、种族、背景故事等],

[Clothing Breakdown]:
(clothing breakdown:1.5), (outfit decomposition:1.4), garment analysis, (floating apparel:1.3), 
displaying outerwear, displaying upper body garment, displaying lower body garment, 

[Footwear Focus]:
(detailed footwear display:1.5), (floating shoes:1.4), shoe design breakdown, focus on shoes, 

[Inventory & Details]:
(inventory knolling:1.2), open container, personal accessories, organized items display, expression panels`;

const MOOD_BOARD_PROMPT_TEXT = `# Directive: Create a "Rich Narrative Mood Board" (8-Grid Layout)

## 1. PROJECT INPUT 

**A. [Story & Concept / 故事与核心想法]**
> [跟据自身内容书写]

**B. [Key Symbols / 核心意象 (Optional)]**
> [深度理解参考图，自行创作]

**C. [Color Preferences / 色彩倾向 (Optional)]**
> [深度理解参考图，自行创作]

**D. [Reference Images / 参考图]**
> (See attached images / 请读取我上传的图片)

---

## 2. Role Definition
Act as a **Senior Art Director**. Synthesize the Input above into a single, cohesive, high-density **Visual Mood Board** using a complex **8-Panel Asymmetrical Grid Layout**.

## 3. Layout Mapping (Strict Adherence)
You must design a visual composition that tells the story through **8 distinct panels** within one image. **Do not** generate random grids. Map the content exactly as follows:

* **Panel 1 (The World):** A wide, cinematic establishing shot of the environment (based on Input A).
* **Panel 2 (The Protagonist):** A portrait close-up (based on reference images), focusing on micro-expressions.
* **Panel 3 (The Metaphor):** An **abstract symbolic object** representing the core theme (based on Input B).
* **Panel 4 (The Palette):** A graphical **Color Palette Strip** showcasing 5 specific colors extracted from the scene.
* **Panel 5 (The Texture):** Extreme macro close-up of a material surface (e.g., rust, skin, fabric) to add tactile richness.
* **Panel 6 (The Motion):** A motion-blurred or long-exposure shot representing time/chaos.
* **Panel 7 (The Detail):** A focused shot of a specific prop or accessory relevant to the plot.
* **Panel 8 (The AI Art Interpretation - CRITICAL):** This is your **free creative space**. Generate an artistic, surreal, or abstract re-interpretation of the story's emotion. **Do not just copy the inputs.** Create a "Vibe Image" (e.g., Double Exposure, Oil Painting style, or abstract geometry) that captures the *soul* of the narrative.

## 4. Execution Requirements
* **Composition Style:** High-end Editorial / Magazine Layout. Clean, thin white borders.
* **Visual Unity:** All panels must share the same lighting conditions and color grading logic (Unified Aesthetic).
* **Task:** Provide the **Final English Image Prompt** that explicitly describes this 8-grid layout, ensuring Panel 8 stands out as an artistic variation.`;
// 已删除的模型ID列表（用于过滤）
const DELETED_MODEL_IDS = [
    'gemini-image',
    'qwen-image',
    'doubao-seedream',
    'hailuo-02',
    'kling-v1-6',
    'wan-2.5'
];

const ASYNC_CONFIG_TEMPLATE = {
    enabled: true,
    requestIdPaths: ['requestId', 'request_id'],
    pollIntervalMs: 3000,
    maxAttempts: 300,
    statusRequest: {
        endpoint: '/w/v1/webapp/task/openapi/detail',
        method: 'GET',
        headers: { Authorization: 'Bearer {{provider.key}}' },
        query: { requestId: '{{requestId}}' },
        bodyType: 'json',
        body: {}
    },
    statusPath: 'data.status',
    successValues: ['Success'],
    failureValues: ['Failed', 'Canceled'],
    outputsRequest: {
        endpoint: '/w/v1/webapp/task/openapi/outputs',
        method: 'GET',
        headers: { Authorization: 'Bearer {{provider.key}}' },
        query: { requestId: '{{requestId}}' },
        bodyType: 'json',
        body: {}
    },
    outputsPath: 'data.outputs',
    outputsUrlField: 'object_url',
    errorPath: 'message'
};

const normalizeShotIdValue = (value) => {
    if (value === null || value === undefined) return '';
    return String(value).trim();
};
const extractShotIdMeta = (value) => {
    const raw = normalizeShotIdValue(value);
    if (!raw) return { raw: '', token: '', num: null, base: null };
    const tokenMatch = raw.match(/(\d+(?:\.\d+)?)/);
    const token = tokenMatch ? tokenMatch[1] : '';
    let num = Number(raw);
    if (!Number.isFinite(num) && token) {
        num = Number(token);
    }
    if (!Number.isFinite(num)) num = null;
    const base = Number.isFinite(num) ? Math.floor(num) : null;
    return { raw, token, num, base };
};
const normalizeShotToken = (token) => {
    if (!token) return '';
    const trimmed = String(token).trim();
    if (!trimmed) return '';
    if (!trimmed.includes('.')) return trimmed;
    return trimmed.replace(/\.0+$/, '').replace(/(\.\d*?[1-9])0+$/, '$1');
};
const isSameShotId = (a, b) => {
    const metaA = extractShotIdMeta(a);
    const metaB = extractShotIdMeta(b);
    if (!metaA.raw || !metaB.raw) return false;
    if (metaA.raw === metaB.raw) return true;
    const tokenA = normalizeShotToken(metaA.token);
    const tokenB = normalizeShotToken(metaB.token);
    if (tokenA && tokenB && tokenA === tokenB) return true;
    if (Number.isFinite(metaA.num) && Number.isFinite(metaB.num)) {
        if (Math.abs(metaA.num - metaB.num) < 1e-3) return true;
    }
    return false;
};
const isStoryboardDebugEnabled = () => {
    try {
        return localStorage.getItem('tapnow_debug_storyboard') === '1';
    } catch (e) {
        return false;
    }
};
const findStoryboardNodeById = (nodes, nodeId) => {
    if (!Array.isArray(nodes) || !nodeId) return null;
    const direct = nodes.find(n => n.id === nodeId);
    if (direct) return direct;
    const trimmed = String(nodeId).trim();
    if (!trimmed) return null;
    return nodes.find(n => String(n.id || '').trim() === trimmed) || null;
};
const resolveStoryboardShotCandidate = (node, shotId, historyItem) => {
    const shots = node?.settings?.shots || [];
    const direct = shots.find(s => isSameShotId(s.id, shotId));
    if (direct) return { shot: direct, reason: 'direct' };
    if (!historyItem) return null;
    const prompt = (historyItem.prompt || '').trim();
    const desc = (historyItem.description || '').trim();
    const startTime = historyItem.startTime || historyItem.time || null;
    let best = null;
    let bestScore = -Infinity;
    shots.forEach((s) => {
        let score = 0;
        if (prompt && s.prompt && s.prompt.trim() === prompt) score += 5;
        if (prompt && s.description && s.description.trim() === prompt) score += 4;
        if (desc && s.description && s.description.trim() === desc) score += 3;
        if (startTime && s.generationStartTime) {
            const diff = Math.abs(Number(startTime) - Number(s.generationStartTime));
            if (Number.isFinite(diff)) {
                if (diff < 20000) score += Math.max(0, 2 - diff / 10000);
            }
        }
        if (s.status === 'generating') score += 1;
        if (Array.isArray(s.output_images) && s.output_images.length > 0) score -= 2;
        if (score > bestScore) {
            bestScore = score;
            best = s;
        }
    });
    if (bestScore > 0 && best) return { shot: best, reason: 'fallback' };
    if (shots.length === 1) return { shot: shots[0], reason: 'fallback' };
    const generatingShots = shots.filter((s) => s.status === 'generating');
    if (generatingShots.length === 1) return { shot: generatingShots[0], reason: 'fallback' };
    const emptyShots = shots.filter((s) => !Array.isArray(s.output_images) || s.output_images.length === 0);
    if (emptyShots.length === 1) return { shot: emptyShots[0], reason: 'fallback' };
    return null;
};

const parseStoryboardSourceNodeId = (sourceNodeId) => {
    if (!sourceNodeId || typeof sourceNodeId !== 'string') return null;
    if (!sourceNodeId.startsWith('storyboard-') || !sourceNodeId.includes('-shot-')) return null;
    const parts = sourceNodeId.split('-shot-');
    if (parts.length !== 2) return null;
    const shotId = parts[1];
    const isImageMode = parts[0].startsWith('storyboard-img-');
    const nodeId = isImageMode
        ? parts[0].replace('storyboard-img-', '')
        : parts[0].replace('storyboard-', '');
    if (!nodeId || !shotId) return null;
    return { nodeId, shotId, isImageMode };
};
const ASYNC_CONFIG_TEMPLATE_TEXT = JSON.stringify(ASYNC_CONFIG_TEMPLATE, null, 2);
const buildEmptyAsyncConfig = () => ({
    enabled: false,
    requestIdPaths: ['requestId', 'request_id'],
    pollIntervalMs: 3000,
    maxAttempts: 300,
    statusRequest: {
        endpoint: '',
        method: 'GET',
        headers: {},
        query: {},
        bodyType: 'json',
        body: {}
    },
    statusPath: '',
    successValues: [],
    failureValues: [],
    outputsRequest: {
        endpoint: '',
        method: 'GET',
        headers: {},
        query: {},
        bodyType: 'json',
        body: {}
    },
    outputsPath: '',
    outputsUrlField: '',
    errorPath: ''
});

const DEFAULT_MODEL_LIBRARY = [
    ...DEFAULT_API_CONFIGS
        .filter((config) => !DELETED_MODEL_IDS.includes(config.id))
        .filter((config) => !['Tongyi-MAI/Z-Image-Turbo'].includes(config.id))
        .map((config) => {
            const isVideo = config.type === 'Video';
            const supportsFirstLastFrame = isVideo && /veo3\.1/i.test(config.id);
            const supportsHD = isVideo && /sora-2/i.test(config.id);
            const entryBase = {
                id: config.id,
                displayName: config.id,
                modelName: config.id,
                type: config.type || 'Chat',
                ratioLimits: null,
                resolutionLimits: null,
                durations: Array.isArray(config.durations) ? config.durations : null,
                videoResolutions: isVideo ? [...VIDEO_RES_OPTIONS] : null,
                supportsFirstLastFrame,
                supportsHD,
                apiType: DEFAULT_PROVIDERS[config.provider]?.apiType || 'openai',
                customParams: [],
                asyncConfig: null
            };
            return ({
                ...entryBase,
                requestTemplate: getDefaultRequestTemplateForEntry(entryBase),
                requestOverrideEnabled: false,
                requestOverridePatch: null
            });
    })
];

const getDefaultRatiosForModel = (modelId) => {
    if (!modelId) return RATIOS;
    if (modelId.includes('grok')) return GROK_VIDEO_RATIOS;
    return RATIOS;
};
const RESOLUTIONS = ['Auto', '1K', '2K', '4K'];
const normalizeResolutionOption = (value) => {
    const raw = String(value || '').trim();
    if (!raw) return null;
    const upper = raw.toUpperCase();
    if (upper === 'AUTO') return 'Auto';
    if (upper === '1K' || upper === '2K' || upper === '4K') return upper;
    const sizeMatch = raw.match(/^(\d+)\s*[xX]\s*(\d+)$/);
    if (sizeMatch) return `${sizeMatch[1]}x${sizeMatch[2]}`;
    const kMatch = upper.match(/^(\d+)K$/);
    if (kMatch) return `${kMatch[1]}K`;
    return raw;
};
const normalizeImageResolution = (value) => {
    const normalized = normalizeResolutionOption(value);
    if (normalized) return normalized;
    return '2K';
};
const isExplicitImageResolution = (value) => {
    const raw = String(value || '').trim();
    return /^\d+\s*[xX]\s*\d+$/.test(raw);
};
const normalizeVideoResolution = (value) => {
    const raw = String(value || '').trim();
    if (!raw) return '720P';
    if (raw === '不选') return 'Auto';
    const upper = raw.toUpperCase();
    if (upper === 'AUTO') return 'Auto';
    if (upper.endsWith('P') || upper.endsWith('K')) return upper;
    return upper;
};
const normalizeVideoResolutionLower = (value) => {
    const normalized = normalizeVideoResolution(value);
    if (!normalized || normalized === 'Auto') return '';
    return normalized.toLowerCase();
};
const stripValueNotes = (value) => {
    if (value === null || value === undefined) return '';
    return String(value)
        .replace(/[（(][^）)]*[）)]/g, '')
        .replace(/\s+/g, '')
        .trim();
};
const normalizeJimengVideoRatio = (value, options = {}) => {
    const defaultRatio = options.defaultRatio ? String(options.defaultRatio) : '1:1';
    const allowed = Array.isArray(options.allowedRatios)
        ? new Set(options.allowedRatios.map((item) => String(item).toLowerCase()))
        : null;
    const raw = stripValueNotes(value);
    if (!raw) return defaultRatio;
    const lower = raw.toLowerCase();
    if (lower === 'auto') {
        return allowed ? (allowed.has('auto') ? 'auto' : defaultRatio) : defaultRatio;
    }
    const match = raw.match(/^(\d+):(\d+)$/);
    if (match) {
        const w = parseInt(match[1], 10);
        const h = parseInt(match[2], 10);
        if (Number.isFinite(w) && Number.isFinite(h) && w > 0 && h > 0) {
            const normalized = `${w}:${h}`;
            if (allowed && !allowed.has(normalized.toLowerCase())) return defaultRatio;
            return normalized;
        }
    }
    if (allowed && !allowed.has(raw.toLowerCase())) return defaultRatio;
    return raw;
};
const supportsJimengVideoResolution = (modelKey) => {
    if (!modelKey) return false;
    const raw = String(modelKey).toLowerCase();
    if (!raw) return false;
    if (raw.includes('sora2')) return false;
    if (raw.includes('veo3')) return false;
    if (raw.includes('3.5')) return false;
    if (raw.includes('3.0-pro') || raw.includes('3.5-pro')) return false;
    if (raw.includes('2.0')) return false;
    if (raw.includes('vgfm_3.0_fast')) return true;
    if (raw.includes('vgfm_3.0') && !raw.includes('_pro')) return true;
    return raw.includes('video-3.0-fast') || raw.includes('video-3.0');
};
const normalizeJimengVideoResolution = (value, { allowExplicit = false } = {}) => {
    const normalized = normalizeVideoResolutionLower(stripValueNotes(value));
    if (!normalized || normalized === 'auto') return '';
    if (normalized === '720p' || normalized === '1080p') return normalized;
    if (normalized === '2k' || normalized === '4k') return '1080p';
    const cleaned = normalized.replace(/[^0-9x]/g, '');
    if (/^\d+x\d+$/.test(cleaned)) {
        if (!allowExplicit) {
            const [wRaw, hRaw] = cleaned.split('x').map((v) => parseInt(v, 10));
            const maxSide = Math.max(wRaw || 0, hRaw || 0);
            if (!maxSide) return '';
            return maxSide <= 1280 ? '720p' : '1080p';
        }
        return cleaned;
    }
    return '';
};
const normalizeDurationValue = (value, fallback = 8) => {
    if (value === null || value === undefined) return fallback;
    const cleaned = String(value).trim().replace(/[^\d]/g, '');
    const parsed = parseInt(cleaned, 10);
    return Number.isFinite(parsed) ? parsed : fallback;
};
const normalizeJimengVideoDuration = (value, allowed = []) => {
    const fallback = allowed && allowed.length > 0 ? allowed[0] : 5;
    const parsed = normalizeDurationValue(value, fallback);
    if (!allowed || allowed.length === 0) return parsed;
    return allowed.includes(parsed) ? parsed : fallback;
};
const isImageModelType = (type) => type === 'Image' || type === 'ChatImage';
const isChatModelType = (type) => type === 'Chat' || type === 'ChatImage';
const MAX_CUSTOM_PARAMS = 30;
const MAX_CUSTOM_PARAM_VALUES = 50;
const COMPLETED_STATUS_SET = new Set(['completed', 'complete', 'success', 'succeeded', 'done', 'finished', 'ok']);
const isCompletedLikeStatus = (status) => {
    if (status === null || status === undefined || status === '') return true;
    const normalized = String(status).trim().toLowerCase();
    if (!normalized) return true;
    return COMPLETED_STATUS_SET.has(normalized);
};
const normalizeCustomParamNotes = (notes) => {
    if (!notes || typeof notes !== 'object') return {};
    const next = {};
    Object.entries(notes).forEach(([value, note]) => {
        const key = String(value || '').trim();
        const text = typeof note === 'string' ? note.trim() : '';
        if (key && text) next[key] = text;
    });
    return next;
};
const normalizeValueNotes = (notes) => normalizeCustomParamNotes(notes);
const normalizeResolutionNotes = (notes) => {
    if (!notes || typeof notes !== 'object') return {};
    const next = {};
    Object.entries(notes).forEach(([value, note]) => {
        const key = normalizeResolutionOption(value);
        const text = typeof note === 'string' ? note.trim() : '';
        if (key && text) next[key] = text;
    });
    return next;
};
const normalizeCustomParams = (params) => {
    if (!Array.isArray(params)) return [];
    return params.map((param, index) => {
        if (!param) return null;
        const id = String(param.id || '').trim()
            || `param-${Date.now()}-${Math.random().toString(36).slice(2, 6)}-${index}`;
        const rawName = param?.name ?? param?.label ?? param?.displayName ?? param?.paramName ?? param?.key;
        const name = rawName !== undefined && rawName !== null ? String(rawName).trim() : '';
        const values = Array.isArray(param.values)
            ? param.values.map(value => String(value).trim()).filter(Boolean)
            : [];
        const rawDefault = param?.defaultValue ?? param?.default ?? '';
        const defaultValue = rawDefault === null || rawDefault === undefined
            ? ''
            : String(rawDefault).trim();
        const normalizedNotes = normalizeCustomParamNotes(param.valueNotes || param.valueLabels || param.notes);
        const notesEnabled = typeof param.notesEnabled === 'boolean'
            ? param.notesEnabled
            : Object.keys(normalizedNotes).length > 0;
        return {
            id,
            name,
            values,
            override: !!param.override,
            notesEnabled,
            valueNotes: normalizedNotes,
            defaultValue
        };
    }).filter(Boolean);
};
const getImageSourceFallbackByParam = (paramName, imageSources = []) => {
    if (!paramName || !Array.isArray(imageSources) || imageSources.length === 0) return null;
    const lower = String(paramName).toLowerCase();
    let index = null;
    if (lower.includes('imagea')) index = 0;
    else if (lower.includes('imageb')) index = 1;
    else if (lower.includes('imagec')) index = 2;
    else if (lower.includes('imaged')) index = 3;
    if (index === null) {
        const numberMatch = lower.match(/image(?:_|-)?(\d+)/);
        if (numberMatch) {
            const parsed = parseInt(numberMatch[1], 10);
            if (Number.isFinite(parsed) && parsed > 0) index = parsed - 1;
        }
    }
    if (index === null) return null;
    return imageSources[index] || null;
};
function getDefaultRequestTemplateForType(type) {
    const modelType = type || 'Chat';
    let endpoint = '/v1/images/generations';
    if (modelType === 'Video') endpoint = '/v1/videos/generations';
    if (modelType === 'Chat' || modelType === 'ChatImage') endpoint = '/v1/chat/completions';
    let body = {
        model: '{{modelName}}',
        prompt: '{{prompt}}'
    };
    if (modelType === 'Video') {
        body = {
            model: '{{modelName}}',
            prompt: '{{prompt}}',
            duration: '{{duration:number}}',
            ratio: '{{ratio}}',
            resolution: '{{resolution}}'
        };
    } else if (modelType === 'Chat' || modelType === 'ChatImage') {
        body = {
            model: '{{modelName}}',
            messages: [{ role: 'user', content: '{{prompt}}' }],
            stream: false
        };
    } else {
        body = {
            model: '{{modelName}}',
            prompt: '{{prompt}}',
            n: 1,
            size: '{{size}}'
        };
    }
    return {
        enabled: false,
        endpoint,
        method: 'POST',
        bodyType: 'json',
        headers: { 'Content-Type': 'application/json' },
        query: {},
        files: {},
        timeoutMs: null,
        responseParser: '',
        body
    };
}
function isJimengVideoModelId(value) {
    const raw = String(value || '').toLowerCase();
    if (!raw) return false;
    return raw.includes('jimeng') || raw.includes('dreamina');
}
function getJimengVideoRequestTemplate() {
    return {
        enabled: true,
        endpoint: '/v1/videos/generations',
        method: 'POST',
        bodyType: 'auto',
        headers: { 'Content-Type': 'application/json' },
        query: {},
        files: {
            image_file_1: '{{firstFrame:blob}}',
            image_file_2: '{{lastFrame:blob}}'
        },
        timeoutMs: null,
        responseParser: 'jimeng.video',
        body: {
            model: '{{modelName}}',
            prompt: '{{prompt}}',
            duration: '{{jimengDuration:number}}',
            ratio: '{{jimengRatio}}',
            resolution: '{{jimengResolution}}'
        }
    };
}
function getDefaultRequestTemplateForEntry(entry) {
    const type = entry?.type || 'Chat';
    const id = entry?.id || entry?.modelName || '';
    if (type === 'Video' && isJimengVideoModelId(id)) {
        return getJimengVideoRequestTemplate();
    }
    return getDefaultRequestTemplateForType(type);
}
const getCustomParamSelection = (param, selections) => {
    if (!param) return '';
    if (selections) {
        const byId = param.id && selections[param.id];
        if (byId !== undefined && byId !== null && byId !== '') return byId;
        const byName = param.name && selections[param.name];
        if (byName !== undefined && byName !== null && byName !== '') return byName;
    }
    const fallback = param?.defaultValue ?? '';
    if (fallback !== undefined && fallback !== null && fallback !== '') return fallback;
    return '';
};
const getValueLabelWithNotes = (value, notesEnabled, notes) => {
    if (!value) return '';
    if (!notesEnabled) return value;
    const note = notes?.[value];
    return note ? `${value}(${note})` : value;
};
const getNoteLabelWithNotes = (value, notesEnabled, notes) => {
    if (!value) return '';
    if (!notesEnabled) return value;
    const note = notes?.[value];
    return note || value;
};
const getCustomParamValueLabel = (param, value) => {
    return getValueLabelWithNotes(value, !!param?.notesEnabled, param?.valueNotes || {});
};
const isCustomParamInputMode = (param) => {
    if (!param) return false;
    const rawName = String(param?.name || '');
    const name = rawName.toLowerCase();
    if (name.includes('input') || rawName.includes('输入')) return true;
    const values = Array.isArray(param?.values) ? param.values : [];
    return values.some((value) => {
        const rawValue = String(value || '');
        return rawValue.toLowerCase().includes('input') || rawValue.includes('输入');
    });
};
const applyCustomParamsToPayload = (payload, customParams, selections) => {
    if (!payload || !Array.isArray(customParams) || customParams.length === 0) return payload;
    const isFormData = typeof FormData !== 'undefined' && payload instanceof FormData;
    customParams.forEach((param) => {
        const name = String(param?.name || '').trim();
        if (!name) return;
        const value = getCustomParamSelection(param, selections);
        if (value === '' || value === undefined || value === null) return;
        if (isFormData) {
            if (param.override || !payload.has(name)) {
                payload.set(name, value);
            }
            return;
        }
        if (param.override || payload[name] === undefined) {
            payload[name] = value;
        }
    });
    return payload;
};
const buildCustomParamPreviewPayload = (basePayload, customParams) => {
    if (!basePayload) return basePayload;
    if (!Array.isArray(customParams) || customParams.length === 0) return basePayload;
    const preview = { ...basePayload };
    customParams.forEach((param) => {
        const name = String(param?.name || '').trim();
        if (!name) return;
        const value = Array.isArray(param.values) && param.values.length > 0 ? param.values[0] : '';
        if (value === '') return;
        if (param.override || preview[name] === undefined) {
            preview[name] = value;
        }
    });
    return preview;
};
const normalizePreviewOverridePatch = (patch) => {
    if (!patch || typeof patch !== 'object' || Array.isArray(patch)) return null;
    return { ...patch };
};
const isPreviewValueEqual = (left, right) => {
    if (left === right) return true;
    if (typeof left === 'object' || typeof right === 'object') {
        try {
            return JSON.stringify(left) === JSON.stringify(right);
        } catch (e) {
            return false;
        }
    }
    return false;
};
const buildPreviewOverridePatch = (basePayload, editedPayload) => {
    if (!basePayload || !editedPayload || typeof editedPayload !== 'object') return null;
    const patch = {};
    const baseKeys = new Set(Object.keys(basePayload));
    Object.keys(editedPayload).forEach((key) => {
        const editedValue = editedPayload[key];
        const baseValue = basePayload[key];
        if (!isPreviewValueEqual(baseValue, editedValue)) {
            patch[key] = editedValue;
        }
        baseKeys.delete(key);
    });
    baseKeys.forEach((key) => {
        patch[key] = null;
    });
    return Object.keys(patch).length > 0 ? patch : null;
};
const applyPreviewOverridePatch = (payload, patch) => {
    if (!payload || !patch || typeof patch !== 'object') return payload;
    const isFormData = typeof FormData !== 'undefined' && payload instanceof FormData;
    Object.entries(patch).forEach(([key, value]) => {
        if (!key) return;
        if (value === null) {
            if (isFormData) {
                payload.delete(key);
            } else {
                delete payload[key];
            }
            return;
        }
        if (isFormData) {
            const nextValue = typeof value === 'string' ? value : JSON.stringify(value);
            payload.set(key, nextValue);
            return;
        }
        payload[key] = value;
    });
    return payload;
};
const normalizeRequestTemplate = (template) => {
    if (!template || typeof template !== 'object') return null;
    const normalized = {
        enabled: template.enabled !== false,
        endpoint: typeof template.endpoint === 'string' ? template.endpoint.trim() : '',
        method: (template.method || 'POST').toString().toUpperCase(),
        bodyType: (template.bodyType || 'json').toString().toLowerCase(),
        headers: (template.headers && typeof template.headers === 'object' && !Array.isArray(template.headers))
            ? { ...template.headers }
            : {},
        query: (template.query && typeof template.query === 'object' && !Array.isArray(template.query))
            ? { ...template.query }
            : {},
        files: (template.files && typeof template.files === 'object' && !Array.isArray(template.files))
            ? { ...template.files }
            : {},
        timeoutMs: Number.isFinite(template.timeoutMs) ? Number(template.timeoutMs) : null,
        responseParser: typeof template.responseParser === 'string' ? template.responseParser.trim() : '',
        body: (template.body && typeof template.body === 'object' && !Array.isArray(template.body))
            ? template.body
            : (template.body ?? {})
    };
    return normalized;
};
const normalizeStringArray = (value) => {
    if (Array.isArray(value)) {
        return value.map(item => String(item || '').trim()).filter(Boolean);
    }
    if (typeof value === 'string') {
        const trimmed = value.trim();
        return trimmed ? [trimmed] : [];
    }
    return [];
};
const normalizeAsyncRequestTemplate = (template) => {
    if (!template || typeof template !== 'object') return null;
    return normalizeRequestTemplate({ ...template, enabled: true });
};
const coerceAsyncRequestTemplate = (value, defaultMethod = 'GET') => {
    if (!value) return null;
    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return null;
        const hasRequestId = /\{\{\s*requestId\s*\}\}/i.test(trimmed)
            || /requestId=|request_id=|taskId=/.test(trimmed);
        const endpoint = hasRequestId
            ? trimmed
            : `${trimmed}${trimmed.includes('?') ? '&' : '?'}requestId={{requestId}}`;
        return normalizeRequestTemplate({ endpoint, method: defaultMethod });
    }
    if (typeof value === 'object') {
        return normalizeAsyncRequestTemplate(value);
    }
    return null;
};
const normalizeAsyncConfig = (config) => {
    if (!config || typeof config !== 'object') return null;
    const normalized = {
        enabled: config.enabled === true,
        requestIdPaths: normalizeStringArray(config.requestIdPaths || config.requestIdPath || config.requestId),
        pollIntervalMs: Number.isFinite(Number(config.pollIntervalMs)) ? Number(config.pollIntervalMs) : 3000,
        maxAttempts: Number.isFinite(Number(config.maxAttempts)) ? Number(config.maxAttempts) : 300,
        statusRequest: coerceAsyncRequestTemplate(config.statusRequest || config.status || config.pollRequest || config.detail),
        statusPath: typeof config.statusPath === 'string' ? config.statusPath.trim() : '',
        successValues: normalizeStringArray(config.successValues || config.successStatuses || config.successStatus || config.success),
        failureValues: normalizeStringArray(config.failureValues || config.failureStatuses || config.failureStatus || config.failure),
        outputsRequest: coerceAsyncRequestTemplate(config.outputsRequest || config.outputs || config.resultRequest),
        outputsPath: typeof config.outputsPath === 'string' ? config.outputsPath.trim() : '',
        outputsUrlField: typeof config.outputsUrlField === 'string' ? config.outputsUrlField.trim() : '',
        errorPath: typeof config.errorPath === 'string' ? config.errorPath.trim() : ''
    };
    if (!normalized.requestIdPaths.length) {
        normalized.requestIdPaths = ['requestId', 'request_id', 'data.requestId', 'data.request_id'];
    }
    normalized.successValues = normalized.successValues.length
        ? normalized.successValues.map(v => v.toUpperCase())
        : ['SUCCESS', 'SUCCEED', 'COMPLETED', 'FINISHED', 'DONE'];
    normalized.failureValues = normalized.failureValues.length
        ? normalized.failureValues.map(v => v.toUpperCase())
        : ['FAILED', 'ERROR', 'CANCELLED', 'CANCELED', 'FAILURE'];
    return normalized;
};
const normalizeModelLibraryEntry = (entry, index = 0) => {
    if (!entry || typeof entry !== 'object') return null;
    const rawId = String(entry.id || entry.modelName || entry.displayName || '').trim();
    const id = rawId || `library-${Date.now()}-${Math.random().toString(36).slice(2, 6)}-${index}`;
    return {
        id,
        displayName: entry.displayName || entry.modelName || id,
        modelName: entry.modelName || entry.displayName || id,
        type: entry.type || 'Chat',
        apiType: entry.apiType || 'openai',
        ratioLimits: Array.isArray(entry.ratioLimits) ? entry.ratioLimits : null,
        ratioNotes: normalizeValueNotes(entry.ratioNotes),
        ratioNotesEnabled: !!entry.ratioNotesEnabled,
        resolutionLimits: Array.isArray(entry.resolutionLimits) ? entry.resolutionLimits : null,
        resolutionNotes: normalizeResolutionNotes(entry.resolutionNotes),
        resolutionNotesEnabled: !!entry.resolutionNotesEnabled,
        durations: Array.isArray(entry.durations) ? entry.durations : null,
        durationNotes: normalizeValueNotes(entry.durationNotes),
        durationNotesEnabled: !!entry.durationNotesEnabled,
        videoResolutions: Array.isArray(entry.videoResolutions) ? entry.videoResolutions : null,
        videoResolutionNotes: normalizeValueNotes(entry.videoResolutionNotes),
        videoResolutionNotesEnabled: !!entry.videoResolutionNotesEnabled,
        supportsFirstLastFrame: !!entry.supportsFirstLastFrame,
        supportsHD: !!entry.supportsHD,
        omitRatioOnSubmit: !!entry.omitRatioOnSubmit,
        omitResolutionOnSubmit: !!entry.omitResolutionOnSubmit,
        customParams: normalizeCustomParams(entry.customParams),
        asyncConfig: normalizeAsyncConfig(entry.asyncConfig),
        previewOverrideEnabled: !!entry.previewOverrideEnabled,
        previewOverridePatch: normalizePreviewOverridePatch(entry.previewOverridePatch),
        requestTemplate: normalizeRequestTemplate(entry.requestTemplate || getDefaultRequestTemplateForEntry(entry)),
        requestOverrideEnabled: !!entry.requestOverrideEnabled,
        requestOverridePatch: normalizeRequestOverridePatch(entry.requestOverridePatch),
        responseParser: entry.responseParser || ''
    };
};
const normalizeRequestOverridePatch = (patch) => {
    return normalizePreviewOverridePatch(patch);
};
const TEMPLATE_VAR_PATTERN = /\{\{\s*([a-zA-Z0-9_.-]+)(?::([a-zA-Z0-9_-]+))?\s*\}\}/g;
const getTemplateVarValue = (vars, path) => {
    if (!vars || !path) return undefined;
    return path.split('.').reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined), vars);
};
const coerceTemplateValue = (value, type, options = {}) => {
    if (type === 'number') {
        if (value === null || value === undefined || value === '') return value;
        if (typeof value === 'number' && Number.isFinite(value)) return value;
        const parsed = parseFloat(String(value).replace(/[^\d.-]/g, ''));
        return Number.isFinite(parsed) ? parsed : value;
    }
    if (type === 'string') {
        return value === null || value === undefined ? '' : String(value);
    }
    if (type === 'blob') {
        if (options.bodyType === 'json' && options.fallbackBlobAsDataUrl) {
            return options.fallbackBlobAsDataUrl;
        }
        return value;
    }
    return value;
};
const getValueByPath = (data, path) => {
    if (!data || !path) return undefined;
    const normalizedPath = String(path).replace(/\[(\d+)\]/g, '.$1').replace(/^\./, '');
    const parts = normalizedPath.split('.').filter(Boolean);
    let current = data;
    for (const part of parts) {
        if (current === null || current === undefined) return undefined;
        current = current[part];
    }
    return current;
};
const getValueByPathAny = (data, paths) => {
    if (!paths || paths.length === 0) return undefined;
    for (const path of paths) {
        const value = getValueByPath(data, path);
        if (value !== undefined && value !== null && value !== '') return value;
    }
    return undefined;
};
const normalizeAsyncStatusValue = (value) => {
    if (value === undefined || value === null) return '';
    return String(value).trim().toUpperCase();
};
const extractAsyncOutputUrls = (outputs, urlField) => {
    const urls = [];
    const pushUrl = (value) => {
        if (!value) return;
        if (typeof value === 'string') {
            const trimmed = value.trim();
            if (trimmed) urls.push(trimmed);
        }
    };
    const pushFromObject = (value) => {
        if (!value || typeof value !== 'object') return;
        if (urlField && value[urlField]) {
            pushUrl(value[urlField]);
            return;
        }
        const directUrl = value.url || value.image_url || value.imageUrl || value.object_url || value.objectUrl || value.path || value.uri || value.file_uri || value.fileUri;
        if (directUrl) pushUrl(directUrl);
        const base64Payload = value.b64_json || value.base64 || value.data;
        if (typeof base64Payload === 'string' && base64Payload.trim()) {
            pushUrl(base64Payload);
        }
    };
    if (Array.isArray(outputs)) {
        outputs.forEach((item) => {
            if (!item) return;
            if (typeof item === 'string') {
                pushUrl(item);
                return;
            }
            if (typeof item === 'object') {
                pushFromObject(item);
            }
        });
    } else if (outputs && typeof outputs === 'object') {
        pushFromObject(outputs);
    } else if (typeof outputs === 'string') {
        pushUrl(outputs);
    }
    return urls;
};
const isLikelyImagePayload = (value) => {
    if (!value || typeof value !== 'string') return false;
    const trimmed = value.trim();
    if (!trimmed) return false;
    if (trimmed.startsWith('http://') || trimmed.startsWith('https://') || trimmed.startsWith('data:') || trimmed.startsWith('blob:')) return true;
    if (LocalImageManager?.isImageId && LocalImageManager.isImageId(trimmed)) return true;
    const base64Like = /^[A-Za-z0-9+/=_-]+$/.test(trimmed);
    return base64Like && trimmed.length > 64;
};
const collectDeepImageValues = (input, maxDepth = 6) => {
    const results = new Set();
    const visited = new WeakSet();
    const pushValue = (value) => {
        if (isLikelyImagePayload(value)) results.add(value.trim());
    };
    const walk = (obj, depth = 0) => {
        if (depth > maxDepth || obj === null || obj === undefined) return;
        if (typeof obj === 'string') {
            pushValue(obj);
            return;
        }
        if (typeof obj !== 'object') return;
        if (visited.has(obj)) return;
        visited.add(obj);
        const urlFields = ['url', 'image_url', 'imageUrl', 'image', 'src', 'link', 'href', 'object_url', 'objectUrl', 'path', 'uri', 'file_uri', 'fileUri', 'data', 'base64', 'b64_json'];
        for (const field of urlFields) {
            if (obj[field]) pushValue(obj[field]);
        }
        if (Array.isArray(obj)) {
            obj.forEach((item) => walk(item, depth + 1));
            return;
        }
        Object.values(obj).forEach((value) => walk(value, depth + 1));
    };
    walk(input, 0);
    return Array.from(results);
};
const collectImmediateImageUrls = (data) => {
    if (!data || typeof data !== 'object') return [];
    const urls = new Set();
    const pushUrl = (value) => {
        if (!value) return;
        if (typeof value === 'string') {
            const trimmed = value.trim();
            if (trimmed) urls.add(trimmed);
            return;
        }
        if (Array.isArray(value)) {
            value.forEach((entry) => pushUrl(entry));
            return;
        }
        if (typeof value === 'object') {
            const directUrl = value.url || value.image_url || value.imageUrl || value.object_url || value.objectUrl || value.path || value.uri || value.file_uri || value.fileUri;
            if (directUrl) pushUrl(directUrl);
            const b64 = value.b64_json || value.base64 || value.data;
            if (typeof b64 === 'string' && b64.trim()) urls.add(b64.trim());
        }
    };
    const sources = [
        data?.data?.data,
        data?.data,
        data?.preview,
        data?.preview?.data,
        data?.response,
        data?.response?.data,
        data?.result,
        data?.result?.data,
        data?.output,
        data?.output?.data,
        data?.images,
        data?.data?.images,
        data?.output_images,
        data?.output?.output_images,
        data?.data?.output_images,
        data?.data?.output?.output_images,
        data?.result?.output_images,
        data?.result?.output?.output_images,
        data?.output?.images,
        data?.data?.output?.images
    ];
    sources.forEach((entry) => pushUrl(entry));
    return Array.from(urls);
};
const resolveTemplateString = (value, vars, options = {}) => {
    if (typeof value !== 'string') return value;
    const trimmed = value.trim();
    const singleMatch = trimmed.match(/^{{\s*([a-zA-Z0-9_.-]+)(?::([a-zA-Z0-9_-]+))?\s*}}$/);
    if (singleMatch) {
        const [, varName, varType] = singleMatch;
        const fallbackBlob = varType === 'blob'
            ? (getTemplateVarValue(vars, `${varName}DataUrl`) || getTemplateVarValue(vars, `${varName}DataURL`))
            : undefined;
        const raw = getTemplateVarValue(vars, varType === 'blob' ? `${varName}Blob` : varName);
        return coerceTemplateValue(raw, varType, { bodyType: options.bodyType, fallbackBlobAsDataUrl: fallbackBlob });
    }
    return value.replace(TEMPLATE_VAR_PATTERN, (matchText, varName, varType, offset) => {
        const fallbackBlob = varType === 'blob'
            ? (getTemplateVarValue(vars, `${varName}DataUrl`) || getTemplateVarValue(vars, `${varName}DataURL`))
            : undefined;
        const raw = getTemplateVarValue(vars, varType === 'blob' ? `${varName}Blob` : varName);
        const coerced = coerceTemplateValue(raw, varType, { bodyType: options.bodyType, fallbackBlobAsDataUrl: fallbackBlob });
        if (coerced === null || coerced === undefined) {
            if (options.bodyType === 'raw') {
                const prevChar = value[offset - 1];
                const nextChar = value[offset + matchText.length];
                if (prevChar === '"' && nextChar === '"') {
                    return '';
                }
                return 'null';
            }
            return '';
        }
        if (typeof coerced === 'object') {
            try {
                return JSON.stringify(coerced);
            } catch (e) {
                return '';
            }
        }
        return String(coerced);
    });
};
const resolveTemplateValue = (value, vars, options = {}) => {
    if (Array.isArray(value)) {
        return value.map((item) => resolveTemplateValue(item, vars, options));
    }
    if (value && typeof value === 'object' && !(value instanceof Blob) && !(value instanceof File)) {
        const next = {};
        Object.entries(value).forEach(([key, val]) => {
            next[key] = resolveTemplateValue(val, vars, options);
        });
        return next;
    }
    if (typeof value === 'string') {
        return resolveTemplateString(value, vars, options);
    }
    return value;
};
const appendQueryParams = (endpoint, query) => {
    if (!endpoint || !query || typeof query !== 'object') return endpoint;
    const entries = Object.entries(query).filter(([key, val]) => key);
    if (entries.length === 0) return endpoint;
    const isAbsolute = /^https?:/i.test(endpoint);
    const base = isAbsolute ? undefined : 'http://placeholder';
    let urlObj;
    try {
        urlObj = new URL(endpoint, base);
    } catch (e) {
        return endpoint;
    }
    entries.forEach(([key, val]) => {
        if (val === undefined || val === null || val === '') return;
        if (Array.isArray(val)) {
            val.forEach((item) => {
                if (item === undefined || item === null || item === '') return;
                urlObj.searchParams.append(key, String(item));
            });
            return;
        }
        urlObj.searchParams.set(key, String(val));
    });
    if (isAbsolute) return urlObj.toString();
    const path = urlObj.pathname || '';
    const search = urlObj.search || '';
    const hash = urlObj.hash || '';
    return `${path}${search}${hash}`;
};
const compactTemplateObject = (value) => {
    if (Array.isArray(value)) {
        return value
            .map((item) => compactTemplateObject(item))
            .filter((item) => item !== undefined && item !== null);
    }
    if (value && typeof value === 'object' && !(value instanceof Blob) && !(value instanceof File)) {
        const next = {};
        Object.entries(value).forEach(([key, val]) => {
            if (!key) return;
            const cleaned = compactTemplateObject(val);
            if (cleaned === undefined || cleaned === null) return;
            next[key] = cleaned;
        });
        return next;
    }
    return value;
};
const hasBinaryTemplateValue = (value) => {
    if (!value) return false;
    if (value instanceof Blob || value instanceof File) return true;
    if (typeof value === 'string' && value.startsWith('data:')) return true;
    if (Array.isArray(value)) return value.some((item) => hasBinaryTemplateValue(item));
    if (typeof value === 'object') {
        return Object.values(value).some((item) => hasBinaryTemplateValue(item));
    }
    return false;
};
const buildRequestFromTemplate = (template, vars, options = {}) => {
    if (!template) return null;
    const rawBodyType = (template.bodyType || 'json').toString().toLowerCase();
    const method = (template.method || 'POST').toString().toUpperCase();
    const resolveTemplateWith = (bodyTypeForResolve) => ({
        resolvedEndpoint: resolveTemplateString(template.endpoint || '', vars, { bodyType: bodyTypeForResolve }),
        headers: compactTemplateObject(resolveTemplateValue(template.headers || {}, vars, { bodyType: bodyTypeForResolve })),
        resolvedQuery: compactTemplateObject(resolveTemplateValue(template.query || {}, vars, { bodyType: bodyTypeForResolve })),
        resolvedBody: compactTemplateObject(resolveTemplateValue(template.body || {}, vars, { bodyType: bodyTypeForResolve })),
        resolvedFiles: compactTemplateObject(resolveTemplateValue(template.files || {}, vars, { bodyType: bodyTypeForResolve }))
    });
    const resolveBodyType = rawBodyType === 'auto' ? 'multipart' : rawBodyType;
    let { resolvedEndpoint, headers, resolvedQuery, resolvedBody, resolvedFiles } = resolveTemplateWith(resolveBodyType);
    let bodyType = rawBodyType === 'auto'
        ? (hasBinaryTemplateValue(resolvedBody) || hasBinaryTemplateValue(resolvedFiles) ? 'multipart' : 'json')
        : rawBodyType;
    if (rawBodyType === 'auto' && bodyType === 'json') {
        ({ resolvedEndpoint, headers, resolvedQuery, resolvedBody, resolvedFiles } = resolveTemplateWith('json'));
    }
    let body = resolvedBody;
    if (bodyType === 'multipart') {
        const form = new FormData();
        Object.entries(resolvedBody || {}).forEach(([key, val]) => {
            if (val === undefined || val === null || key === '') return;
            if (Array.isArray(val)) {
                val.forEach((item) => {
                    if (item === undefined || item === null) return;
                    if (item instanceof Blob || item instanceof File) {
                        form.append(key, item, item.name || 'file');
                    } else if (typeof item === 'object') {
                        form.append(key, JSON.stringify(item));
                    } else {
                        form.append(key, String(item));
                    }
                });
                return;
            }
            if (val instanceof Blob || val instanceof File) {
                form.append(key, val, val.name || 'file');
            } else if (typeof val === 'object') {
                form.append(key, JSON.stringify(val));
            } else {
                form.append(key, String(val));
            }
        });
        Object.entries(resolvedFiles || {}).forEach(([key, val]) => {
            if (!key || val === undefined || val === null) return;
            const appendFile = (fileVal) => {
                if (!fileVal) return;
                if (fileVal instanceof Blob || fileVal instanceof File) {
                    form.append(key, fileVal, fileVal.name || 'file');
                    return;
                }
                if (typeof fileVal === 'string' && fileVal.startsWith('data:')) {
                    try {
                        const blob = dataUrlToBlob(fileVal);
                        form.append(key, blob, 'file');
                    } catch { }
                }
            };
            if (Array.isArray(val)) {
                val.forEach(appendFile);
                return;
            }
            appendFile(val);
        });
        body = form;
    } else if (bodyType === 'raw') {
        if (typeof body !== 'string') {
            body = JSON.stringify(body ?? {});
        }
    }
    return {
        url: appendQueryParams(resolvedEndpoint, resolvedQuery),
        method,
        headers,
        body,
        bodyType,
        timeoutMs: Number.isFinite(template.timeoutMs) ? Number(template.timeoutMs) : null,
        responseParser: template.responseParser || ''
    };
};
const applyRequestOverridePatch = (request, patch) => {
    if (!request || !patch || typeof patch !== 'object') return request;
    const next = { ...request };
    Object.entries(patch).forEach(([key, value]) => {
        if (!key) return;
        if (value === null) {
            delete next[key];
        } else {
            next[key] = value;
        }
    });
    return next;
};
const coerceFormDataFromObject = (data) => {
    if (typeof FormData === 'undefined') return data;
    if (data instanceof FormData) return data;
    const form = new FormData();
    const entries = data && typeof data === 'object' ? Object.entries(data) : [];
    entries.forEach(([key, val]) => {
        if (val === undefined || val === null || key === '') return;
        if (Array.isArray(val)) {
            val.forEach((item) => {
                if (item === undefined || item === null) return;
                if (item instanceof Blob || item instanceof File) {
                    form.append(key, item, item.name || 'file');
                } else if (typeof item === 'object') {
                    form.append(key, JSON.stringify(item));
                } else {
                    form.append(key, String(item));
                }
            });
            return;
        }
        if (val instanceof Blob || val instanceof File) {
            form.append(key, val, val.name || 'file');
        } else if (typeof val === 'object') {
            form.append(key, JSON.stringify(val));
        } else {
            form.append(key, String(val));
        }
    });
    return form;
};
const formatRequestPreview = (request) => {
    if (!request) return null;
    const formatted = { ...request };
    if (request.body instanceof FormData) {
        const formEntries = {};
        request.body.forEach((value, key) => {
            if (!formEntries[key]) formEntries[key] = [];
            if (value instanceof Blob || value instanceof File) {
                formEntries[key].push('[Blob]');
            } else {
                formEntries[key].push(value);
            }
        });
        formatted.body = formEntries;
    }
    return formatted;
};
const getModelLibraryPreviewEndpoint = (entry) => {
    if (!entry) return '/v1/images/generations';
    if (entry.type === 'Video') return '/v1/videos/generations';
    if (entry.type === 'Chat' || entry.type === 'ChatImage') return '/v1/chat/completions';
    return '/v1/images/generations';
};
const buildPythonPreviewSnippet = (endpoint, payload) => {
    const jsonText = JSON.stringify(payload || {}, null, 2);
    return [
        'import requests, json',
        'BASE_URL = "https://api.example.com"',
        'API_KEY = "YOUR_API_KEY"',
        `url = f"{BASE_URL}${endpoint}"`,
        'headers = {"Authorization": f"Bearer {API_KEY}", "Content-Type": "application/json"}',
        `payload = json.loads('''${jsonText}''')`,
        'resp = requests.post(url, headers=headers, json=payload)',
        'print(resp.json())'
    ].join('\n');
};
// 根据模型返回不同的分辨率选项
const getDefaultResolutionsForModel = (modelId) => {
    if (!modelId) return RESOLUTIONS;
    // jimeng-4.5模型只显示2K和4K两个选项
    if (modelId.includes('jimeng-4.5')) return ['2K', '4K'];
    return RESOLUTIONS;
};
// Midjourney版本列表
const MJ_VERSIONS = [
    { label: 'MJ V7', value: '--v 7' },
    { label: 'MJ V6.1', value: '--v 6.1' },
    { label: 'MJ V6', value: '--v 6' },
    { label: 'MJ V5.2', value: '--v 5.2' },
    { label: 'MJ V5.1', value: '--v 5.1' },
    { label: 'Niji V6', value: '--niji 6' },
    { label: 'Niji V5', value: '--niji 5' },
    { label: 'Niji V4', value: '--niji 4' }
];

// --- 辅助：计算真实分辨率 ---
const calculateResolution = (ratio, baseResolution) => {
    let baseW = 1024;
    let baseH = 1024;

    if (isExplicitImageResolution(baseResolution)) {
        const parts = String(baseResolution).trim().split(/[xX]/);
        const parsedW = parseInt(parts[0], 10);
        const parsedH = parseInt(parts[1], 10);
        if (Number.isFinite(parsedW) && Number.isFinite(parsedH)) {
            const safeW = Math.max(16, Math.round(parsedW / 16) * 16);
            const safeH = Math.max(16, Math.round(parsedH / 16) * 16);
            return { str: `${safeW}x${safeH}`, w: safeW, h: safeH };
        }
    }

    if (baseResolution === '1080P') { baseW = 1920; baseH = 1080; }
    else if (baseResolution === '720P') { baseW = 1280; baseH = 720; }
    else if (baseResolution === '2K') { baseW = 2048; baseH = 2048; }
    else if (baseResolution === '4K') { baseW = 3840; baseH = 2160; }
    else if (typeof baseResolution === 'string') {
        const kMatch = baseResolution.toUpperCase().match(/^(\d+)K$/);
        if (kMatch) {
            const size = parseInt(kMatch[1], 10) * 1024;
            baseW = size;
            baseH = size;
        }
    }

    if (ratio === 'Auto') {
        return { str: `${baseW}x${baseH}`, w: baseW, h: baseH };
    }

    const [rW, rH] = ratio.split(':').map(Number);
    if (!rW || !rH) return { str: '1024x1024', w: 1024, h: 1024 };

    let targetW;
    let targetH;

    if (Math.abs(rW - rH) < 0.1) {
        targetW = baseW; targetH = baseH;
    } else if (rW > rH) {
        targetW = (baseResolution === 'Auto' || baseResolution === '1K') ? 1280 : baseW;
        targetH = Math.round(targetW * (rH / rW));
    } else {
        targetH = (baseResolution === 'Auto' || baseResolution === '1K') ? 1280 : baseW;
        targetW = Math.round(targetH * (rW / rH));
    }

    targetW = Math.round(targetW / 16) * 16;
    targetH = Math.round(targetH / 16) * 16;

    return { str: `${targetW}x${targetH}`, w: targetW, h: targetH };
};

const getModelParams = (modelId, ratio, resolution) => {
    const { str, w, h } = calculateResolution(ratio, resolution);
    if (isExplicitImageResolution(resolution)) {
        return { sizeStr: str, w, h };
    }
    if (modelId.includes('minimax')) {
        return { sizeStr: resolution === '4K' ? '1080p' : '720p', w, h };
    }
    if (modelId.includes('jimeng') || modelId.includes('veo')) {
        return { sizeStr: ratio, w, h };
    }
    if (modelId.includes('grok')) {
        // Grok 接口需要传 aspect_ratio，size 传比例字符串即可
        return { sizeStr: ratio, w, h };
    }
    return { sizeStr: str, w, h };
};

const AUTOSAVE_LOCAL_KEY = 'tapnow_autosave';
const AUTOSAVE_META_KEY = 'tapnow_autosave_meta';
const AUTOSAVE_IDB_NAME = 'tapnow_autosave_db';
const AUTOSAVE_IDB_STORE = 'autosave';
const ASSET_BUNDLE_META_KEY = 'tapnow_asset_bundle_meta';

let assetBundleMetaCache = null;
const readAssetBundleMeta = () => {
    if (assetBundleMetaCache) return assetBundleMetaCache;
    try {
        const raw = localStorage.getItem(ASSET_BUNDLE_META_KEY);
        assetBundleMetaCache = raw ? JSON.parse(raw) : null;
        return assetBundleMetaCache;
    } catch (e) {
        assetBundleMetaCache = null;
        return null;
    }
};

const writeAssetBundleMeta = (meta) => {
    try {
        assetBundleMetaCache = meta || null;
        if (!meta) {
            localStorage.removeItem(ASSET_BUNDLE_META_KEY);
            return;
        }
        localStorage.setItem(ASSET_BUNDLE_META_KEY, JSON.stringify(meta));
    } catch (e) { }
};

const getAssetBundleFallbackById = (id) => {
    if (!id) return '';
    const meta = readAssetBundleMeta();
    if (!meta || !meta.idToOriginal) return '';
    return meta.idToOriginal[id] || '';
};
const AUTOSAVE_IDB_KEY = 'latest';

const openAutoSaveDb = () => {
    if (typeof indexedDB === 'undefined') {
        return Promise.reject(new Error('IndexedDB not available'));
    }
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_IDB_NAME, 1);
        request.onupgradeneeded = () => {
            const db = request.result;
            if (!db.objectStoreNames.contains(AUTOSAVE_IDB_STORE)) {
                db.createObjectStore(AUTOSAVE_IDB_STORE);
            }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error || new Error('IndexedDB open failed'));
    });
};

const readAutoSaveFromIdb = async () => {
    try {
        const db = await openAutoSaveDb();
        return await new Promise((resolve) => {
            const tx = db.transaction(AUTOSAVE_IDB_STORE, 'readonly');
            const store = tx.objectStore(AUTOSAVE_IDB_STORE);
            const req = store.get(AUTOSAVE_IDB_KEY);
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => resolve(null);
            tx.oncomplete = () => db.close();
            tx.onerror = () => db.close();
        });
    } catch (e) {
        return null;
    }
};

const writeAutoSaveToIdb = async (payload) => {
    const db = await openAutoSaveDb();
    return await new Promise((resolve, reject) => {
        const tx = db.transaction(AUTOSAVE_IDB_STORE, 'readwrite');
        const store = tx.objectStore(AUTOSAVE_IDB_STORE);
        const req = store.put(payload, AUTOSAVE_IDB_KEY);
        req.onsuccess = () => resolve(true);
        req.onerror = () => reject(req.error || new Error('IndexedDB write failed'));
        tx.oncomplete = () => db.close();
        tx.onerror = () => db.close();
    });
};

const readAutoSaveMeta = () => {
    try {
        const raw = localStorage.getItem(AUTOSAVE_META_KEY);
        return raw ? JSON.parse(raw) : null;
    } catch (e) {
        return null;
    }
};

const writeAutoSaveMeta = (meta) => {
    try {
        localStorage.setItem(AUTOSAVE_META_KEY, JSON.stringify(meta));
    } catch (e) { }
};

// --- Helper: Get Image Dimensions ---
const getImageDimensions = (src) => {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight });
        img.onerror = () => reject(new Error("Failed to load image"));
        img.src = src;
    });
};

// --- Helper: Check if URL is video ---
const isVideoUrl = (url) => {
    if (!url) return false;
    if (url.startsWith('data:video')) return true;
    if (url.includes('force_video_display=true')) return true;
    const ext = url.split('.').pop().split('?')[0].toLowerCase();
    return ['mp4', 'webm', 'ogg', 'mov'].includes(ext);
};

const getMimeTypeFromPath = (path) => {
    if (!path || typeof path !== 'string') return '';
    const clean = path.split('?')[0].split('#')[0];
    const ext = clean.split('.').pop().toLowerCase();
    const map = {
        jpg: 'image/jpeg',
        jpeg: 'image/jpeg',
        png: 'image/png',
        webp: 'image/webp',
        gif: 'image/gif',
        bmp: 'image/bmp',
        svg: 'image/svg+xml',
        mp4: 'video/mp4',
        webm: 'video/webm',
        ogg: 'video/ogg',
        mov: 'video/quicktime'
    };
    return map[ext] || '';
};

// --- Helper: Load Video Metadata ---
const getVideoMetadata = (src) => {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.preload = 'metadata';
        video.muted = true;
        video.playsInline = true;
        video.onloadedmetadata = () => {
            resolve({
                duration: Number(video.duration) || 0,
                w: video.videoWidth || 0,
                h: video.videoHeight || 0,
            });
        };
        video.onerror = () => reject(new Error('视频加载失败'));
        video.src = src;
    });
};

// --- Helper: Extract Key Frames from video using <video> + <canvas> ---
const extractKeyFrames = (src, { fps = 2 } = {}) => {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';
        video.src = src;
        const frames = [];

        const handleError = () => reject(new Error('视频抽帧失败'));
        video.onerror = handleError;

        video.onloadedmetadata = () => {
            const duration = Number(video.duration) || 0;
            if (!duration || !isFinite(duration)) {
                reject(new Error('无法读取视频时长'));
                return;
            }
            canvas.width = video.videoWidth || 1280;
            canvas.height = video.videoHeight || 720;
            const interval = 1 / Math.max(0.1, fps);
            let current = 0;

            const captureFrame = () => {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                frames.push({
                    time: Number(current.toFixed(2)),
                    url: canvas.toDataURL('image/jpeg', 0.82),
                });
                current += interval;
                if (current <= duration) {
                    video.currentTime = Math.min(current, duration);
                } else {
                    resolve(frames);
                }
            };

            video.onseeked = captureFrame;
            // 启动首次抽帧
            video.currentTime = 0;
        };
    });
};

// --- Component: ImageCompareView (Beautified & Optimized) ---
const ImageCompareView = React.memo(({ img1, img2, theme = 'dark', language }) => {
    const [pos, setPos] = useState(50);
    const containerRef = useRef(null);
    const [isHovering, setIsHovering] = useState(false);
    const requestRef = useRef();
    const isSolarized = theme === 'solarized';
    const isDark = theme === 'dark';

    const handleMove = useCallback((e) => {
        if (!containerRef.current) return;

        // 使用 requestAnimationFrame 优化性能
        if (requestRef.current) return;

        requestRef.current = requestAnimationFrame(() => {
            if (!containerRef.current) return;
            const rect = containerRef.current.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
            setPos((x / rect.width) * 100);
            requestRef.current = null;
        });
    }, []);

    useEffect(() => {
        return () => {
            if (requestRef.current) {
                cancelAnimationFrame(requestRef.current);
            }
        };
    }, []);

    const normalizeCompareImage = (value) => {
        if (!value || typeof value !== 'string') return value;
        if (value.startsWith('data:')) return normalizeDataUrl(value);
        return value;
    };
    const displayImg1 = normalizeCompareImage(img1);
    const displayImg2 = normalizeCompareImage(img2 || img1);

    if (!displayImg1) return (
        <div className={`w-full h-full flex flex-col items-center justify-center rounded-lg border border-dashed pointer-events-none ${isDark
            ? 'text-zinc-500 bg-zinc-900/50 border-zinc-800'
            : isSolarized
                ? 'text-zinc-600 bg-[#eee8d5] border-[#d7cfb2]'
                : 'text-zinc-500 bg-zinc-100 border-zinc-200'
            }`}>
            <Split size={24} className="mb-2 opacity-50" />
            <span className="text-xs font-medium">连接图片以对比</span>
        </div>
    );

    return (
        <div
            ref={containerRef}
            className={`relative w-full h-full cursor-col-resize overflow-hidden group rounded-lg select-none shadow-2xl border ${isDark
                ? 'border-zinc-800 bg-[#09090b]'
                : isSolarized
                    ? 'border-[#eee8d5] bg-[#eee8d5]'
                    : 'border-zinc-200 bg-zinc-100'
                }`}
            onMouseMove={handleMove}
            onTouchMove={handleMove}
            onMouseEnter={() => setIsHovering(true)}
            onMouseLeave={() => setIsHovering(false)}
        >
            {/* Checkered Background */}
            <div className="absolute inset-0 opacity-20 pointer-events-none"
                style={{
                    backgroundImage: `conic-gradient(${isDark ? '#333' : isSolarized ? '#c9c2a8' : '#bbb'} 90deg, transparent 90deg), conic-gradient(transparent 90deg, ${isDark ? '#333' : isSolarized ? '#c9c2a8' : '#bbb'} 90deg)`,
                    backgroundSize: '20px 20px',
                    backgroundPosition: '0 0, 10px 10px'
                }}
            />
            <LazyBase64Image src={displayImg1} loading="lazy" decoding="async" className="absolute inset-0 w-full h-full object-contain pointer-events-none select-none" draggable={false} />
            <div
                className="absolute inset-0 w-full h-full overflow-hidden pointer-events-none select-none"
                style={{ clipPath: `inset(0 0 0 ${pos}%)` }}
            >
                <LazyBase64Image src={displayImg2} loading="lazy" decoding="async" className="absolute inset-0 w-full h-full object-contain" draggable={false} />
            </div>
            <div
                className="absolute top-0 bottom-0 w-0.5 bg-white/80 shadow-[0_0_10px_rgba(0,0,0,0.5)] pointer-events-none"
                style={{ left: `${pos}%` }}
            >
                <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-6 h-6 bg-white rounded-full shadow-lg flex items-center justify-center text-black">
                    <Split size={12} className="rotate-90" />
                </div>
            </div>
            <div className={`absolute bottom-2 left-2 bg-black/70 text-white text-[10px] font-medium px-2 py-0.5 rounded border border-white/10 transition-opacity duration-200 pointer-events-none ${isHovering ? 'opacity-100' : 'opacity-60'}`}>
                {t('原始')}
            </div>
            <div className={`absolute bottom-2 right-2 bg-blue-600/80 text-white text-[10px] font-medium px-2 py-0.5 rounded border border-white/10 transition-opacity duration-200 pointer-events-none ${isHovering ? 'opacity-100' : 'opacity-60'}`}>
                {t('生成')}
            </div>
        </div>
    );
});

// --- 辅助组件 ---
const Button = React.memo(({ children, onClick, className = '', variant = 'primary', icon: Icon, disabled = false, title = '' }) => {
    const baseStyle = 'flex items-center justify-center px-3 py-1.5 rounded-lg transition-all duration-200 font-medium text-xs select-none disabled:opacity-50 disabled:cursor-not-allowed';
    const variants = {
        primary: 'bg-blue-600 hover:bg-blue-500 text-white shadow-lg shadow-blue-900/20 active:scale-95',
        secondary: 'bg-zinc-800 hover:bg-zinc-700 text-zinc-300 border border-zinc-700 active:scale-95',
        ghost: 'bg-transparent hover:bg-zinc-800 text-zinc-400 hover:text-white',
        danger: 'bg-red-900/30 hover:bg-red-800 text-red-200 border border-red-800 active:scale-95',
    };
    return (
        <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${variants[variant]} ${className}`} title={title}>
            {Icon && <Icon size={14} className={children ? 'mr-1.5' : ''} />}
            {children}
        </button>
    );
});

// --- 性能优化工具函数 ---
const debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

const Modal = ({ isOpen, onClose, title, children, theme = 'dark' }) => {
    if (!isOpen) return null;
    const isDark = theme === 'dark';
    const isSolarized = theme === 'solarized';
    return (
        // V3.4.8: 改用 onMouseDown 关闭，避免拖拽到外部时误触 (onClick 会在 mouseUp 时触发)
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm" onMouseDown={onClose}>
            <div
                className={`rounded-xl shadow-2xl w-[680px] max-w-[90vw] overflow-hidden animate-in fade-in zoom-in-95 duration-200 flex flex-col max-h-[85vh] border ${isDark
                    ? 'bg-[#09090b] border-zinc-800'
                    : isSolarized
                        ? 'bg-[#eee8d5] border-[#d7cfb2]'
                        : 'bg-white border-zinc-200'
                    }`}
                onMouseDown={(e) => e.stopPropagation()}
                onClick={(e) => e.stopPropagation()}
            >
                <div
                    className={`flex items-center justify-between p-5 border-b shrink-0 ${isDark
                        ? 'border-zinc-800/50'
                        : isSolarized
                            ? 'border-[#d7cfb2]'
                            : 'border-zinc-200'
                        }`}
                >
                    <h3 className={`font-bold text-lg ${isDark ? 'text-white' : 'text-zinc-900'}`}>{title}</h3>
                    <button
                        onClick={onClose}
                        className={isDark
                            ? 'text-zinc-500 hover:text-white'
                            : isSolarized
                                ? 'text-zinc-600 hover:text-zinc-900'
                                : 'text-zinc-500 hover:text-zinc-900'}
                    >
                        <X size={20} />
                    </button>
                </div>
                <div className={`p-0 overflow-y-auto custom-scrollbar flex-1 ${isDark
                    ? 'bg-[#09090b]'
                    : isSolarized
                        ? 'bg-[#eee8d5]'
                        : 'bg-white'
                    }`}>
                    {children}
                </div>
            </div>
        </div>
    );
};

const getLightboxNavImages = (item) => {
    if (!item) return null;
    if (Array.isArray(item.mjImages) && item.mjImages.length > 1) return item.mjImages;
    if (Array.isArray(item.output_images) && item.output_images.length > 1) return item.output_images;
    return null;
};

const Lightbox = ({ item, onClose, onNavigate, onShotNavigate, onHistoryNavigate }) => {
    // 使用ref存储最新的item值，避免闭包问题
    const itemRef = useRef(item);
    const overlayRef = useRef(null);
    const navGuardRef = useRef({ lastAt: 0, lastHistoryAt: 0, lastShotAt: 0, activeKey: null, cooldownUntil: 0 });
    const onNavigateRef = useRef(onNavigate);
    const onShotNavigateRef = useRef(onShotNavigate);
    const onHistoryNavigateRef = useRef(onHistoryNavigate);
    itemRef.current = item;
    onNavigateRef.current = onNavigate;
    onShotNavigateRef.current = onShotNavigate;
    onHistoryNavigateRef.current = onHistoryNavigate;
    useEffect(() => {
        if (item) {
            requestAnimationFrame(() => {
                if (overlayRef.current && typeof overlayRef.current.focus === 'function') {
                    overlayRef.current.focus();
                }
            });
        } else {
            navGuardRef.current.activeKey = null;
        }
    }, [item]);
    const normalizeNavKey = (key) => {
        if (!key) return '';
        const map = {
            Left: 'ArrowLeft',
            Right: 'ArrowRight',
            Up: 'ArrowUp',
            Down: 'ArrowDown'
        };
        return map[key] || key;
    };
    const logLightbox = (action, detail = {}) => {
        const current = itemRef.current || item;
        const navImages = getLightboxNavImages(current);
        console.log('[Lightbox]', action, {
            id: current?.id,
            type: current?.type,
            url: current?.url,
            mjCount: Array.isArray(navImages) ? navImages.length : 0,
            ...detail
        });
    };
    useEffect(() => {
        if (!item) return;
        logLightbox('open');
    }, [item]);

    const isVideoItem = item?.type === 'video' || (item?.url && isVideoUrl(item.url));
    const sourceList = useMemo(() => {
        if (!item) return [];
        const list = [];
        const pushUnique = (val) => {
            if (val && !list.includes(val)) list.push(val);
        };
        pushUnique(item.url);
        if (!isVideoItem) pushUnique(item.thumbnailUrl);
        pushUnique(item.originalUrl);
        pushUnique(item.mjOriginalUrl);
        return list;
    }, [item, isVideoItem]);
    const [activeSrcIndex, setActiveSrcIndex] = useState(0);
    useEffect(() => {
        setActiveSrcIndex(0);
    }, [item, sourceList.length]);
    const displayUrl = sourceList[activeSrcIndex] || item?.url || '';
    const [mediaReady, setMediaReady] = useState(false);
    useEffect(() => {
        setMediaReady(false);
    }, [displayUrl, item?.id, item?.selectedMjImageIndex, item?.type]);
    const navImages = useMemo(() => getLightboxNavImages(item), [item]);
    const handleMediaError = () => {
        logLightbox('media_error', { index: activeSrcIndex, total: sourceList.length });
        setMediaReady(false);
        setActiveSrcIndex((prev) => (prev < sourceList.length - 1 ? prev + 1 : prev));
    };
    const handleClose = (reason = 'manual') => {
        logLightbox('close', { reason });
        if (onClose) onClose();
    };

    // 键盘事件处理：左右方向键切换图片，上下方向键切换镜头
    useEffect(() => {
        if (!item) return;

        const handleKeyDown = (e) => {
            // 使用ref获取最新的item值
            const currentItem = itemRef.current;
            if (!currentItem) return;

            // 防止在输入框中触发
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // Lightbox 打开时允许全局键盘导航（仅屏蔽输入框/可编辑区域）
            if (e.repeat) return;
            const guard = navGuardRef.current;
            const now = Date.now();
            if (guard.activeKey && now - guard.lastAt > 800) {
                guard.activeKey = null;
            }
            const normalizedKey = normalizeNavKey(e.key);
            const navKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
            const usesActiveKeyGuard = normalizedKey === 'ArrowLeft' || normalizedKey === 'ArrowRight';
            if (navKeys.includes(normalizedKey) && usesActiveKeyGuard) {
                if (guard.activeKey && guard.activeKey === normalizedKey) return;
                if (guard.activeKey && guard.activeKey !== normalizedKey) return;
                guard.activeKey = normalizedKey;
                guard.lastAt = now;
            }

            if (normalizedKey === 'ArrowLeft') {
                // 只在有多张图片时响应
                const currentImages = getLightboxNavImages(currentItem);
                if (!currentImages || currentImages.length <= 1) return;
                e.preventDefault();
                e.stopPropagation();
                const currentIndex = currentItem.selectedMjImageIndex !== undefined ? currentItem.selectedMjImageIndex : 0;
                const prevIndex = currentIndex > 0 ? currentIndex - 1 : currentImages.length - 1;
                const handleNavigate = onNavigateRef.current;
                if (prevIndex >= 0 && prevIndex < currentImages.length && handleNavigate) {
                    logLightbox('navigate_left', { from: currentIndex, to: prevIndex, total: currentImages.length });
                    // V3.7.22: 立即更新 ref，避免快速按键时状态过时
                    itemRef.current = {
                        ...currentItem,
                        mjImages: currentImages,
                        selectedMjImageIndex: prevIndex,
                        url: currentImages[prevIndex]
                    };
                    handleNavigate(prevIndex);
                }
            } else if (normalizedKey === 'ArrowRight') {
                // 只在有多张图片时响应
                const currentImages = getLightboxNavImages(currentItem);
                if (!currentImages || currentImages.length <= 1) return;
                e.preventDefault();
                e.stopPropagation();
                const currentIndex = currentItem.selectedMjImageIndex !== undefined ? currentItem.selectedMjImageIndex : 0;
                const nextIndex = currentIndex < currentImages.length - 1 ? currentIndex + 1 : 0;
                const handleNavigate = onNavigateRef.current;
                if (nextIndex >= 0 && nextIndex < currentImages.length && handleNavigate) {
                    logLightbox('navigate_right', { from: currentIndex, to: nextIndex, total: currentImages.length });
                    // V3.7.22: 立即更新 ref，避免快速按键时状态过时
                    itemRef.current = {
                        ...currentItem,
                        mjImages: currentImages,
                        selectedMjImageIndex: nextIndex,
                        url: currentImages[nextIndex]
                    };
                    handleNavigate(nextIndex);
                }
            } else if (normalizedKey === 'ArrowUp') {
                // V3.7.21: 上键切换到上一个镜头
                e.preventDefault();
                e.stopPropagation();
                const guard = navGuardRef.current;
                const handleShotNavigate = onShotNavigateRef.current;
                if (currentItem.storyboardContext && handleShotNavigate) {
                    if (now < guard.cooldownUntil) return;
                    if (now - guard.lastShotAt < 320) return;
                    guard.lastShotAt = now;
                    guard.cooldownUntil = now + 300;
                    const { shotIndex, allShots } = currentItem.storyboardContext;
                    if (shotIndex > 0) {
                        logLightbox('shot_up', { from: shotIndex, to: shotIndex - 1, total: allShots.length });
                        handleShotNavigate(shotIndex - 1, allShots);
                    }
                } else if (onHistoryNavigateRef.current) {
                    // V3.7.29: 历史项导航（向上 = 更早的项目）
                    if (now < guard.cooldownUntil) return;
                    if (now - guard.lastHistoryAt < 320) return;
                    guard.lastHistoryAt = now;
                    guard.cooldownUntil = now + 300;
                    logLightbox('history_up_key');
                    logLightbox('history_up');
                    onHistoryNavigateRef.current(-1);
                }
            } else if (normalizedKey === 'ArrowDown') {
                // V3.7.21: 下键切换到下一个镜头
                e.preventDefault();
                e.stopPropagation();
                const guard = navGuardRef.current;
                const handleShotNavigate = onShotNavigateRef.current;
                if (currentItem.storyboardContext && handleShotNavigate) {
                    if (now < guard.cooldownUntil) return;
                    if (now - guard.lastShotAt < 320) return;
                    guard.lastShotAt = now;
                    guard.cooldownUntil = now + 300;
                    const { shotIndex, allShots } = currentItem.storyboardContext;
                    if (shotIndex < allShots.length - 1) {
                        logLightbox('shot_down', { from: shotIndex, to: shotIndex + 1, total: allShots.length });
                        handleShotNavigate(shotIndex + 1, allShots);
                    }
                } else if (onHistoryNavigateRef.current) {
                    // V3.7.29: 历史项导航（向下 = 更新的项目）
                    if (now < guard.cooldownUntil) return;
                    if (now - guard.lastHistoryAt < 320) return;
                    guard.lastHistoryAt = now;
                    guard.cooldownUntil = now + 300;
                    logLightbox('history_down_key');
                    logLightbox('history_down');
                    onHistoryNavigateRef.current(1);
                }
            } else if (e.key === 'Escape' || e.key === 'Esc') {
                // V3.7.28: ESC 关闭预览
                e.preventDefault();
                e.stopPropagation();
                handleClose('esc');
            }
        };
        const handleKeyUp = (e) => {
            const normalizedKey = normalizeNavKey(e.key);
            const guard = navGuardRef.current;
            if (guard.activeKey === normalizedKey) {
                guard.activeKey = null;
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        return () => {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
        };
    }, [item]);

    if (!item) return null;

    return (
        <div
            ref={overlayRef}
            tabIndex={-1}
            className="fixed inset-0 z-[200] lightbox-overlay flex flex-col items-center justify-center animate-in fade-in duration-200 focus:outline-none"
            onClick={() => handleClose('overlay')}
            onMouseDown={() => {
                if (overlayRef.current && typeof overlayRef.current.focus === 'function') {
                    overlayRef.current.focus();
                }
            }}
        >
            <button className="absolute top-4 right-4 text-white/70 hover:text-white p-2 bg-black/50 rounded-full transition-colors" onClick={() => handleClose('button')}><X size={24} /></button>
            <div className="max-w-[90vw] max-h-[85vh] relative" onClick={(e) => e.stopPropagation()}>
                {item.type === 'image' ? (
                    <LazyBase64Image
                        key={displayUrl}
                        src={displayUrl}
                        alt={item.prompt}
                        className="max-w-full max-h-[85vh] rounded-lg shadow-2xl object-contain"
                        onError={handleMediaError}
                        onLoad={() => setMediaReady(true)}
                    />
                ) : (
                    <ResolvedVideo
                        key={displayUrl}
                        src={displayUrl}
                        controls
                        autoPlay
                        className="max-w-full max-h-[85vh] rounded-lg shadow-2xl"
                        poster={item.thumbnailUrl || undefined}
                        onError={handleMediaError}
                        onLoadedMetadata={() => setMediaReady(true)}
                        onCanPlay={() => setMediaReady(true)}
                    />
                )}
                {!mediaReady && (
                    <div className="absolute inset-0 flex items-center justify-center rounded-lg bg-black/35 text-white/80 text-xs pointer-events-none">
                        {t('加载中...')}
                    </div>
                )}
                <div className="absolute bottom-8 left-1/2 -translate-x-1/2 bg-black/60 backdrop-blur-md px-6 py-3 rounded-full text-white text-sm font-medium border border-white/10 text-center shadow-2xl">
                    <div className="line-clamp-1 max-w-xl">{item.prompt}</div>
                    <div className="text-[10px] text-zinc-400 mt-1">
                        {item.width}x{item.height} • {item.id}
                        {navImages && navImages.length > 1 && (
                            <span className="ml-2">({(item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0) + 1}/{navImages.length})</span>
                        )}
                        {/* V3.7.21: 镜头位置指示器 */}
                        {item.storyboardContext && (
                            <span className="ml-2 text-blue-400">Shot {item.storyboardContext.shotIndex + 1}/{item.storyboardContext.allShots?.length || 1}</span>
                        )}
                    </div>
                </div>
                {/* 左右切换提示 */}
                {navImages && navImages.length > 1 && (
                    <>
                        <button
                            className="absolute left-4 top-1/2 -translate-y-1/2 text-white/70 hover:text-white p-3 bg-black/50 rounded-full transition-colors"
                            onClick={(e) => {
                                e.stopPropagation();
                                const currentIndex = item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0;
                                const prevIndex = currentIndex > 0 ? currentIndex - 1 : navImages.length - 1;
                                if (onNavigate) onNavigate(prevIndex);
                            }}
                            title={t('上一张 (←)')}
                        >
                            <ChevronLeft size={24} />
                        </button>
                        <button
                            className="absolute right-4 top-1/2 -translate-y-1/2 text-white/70 hover:text-white p-3 bg-black/50 rounded-full transition-colors"
                            onClick={(e) => {
                                e.stopPropagation();
                                const currentIndex = item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0;
                                const nextIndex = currentIndex < navImages.length - 1 ? currentIndex + 1 : 0;
                                if (onNavigate) onNavigate(nextIndex);
                            }}
                            title={t('下一张 (→)')}
                        >
                            <ChevronRight size={24} />
                        </button>
                    </>
                )}
                {(item.storyboardContext || onHistoryNavigate) && (
                    <>
                        <button
                            className="absolute right-4 top-[34%] -translate-y-1/2 text-white/70 hover:text-white p-2 bg-black/50 rounded-full transition-colors"
                            onClick={(e) => {
                                e.stopPropagation();
                                if (item.storyboardContext && onShotNavigate) {
                                    const { shotIndex, allShots } = item.storyboardContext;
                                    if (shotIndex > 0) {
                                        logLightbox('shot_up_click', { from: shotIndex, to: shotIndex - 1 });
                                        onShotNavigate(shotIndex - 1, allShots);
                                    }
                                    return;
                                }
                                if (onHistoryNavigate) {
                                    logLightbox('history_up_click');
                                    onHistoryNavigate(-1);
                                }
                            }}
                            title={item.storyboardContext ? t('上一镜头 (↑)') : t('上一组 (↑)')}
                        >
                            <ChevronUp size={18} />
                        </button>
                        <button
                            className="absolute right-4 top-[66%] -translate-y-1/2 text-white/70 hover:text-white p-2 bg-black/50 rounded-full transition-colors"
                            onClick={(e) => {
                                e.stopPropagation();
                                if (item.storyboardContext && onShotNavigate) {
                                    const { shotIndex, allShots } = item.storyboardContext;
                                    if (shotIndex < allShots.length - 1) {
                                        logLightbox('shot_down_click', { from: shotIndex, to: shotIndex + 1 });
                                        onShotNavigate(shotIndex + 1, allShots);
                                    }
                                    return;
                                }
                                if (onHistoryNavigate) {
                                    logLightbox('history_down_click');
                                    onHistoryNavigate(1);
                                }
                            }}
                            title={item.storyboardContext ? t('下一镜头 (↓)') : t('下一组 (↓)')}
                        >
                            <ChevronDown size={18} />
                        </button>
                    </>
                )}
            </div>
        </div>
    );
};

function TapnowApp() {
    const [theme, setTheme] = useState(() => {
        try {
            return localStorage.getItem('tapnow_theme') || 'dark';
        } catch (e) {
            return 'dark';
        }
    });
    const [language, setLanguage] = useState('zh');

    useEffect(() => {
        if (i18n.language !== language) {
            i18n.changeLanguage(language);
        }
    }, [language]);

    // V3.7.27: Toast 通知系统
    const [toasts, setToasts] = useState([]);
    const toastTimersRef = useRef(new Map());
    const showToast = useCallback((message, type = 'info', duration = 3000) => {
        const id = Date.now() + Math.random();
        setToasts(prev => [...prev, { id, message, type }]);
        const timer = setTimeout(() => {
            setToasts(prev => prev.filter(t => t.id !== id));
            toastTimersRef.current.delete(id);
        }, duration);
        toastTimersRef.current.set(id, timer);
        return id;
    }, []);
    const dismissToast = useCallback((id) => {
        if (!id) return;
        const timer = toastTimersRef.current.get(id);
        if (timer) {
            clearTimeout(timer);
            toastTimersRef.current.delete(id);
        }
        setToasts(prev => prev.filter(t => t.id !== id));
    }, []);
    useEffect(() => {
        return () => {
            toastTimersRef.current.forEach((timer) => clearTimeout(timer));
            toastTimersRef.current.clear();
        };
    }, []);

    useEffect(() => {
        const styleSheet = document.createElement('style');
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
        return () => { document.head.removeChild(styleSheet); };
    }, []);

    useEffect(() => {
        window.__APP_BOOTED__ = true;
        if (window.__APP_BOOT_TIMER__) {
            clearTimeout(window.__APP_BOOT_TIMER__);
            window.__APP_BOOT_TIMER__ = null;
        }
    }, []);

    useEffect(() => {
        try {
            localStorage.setItem('tapnow_theme', theme);
        } catch (e) { }
        const root = document.documentElement;
        root.classList.remove('theme-dark', 'theme-light', 'theme-solarized');
        if (theme === 'dark') {
            root.classList.add('theme-dark');
            document.body.style.backgroundColor = '#09090b';
        } else if (theme === 'solarized') {
            root.classList.add('theme-solarized');
            document.body.style.backgroundColor = '#fdf6e3';
        } else {
            root.classList.add('theme-light');
            document.body.style.backgroundColor = '#f4f4f5';
        }
    }, [theme]);

    const autoSaveUseIdbRef = useRef(false);
    useEffect(() => {
        const meta = readAutoSaveMeta();
        autoSaveUseIdbRef.current = meta?.storage === 'idb';
    }, []);
    useEffect(() => {
        const meta = readAssetBundleMeta();
        if (!meta) return;
        const idToOriginal = meta.idToOriginal || {};
        const pathToOriginal = meta.pathToOriginal || {};
        const pathToId = meta.pathToId || {};
        const effectivePathToId = { ...pathToId };
        Object.entries(idToOriginal).forEach(([id, url]) => {
            if (id && url) assetBundleIdToOriginalRef.current.set(id, url);
        });
        Object.entries(pathToOriginal).forEach(([path, url]) => {
            if (path && url) assetBundlePathToOriginalRef.current.set(path, url);
        });
        if (Object.keys(effectivePathToId).length === 0 && Object.keys(idToOriginal).length > 0 && Object.keys(pathToOriginal).length > 0) {
            const originalToId = new Map(Object.entries(idToOriginal).map(([id, url]) => [url, id]));
            Object.entries(pathToOriginal).forEach(([path, url]) => {
                if (!path || !url) return;
                const mappedId = originalToId.get(url);
                if (mappedId) effectivePathToId[path] = mappedId;
            });
        }
        Object.entries(effectivePathToId).forEach(([path, id]) => {
            if (path && id) assetBundlePathToIdRef.current.set(path, id);
        });
        if (Object.keys(idToOriginal).length > 0 || Object.keys(pathToOriginal).length > 0 || Object.keys(effectivePathToId).length > 0) {
            setAssetBundleActive(true);
        }
    }, []);

    // V3.5.12-a: Auto-save interval for OOM protection (every 60 seconds)
    useEffect(() => {
        const saveInterval = setInterval(() => {
            const saveAuto = async () => {
                const timestamp = Date.now();
                const safeNodes = await sanitizeObjectForAutoSave(nodesRef.current);
                const saveData = {
                    nodes: safeNodes,
                    connections: connectionsRef.current,
                    timestamp
                };
                const payload = JSON.stringify(saveData);
                try {
                    await writeAutoSaveToIdb(payload);
                    autoSaveUseIdbRef.current = true;
                    writeAutoSaveMeta({ timestamp, storage: 'idb' });
                    try { localStorage.removeItem(AUTOSAVE_LOCAL_KEY); } catch (e) { }
                    console.log('[AutoSave] 已写入 IndexedDB', new Date().toLocaleTimeString());
                } catch (e) {
                    try {
                        if (payload.length > 4 * 1024 * 1024) {
                            throw new Error('payload too large');
                        }
                        localStorage.setItem(AUTOSAVE_LOCAL_KEY, payload);
                        autoSaveUseIdbRef.current = false;
                        writeAutoSaveMeta({ timestamp, storage: 'local' });
                        console.log('[AutoSave] IndexedDB 失败，已降级本地存储', new Date().toLocaleTimeString());
                    } catch (err) {
                        console.warn('[AutoSave] 自动保存失败:', err.message || err);
                    }
                }
            };
            saveAuto();
        }, 60000); // 60 seconds

        return () => clearInterval(saveInterval);
    }, []);

    // V3.5.12-a: beforeunload warning to prevent accidental data loss
    useEffect(() => {
        const handleBeforeUnload = (e) => {
            // Only warn if there are nodes on the canvas
            if (nodesRef.current && nodesRef.current.length > 0) {
                e.preventDefault();
                e.returnValue = '您有未保存的更改，确定要离开吗？';
                return e.returnValue;
            }
        };

        window.addEventListener('beforeunload', handleBeforeUnload);
        return () => window.removeEventListener('beforeunload', handleBeforeUnload);
    }, []);

    const [nodes, setNodes] = useState(() => {
        try {
            const meta = readAutoSaveMeta();
            if (meta?.storage === 'idb') return [];
            const saved = localStorage.getItem(AUTOSAVE_LOCAL_KEY);
            if (saved) {
                const parsed = JSON.parse(saved);
                return parsed.nodes || [];
            }
            // Compatible with legacy storage
            const legacy = localStorage.getItem('tapnow_nodes');
            return legacy ? JSON.parse(legacy) : [];
        } catch (e) { return []; }
    });
    const [connections, setConnections] = useState(() => {
        try {
            const meta = readAutoSaveMeta();
            if (meta?.storage === 'idb') return [];
            const saved = localStorage.getItem(AUTOSAVE_LOCAL_KEY);
            if (saved) {
                const parsed = JSON.parse(saved);
                return parsed.connections || [];
            }
            // Compatible with legacy storage
            const legacy = localStorage.getItem('tapnow_connections');
            return legacy ? JSON.parse(legacy) : [];
        } catch (e) { return []; }
    });

    useEffect(() => {
        const meta = readAutoSaveMeta();
        if (meta?.storage !== 'idb') return;
        let cancelled = false;
        const loadAutoSave = async () => {
            const saved = await readAutoSaveFromIdb();
            if (!saved || cancelled) return;
            try {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed.nodes)) setNodes(parsed.nodes);
                if (Array.isArray(parsed.connections)) setConnections(parsed.connections);
            } catch (e) { }
        };
        loadAutoSave();
        return () => { cancelled = true; };
    }, []);

    // === V3.4.7: Undo/Redo 功能 (可配置步数) ===
    const [maxUndoSteps, setMaxUndoSteps] = useState(() => {
        const saved = localStorage.getItem('tapnow_max_undo_steps');
        return saved ? Math.min(30, Math.max(1, parseInt(saved) || 5)) : 5;
    });
    const [undoStack, setUndoStack] = useState([]); // { nodes, connections }[]
    const [redoStack, setRedoStack] = useState([]);
    const isUndoRedoRef = useRef(false); // 防止 undo/redo 操作本身被记录

    // V3.5.20: State for drag-insert logic (VideoKeyframes & Storyboard)
    const [dragInsertNodeId, setDragInsertNodeId] = useState(null);
    const [dragInsertIndex, setDragInsertIndex] = useState(null);
    const [dragOverNodeId, setDragOverNodeId] = useState(null); // V3.5.22: Fixed ReferenceError

    // V3.5.24: Batch Generation State
    const [batchQueue, setBatchQueue] = useState([]); // Array of {nodeId, shotId, retryCount}
    const [batchGroups, setBatchGroups] = useState([]); // Batch group metadata
    const batchTaskCounterRef = useRef(new Map()); // nodeId -> taskIndex
    const shotBatchMapRef = useRef(new Map()); // key: nodeId:shotId -> { batchId, batchOrder, taskIndex }
    const [batchQueueMode, setBatchQueueMode] = useState(() => {
        try {
            return localStorage.getItem('tapnow_batch_queue_mode') || 'parallel';
        } catch (e) {
            return 'parallel';
        }
    });
    const [batchTick, setBatchTick] = useState(0); // Used to trigger next batch after cooldown
    const [batchConcurrency, setBatchConcurrency] = useState(() => parseInt(localStorage.getItem('tapnow_batch_concurrency') || '1')); // Default 1
    const pendingStartsRef = useRef(new Set()); // Track items that are starting but not yet 'generating' in nodes
    const batchStateRef = useRef('idle'); // 'idle' | 'running' | 'cooling'

    // Save batch concurrency to localStorage
    useEffect(() => {
        localStorage.setItem('tapnow_batch_concurrency', batchConcurrency);
    }, [batchConcurrency]);

    useEffect(() => {
        localStorage.setItem('tapnow_batch_queue_mode', batchQueueMode);
    }, [batchQueueMode]);

    // 保存当前状态到撤销栈
    const saveToUndoStack = useCallback(() => {
        if (isUndoRedoRef.current) return; // undo/redo 操作不记录
        setUndoStack(prev => {
            const newStack = [...prev, { nodes: JSON.parse(JSON.stringify(nodes)), connections: JSON.parse(JSON.stringify(connections)) }];
            // 限制最多保存 maxUndoSteps 步
            return newStack.slice(-maxUndoSteps);
        });
        setRedoStack([]); // 有新操作时清空 redo 栈
    }, [nodes, connections]);

    // 使用 ref 来解决 useEffect 闭包问题
    const saveToUndoStackRef = useRef(saveToUndoStack);
    useEffect(() => {
        saveToUndoStackRef.current = saveToUndoStack;
    }, [saveToUndoStack]);

    // V3.5.24: Batch Queue Processor
    // V3.7.26: Strict Batch Queue Processor (Wait for batch finish + 1s delay)
    // V3.7.29: Enhanced state machine logic + Debug logging
    useEffect(() => {
        // 1. Calculate current active shots
        let currentGeneratingCount = 0;
        const stuckTasks = []; // V3.7.27: 检测卡住的任务
        const now = Date.now();

        nodes.forEach(n => {
            if (n.settings?.shots) {
                n.settings.shots.forEach(s => {
                    if (s.status === 'generating') {
                        currentGeneratingCount++;
                        // V3.7.27: 检测超时任务
                        const mode = n.settings?.mode || 'video';
                        const taskTimeoutMs = mode === 'image' ? IMAGE_TASK_TIMEOUT_MS : VIDEO_TASK_TIMEOUT_MS;
                        if (s.generationStartTime && (now - s.generationStartTime) > taskTimeoutMs) {
                            stuckTasks.push({ nodeId: n.id, shotId: s.id, timeoutMs: taskTimeoutMs });
                        }
                    }
                    // Cleanup pending starts
                    const key = `${n.id}:${s.id}`;
                    if (pendingStartsRef.current.has(key)) {
                        if (s.status === 'generating' || s.status === 'done' || s.status === 'failed') {
                            pendingStartsRef.current.delete(key);
                        }
                    }
                });
            }
        });

        // V3.7.27: 自动标记超时任务为 failed，防止队列阻塞
        if (stuckTasks.length > 0) {
            console.warn(`[Batch] ${stuckTasks.length} tasks timed out (image>${IMAGE_TASK_TIMEOUT_MS / 1000}s, video>${VIDEO_TASK_TIMEOUT_MS / 1000}s). Auto-marking as failed.`);
            stuckTasks.forEach(({ nodeId, shotId, timeoutMs }) => {
                const timeoutSeconds = Math.round((timeoutMs || IMAGE_TASK_TIMEOUT_MS) / 1000);
                // V3.7.29: 使用条件更新，防止覆盖已完成的状态
                updateShot(nodeId, shotId, { status: 'failed', errorMsg: `任务超时（${timeoutSeconds}s）` }, { onlyIfStatus: 'generating' });
            });
            currentGeneratingCount -= stuckTasks.length;
        }

        // Add pending starts (tasks initiated but not yet generating)
        const totalActive = currentGeneratingCount + pendingStartsRef.current.size;

        if (batchQueue.length === 0) {
            if (totalActive === 0) {
                batchStateRef.current = 'idle';
                pendingStartsRef.current.clear(); // V3.7.29: 清理挂起任务
            }
            return;
        }

        // 2. State Machine Logic
        if (totalActive > 0) {
            batchStateRef.current = 'running';
            return; // Wait for current batch to finish
        }

        // If totalActive is 0:
        if (batchStateRef.current === 'running') {
            // Just finished a batch
            batchStateRef.current = 'cooling';
            setTimeout(() => {
                batchStateRef.current = 'idle';
                setBatchTick(t => t + 1); // Trigger next batch
            }, 1000);
            return;
        }

        if (batchStateRef.current === 'cooling') {
            return; // Still cooling down
        }

        // 3. Start Next Batch (State is 'idle')
        const batchSize = batchConcurrency === 0 ? batchQueue.length : batchConcurrency;
        const toProcess = batchQueue.slice(0, batchSize);
        const remaining = batchQueue.slice(batchSize);

        if (toProcess.length > 0) {

            // Update queue first
            setBatchQueue(remaining);

            // Mark strict running state
            batchStateRef.current = 'running';

            // Trigger all concurrently (No internal delay, delay is between batches)
            toProcess.forEach((item) => {
                pendingStartsRef.current.add(`${item.nodeId}:${item.shotId}`);

                // Find correct shot object
                const currentNode = nodes.find(n => n.id === item.nodeId);
                const currentShot = currentNode?.settings?.shots?.find(s => isSameShotId(s.id, item.shotId));

                if (currentShot) {
                    if (item.mode === 'image') {
                        generateSingleImage(item.nodeId, currentShot);
                    } else {
                        generateSingleShot(item.nodeId, currentShot);
                    }
                }
            });
        }
    }, [batchQueue, nodes, batchConcurrency, batchTick]);

    // V3.7.27: 周期性触发队列检查，防止因状态更新遗漏导致的阻塞
    useEffect(() => {
        const hasGenerating = nodes.some(n => (n.settings?.shots || []).some(s => s.status === 'generating'));
        const hasPendingStarts = pendingStartsRef.current.size > 0;
        if (batchQueue.length === 0 && !hasGenerating && !hasPendingStarts) return;
        const interval = setInterval(() => {
            setBatchTick(t => t + 1);
        }, 5000); // 每5秒检查一次
        return () => clearInterval(interval);
    }, [batchQueue.length, nodes]);

    const clearBatchQueue = useCallback((stopRunning = false) => {
        setBatchQueue([]);
        pendingStartsRef.current.clear();
        batchStateRef.current = 'idle';
        shotBatchMapRef.current.clear();

        if (!stopRunning) return;

        setNodes(prev => prev.map(n => {
            if (n.type !== 'storyboard-node') return n;
            const shots = n.settings?.shots || [];
            let changed = false;
            const updatedShots = shots.map(s => {
                if (s.status === 'generating') {
                    changed = true;
                    return { ...s, status: 'failed', errorMsg: '已手动终止' };
                }
                return s;
            });
            if (!changed) return n;
            return { ...n, settings: { ...n.settings, shots: updatedShots } };
        }));
    }, [setBatchQueue, setNodes]);

    const removeQueuedBatchItem = useCallback((nodeId, shotId) => {
        setBatchQueue(prev => prev.filter(item => !(item.nodeId === nodeId && item.shotId === shotId)));
        pendingStartsRef.current.delete(`${nodeId}:${shotId}`);
        updateShot(nodeId, shotId, { status: 'draft', errorMsg: '' });
    }, [setBatchQueue]);

    const stopRunningShot = useCallback((nodeId, shotId) => {
        updateShot(nodeId, shotId, { status: 'failed', errorMsg: '已手动终止' });
    }, []);

    const removeQueuedBatchGroup = useCallback((batchId) => {
        setBatchQueue(prev => prev.filter(item => {
            if (item.batchId !== batchId) return true;
            pendingStartsRef.current.delete(`${item.nodeId}:${item.shotId}`);
            shotBatchMapRef.current.delete(`${item.nodeId}:${item.shotId}`);
            updateShot(item.nodeId, item.shotId, { status: 'draft', errorMsg: '' });
            return false;
        }));
    }, [setBatchQueue]);

    const clearNodeQueue = useCallback((nodeId, stopRunning = false) => {
        setBatchQueue(prev => prev.filter(item => {
            if (item.nodeId !== nodeId) return true;
            pendingStartsRef.current.delete(`${item.nodeId}:${item.shotId}`);
            shotBatchMapRef.current.delete(`${item.nodeId}:${item.shotId}`);
            return false;
        }));

        if (!stopRunning) return;
        setNodes(prev => prev.map(n => {
            if (n.id !== nodeId || n.type !== 'storyboard-node') return n;
            const shots = n.settings?.shots || [];
            let changed = false;
            const updatedShots = shots.map(s => {
                if (s.status === 'generating') {
                    changed = true;
                    return { ...s, status: 'failed', errorMsg: '已手动终止' };
                }
                return s;
            });
            if (!changed) return n;
            return { ...n, settings: { ...n.settings, shots: updatedShots } };
        }));
    }, [setBatchQueue, setNodes]);

    const batchQueueItems = useMemo(() => {
        return batchQueue.map((item, idx) => {
            const node = nodes.find(n => n.id === item.nodeId);
            const shots = node?.settings?.shots || [];
            const shotIndex = shots.findIndex(s => s.id === item.shotId);
            const shot = shotIndex >= 0 ? shots[shotIndex] : null;
            return {
                ...item,
                order: idx + 1,
                projectTitle: node?.settings?.projectTitle || '未命名分镜',
                sceneIndex: shot?.scene_index || (shotIndex >= 0 ? shotIndex + 1 : '?'),
                taskIndex: item.taskIndex,
                batchId: item.batchId,
                batchOrder: item.batchOrder,
                batchConcurrency: item.batchConcurrency
            };
        });
    }, [batchQueue, nodes]);

    const batchRunningItems = useMemo(() => {
        const running = [];
        nodes.forEach(n => {
            if (n.type !== 'storyboard-node') return;
            const shots = n.settings?.shots || [];
            shots.forEach((s, idx) => {
                if (s.status !== 'generating') return;
                const batchMeta = shotBatchMapRef.current.get(`${n.id}:${s.id}`) || {};
                running.push({
                    nodeId: n.id,
                    shotId: s.id,
                    projectTitle: n.settings?.projectTitle || '未命名分镜',
                    sceneIndex: s.scene_index || idx + 1,
                    batchId: batchMeta.batchId,
                    batchOrder: batchMeta.batchOrder,
                    taskIndex: batchMeta.taskIndex
                });
            });
        });
        return running;
    }, [nodes]);

    useEffect(() => {
        const activeKeys = new Set();
        batchQueue.forEach(item => {
            activeKeys.add(`${item.nodeId}:${item.shotId}`);
        });
        nodes.forEach(n => {
            if (n.type !== 'storyboard-node') return;
            const shots = n.settings?.shots || [];
            shots.forEach(s => {
                if (s.status === 'generating') {
                    activeKeys.add(`${n.id}:${s.id}`);
                }
            });
        });

        if (activeKeys.size === 0) {
            shotBatchMapRef.current.clear();
            setBatchGroups([]);
            return;
        }

        shotBatchMapRef.current.forEach((value, key) => {
            if (!activeKeys.has(key)) shotBatchMapRef.current.delete(key);
        });

        setBatchGroups(prev => prev.filter(group =>
            group.shotIds.some(shotId => activeKeys.has(`${group.nodeId}:${shotId}`))
        ));
    }, [batchQueue, nodes]);

    // 撤销操作
    const undo = useCallback(() => {
        if (undoStack.length === 0) return;
        isUndoRedoRef.current = true;
        const lastState = undoStack[undoStack.length - 1];
        // 当前状态入 redo 栈
        setRedoStack(prev => [...prev, { nodes: JSON.parse(JSON.stringify(nodes)), connections: JSON.parse(JSON.stringify(connections)) }]);
        // 恢复上一个状态
        setNodes(lastState.nodes);
        setConnections(lastState.connections);
        // 移除已使用的状态
        setUndoStack(prev => prev.slice(0, -1));
        setTimeout(() => { isUndoRedoRef.current = false; }, 100);
    }, [undoStack, nodes, connections]);

    // 重做操作
    const redo = useCallback(() => {
        if (redoStack.length === 0) return;
        isUndoRedoRef.current = true;
        const nextState = redoStack[redoStack.length - 1];
        // 当前状态入 undo 栈
        setUndoStack(prev => [...prev, { nodes: JSON.parse(JSON.stringify(nodes)), connections: JSON.parse(JSON.stringify(connections)) }]);
        // 恢复下一个状态
        setNodes(nextState.nodes);
        setConnections(nextState.connections);
        // 移除已使用的状态
        setRedoStack(prev => prev.slice(0, -1));
        setTimeout(() => { isUndoRedoRef.current = false; }, 100);
    }, [redoStack, nodes, connections]);

    // 快捷键监听
    useEffect(() => {
        const handleKeyDown = (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                if (e.shiftKey) {
                    e.preventDefault();
                    redo();
                } else {
                    e.preventDefault();
                    undo();
                }
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [undo, redo]);
    // === End Undo/Redo ===
    const [view, setView] = useState(() => ({ ...DEFAULT_VIEW }));
    const normalizeViewState = (candidate) => {
        if (!candidate || typeof candidate !== 'object') return { ...DEFAULT_VIEW };
        const x = Number.isFinite(candidate.x) ? candidate.x : DEFAULT_VIEW.x;
        const y = Number.isFinite(candidate.y) ? candidate.y : DEFAULT_VIEW.y;
        const zoom = Number.isFinite(candidate.zoom) && candidate.zoom > 0 ? candidate.zoom : DEFAULT_VIEW.zoom;
        return { x, y, zoom };
    };
    // 性能优化：使用 ref 存储 view 和拖拽状态，避免频繁 setState
    const viewRef = useRef({ x: 0, y: 0, zoom: 1 });
    const viewRafRef = useRef(null);
    const dragOffsetRef = useRef(new Map()); // nodeId -> { x, y }
    const dragStartPosRef = useRef(new Map()); // nodeId -> { x, y }
    const [selectedNodeId, setSelectedNodeId] = useState(null);

    const normalizeProviderConfig = (providerKey, config = {}) => {
        const defaults = DEFAULT_PROVIDERS[providerKey] || {
            key: '',
            url: DEFAULT_BASE_URL,
            apiType: 'openai',
            useProxy: false,
            forceAsync: false
        };
        return {
            ...defaults,
            ...config,
            enabled: config?.enabled !== false
        };
    };

    const [modelLibrary, setModelLibrary] = useState(() => {
        const saved = localStorage.getItem('tapnow_model_library');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed)) {
                    return parsed.map((entry) => ({
                        id: entry.id,
                        displayName: entry.displayName || entry.modelName || entry.id,
                        modelName: entry.modelName || entry.displayName || entry.id,
                        type: entry.type || 'Chat',
                        apiType: entry.apiType || 'openai',
                        ratioLimits: Array.isArray(entry.ratioLimits) ? entry.ratioLimits : null,
                        ratioNotes: normalizeValueNotes(entry.ratioNotes),
                        ratioNotesEnabled: !!entry.ratioNotesEnabled,
                        resolutionLimits: Array.isArray(entry.resolutionLimits) ? entry.resolutionLimits : null,
                        resolutionNotes: normalizeResolutionNotes(entry.resolutionNotes),
                        resolutionNotesEnabled: !!entry.resolutionNotesEnabled,
                        durations: Array.isArray(entry.durations) ? entry.durations : null,
                        durationNotes: normalizeValueNotes(entry.durationNotes),
                        durationNotesEnabled: !!entry.durationNotesEnabled,
                        videoResolutions: Array.isArray(entry.videoResolutions) ? entry.videoResolutions : null,
                        videoResolutionNotes: normalizeValueNotes(entry.videoResolutionNotes),
                        videoResolutionNotesEnabled: !!entry.videoResolutionNotesEnabled,
                        supportsFirstLastFrame: !!entry.supportsFirstLastFrame,
                        supportsHD: !!entry.supportsHD,
                        omitRatioOnSubmit: !!entry.omitRatioOnSubmit,
                        omitResolutionOnSubmit: !!entry.omitResolutionOnSubmit,
                        customParams: normalizeCustomParams(entry.customParams),
                        asyncConfig: entry.asyncConfig && typeof entry.asyncConfig === 'object' ? entry.asyncConfig : null,
                        previewOverrideEnabled: !!entry.previewOverrideEnabled,
                        previewOverridePatch: normalizePreviewOverridePatch(entry.previewOverridePatch),
                        requestTemplate: normalizeRequestTemplate(entry.requestTemplate || getDefaultRequestTemplateForEntry(entry)),
                        requestOverrideEnabled: !!entry.requestOverrideEnabled,
                        requestOverridePatch: normalizeRequestOverridePatch(entry.requestOverridePatch)
                    })).filter((entry) => entry.id);
                }
            } catch (e) {
                console.error('加载 modelLibrary 配置失败:', e);
            }
        }
    return DEFAULT_MODEL_LIBRARY.map((entry) => ({ ...entry }));
});
    const collapsedLibraryStateLoadedRef = useRef(false);
    const [collapsedLibraryModels, setCollapsedLibraryModels] = useState(() => {
        const saved = localStorage.getItem('tapnow_model_library_collapsed');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed)) {
                    collapsedLibraryStateLoadedRef.current = true;
                    return new Set(parsed.filter(Boolean));
                }
            } catch (e) {
                console.warn('加载模型库折叠状态失败:', e);
            }
        }
        return new Set();
    });
    useEffect(() => {
        try {
            localStorage.setItem('tapnow_model_library', JSON.stringify(modelLibrary));
        } catch (e) {
            console.error('保存 modelLibrary 配置失败:', e);
        }
    }, [modelLibrary]);
    useEffect(() => {
        if (!modelLibrary.length) return;
        setCollapsedLibraryModels(prev => {
            const next = new Set();
            const hasStoredState = collapsedLibraryStateLoadedRef.current;
            modelLibrary.forEach((entry) => {
                if (prev.has(entry.id)) {
                    next.add(entry.id);
                } else if (!hasStoredState) {
                    // 初次加载时默认全部折叠
                    next.add(entry.id);
                }
            });
            collapsedLibraryStateLoadedRef.current = true;
            return next;
        });
    }, [modelLibrary]);

    useEffect(() => {
        try {
            const payload = Array.from(collapsedLibraryModels);
            localStorage.setItem('tapnow_model_library_collapsed', JSON.stringify(payload));
        } catch (e) {
            console.error('保存模型库折叠状态失败:', e);
        }
    }, [collapsedLibraryModels]);

    const [apiConfigs, setApiConfigs] = useState(() => {
        const saved = localStorage.getItem('tapnow_api_configs');

        // V3.6.0: 如果有存量数据，直接使用（不再合并默认模型）
        if (saved) {
            try {
                let configs = JSON.parse(saved);

                // V3.6.0 迁移：将旧格式转换为新格式
                configs = configs.map(config => {
                    const normalized = {
                        ...config,
                        id: config.id || config.modelName,
                        provider: config.provider,
                        type: config.type || 'Chat',
                        modelName: config.modelName || config.id,
                        displayName: config.displayName || config.modelName || config.id,
                        ...(config.durations ? { durations: config.durations } : {})
                    };
                    const { key, url, isCustom, ...rest } = normalized;
                    return rest;
                });

                // 过滤掉已删除的模型配置
                configs = configs.filter(c => !DELETED_MODEL_IDS.includes(c.id));

                // V3.7.22: 允许同名模型共存（不再按 id 去重）
                const existingIds = new Set(configs.map(c => c.id).filter(Boolean));

                // V3.7.24: 确保 Chat 模型存在（旧版本可能没有 Chat 类型）
                const chatModels = DEFAULT_API_CONFIGS.filter(m => isChatModelType(m.type));
                chatModels.forEach(m => {
                    if (!existingIds.has(m.id)) {
                        configs.push(m);
                        existingIds.add(m.id);
                    }
                });

                // V3.8.2: Ensure every config has a unique internal ID for UI rendering stability
                // This prevents input focus loss when editing the ID
                configs = configs.map(c => c._uid ? c : { ...c, _uid: `uid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` });

                return configs;
            } catch (e) {
                console.error('[V3.6.0] 迁移 apiConfigs 失败:', e);
            }
        }

        // V3.6.0: 首次加载才使用默认模型
        return DEFAULT_API_CONFIGS.map(c => ({ ...c, _uid: `uid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` }));
    });

    // V3.3: Provider 状态管理
    // V3.4.18: 使用 _deleted 标记追踪删除的Provider
    const [providers, setProviders] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_providers');
            if (saved) {
                const parsed = JSON.parse(saved);
                // 直接使用用户保存的数据，不再自动补充默认Provider
                // 如果用户删除了一个Provider，它就不会再出现
                return Object.fromEntries(Object.entries(parsed).map(([key, config]) => [key, normalizeProviderConfig(key, config)]));
            }
        } catch (e) {
            console.error('加载 providers 配置失败:', e);
        }
        return Object.fromEntries(Object.entries(DEFAULT_PROVIDERS).map(([key, config]) => [key, normalizeProviderConfig(key, config)]));
    });

    // V3.3: 持久化 providers
    useEffect(() => {
        try {
            localStorage.setItem('tapnow_providers', JSON.stringify(providers));
        } catch (e) {
            console.error('保存 providers 配置失败:', e);
        }
    }, [providers]);

    // V3.6.0: 辅助函数 - 获取模型的 key 和 url
    const getModelConfig = useCallback((modelId) => {
        const config = apiConfigs.find(c => c.id === modelId);
        if (!config) return { key: '', url: DEFAULT_BASE_URL, id: modelId };

        const providerConfig = providers[config.provider] || {};
        return {
            ...config,
            // V3.6.0: 直接用 id 作为 modelName
            modelName: config.id,
            key: providerConfig.key || '',
            url: providerConfig.url || DEFAULT_BASE_URL
        };
    }, [apiConfigs, providers]);

    const [globalApiKey, setGlobalApiKey] = useState(() => localStorage.getItem('tapnow_global_key') || '');

    // API 黑名单机制 (比照 Jimeng-api-tool 实现)
    const [apiBlacklist, setApiBlacklist] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_api_blacklist');
            if (!saved) return {};
            const parsed = JSON.parse(saved);
            const today = new Date().toDateString();
            // 每日重置：如果日期变更，清空黑名单
            if (parsed.date !== today) return {};
            return parsed.blacklist || {};
        } catch (e) {
            return {};
        }
    });

    // 持久化黑名单
    useEffect(() => {
        try {
            localStorage.setItem('tapnow_api_blacklist', JSON.stringify({
                date: new Date().toDateString(),
                blacklist: apiBlacklist
            }));
        } catch (e) { }
    }, [apiBlacklist]);

    // 黑名单 ref 用于并发请求间的同步访问（解决 React 状态异步更新问题）
    const apiBlacklistRef = useRef(apiBlacklist);
    useEffect(() => {
        apiBlacklistRef.current = apiBlacklist;
    }, [apiBlacklist]);

    const addToBlacklist = (key, reason) => {
        if (!key) return;
        const entry = {
            date: new Date().toDateString(),
            reason: reason,
            timestamp: Date.now()
        };
        // 立即同步更新 ref（解决并发请求竞态）
        const oldBlacklist = apiBlacklistRef.current || {};
        apiBlacklistRef.current = { ...oldBlacklist, [key]: entry };

        // V3.5.1 Debug: 详细追踪黑名单更新

        // 异步更新 React 状态（用于持久化和 UI）
        setApiBlacklist(prev => ({
            ...prev,
            [key]: entry
        }));
    };

    // V3.7.23: API 临时暂停列表（用于登录失效等可恢复错误，TTL 60分钟）
    const [apiSuspendList, setApiSuspendList] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_api_suspend');
            if (!saved) return {};
            const parsed = JSON.parse(saved);
            const now = Date.now();
            // 清理过期项（60分钟）
            return Object.fromEntries(
                Object.entries(parsed).filter(([, v]) => now - v.timestamp < 60 * 60 * 1000)
            );
        } catch (e) { return {}; }
    });

    // 持久化暂停列表
    useEffect(() => {
        try {
            localStorage.setItem('tapnow_api_suspend', JSON.stringify(apiSuspendList));
        } catch (e) { }
    }, [apiSuspendList]);

    const apiSuspendListRef = useRef(apiSuspendList);
    useEffect(() => { apiSuspendListRef.current = apiSuspendList; }, [apiSuspendList]);

    const addToSuspendList = (key, reason, ttlMs = 60 * 60 * 1000) => {
        if (!key) return;
        const entry = { reason, timestamp: Date.now(), ttl: ttlMs };
        apiSuspendListRef.current = { ...apiSuspendListRef.current, [key]: entry };
        setApiSuspendList(prev => ({ ...prev, [key]: entry }));
    };

    const isKeySuspended = (key) => {
        const entry = apiSuspendListRef.current?.[key];
        if (!entry) return false;
        return Date.now() - entry.timestamp < (entry.ttl || 60 * 60 * 1000);
    };

    // V3.7.23: 1006 错误熔断机制（2分钟内10次触发熔断）
    const error1006WindowRef = useRef([]);
    const CIRCUIT_BREAKER_WINDOW_MS = 2 * 60 * 1000; // 2分钟
    const CIRCUIT_BREAKER_THRESHOLD = 10; // 10次

    const checkCircuitBreaker = () => {
        const now = Date.now();
        const recentErrors = error1006WindowRef.current.filter(t => now - t < CIRCUIT_BREAKER_WINDOW_MS);
        error1006WindowRef.current = recentErrors;
        return recentErrors.length >= CIRCUIT_BREAKER_THRESHOLD;
    };

    const record1006Error = () => {
        error1006WindowRef.current.push(Date.now());
    };

    // 即梦图生图使用本地文件设置（默认true，强制使用本地文件而不是URL）
    const [jimengUseLocalFile, setJimengUseLocalFile] = useState(() => {
        const saved = localStorage.getItem('tapnow_jimeng_use_local_file');
        return saved !== null ? saved === 'true' : true; // 默认true
    });

    // V3.4.7: 项目名称状态 - 新项目（无节点）始终显示"未命名项目"
    const [projectName, setProjectName] = useState(() => {
        try {
            // 如果没有保存的节点，说明是新项目，强制显示"未命名项目"
            const savedNodes = localStorage.getItem('tapnow_nodes');
            if (!savedNodes || JSON.parse(savedNodes).length === 0) {
                localStorage.removeItem('tapnow_project_name');
                return '未命名项目';
            }
            const saved = localStorage.getItem('tapnow_project_name');
            return saved || '未命名项目';
        } catch (e) {
            return '未命名项目';
        }
    });
    const [isEditingProjectName, setIsEditingProjectName] = useState(false);
    const projectNameInputRef = useRef(null);

    // 进度条状态
    const [progressState, setProgressState] = useState({
        visible: false,
        progress: 0,
        status: '',
        type: 'import' // 'import' | 'export'
    });

    // V2.6.1 Feature: 历史面板性能模式 (Performance Mode)
    // off: 关闭 (显示原图)
    // normal: 普通 (缩略图质量 0.6)
    // ultra: 极速 (缩略图质量 0.3)
    const [performanceMode, setPerformanceMode] = useState(() => {
        try {
            const savedHistory = localStorage.getItem('tapnow_history_performance_mode');
            if (savedHistory !== null) {
                if (savedHistory === 'true') return 'normal';
                if (savedHistory === 'false') return 'off';
                return savedHistory || 'off';
            }
            return localStorage.getItem('tapnow_performance_mode') || 'off';
        } catch (e) {
            return 'off';
        }
    });
    // 全局性能模式（与历史面板独立）
    const [globalPerformanceMode, setGlobalPerformanceMode] = useState(() => {
        try {
            return localStorage.getItem('tapnow_global_performance_mode') || 'off';
        } catch (e) {
            return 'off';
        }
    });

    // V2.6.1 Feature: 本地服务器 URL
    const [localServerUrl, setLocalServerUrl] = useState(() => {
        return localStorage.getItem('tapnow_local_server_url') || 'http://127.0.0.1:9527';
    });

    // V2.6.1 Feature: 本地缓存服务器状态
    const [localCacheServerConnected, setLocalCacheServerConnected] = useState(false);
    const [localCacheEnabled, setLocalCacheEnabled] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_local_cache_enabled');
            if (saved !== null) return saved === 'true';
            const legacy = localStorage.getItem('tapnow_show_local_cache_banner');
            return legacy === null ? true : legacy === 'true';
        } catch (e) {
            return true;
        }
    });
    const [cacheRedownloadOnEnable, setCacheRedownloadOnEnable] = useState(() => {
        try {
            return localStorage.getItem('tapnow_cache_redownload_on_enable') === 'true';
        } catch (e) {
            return false;
        }
    });
    const [saveHistoryAssets, setSaveHistoryAssets] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_save_history_assets');
            if (saved === null) return true;
            return saved === 'true';
        } catch (e) {
            return true;
        }
    });
    const HISTORY_SAVE_LIMIT_MIN = 20;
    const HISTORY_SAVE_LIMIT_MAX = 160;
    const normalizeHistorySaveLimit = (value) => {
        const parsed = Number.parseInt(value, 10);
        const safe = Number.isFinite(parsed) ? parsed : 80;
        return Math.min(HISTORY_SAVE_LIMIT_MAX, Math.max(HISTORY_SAVE_LIMIT_MIN, safe));
    };
    const [historySaveLimit, setHistorySaveLimit] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_history_limit');
            if (saved === null) return 80;
            return normalizeHistorySaveLimit(saved);
        } catch (e) {
            return 80;
        }
    });
    const [historySaveLimitInput, setHistorySaveLimitInput] = useState(() => String(historySaveLimit));
    const historySaveLimitTimerRef = useRef(null);
    const historySaveLimitErrorRef = useRef({ lastValue: null, toastId: null });
    const [cacheRefreshTick, setCacheRefreshTick] = useState(0);
    const [localCacheBannerVisible, setLocalCacheBannerVisible] = useState(false);
    const localCacheBannerTimerRef = useRef(null);
    const localCacheActive = localCacheEnabled && localCacheServerConnected;
    const [localServerConfig, setLocalServerConfig] = useState({
        savePath: '',
        imageSavePath: '',
        videoSavePath: '',
        convertPngToJpg: true,
        jpgQuality: 95,
        pilAvailable: false
    });
    const thumbnailCacheRef = useRef(new Map());
    const triedCacheIdsRef = useRef(new Set());
    const localCacheCheckRef = useRef(new Map());
    const cachedHistoryUrlRef = useRef(new Map());
    const localCachePathRef = useRef({ savePath: '', imageSavePath: '', videoSavePath: '' });
    const cacheFetchFailureRef = useRef(new Map());
    const cacheHeadProbeRef = useRef(new Map());
    const cacheImageRunRef = useRef(false);
    const cacheVideoRunRef = useRef(false);
    const localCacheFileIndexRef = useRef(new Set());
    const localCacheIndexReadyRef = useRef(false);
    const [localCacheIndexTick, setLocalCacheIndexTick] = useState(0);
    const assetBundlePathToOriginalRef = useRef(new Map());
    const assetBundlePathToIdRef = useRef(new Map());
    const assetBundleBlobToOriginalRef = useRef(new Map());
    const assetBundleIdToOriginalRef = useRef(new Map());
    const assetBundleBlobUrlsRef = useRef(new Set());
    const [assetBundleActive, setAssetBundleActive] = useState(false);
    const autoSaveUrlCacheRef = useRef(new Map());
    const normalizeLocalCacheRelPath = useCallback((value) => {
        if (!value) return '';
        return String(value).replace(/\\/g, '/').replace(/^\/+/, '');
    }, []);
    const extractLocalCacheRelPath = useCallback((url) => {
        if (!url) return '';
        const base = (localServerUrl || '').replace(/\/+$/, '');
        if (!base || !url.startsWith(base)) return '';
        const rest = url.slice(base.length);
        const match = rest.match(/^\/file\/(.+)/);
        if (!match) return '';
        try {
            return normalizeLocalCacheRelPath(decodeURIComponent(match[1]));
        } catch (e) {
            return normalizeLocalCacheRelPath(match[1]);
        }
    }, [localServerUrl, normalizeLocalCacheRelPath]);
    const isLocalCacheUrl = useCallback((url) => {
        if (!url) return false;
        const str = String(url);
        const base = (localServerUrl || '').trim().replace(/\/+$/, '');
        if (base && str.startsWith(`${base}/file/`)) return true;
        try {
            const parsed = new URL(str);
            if ((parsed.hostname === '127.0.0.1' || parsed.hostname === 'localhost') && parsed.pathname.startsWith('/file/')) {
                return true;
            }
        } catch (e) { }
        return false;
    }, [localServerUrl]);
    const isComfyLocalUrl = useCallback((url) => {
        if (!url) return false;
        try {
            const parsed = new URL(String(url));
            const isLocalHost = parsed.hostname === '127.0.0.1' || parsed.hostname === 'localhost';
            return isLocalHost && parsed.port === '8188';
        } catch (e) {
            return false;
        }
    }, []);
    const isLocalCacheUrlAvailable = useCallback((url) => {
        if (!url) return false;
        const relPath = extractLocalCacheRelPath(url);
        if (!relPath) return false;
        // 索引未就绪时，先视为不可用，避免触发 404 噪音
        if (!localCacheIndexReadyRef.current) return false;
        return localCacheFileIndexRef.current.has(relPath);
    }, [extractLocalCacheRelPath, localCacheIndexTick]);
    const resetAssetBundleState = useCallback((options = {}) => {
        assetBundlePathToOriginalRef.current.clear();
        assetBundlePathToIdRef.current.clear();
        assetBundleBlobToOriginalRef.current.clear();
        assetBundleIdToOriginalRef.current.clear();
        assetBundleBlobUrlsRef.current.forEach((url) => {
            if (url && url.startsWith('blob:')) {
                try { URL.revokeObjectURL(url); } catch (e) { }
            }
        });
        assetBundleBlobUrlsRef.current.clear();
        autoSaveUrlCacheRef.current.clear();
        if (!options.keepStorage) {
            writeAssetBundleMeta(null);
        }
        if (!options.keepActive) {
            setAssetBundleActive(false);
        }
    }, []);
    const persistAssetBundleMeta = useCallback(() => {
        const idToOriginal = Object.fromEntries(assetBundleIdToOriginalRef.current);
        const pathToOriginal = Object.fromEntries(assetBundlePathToOriginalRef.current);
        const pathToId = Object.fromEntries(assetBundlePathToIdRef.current);
        if (Object.keys(idToOriginal).length === 0 && Object.keys(pathToOriginal).length === 0 && Object.keys(pathToId).length === 0) {
            writeAssetBundleMeta(null);
            return;
        }
        writeAssetBundleMeta({
            idToOriginal,
            pathToOriginal,
            pathToId,
            updatedAt: Date.now()
        });
    }, []);
    const resolveAssetBundleUrl = useCallback((value) => {
        if (!value || typeof value !== 'string') return value;
        if (!value.startsWith('asset://')) return value;
        const path = value.replace(/^asset:\/\//, '');
        if (!path) return value;
        return assetBundlePathToIdRef.current.get(path)
            || assetBundlePathToOriginalRef.current.get(path)
            || value;
    }, []);
    const getAssetFallbackUrl = useCallback((value) => {
        if (!value || typeof value !== 'string') return '';
        if (LocalImageManager.isImageId(value)) {
            return assetBundleIdToOriginalRef.current.get(value) || '';
        }
        if (value.startsWith('asset://')) {
            const path = value.replace(/^asset:\/\//, '');
            return assetBundlePathToOriginalRef.current.get(path) || '';
        }
        if (value.startsWith('blob:')) {
            return assetBundleBlobToOriginalRef.current.get(value) || '';
        }
        return '';
    }, []);
    const resolveSpecialUrl = useCallback(async (value) => {
        if (!value || typeof value !== 'string') return value;
        let next = value;
        if (next.startsWith('asset://')) {
            next = resolveAssetBundleUrl(next);
        }
        if (LocalImageManager.isImageId(next)) {
            const dataUrl = await LocalImageManager.getImage(next);
            if (dataUrl) return dataUrl;
            const fallback = getAssetFallbackUrl(next);
            return fallback || next;
        }
        return next;
    }, [resolveAssetBundleUrl, getAssetFallbackUrl]);

    const resolveUrlForMediaMeta = useCallback(async (value) => {
        if (!value || typeof value !== 'string') return '';
        if (LocalImageManager.isImageId(value) || value.startsWith('asset://')) {
            const resolved = await resolveSpecialUrl(value);
            return resolved || value;
        }
        return value;
    }, [resolveSpecialUrl]);
    const getLocalCacheCandidateUrl = useCallback((expectedId, extensions = [], preferHistoryPath = false) => {
        const base = (localServerUrl || '').trim().replace(/\/+$/, '');
        if (!base || !expectedId) return '';
        if (!localCacheIndexReadyRef.current) return '';
        const segments = [
            preferHistoryPath ? 'history' : '.tapnow_cache/history',
            preferHistoryPath ? '.tapnow_cache/history' : 'history'
        ];
        const candidates = [];
        segments.forEach((seg) => {
            extensions.forEach((ext) => {
                candidates.push(`${seg}/${expectedId}${ext}`);
            });
        });
        for (const rel of candidates) {
            const normalized = normalizeLocalCacheRelPath(rel);
            if (localCacheFileIndexRef.current.has(normalized)) {
                return `${base}/file/${normalized}`;
            }
        }
        return '';
    }, [localServerUrl, normalizeLocalCacheRelPath, localCacheIndexTick]);

    const refreshLocalCacheFileIndex = useCallback(async (options = {}) => {
        if (!localCacheActive) return;
        const base = (localServerUrl || '').replace(/\/+$/, '');
        if (!base) return;
        const silent = options.silent === true;
        try {
            const res = await fetch(`${base}/list-files`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const files = Array.isArray(data?.files)
                ? data.files
                : (Array.isArray(data?.data?.files) ? data.data.files : []);
            const next = new Set();
            files.forEach((file) => {
                const rel = normalizeLocalCacheRelPath(file?.rel_path || file?.relPath || file?.path || '');
                if (rel) next.add(rel);
            });
            localCacheFileIndexRef.current = next;
            localCacheIndexReadyRef.current = true;
            setLocalCacheIndexTick((prev) => prev + 1);
            if (!silent) showToast('本地缓存索引已更新', 'success', 1500);
        } catch (e) {
            localCacheIndexReadyRef.current = false;
            if (!silent) showToast('本地缓存索引更新失败', 'warning', 1500);
        }
    }, [localCacheActive, localServerUrl, normalizeLocalCacheRelPath, showToast]);

    // 持久化性能模式和本地服务器设置
    useEffect(() => {
        localStorage.setItem('tapnow_performance_mode', performanceMode);
        localStorage.setItem('tapnow_history_performance_mode', performanceMode);
    }, [performanceMode]);
    useEffect(() => {
        localStorage.setItem('tapnow_save_history_assets', String(saveHistoryAssets));
    }, [saveHistoryAssets]);
    useEffect(() => {
        try {
            localStorage.setItem('tapnow_history_limit', String(historySaveLimit));
        } catch (e) { }
    }, [historySaveLimit]);

    useEffect(() => {
        setHistorySaveLimitInput(String(historySaveLimit));
    }, [historySaveLimit]);

    const applyHistorySaveLimitInput = useCallback((rawValue) => {
        const trimmed = String(rawValue ?? '').trim();
        if (!trimmed) {
            if (historySaveLimitErrorRef.current.toastId) {
                dismissToast(historySaveLimitErrorRef.current.toastId);
                historySaveLimitErrorRef.current.toastId = null;
                historySaveLimitErrorRef.current.lastValue = null;
            }
            return;
        }
        const parsed = Number.parseInt(trimmed, 10);
        if (!Number.isFinite(parsed)) return;
        if (parsed < HISTORY_SAVE_LIMIT_MIN || parsed > HISTORY_SAVE_LIMIT_MAX) {
            if (historySaveLimitErrorRef.current.lastValue !== trimmed) {
                historySaveLimitErrorRef.current.lastValue = trimmed;
                if (historySaveLimitErrorRef.current.toastId) {
                    dismissToast(historySaveLimitErrorRef.current.toastId);
                }
                historySaveLimitErrorRef.current.toastId = showToast(`${t('历史保存上限需在')} ${HISTORY_SAVE_LIMIT_MIN}-${HISTORY_SAVE_LIMIT_MAX} ${t('之间')}`, 'error', 300000);
            }
            return;
        }
        if (historySaveLimitErrorRef.current.toastId) {
            dismissToast(historySaveLimitErrorRef.current.toastId);
            historySaveLimitErrorRef.current.toastId = null;
        }
        historySaveLimitErrorRef.current.lastValue = null;
        setHistorySaveLimit(parsed);
        setHistorySaveLimitInput(String(parsed));
    }, [HISTORY_SAVE_LIMIT_MIN, HISTORY_SAVE_LIMIT_MAX, showToast, dismissToast, t]);
    useEffect(() => {
        return () => {
            if (historySaveLimitTimerRef.current) {
                clearTimeout(historySaveLimitTimerRef.current);
                historySaveLimitTimerRef.current = null;
            }
        };
    }, []);

    useEffect(() => {
        localStorage.setItem('tapnow_global_performance_mode', globalPerformanceMode);
    }, [globalPerformanceMode]);

    useEffect(() => {
        localStorage.setItem('tapnow_local_server_url', localServerUrl);
    }, [localServerUrl]);
    useEffect(() => {
        try { localStorage.setItem('tapnow_local_cache_enabled', String(localCacheEnabled)); } catch (e) { }
    }, [localCacheEnabled]);
    useEffect(() => {
        try { localStorage.setItem('tapnow_cache_redownload_on_enable', String(cacheRedownloadOnEnable)); } catch (e) { }
    }, [cacheRedownloadOnEnable]);
    useEffect(() => {
        if (!localCacheActive) {
            localCacheIndexReadyRef.current = false;
            return;
        }
        refreshLocalCacheFileIndex({ silent: true });
    }, [localCacheActive, localServerUrl, localServerConfig.savePath, localServerConfig.imageSavePath, localServerConfig.videoSavePath, cacheRefreshTick, refreshLocalCacheFileIndex]);

    const getHistoryFallbackUrl = (item, options = {}) => {
        const allowLocalCache = options.allowLocalCache ?? localCacheActive;
        if (!item) return '';
        const candidates = [];
        if (allowLocalCache) {
            if (item.localCacheUrl) candidates.push(item.localCacheUrl);
            if (item.localCacheMap && typeof item.localCacheMap === 'object') {
                candidates.push(...Object.values(item.localCacheMap));
            }
        }
        if (item.localCacheMap && typeof item.localCacheMap === 'object') {
            candidates.push(...Object.keys(item.localCacheMap));
        }
        if (Array.isArray(item.mjImages)) candidates.push(...item.mjImages);
        if (Array.isArray(item.output_images)) candidates.push(...item.output_images);
        if (item.originalUrl) candidates.push(item.originalUrl);
        if (item.mjOriginalUrl) candidates.push(item.mjOriginalUrl);
        if (item.url) candidates.push(item.url);
        for (const candidate of candidates) {
            if (typeof candidate === 'string' && candidate && !candidate.startsWith('blob:')) {
                if (!allowLocalCache && isLocalCacheUrl(candidate)) continue;
                return candidate;
            }
        }
        return '';
    };

    const sanitizeHistoryUrlValue = (value, fallback = '', options = {}) => {
        const allowLocalCache = options.allowLocalCache ?? localCacheActive;
        if (!value || typeof value !== 'string') return value;
        if (!allowLocalCache && isLocalCacheUrl(value)) return fallback || '';
        if (LocalImageManager.isImageId(value)) return value;
        if (value.startsWith('asset://')) {
            const resolved = resolveAssetBundleUrl(value);
            if (resolved && resolved !== value) return resolved;
            const assetFallback = getAssetFallbackUrl(value);
            return assetFallback || value;
        }
        if (value.startsWith('data:') && value.includes('...')) {
            return fallback || '';
        }
        if (value.startsWith('blob:')) {
            return fallback || '';
        }
        return value;
    };

    const sanitizeHistoryItemForLoad = (item) => {
        const fallback = getHistoryFallbackUrl(item, { allowLocalCache: localCacheActive });
        const next = { ...item };
        next.url = sanitizeHistoryUrlValue(next.url, fallback, { allowLocalCache: localCacheActive });
        next.originalUrl = sanitizeHistoryUrlValue(next.originalUrl, fallback, { allowLocalCache: localCacheActive });
        next.mjOriginalUrl = sanitizeHistoryUrlValue(next.mjOriginalUrl, fallback, { allowLocalCache: localCacheActive });
        if (Array.isArray(next.output_images)) {
            next.output_images = next.output_images.map((url) => sanitizeHistoryUrlValue(url, fallback, { allowLocalCache: localCacheActive })).filter(Boolean);
        }
        if (Array.isArray(next.mjImages)) {
            const sanitized = next.mjImages.map((url) => sanitizeHistoryUrlValue(url, fallback, { allowLocalCache: localCacheActive })).filter(Boolean);
            if (sanitized.length === 0 && next.mjOriginalUrl) {
                next.mjImages = null;
                next.mjNeedsSplit = true;
            } else {
                next.mjImages = sanitized;
            }
        }
        if (Array.isArray(next.mjImages) && next.mjImages.length > 1) {
            if (!Array.isArray(next.output_images) || next.output_images.length < next.mjImages.length) {
                next.output_images = [...next.mjImages];
            }
        }
        if ((!Array.isArray(next.output_images) || next.output_images.length < 2)
            && next.localCacheMap && typeof next.localCacheMap === 'object') {
            const cacheKeys = Object.keys(next.localCacheMap).filter(Boolean);
            if (cacheKeys.length > 1) {
                next.output_images = cacheKeys.slice(0, 12);
            }
        }
        if (Array.isArray(next.mjThumbnails)) {
            next.mjThumbnails = next.mjThumbnails.map((url) => sanitizeHistoryUrlValue(url, fallback, { allowLocalCache: localCacheActive })).filter(Boolean);
        }
        if (next.thumbnailUrl) {
            next.thumbnailUrl = sanitizeHistoryUrlValue(next.thumbnailUrl, fallback, { allowLocalCache: localCacheActive });
        }
        return next;
    };

    const [history, setHistory] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_history');
            if (!saved) return [];
            const parsed = JSON.parse(saved);
            // 检查是否有需要重新切割的Midjourney图片 + 修复 blob/asset 残留
            return parsed.map(item => {
                const sanitized = sanitizeHistoryItemForLoad(item);
                if (sanitized.mjNeedsSplit && sanitized.mjOriginalUrl && sanitized.apiConfig?.modelId?.includes('mj')) {
                    // 标记需要重新切割，但不立即切割（避免阻塞初始化）
                    return { ...sanitized, url: sanitized.mjOriginalUrl, mjImages: null, mjNeedsSplit: true };
                }
                return sanitized;
            });
        } catch (e) {
            console.error('加载历史记录失败:', e);
            return [];
        }
    });

    // V3.4.12: 会话开始时间，用于追踪"本次生成"
    const [sessionStartTime] = useState(() => Date.now());
    // V3.4.12: 下载进度状态
    const [downloadProgress, setDownloadProgress] = useState({ active: false, current: 0, total: 0, filename: '' });
    const [downloadDisplay, setDownloadDisplay] = useState({ visible: false, current: 0, total: 0 });
    const downloadDisplayRef = useRef({ lastCurrent: 0, lastTotal: 0, holdUntil: 0, wasActive: false, timer: null });
    // V3.4.12: 历史记录选择状态
    const [historySelection, setHistorySelection] = useState(new Set());
    useEffect(() => {
        const now = Date.now();
        const ref = downloadDisplayRef.current;
        if (downloadProgress.total > 0) {
            ref.lastCurrent = downloadProgress.current;
            ref.lastTotal = downloadProgress.total;
        }
        if (downloadProgress.active) {
            if (ref.timer) {
                clearTimeout(ref.timer);
                ref.timer = null;
            }
            ref.holdUntil = 0;
            setDownloadDisplay({ visible: true, current: downloadProgress.current, total: downloadProgress.total });
        } else {
            if (ref.wasActive && ref.lastTotal > 0) {
                ref.holdUntil = now + 10000;
                if (ref.timer) clearTimeout(ref.timer);
                ref.timer = setTimeout(() => {
                    setDownloadDisplay((prev) => ({ ...prev, visible: false }));
                    downloadDisplayRef.current.timer = null;
                }, 10000);
                setDownloadDisplay({ visible: true, current: ref.lastCurrent, total: ref.lastTotal });
            } else if (ref.holdUntil > now) {
                setDownloadDisplay({ visible: true, current: ref.lastCurrent, total: ref.lastTotal });
            } else {
                setDownloadDisplay((prev) => (prev.visible ? { ...prev, visible: false } : prev));
            }
        }
        ref.wasActive = downloadProgress.active;
    }, [downloadProgress]);
    useEffect(() => {
        return () => {
            if (downloadDisplayRef.current.timer) {
                clearTimeout(downloadDisplayRef.current.timer);
                downloadDisplayRef.current.timer = null;
            }
        };
    }, []);
    // V3.4.12: 自动保存配置
    const [autoSaveConfig, setAutoSaveConfig] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_auto_save_config');
            return saved ? JSON.parse(saved) : { enabled: false, interval: 5, folderPath: '' };
        } catch (e) {
            return { enabled: false, interval: 5, folderPath: '' };
        }
    });
    // V3.4.12: 是否显示自动保存恢复弹窗
    const [showAutoSaveRecovery, setShowAutoSaveRecovery] = useState(false);


    const [chatSessions, setChatSessions] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_chat_sessions');
            return saved ? JSON.parse(saved) : [{ id: 'default', title: t('新对话'), messages: [] }];
        } catch (e) {
            return [{ id: 'default', title: t('新对话'), messages: [] }];
        }
    });
    const [currentChatId, setCurrentChatId] = useState('default');
    const [chatInput, setChatInput] = useState('');
    const [isChatOpen, setIsChatOpen] = useState(false);
    const [chatWidth, setChatWidth] = useState(400);
    const [chatFiles, setChatFiles] = useState([]);
    const [chatModel, setChatModel] = useState(() => {
        try { return localStorage.getItem('tapnow_chat_model') || 'gemini-3-pro'; } catch { return 'gemini-3-pro'; }
    });
    const [chatModelDropdownOpen, setChatModelDropdownOpen] = useState(false);
    const [chatHoveredProvider, setChatHoveredProvider] = useState(null);
    const [isChatSending, setIsChatSending] = useState(false);

    // V3.7.24: 保存聊天模型选择到 localStorage
    useEffect(() => {
        try { localStorage.setItem('tapnow_chat_model', chatModel); } catch { }
    }, [chatModel]);

    const [lightboxItem, setLightboxItem] = useState(null);
    // V3.7.22: Ref 用于解决 onNavigate 闭包过时问题
    const lightboxItemRef = useRef(lightboxItem);
    lightboxItemRef.current = lightboxItem;
    const lightboxHistorySnapshotRef = useRef(null); // 保存打开时的历史顺序，避免滚动/新增导致跳序
    const lightboxHistoryIndexRef = useRef(-1);
    const [promptLibrary, setPromptLibrary] = useState(() => {
        try {
            const saved = localStorage.getItem(PROMPT_LIBRARY_KEY);
            const parsed = saved ? JSON.parse(saved) : [];
            const defaults = [
                { id: 'grid-default', name: t('九宫格分镜脚本'), prompt: GRID_PROMPT_TEXT },
                { id: 'upscale-default', name: t('高清放大'), prompt: UPSCALE_PROMPT_TEXT },
                { id: 'moodboard-default', name: t('情绪版'), prompt: MOOD_BOARD_PROMPT_TEXT },
                { id: 'storyboard-default', name: t('【分镜版】'), prompt: STORYBOARD_PROMPT_TEXT },
                { id: 'character-sheet-default', name: t('【角色板】'), prompt: CHARACTER_SHEET_PROMPT_TEXT }
            ];
            // 确保默认项存在且不重复
            const existingIds = new Set((parsed || []).map(p => p.id));
            const merged = [...parsed];
            defaults.forEach(def => {
                const hasSameName = merged.some(p => p.name === def.name);
                if (!existingIds.has(def.id) && !hasSameName) merged.unshift(def);
            });
            return merged;
        } catch (e) {
            return [
                { id: 'grid-default', name: t('九宫格分镜脚本'), prompt: GRID_PROMPT_TEXT },
                { id: 'upscale-default', name: t('高清放大'), prompt: UPSCALE_PROMPT_TEXT },
                { id: 'moodboard-default', name: t('情绪版'), prompt: MOOD_BOARD_PROMPT_TEXT },
                { id: 'storyboard-default', name: t('【分镜版】'), prompt: STORYBOARD_PROMPT_TEXT },
                { id: 'character-sheet-default', name: t('【角色板】'), prompt: CHARACTER_SHEET_PROMPT_TEXT }
            ];
        }
    });
    const [promptLibraryForm, setPromptLibraryForm] = useState({ name: '', prompt: '' });
    const [promptLibraryCollapsed, setPromptLibraryCollapsed] = useState(false);
    const [promptLibraryEditorOpen, setPromptLibraryEditorOpen] = useState(false);
    useEffect(() => {
        try {
            localStorage.setItem(PROMPT_LIBRARY_KEY, JSON.stringify(promptLibrary));
        } catch (e) { }
    }, [promptLibrary]);

    // State management
    const [isPanning, setIsPanning] = useState(false);
    const [isDragging, setIsDragging] = useState(false);
    const [dragNodeId, setDragNodeId] = useState(null);
    const [resizingNodeId, setResizingNodeId] = useState(null);
    const [connectingSource, setConnectingSource] = useState(null);
    const [connectingTarget, setConnectingTarget] = useState(null); // 从输入端口开始的连接目标节点ID
    const [connectingInputType, setConnectingInputType] = useState(null); // 'default', 'oref', 'sref'
    const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
    const [hoverTargetId, setHoverTargetId] = useState(null);
    const [isMouseOverStoryboard, setIsMouseOverStoryboard] = useState(false); // 鼠标是否在智能分镜表窗口内

    // 框选相关状态
    // V3.7.33: Storyboard Shot Execution Timer
    const [shotTimers, setShotTimers] = useState({});

    useEffect(() => {
        const interval = setInterval(() => {
            const now = Date.now();
            const updates = {};
            let hasUpdates = false;

            if (nodesRef.current) {
                nodesRef.current.forEach(node => {
                    if (node.type === 'storyboard-node' && node.settings?.shots) {
                        node.settings.shots.forEach(shot => {
                            if (shot.status === 'generating' && shot.generationStartTime) {
                                const elapsedSeconds = (now - shot.generationStartTime) / 1000;
                                updates[`${node.id}-${shot.id}`] = `${elapsedSeconds.toFixed(1)}s`;
                                hasUpdates = true;
                            }
                        });
                    }
                });
            }

            if (hasUpdates) {
                setShotTimers(updates);
            }
        }, 100);
        return () => clearInterval(interval);
    }, []);

    const [isSelecting, setIsSelecting] = useState(false);
    const [selectionBox, setSelectionBox] = useState(null); // { startX, startY, endX, endY } (屏幕坐标)
    const [selectedNodeIds, setSelectedNodeIds] = useState(new Set()); // 多选节点ID集合
    const isSelectingRef = useRef(false); // 使用ref跟踪框选状态，确保即使Ctrl松开也能继续框选

    const [contextMenu, setContextMenu] = useState({ x: 0, y: 0, worldX: 0, worldY: 0, visible: false });
    const [contextMenuExpanded, setContextMenuExpanded] = useState(false);
    const [selectionContextMenu, setSelectionContextMenu] = useState({ visible: false, x: 0, y: 0 });
    const [historyContextMenu, setHistoryContextMenu] = useState({ visible: false, x: 0, y: 0, worldX: 0, worldY: 0, item: null });
    const [historySendMenuOpen, setHistorySendMenuOpen] = useState(false);
    const [isChatInputFocused, setIsChatInputFocused] = useState(false);
    const [isChatHovered, setIsChatHovered] = useState(false);
    const lastInteractionRef = useRef({ target: null, at: 0 });
    const markInteraction = useCallback((target) => {
        lastInteractionRef.current = { target, at: Date.now() };
    }, []);
    const historySendMenuCloseTimerRef = useRef(null);
    const openHistorySendMenu = useCallback(() => {
        if (historySendMenuCloseTimerRef.current) {
            clearTimeout(historySendMenuCloseTimerRef.current);
            historySendMenuCloseTimerRef.current = null;
        }
        setHistorySendMenuOpen(true);
    }, []);
    const scheduleHistorySendMenuClose = useCallback(() => {
        if (historySendMenuCloseTimerRef.current) {
            clearTimeout(historySendMenuCloseTimerRef.current);
        }
        historySendMenuCloseTimerRef.current = setTimeout(() => {
            setHistorySendMenuOpen(false);
            historySendMenuCloseTimerRef.current = null;
        }, 1000);
    }, []);
    // 记录当前选中的分镜格，用于接收历史记录图片
    const [activeShot, setActiveShot] = useState({ nodeId: null, shotId: null });
    const [frameContextMenu, setFrameContextMenu] = useState({ visible: false, x: 0, y: 0, nodeId: null, frame: null });
    const [previewContextMenu, setPreviewContextMenu] = useState({ visible: false, x: 0, y: 0, item: null });
    const [inputImageContextMenu, setInputImageContextMenu] = useState({ visible: false, x: 0, y: 0, nodeId: null });
    const [settingsOpen, setSettingsOpen] = useState(false);
    const [settingsTab, setSettingsTab] = useState('providers');
    const [editingApiModels, setEditingApiModels] = useState(() => new Set());
    const [editingLibraryModels, setEditingLibraryModels] = useState(() => new Set());
    const [libraryPreviewModels, setLibraryPreviewModels] = useState(() => new Set());
    const [libraryPreviewEditing, setLibraryPreviewEditing] = useState(() => new Set());
    const [libraryPreviewDrafts, setLibraryPreviewDrafts] = useState(() => ({}));
    const [libraryRequestPreviewEditing, setLibraryRequestPreviewEditing] = useState(() => new Set());
    const [libraryRequestPreviewDrafts, setLibraryRequestPreviewDrafts] = useState(() => ({}));
    const [libraryRequestTemplateDrafts, setLibraryRequestTemplateDrafts] = useState(() => ({}));
    const [libraryAsyncConfigDrafts, setLibraryAsyncConfigDrafts] = useState(() => ({}));
    const [libraryAsyncPreviewModels, setLibraryAsyncPreviewModels] = useState(() => new Set());
    const [libraryNotesCollapsed, setLibraryNotesCollapsed] = useState(() => ({}));
    const [librarySectionCollapsed, setLibrarySectionCollapsed] = useState(() => ({}));
    const [historyOpen, setHistoryOpen] = useState(false);
    const [historyCachePanelOpen, setHistoryCachePanelOpen] = useState(false);
    const [historyQueuePanelOpen, setHistoryQueuePanelOpen] = useState(false);
    const [historyFocusIndex, setHistoryFocusIndex] = useState(-1); // V3.7.28: 历史列表键盘导航
    const [historyFocusId, setHistoryFocusId] = useState(null);
    const [charactersOpen, setCharactersOpen] = useState(false);
    const [characterLibrary, setCharacterLibrary] = useState(() => {
        try {
            const saved = localStorage.getItem('tapnow_characters');
            return saved ? JSON.parse(saved) : [];
        } catch (e) {
            console.error('加载角色库失败:', e);
            return [];
        }
    });
    const [createCharacterOpen, setCreateCharacterOpen] = useState(false);
    const [createCharacterVideoSourceType, setCreateCharacterVideoSourceType] = useState('url');
    const [createCharacterVideoUrl, setCreateCharacterVideoUrl] = useState('');
    const [createCharacterSelectedTaskId, setCreateCharacterSelectedTaskId] = useState('');
    const [createCharacterStartSecond, setCreateCharacterStartSecond] = useState(1);
    const [createCharacterEndSecond, setCreateCharacterEndSecond] = useState(3);
    const [createCharacterEndpoint, setCreateCharacterEndpoint] = useState('');
    const [createCharacterSubmitting, setCreateCharacterSubmitting] = useState(false);
    const [createCharacterVideoError, setCreateCharacterVideoError] = useState(null);
    const [characterReferenceBarExpanded, setCharacterReferenceBarExpanded] = useState({});
    const [batchModalOpen, setBatchModalOpen] = useState(false);
    const [batchSelectedIds, setBatchSelectedIds] = useState(new Set());
    const [chatSessionDropdownOpen, setChatSessionDropdownOpen] = useState(false);
    const [activeTool, setActiveTool] = useState('select');
    const [activeDropdown, setActiveDropdown] = useState(null);
    const [hoveredProvider, setHoveredProvider] = useState(null); // V3.4.6: Provider 二级菜单状态
    const [expandedProviders, setExpandedProviders] = useState({}); // V3.4.7: Settings Modal Provider 展开状态
    const [editingProvider, setEditingProvider] = useState(null); // V3.4.7: Settings Modal Provider 编辑状态
    const [deletingProviderKey, setDeletingProviderKey] = useState(null); // V3.4.7: Settings Modal Provider 删除确认状态
    const [apiTesting, setApiTesting] = useState(null);
    const [apiStatus, setApiStatus] = useState({});
    // 实时计时器状态：nodeId -> elapsedSeconds
    const [nodeTimers, setNodeTimers] = useState({});
    // V3.4.8: 记住上次使用的模型
    const [lastUsedImageModel, setLastUsedImageModel] = useState(() => {
        try { return localStorage.getItem('tapnow_last_image_model') || 'nano-banana'; } catch { return 'nano-banana'; }
    });
    const [lastUsedVideoModel, setLastUsedVideoModel] = useState(() => {
        try { return localStorage.getItem('tapnow_last_video_model') || 'sora-2'; } catch { return 'sora-2'; }
    });
    const [lastUsedRatio, setLastUsedRatio] = useState(() => {
        try { return localStorage.getItem('tapnow_last_ratio') || '1:1'; } catch { return '1:1'; }
    });
    const [lastUsedImageResolution, setLastUsedImageResolution] = useState(() => {
        try { return normalizeImageResolution(localStorage.getItem('tapnow_last_image_res') || '2K'); } catch { return '2K'; }
    });
    const [lastUsedVideoResolution, setLastUsedVideoResolution] = useState(() => {
        try { return normalizeVideoResolution(localStorage.getItem('tapnow_last_video_res') || '720P'); } catch { return '720P'; }
    });
    const [lastUsedSegmentDuration, setLastUsedSegmentDuration] = useState(() => {
        try { return localStorage.getItem('tapnow_last_segment_duration') || '3'; } catch { return '3'; }
    });
    const [lastUsedAnalyzeModel, setLastUsedAnalyzeModel] = useState(() => {
        try { return localStorage.getItem('tapnow_last_analyze_model') || 'gemini-3-pro'; } catch { return 'gemini-3-pro'; }
    });
    const [lastUsedExtractModel, setLastUsedExtractModel] = useState(() => {
        try { return localStorage.getItem('tapnow_last_extract_model') || ''; } catch { return ''; }
    });

    // V2.6.1 Feature: 本地缓存服务器连接检查
    useEffect(() => {
        if (!localCacheEnabled) {
            setLocalCacheServerConnected(false);
            return;
        }
        const baseUrl = (localServerUrl || '').replace(/\/+$/, '');
        if (!baseUrl) {
            setLocalCacheServerConnected(false);
            return;
        }

        let cancelled = false;
        const checkLocalCacheServer = async () => {
            try {
                const res = await fetch(`${baseUrl}/ping`, { method: 'GET' });
                if (res.ok) {
                    const data = await res.json();
                    if (cancelled) return;
                    const rawImagePath = data.image_save_path_raw ?? data.image_save_path ?? '';
                    const rawVideoPath = data.video_save_path_raw ?? data.video_save_path ?? '';
                    setLocalCacheServerConnected(true);
                    setLocalServerConfig(prev => ({
                        ...prev,
                        savePath: normalizeLocalPath(data.save_path || prev.savePath || ''),
                        imageSavePath: normalizeLocalPath(rawImagePath || ''),
                        videoSavePath: normalizeLocalPath(rawVideoPath || ''),
                        convertPngToJpg: data.convert_png_to_jpg !== false,
                        jpgQuality: data.jpg_quality || prev.jpgQuality,
                        pilAvailable: data.pil_available || false
                    }));
                    return;
                }
            } catch (e) { }
            if (cancelled) return;
            setLocalCacheServerConnected(false);
        };

        checkLocalCacheServer();
        const interval = setInterval(checkLocalCacheServer, 30000);
        return () => {
            cancelled = true;
            clearInterval(interval);
        };
    }, [localServerUrl, localCacheEnabled]);

    useEffect(() => {
        if (localCacheBannerTimerRef.current) {
            clearTimeout(localCacheBannerTimerRef.current);
            localCacheBannerTimerRef.current = null;
        }
        if (!localCacheEnabled) {
            setLocalCacheBannerVisible(false);
            return;
        }
        if (localCacheServerConnected) {
            setLocalCacheBannerVisible(true);
            return;
        }
        setLocalCacheBannerVisible(true);
        localCacheBannerTimerRef.current = setTimeout(() => {
            setLocalCacheBannerVisible(false);
            localCacheBannerTimerRef.current = null;
        }, 180000);
        return () => {
            if (localCacheBannerTimerRef.current) {
                clearTimeout(localCacheBannerTimerRef.current);
                localCacheBannerTimerRef.current = null;
            }
        };
    }, [localCacheEnabled, localCacheServerConnected]);

    // V2.6.1 Feature: 同步 local-save 节点连接状态
    useEffect(() => {
        setNodes(prev => prev.map(n => {
            if (n.type !== 'local-save') return n;
            if (n.settings?.serverUrl) return n;
            const nextStatus = localCacheServerConnected ? 'connected' : 'disconnected';
            if (n.settings?.serverStatus === nextStatus) return n;
            return { ...n, settings: { ...n.settings, serverStatus: nextStatus } };
        }));
    }, [localCacheServerConnected]);

    // V2.6.1 Feature: 本地缓存与缩略图辅助函数
    const sanitizeCacheId = useCallback((value) => {
        if (!value) return '';
        return value
            .replace(/[<>:"/\\|?*\x00-\x1F]/g, '_')
            .replace(/\s+/g, '_')
            .replace(/_+/g, '_')
            .replace(/^_+|_+$/g, '')
            .slice(0, 120);
    }, []);

    const normalizeLocalPath = useCallback((value) => {
        if (!value) return '';
        const hasDrive = /^[a-zA-Z]:/.test(value);
        if (!hasDrive) return value.trim();
        return value.replace(/\//g, '\\').replace(/\\+/g, '\\').trim();
    }, []);

    const getFilenameFromUrl = useCallback((url) => {
        if (!url) return null;
        try {
            const urlWithoutQuery = url.split('?')[0];
            const parts = urlWithoutQuery.split('/');
            const filename = parts[parts.length - 1];
            const nameWithoutExt = filename.replace(/\.[^.]+$/, '');
            const sanitized = sanitizeCacheId(nameWithoutExt || '');
            return sanitized || null;
        } catch (e) {
            return null;
        }
    }, [sanitizeCacheId]);

    const getDataUrlExt = useCallback((dataUrl, fallback = '') => {
        if (!dataUrl || !dataUrl.startsWith('data:')) return fallback;
        const match = dataUrl.match(/^data:([^;]+);/i);
        if (!match) return fallback;
        const mime = match[1].toLowerCase();
        const map = {
            'image/jpeg': '.jpg',
            'image/jpg': '.jpg',
            'image/png': '.png',
            'image/webp': '.webp',
            'image/gif': '.gif',
            'video/mp4': '.mp4',
            'video/webm': '.webm',
            'video/quicktime': '.mov'
        };
        return map[mime] || fallback;
    }, []);

    const detectBase64ImageMime = useCallback((raw, fallback = 'image/png') => {
        if (!raw || typeof raw !== 'string') return fallback;
        const trimmed = raw.trim();
        if (!trimmed) return fallback;
        if (trimmed.startsWith('data:')) {
            const match = trimmed.match(/^data:([^;]+);/i);
            return match?.[1]?.toLowerCase() || fallback;
        }
        if (trimmed.startsWith('/9j/')) return 'image/jpeg';
        if (trimmed.startsWith('iVBORw0KGgo')) return 'image/png';
        if (trimmed.startsWith('R0lGOD')) return 'image/gif';
        if (trimmed.startsWith('UklGR') && trimmed.toUpperCase().includes('WEBP')) return 'image/webp';
        return fallback;
    }, []);

    const normalizeImageUrlValue = (value, mimeHint = 'image/png') => {
        if (!value || typeof value !== 'string') return '';
        const trimmed = value.trim();
        if (!trimmed) return '';
        if (trimmed.startsWith('data:')) return normalizeDataUrl(trimmed);
        if (trimmed.startsWith('blob:') || trimmed.startsWith('http://') || trimmed.startsWith('https://')) return trimmed;
        if (LocalImageManager.isImageId(trimmed) || trimmed.startsWith('asset://')) return trimmed;
        const base64Like = /^[A-Za-z0-9+/=_-]+$/.test(trimmed);
        if (base64Like && trimmed.length > 64) {
            const mimeType = detectBase64ImageMime(trimmed, mimeHint);
            const normalized = normalizeBase64Payload(trimmed);
            if (!normalized) return '';
            return `data:${mimeType};base64,${normalized}`;
        }
        return trimmed;
    };

    const persistBase64ImageUrl = async (value, options = {}) => {
        if (!value || typeof value !== 'string' || !value.startsWith('data:')) return value;
        if (options.persistBase64 === false) return value;
        if (!LocalImageManager?.saveImage) return value;
        const minLength = Number.isFinite(options.minLength) ? options.minLength : 2000;
        if (value.length < minLength) return value;
        try {
            const imgId = await LocalImageManager.saveImage(value);
            return imgId || value;
        } catch (e) {
            return value;
        }
    };

    const normalizeImageUrls = async (urls, options = {}) => {
        if (!Array.isArray(urls)) return [];
        const normalized = urls
            .map((url) => normalizeImageUrlValue(url, options.mimeHint || 'image/png'))
            .filter(Boolean);
        const unique = [];
        normalized.forEach((url) => {
            if (!unique.includes(url)) unique.push(url);
        });
        if (options.persistBase64 === false) return unique;
        const persisted = await Promise.all(unique.map((url) => persistBase64ImageUrl(url, options)));
        return persisted.filter(Boolean);
    };

    const getUrlExt = useCallback((url, fallback = '') => {
        if (!url) return fallback;
        const clean = url.split('?')[0].split('#')[0];
        const match = clean.match(/\.([a-zA-Z0-9]+)$/);
        if (!match) return fallback;
        const ext = `.${match[1].toLowerCase()}`;
        if (ext === '.jpeg') return '.jpg';
        return ext;
    }, []);

    const hashString = useCallback((value) => {
        let hash = 0;
        for (let i = 0; i < value.length; i++) {
            hash = ((hash << 5) - hash) + value.charCodeAt(i);
            hash |= 0;
        }
        return Math.abs(hash).toString(36);
    }, []);

    const getCacheIdFromUrl = useCallback((url, fallbackId) => {
        const safeFallback = sanitizeCacheId(fallbackId || '');
        if (!url) return safeFallback || `cache_${Date.now()}`;
        const hashed = hashString(url);
        if (safeFallback) return `${safeFallback}_${hashed}`;
        const fromUrl = getFilenameFromUrl(url);
        if (fromUrl) return `${fromUrl}_${hashed}`;
        return `cache_${hashed}`;
    }, [getFilenameFromUrl, sanitizeCacheId, hashString]);

    const resolveCacheFetchUrl = useCallback((rawUrl, useProxy = false) => {
        if (!rawUrl || typeof rawUrl !== 'string') return rawUrl;
        if (rawUrl.startsWith('data:') || rawUrl.startsWith('blob:')) return rawUrl;
        if (!/^https?:/i.test(rawUrl)) return rawUrl;
        if (!useProxy) return rawUrl;
        const base = (localServerUrl || '').trim().replace(/\/+$/, '');
        if (!base) return rawUrl;
        if (rawUrl.startsWith(base)) return rawUrl;
        return `${base}/proxy?url=${encodeURIComponent(rawUrl)}`;
    }, [localServerUrl]);

    // 获取 Blob 对象（统一资源获取渠道）
    const getBlobFromUrl = async (url, options = {}) => {
        if (!url) throw new Error('Invalid URL');
        const preferLocal = options.preferLocal !== false && localCacheActive;
        const proxyBaseUrl = (options.proxyBaseUrl || localServerUrl || '').trim().replace(/\/+$/, '');
        let rawUrl = String(url);
        rawUrl = await resolveSpecialUrl(rawUrl);
        rawUrl = applyMediaCachePolicy(rawUrl);
        if (!rawUrl) throw new Error('Invalid URL');
        const fetchBlob = async (target) => {
            const res = await fetch(target);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return await res.blob();
        };
        if (rawUrl.startsWith('data:')) {
            const normalized = normalizeDataUrl(rawUrl);
            const blob = dataUrlToBlob(normalized);
            if (!blob) throw new Error('Invalid base64 payload');
            return blob;
        }
        if (rawUrl.startsWith('blob:')) {
            try {
                return await fetchBlob(rawUrl);
            } catch (e) {
                throw new Error('Blob 已失效');
            }
        }
        let targetUrl = rawUrl;
        const cachedUrl = preferLocal && historyLocalCacheMap && historyLocalCacheMap.has(rawUrl)
            ? historyLocalCacheMap.get(rawUrl)
            : null;
        if (cachedUrl) {
            const canUseCached = !isLocalCacheUrl(cachedUrl) || isLocalCacheUrlAvailable(cachedUrl);
            if (canUseCached) {
                try {
                    if (cachedUrl.startsWith('data:')) {
                        const normalized = normalizeDataUrl(cachedUrl);
                        const blob = dataUrlToBlob(normalized);
                        if (blob) return blob;
                    } else if (cachedUrl.startsWith('blob:')) {
                        return await fetchBlob(cachedUrl);
                    } else {
                        return await fetchBlob(cachedUrl);
                    }
                } catch (e) {
                    // 本地缓存不可用时回退到原始URL
                }
            }
        }
        targetUrl = rawUrl;
        if (targetUrl.startsWith('data:')) {
            const normalized = normalizeDataUrl(targetUrl);
            const blob = dataUrlToBlob(normalized);
            if (!blob) throw new Error('Invalid base64 payload');
            return blob;
        }
        if (targetUrl.startsWith('blob:')) {
            try {
                return await fetchBlob(targetUrl);
            } catch (e) {
                throw new Error('Blob 已失效');
            }
        }
        const useProxy = options.useProxy === true;
        let resolvedTarget = targetUrl;
        if (useProxy) {
            if (proxyBaseUrl) {
                resolvedTarget = targetUrl.startsWith(proxyBaseUrl)
                    ? targetUrl
                    : `${proxyBaseUrl}/proxy?url=${encodeURIComponent(targetUrl)}`;
            } else {
                resolvedTarget = resolveCacheFetchUrl(targetUrl, true);
            }
        }
        if (!resolvedTarget) throw new Error('Invalid URL');
        return await fetchBlob(resolvedTarget);
    };

    const coerceImageBlobForJimeng = useCallback(async (blob) => {
        if (!blob) return blob;
        const type = (blob.type || '').toLowerCase();
        if (type.includes('png') || type.includes('jpeg') || type.includes('jpg')) return blob;
        if (typeof createImageBitmap === 'undefined') return blob;
        try {
            const bitmap = await createImageBitmap(blob);
            const canvas = document.createElement('canvas');
            canvas.width = bitmap.width || 0;
            canvas.height = bitmap.height || 0;
            const ctx = canvas.getContext('2d');
            if (!ctx) return blob;
            ctx.drawImage(bitmap, 0, 0);
            const pngBlob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/png'));
            return pngBlob || blob;
        } catch (e) {
            return blob;
        }
    }, []);

    // 获取 Base64 字符串（自动识别 Data URL 或 Blob URL 并转换）
    const getBase64FromUrl = async (url, options = {}) => {
        let resolvedUrl = url;
        if (resolvedUrl && typeof resolvedUrl === 'string') {
            resolvedUrl = await resolveSpecialUrl(resolvedUrl);
        }
        if (resolvedUrl && resolvedUrl.startsWith('data:')) {
            const normalized = normalizeDataUrl(resolvedUrl);
            const blob = dataUrlToBlob(normalized);
            if (!blob) throw new Error('Invalid base64 payload');
            const dataUrl = await blobToDataURL(blob);
            return dataUrl.split(',')[1] || '';
        }
        const blob = await getBlobFromUrl(resolvedUrl, options);
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                const res = reader.result;
                // 返回纯 Base64 部分
                resolve(res.split(',')[1]);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    };

    const blobToDataURL = (blob) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    };

    const normalizePersistLookupKey = useCallback((value) => {
        if (!value || typeof value !== 'string') return '';
        const raw = String(value).trim();
        if (!raw) return '';
        const noHash = raw.split('#')[0];
        const noQuery = noHash.split('?')[0];
        try {
            const parsed = new URL(noQuery);
            const host = String(parsed.hostname || '').toLowerCase();
            let pathname = parsed.pathname || '';
            try { pathname = decodeURIComponent(pathname); } catch (e) { }
            if ((host === '127.0.0.1' || host === 'localhost') && pathname.startsWith('/file/')) {
                return pathname.toLowerCase();
            }
            return `${parsed.origin}${pathname}`.toLowerCase();
        } catch (e) {
            return noQuery.toLowerCase();
        }
    }, []);

    const sourceReferenceLookupRef = useRef(new Map());
    const sourceReferenceResolveCacheRef = useRef(new Map());
    const refreshSourceReferenceLookup = useCallback(() => {
        const map = new Map();
        const pickSourceFallback = (historyItem) => {
            if (!historyItem || typeof historyItem !== 'object') return '';
            const candidates = [
                ...(Array.isArray(historyItem.output_images) ? historyItem.output_images : []),
                ...(Array.isArray(historyItem.mjImages) ? historyItem.mjImages : []),
                historyItem.originalUrl,
                historyItem.mjOriginalUrl,
                historyItem.url
            ];
            for (const candidate of candidates) {
                if (!candidate || typeof candidate !== 'string') continue;
                const normalized = candidate.trim();
                if (!normalized || normalized.startsWith('blob:') || isLocalCacheUrl(normalized)) continue;
                return normalized;
            }
            return '';
        };
        const addPair = (cacheUrl, sourceUrl) => {
            if (!cacheUrl || !sourceUrl) return;
            const normalizedSource = typeof sourceUrl === 'string' ? sourceUrl.trim() : '';
            if (!normalizedSource || normalizedSource.startsWith('blob:') || isLocalCacheUrl(normalizedSource)) return;
            const rawCache = String(cacheUrl);
            map.set(rawCache, normalizedSource);
            const strippedCache = rawCache.split('#')[0].split('?')[0];
            if (strippedCache && strippedCache !== rawCache) {
                map.set(strippedCache, normalizedSource);
            }
            const key = normalizePersistLookupKey(rawCache);
            if (key) map.set(key, normalizedSource);
        };
        for (const [sourceUrl, cacheUrl] of cachedHistoryUrlRef.current.entries()) {
            addPair(cacheUrl, sourceUrl);
        }
        history.forEach((historyItem) => {
            if (!historyItem || typeof historyItem !== 'object') return;
            if (historyItem.localCacheMap && typeof historyItem.localCacheMap === 'object') {
                Object.entries(historyItem.localCacheMap).forEach(([sourceUrl, cacheUrl]) => {
                    addPair(cacheUrl, sourceUrl);
                });
            }
            if (historyItem.localCacheUrl) {
                const fallback = pickSourceFallback(historyItem);
                if (fallback) addPair(historyItem.localCacheUrl, fallback);
            }
        });
        sourceReferenceLookupRef.current = map;
        sourceReferenceResolveCacheRef.current.clear();
    }, [history, isLocalCacheUrl, normalizePersistLookupKey]);
    useEffect(() => {
        refreshSourceReferenceLookup();
    }, [refreshSourceReferenceLookup]);

    const resolveSourceReferenceUrl = useCallback((value) => {
        if (!value || typeof value !== 'string') return value;
        if (sourceReferenceResolveCacheRef.current.has(value)) {
            return sourceReferenceResolveCacheRef.current.get(value);
        }
        let next = value.trim();
        if (!next) {
            sourceReferenceResolveCacheRef.current.set(value, '');
            return '';
        }
        if (LocalImageManager.isImageId(next) || next.startsWith('data:') || next.startsWith('asset://') || next.startsWith('blob:')) {
            sourceReferenceResolveCacheRef.current.set(value, next);
            return next;
        }
        const looksLikeLocalRuntimeUrl = next.includes('127.0.0.1')
            || next.includes('localhost')
            || next.includes('/proxy?url=')
            || next.includes('/file/.tapnow_cache/')
            || next.includes('.tapnow_cache\\');
        if (!looksLikeLocalRuntimeUrl) {
            sourceReferenceResolveCacheRef.current.set(value, next);
            return next;
        }

        const unwrapProxy = (raw) => {
            try {
                const parsed = new URL(String(raw));
                const isLocalHost = parsed.hostname === '127.0.0.1' || parsed.hostname === 'localhost';
                if (isLocalHost && parsed.pathname === '/proxy') {
                    const target = parsed.searchParams.get('url');
                    if (target) return target;
                }
            } catch (e) { }
            return raw;
        };
        next = unwrapProxy(next);

        if (!isLocalCacheUrl(next)) {
            sourceReferenceResolveCacheRef.current.set(value, next);
            return next;
        }

        const direct = sourceReferenceLookupRef.current.get(next);
        if (direct) {
            sourceReferenceResolveCacheRef.current.set(value, direct);
            return direct;
        }
        const stripped = next.split('#')[0].split('?')[0];
        if (stripped) {
            const fromStripped = sourceReferenceLookupRef.current.get(stripped);
            if (fromStripped) {
                sourceReferenceResolveCacheRef.current.set(value, fromStripped);
                return fromStripped;
            }
        }
        const targetKey = normalizePersistLookupKey(next);
        if (targetKey) {
            const fromKey = sourceReferenceLookupRef.current.get(targetKey);
            if (fromKey) {
                sourceReferenceResolveCacheRef.current.set(value, fromKey);
                return fromKey;
            }
        }
        sourceReferenceResolveCacheRef.current.set(value, next);
        return next;
    }, [isLocalCacheUrl, normalizePersistLookupKey]);

    const resolveAutoSaveUrl = useCallback(async (value) => {
        if (!value || typeof value !== 'string') return value;
        if (value.startsWith('asset://')) return value;
        if (!value.startsWith('blob:')) {
            const maybeLocalRuntime = value.includes('127.0.0.1')
                || value.includes('localhost')
                || value.includes('/proxy?url=')
                || value.includes('/file/.tapnow_cache/')
                || value.includes('.tapnow_cache\\');
            if (!maybeLocalRuntime) return value;
            return resolveSourceReferenceUrl(value);
        }
        if (autoSaveUrlCacheRef.current.has(value)) return autoSaveUrlCacheRef.current.get(value);
        const fallback = getAssetFallbackUrl(value);
        if (fallback) {
            autoSaveUrlCacheRef.current.set(value, fallback);
            return fallback;
        }
        try {
            const blob = await getBlobFromUrl(value);
            if (blob && blob.type && blob.type.startsWith('image/')) {
                try {
                    const imgId = await LocalImageManager.saveImage(blob);
                    if (imgId) {
                        autoSaveUrlCacheRef.current.set(value, imgId);
                        return imgId;
                    }
                } catch (e) { }
                const dataUrl = await blobToDataURL(blob);
                autoSaveUrlCacheRef.current.set(value, dataUrl);
                return dataUrl;
            }
            if (blob && blob.type && blob.type.startsWith('video/')) {
                if (blob.size <= 8 * 1024 * 1024) {
                    const dataUrl = await blobToDataURL(blob);
                    autoSaveUrlCacheRef.current.set(value, dataUrl);
                    return dataUrl;
                }
            }
        } catch (e) { }
        const sourceFallback = resolveSourceReferenceUrl(value);
        autoSaveUrlCacheRef.current.set(value, sourceFallback);
        return sourceFallback;
    }, [getBlobFromUrl, getAssetFallbackUrl, resolveSourceReferenceUrl]);

    const sanitizeObjectForAutoSave = useCallback(async (obj) => {
        if (obj === null || obj === undefined) return obj;
        if (typeof obj === 'string') {
            return await resolveAutoSaveUrl(obj);
        }
        if (Array.isArray(obj)) {
            const next = [];
            for (let i = 0; i < obj.length; i++) {
                next[i] = await sanitizeObjectForAutoSave(obj[i]);
            }
            return next;
        }
        if (typeof obj === 'object') {
            const next = {};
            const entries = Object.entries(obj);
            for (let i = 0; i < entries.length; i++) {
                const [key, value] = entries[i];
                next[key] = await sanitizeObjectForAutoSave(value);
            }
            return next;
        }
        return obj;
    }, [resolveAutoSaveUrl]);

    const persistAutoSaveSnapshot = useCallback(async (override = {}) => {
        const snapshotNodes = Array.isArray(override.nodes) ? override.nodes : (nodesRef.current || []);
        const snapshotConnections = Array.isArray(override.connections) ? override.connections : (connectionsRef.current || []);
        const timestamp = Date.now();
        const safeNodes = await sanitizeObjectForAutoSave(snapshotNodes);
        const saveData = {
            nodes: safeNodes,
            connections: snapshotConnections,
            timestamp
        };
        const payload = JSON.stringify(saveData);
        try {
            await writeAutoSaveToIdb(payload);
            autoSaveUseIdbRef.current = true;
            writeAutoSaveMeta({ timestamp, storage: 'idb' });
            try { localStorage.removeItem(AUTOSAVE_LOCAL_KEY); } catch (e) { }
            console.log('[AutoSave] 已立即写入 IndexedDB', new Date().toLocaleTimeString());
        } catch (e) {
            try {
                if (payload.length > 4 * 1024 * 1024) {
                    throw new Error('payload too large');
                }
                localStorage.setItem(AUTOSAVE_LOCAL_KEY, payload);
                autoSaveUseIdbRef.current = false;
                writeAutoSaveMeta({ timestamp, storage: 'local' });
                console.log('[AutoSave] 已立即写入本地存储', new Date().toLocaleTimeString());
            } catch (err) {
                console.warn('[AutoSave] 立即保存失败:', err.message || err);
            }
        }
    }, [sanitizeObjectForAutoSave]);

    const generateThumbnail = useCallback(async (imageUrl, quality = 'normal', options = {}) => {
        const config = quality === 'ultra'
            ? { maxSize: 80, jpegQuality: 0.3 }
            : { maxSize: 150, jpegQuality: 0.6 };
        let resolvedUrl = imageUrl;
        if (!resolvedUrl) return null;
        try {
            if (LocalImageManager.isImageId(resolvedUrl)) {
                resolvedUrl = await LocalImageManager.getImage(resolvedUrl);
            }
        } catch (e) {
            return null;
        }
        if (!resolvedUrl) return null;
        try {
            const blob = await getBlobFromUrl(resolvedUrl, {
                useProxy: options.useProxy,
                preferLocal: options.preferLocal
            });
            if (!blob) return null;
            const blobUrl = URL.createObjectURL(blob);
            return await new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let w = img.naturalWidth;
                    let h = img.naturalHeight;
                    if (w > h) {
                        if (w > config.maxSize) { h = h * config.maxSize / w; w = config.maxSize; }
                    } else {
                        if (h > config.maxSize) { w = w * config.maxSize / h; h = config.maxSize; }
                    }
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, w, h);
                    const dataUrl = canvas.toDataURL('image/jpeg', config.jpegQuality);
                    URL.revokeObjectURL(blobUrl);
                    resolve(dataUrl);
                };
                img.onerror = () => {
                    URL.revokeObjectURL(blobUrl);
                    resolve(null);
                };
                img.src = blobUrl;
            });
        } catch (e) {
            return null;
        }
    }, [getBlobFromUrl]);

    // 辅助函数：将 Base64 Data URL 转换为 Blob URL
    const base64ToBlobUrl = async (base64Data) => {
        try {
            if (!base64Data || typeof base64Data !== 'string') {
                return base64Data;
            }
            // 如果已经是 Blob URL 或 HTTP URL，直接返回
            if (base64Data.startsWith('blob:') || base64Data.startsWith('http://') || base64Data.startsWith('https://')) {
                return base64Data;
            }
            // 如果是 Base64 Data URL，转换为 Blob URL
            if (base64Data.startsWith('data:')) {
                const blob = dataUrlToBlob(base64Data);
                return URL.createObjectURL(blob);
            }
            // 其他情况直接返回
            return base64Data;
        } catch (e) {
            console.error('Base64转Blob失败', e);
            return base64Data; // 失败则返回原数据
        }
    };

    const CACHE_FETCH_RETRY_MS = 5 * 60 * 1000;
    const getCacheFailureKey = useCallback((url) => {
        if (!url) return '';
        try {
            const parsed = new URL(url);
            return parsed.origin || url;
        } catch (e) {
            return url;
        }
    }, []);
    const shouldSkipCacheFetch = useCallback((url) => {
        if (!url) return false;
        const key = getCacheFailureKey(url);
        const lastFail = cacheFetchFailureRef.current.get(key);
        return lastFail && (Date.now() - lastFail < CACHE_FETCH_RETRY_MS);
    }, [getCacheFailureKey]);
    const recordCacheFetchFailure = useCallback((url) => {
        if (!url) return;
        const key = getCacheFailureKey(url);
        cacheFetchFailureRef.current.set(key, Date.now());
    }, [getCacheFailureKey]);
    const shouldProbeCacheHead = useCallback((url, ttlMs = 60000) => {
        if (!url) return false;
        const now = Date.now();
        const last = cacheHeadProbeRef.current.get(url) || 0;
        if (now - last < ttlMs) return false;
        cacheHeadProbeRef.current.set(url, now);
        return true;
    }, []);
    const fetchCacheSource = useCallback(async (imageUrl, options = {}) => {
        const useProxy = options.useProxy === true;
        const proxyBaseUrl = options.proxyBaseUrl;
        const preferLocal = options.preferLocal === true;
        if (!imageUrl) throw new Error('缓存拉取失败: 空链接');
        try {
            const blob = await getBlobFromUrl(imageUrl, { useProxy, preferLocal, proxyBaseUrl });
            if (!blob || blob.size === 0) throw new Error('缓存拉取失败: 空文件');
            return { blob, source: imageUrl };
        } catch (err) {
            throw err || new Error('缓存拉取失败');
        }
    }, [getBlobFromUrl]);

    const saveImageToLocalCache = useCallback(async (itemId, imageUrl, category = 'history', options = {}) => {
        if (!localCacheActive) return null;
        const baseUrl = (localServerUrl || '').replace(/\/+$/, '');
        if (!baseUrl) return null;
        const useProxy = options.useProxy === true;
        try {
            const forcedId = options?.forceId ? sanitizeCacheId(itemId || '') : '';
            const saveId = forcedId || getCacheIdFromUrl(imageUrl, itemId);

            let content = imageUrl;
            if (!imageUrl.startsWith('data:')) {
                if (!useProxy && shouldSkipCacheFetch(imageUrl)) return null;
                const { blob } = await fetchCacheSource(imageUrl, { useProxy });
                content = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
            } else {
                content = normalizeDataUrl(imageUrl);
            }
            const ext = getDataUrlExt(content, getUrlExt(imageUrl, '.jpg'));

            const res = await fetch(`${baseUrl}/save-cache`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: saveId, content, category, ext, type: 'image' })
            });
            if (res.ok) {
                const data = await res.json();
                if (data.success) {
                    const relPath = extractLocalCacheRelPath(data.url);
                    if (relPath) {
                        localCacheFileIndexRef.current.add(relPath);
                        localCacheIndexReadyRef.current = true;
                        setLocalCacheIndexTick((prev) => prev + 1);
                    }
                    return { url: data.url, path: data.path };
                }
            }
        } catch (e) {
            if (imageUrl && !imageUrl.startsWith('data:')) {
                recordCacheFetchFailure(imageUrl);
            }
            console.warn('[缓存] 保存图片缓存失败:', e);
        }
        return null;
    }, [localCacheActive, localServerUrl, getCacheIdFromUrl, getDataUrlExt, getUrlExt, sanitizeCacheId, shouldSkipCacheFetch, fetchCacheSource, recordCacheFetchFailure, extractLocalCacheRelPath]);

    const saveVideoToLocalCache = useCallback(async (itemId, videoUrl, category = 'history', options = {}) => {
        if (!localCacheActive) return null;
        const baseUrl = (localServerUrl || '').replace(/\/+$/, '');
        if (!baseUrl) return null;
        const useProxy = options.useProxy === true;
        try {
            const saveId = getCacheIdFromUrl(videoUrl, itemId);

            if (!useProxy && shouldSkipCacheFetch(videoUrl)) return null;
            const { blob } = await fetchCacheSource(videoUrl, { useProxy });
            const content = await new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.readAsDataURL(blob);
            });
            const ext = getDataUrlExt(content, getUrlExt(videoUrl, '.mp4'));

            const saveRes = await fetch(`${baseUrl}/save-cache`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: saveId, content, category, ext, type: 'video' })
            });
            if (saveRes.ok) {
                const data = await saveRes.json();
                if (data.success) {
                    const relPath = extractLocalCacheRelPath(data.url);
                    if (relPath) {
                        localCacheFileIndexRef.current.add(relPath);
                        localCacheIndexReadyRef.current = true;
                        setLocalCacheIndexTick((prev) => prev + 1);
                    }
                    return { url: data.url, path: data.path };
                }
            }
        } catch (e) {
            if (videoUrl) {
                recordCacheFetchFailure(videoUrl);
            }
            console.warn('[缓存] 保存视频缓存失败:', e);
        }
        return null;
    }, [localCacheActive, localServerUrl, getCacheIdFromUrl, getDataUrlExt, getUrlExt, shouldSkipCacheFetch, fetchCacheSource, recordCacheFetchFailure, extractLocalCacheRelPath]);

    const updateLocalCacheServerConfig = useCallback(async (patch, options = {}) => {
        const silent = options.silent === true;
        const baseUrl = (localServerUrl || '').replace(/\/+$/, '');
        if (!baseUrl) {
            if (!silent) showToast('本地服务地址为空', 'error');
            return false;
        }
        const normalizedPatch = { ...patch };
        if (normalizedPatch.save_path) normalizedPatch.save_path = normalizeLocalPath(normalizedPatch.save_path);
        if (normalizedPatch.image_save_path) normalizedPatch.image_save_path = normalizeLocalPath(normalizedPatch.image_save_path);
        if (normalizedPatch.video_save_path) normalizedPatch.video_save_path = normalizeLocalPath(normalizedPatch.video_save_path);
        try {
            const res = await fetch(`${baseUrl}/config`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(normalizedPatch)
            });
            if (!res.ok) {
                const errText = await res.text();
                throw new Error(errText || '配置更新失败');
            }
            const data = await res.json();
            const serverConfig = data?.config || {};
            const rawImagePath = serverConfig.image_save_path_raw;
            const rawVideoPath = serverConfig.video_save_path_raw;
            setLocalServerConfig(prev => ({
                ...prev,
                savePath: normalizeLocalPath(
                    serverConfig.save_path ?? normalizedPatch.save_path ?? prev.savePath ?? ''
                ),
                imageSavePath: normalizeLocalPath(
                    rawImagePath !== undefined
                        ? rawImagePath
                        : (serverConfig.image_save_path ?? normalizedPatch.image_save_path ?? prev.imageSavePath ?? '')
                ),
                videoSavePath: normalizeLocalPath(
                    rawVideoPath !== undefined
                        ? rawVideoPath
                        : (serverConfig.video_save_path ?? normalizedPatch.video_save_path ?? prev.videoSavePath ?? '')
                ),
                convertPngToJpg: (serverConfig.convert_png_to_jpg ?? normalizedPatch.convert_png_to_jpg) !== undefined
                    ? (serverConfig.convert_png_to_jpg ?? normalizedPatch.convert_png_to_jpg) !== false
                    : prev.convertPngToJpg,
                jpgQuality: serverConfig.jpg_quality ?? normalizedPatch.jpg_quality ?? prev.jpgQuality,
                pilAvailable: serverConfig.pil_available ?? prev.pilAvailable
            }));
            if (!silent) showToast(data?.message || '本地缓存配置已更新', 'success', 2000);
            return true;
        } catch (err) {
            if (!silent) showToast(`配置更新失败: ${err.message || '网络错误'}`, 'error', 2000);
            return false;
        }
    }, [localServerUrl, showToast, normalizeLocalPath]);

    const refreshLocalCache = useCallback((options = {}) => {
        const silent = !!options.silent;
        const reset = options.reset !== false;
        triedCacheIdsRef.current = new Set();
        thumbnailCacheRef.current = new Map();
        localCacheCheckRef.current = new Map();
        cachedHistoryUrlRef.current = new Map();
        cacheFetchFailureRef.current = new Map();
        localCacheFileIndexRef.current = new Set();
        localCacheIndexReadyRef.current = false;
        setLocalCacheIndexTick((prev) => prev + 1);
        if (reset) {
            setHistory(prev => prev.map(item => ({
                ...item,
                localCacheUrl: null,
                localFilePath: null,
                localCacheMap: null
            })));
            setCharacterLibrary(prev => prev.map(item => ({
                ...item,
                localCacheUrl: null,
                localFilePath: null
            })));
        }
        setCacheRefreshTick(prev => prev + 1);
        if (!silent) {
            showToast('已触发缓存刷新，将重新写入本地缓存路径', 'success');
        }
        refreshLocalCacheFileIndex({ silent: true });
    }, [showToast, refreshLocalCacheFileIndex]);

    useEffect(() => {
        if (!localCacheActive) return;
        refreshLocalCache({ silent: true, reset: cacheRedownloadOnEnable });
    }, [localCacheActive, refreshLocalCache, cacheRedownloadOnEnable]);

    const getItemProxyPreference = useCallback((item) => {
        if (typeof item?.useProxy === 'boolean') return item.useProxy;
        if (typeof item?.apiConfig?.useProxy === 'boolean') return item.apiConfig.useProxy;
        let providerKey = String(item?.provider || item?.apiConfig?.provider || '').trim();
        if (!providerKey) {
            const modelKey = String(item?.model || item?.modelName || item?.apiConfig?.modelId || '').trim();
            if (modelKey) {
                const matched = apiConfigs.find(cfg =>
                    cfg?.id === modelKey
                    || cfg?.modelName === modelKey
                    || cfg?.displayName === modelKey
                );
                providerKey = String(matched?.provider || '').trim();
            }
        }
        if (!providerKey) return false;
        if (providers[providerKey]?.useProxy) return true;
        const normalizedKey = providerKey.toLowerCase();
        if (normalizedKey && providers[normalizedKey]?.useProxy) return true;
        return false;
    }, [providers, apiConfigs]);

    const historyLocalCacheMap = useMemo(() => {
        const map = new Map();
        history.forEach((item) => {
            if (!item) return;
            if (item.localCacheMap) {
                Object.entries(item.localCacheMap).forEach(([sourceUrl, cacheUrl]) => {
                    if (sourceUrl && cacheUrl) map.set(sourceUrl, cacheUrl);
                });
            }
            if (item.localCacheUrl) {
                const primaryUrls = [item.url, item.originalUrl, item.mjOriginalUrl].filter(Boolean);
                primaryUrls.forEach((url) => map.set(url, item.localCacheUrl));
                if ((!item.localCacheMap || Object.keys(item.localCacheMap).length === 0)) {
                    if (Array.isArray(item.mjImages) && item.mjImages.length === 1) {
                        map.set(item.mjImages[0], item.localCacheUrl);
                    }
                    if (Array.isArray(item.output_images) && item.output_images.length === 1) {
                        map.set(item.output_images[0], item.localCacheUrl);
                    }
                }
            }
        });
        return map;
    }, [history]);

    const normalizeLocalCacheLookupKey = useCallback((value) => {
        if (!value || typeof value !== 'string') return '';
        const trimmed = value.trim();
        if (!trimmed) return '';
        const noHash = trimmed.split('#')[0];
        const noQuery = noHash.split('?')[0];
        try {
            const parsed = new URL(noQuery);
            const host = String(parsed.hostname || '').toLowerCase();
            let pathname = parsed.pathname || '';
            try {
                pathname = decodeURIComponent(pathname);
            } catch (e) { }
            if ((host === '127.0.0.1' || host === 'localhost') && pathname.startsWith('/file/')) {
                return pathname.toLowerCase();
            }
            return `${parsed.origin}${pathname}`.toLowerCase();
        } catch (e) {
            return noQuery.toLowerCase();
        }
    }, []);

    const localCacheSourceMap = useMemo(() => {
        const map = new Map();
        const addPair = (cacheUrl, sourceUrl) => {
            if (!cacheUrl || !sourceUrl) return;
            const normalizedSource = sanitizeHistoryUrlValue(sourceUrl, '', { allowLocalCache: false }) || sourceUrl;
            if (!normalizedSource || isLocalCacheUrl(normalizedSource)) return;
            const rawCache = String(cacheUrl);
            map.set(rawCache, normalizedSource);
            const strippedCache = rawCache.split('#')[0].split('?')[0];
            if (strippedCache && strippedCache !== rawCache) {
                map.set(strippedCache, normalizedSource);
            }
            const key = normalizeLocalCacheLookupKey(rawCache);
            if (key) {
                map.set(key, normalizedSource);
            }
        };
        history.forEach((item) => {
            if (!item) return;
            if (item.localCacheMap && typeof item.localCacheMap === 'object') {
                Object.entries(item.localCacheMap).forEach(([sourceUrl, cacheUrl]) => {
                    addPair(cacheUrl, sourceUrl);
                });
            }
            if (item.localCacheUrl) {
                const fallback = getHistoryFallbackUrl(item, { allowLocalCache: false });
                if (fallback) addPair(item.localCacheUrl, fallback);
            }
        });
        return map;
    }, [history, getHistoryFallbackUrl, sanitizeHistoryUrlValue, isLocalCacheUrl, normalizeLocalCacheLookupKey]);

    const resolveLocalCacheSourceUrl = useCallback((value) => {
        if (!value || typeof value !== 'string') return '';
        if (!isLocalCacheUrl(value)) return value;
        const direct = localCacheSourceMap.get(value);
        if (direct && !isLocalCacheUrl(direct)) return direct;
        const stripped = value.split('#')[0].split('?')[0];
        if (stripped) {
            const byStripped = localCacheSourceMap.get(stripped);
            if (byStripped && !isLocalCacheUrl(byStripped)) return byStripped;
        }
        const key = normalizeLocalCacheLookupKey(value);
        if (key) {
            const byKey = localCacheSourceMap.get(key);
            if (byKey && !isLocalCacheUrl(byKey)) return byKey;
        }
        return '';
    }, [localCacheSourceMap, normalizeLocalCacheLookupKey, isLocalCacheUrl]);

    const isHistoryCacheMappingValid = useCallback((item, sourceUrl, cacheUrl) => {
        if (!cacheUrl) return false;
        if (!isLocalCacheUrl(cacheUrl)) return true;
        if (!sourceUrl || isLocalCacheUrl(sourceUrl)) return true;
        const safeItemId = sanitizeCacheId(item?.id || '');
        if (!safeItemId) return true;
        const multiImages = Array.isArray(item?.mjImages) && item.mjImages.length > 1
            ? item.mjImages
            : (Array.isArray(item?.output_images) && item.output_images.length > 1 ? item.output_images : null);
        const sourceIndex = multiImages ? multiImages.indexOf(sourceUrl) : -1;
        const fallbackSeed = sourceIndex >= 0 ? `${safeItemId}-${sourceIndex}` : safeItemId;
        const expectedCacheIdRaw = getCacheIdFromUrl(sourceUrl, fallbackSeed);
        const expectedCacheId = sanitizeCacheId(expectedCacheIdRaw) || expectedCacheIdRaw;
        if (!expectedCacheId) return true;
        return String(cacheUrl).includes(expectedCacheId);
    }, [isLocalCacheUrl, sanitizeCacheId, getCacheIdFromUrl]);

    const resolveLocalCacheTargetUrl = useCallback((sourceUrl, options = {}) => {
        if (!sourceUrl || typeof sourceUrl !== 'string') return '';
        if (!localCacheActive) return '';
        if (isLocalCacheUrl(sourceUrl)) {
            return isLocalCacheUrlAvailable(sourceUrl) ? sourceUrl : '';
        }
        const historyItem = options.historyItem || null;
        if (historyItem?.localCacheMap?.[sourceUrl]) {
            const fromItem = historyItem.localCacheMap[sourceUrl];
            if (fromItem
                && isHistoryCacheMappingValid(historyItem, sourceUrl, fromItem)
                && isLocalCacheUrlAvailable(fromItem)) {
                return fromItem;
            }
        }
        if (historyLocalCacheMap && historyLocalCacheMap.has(sourceUrl)) {
            const fromGlobal = historyLocalCacheMap.get(sourceUrl);
            const valid = historyItem
                ? isHistoryCacheMappingValid(historyItem, sourceUrl, fromGlobal)
                : true;
            if (fromGlobal && valid && isLocalCacheUrlAvailable(fromGlobal)) {
                return fromGlobal;
            }
        }
        return '';
    }, [localCacheActive, isLocalCacheUrl, isLocalCacheUrlAvailable, historyLocalCacheMap, isHistoryCacheMappingValid]);

    const applyMediaCachePolicy = useCallback((value, options = {}) => {
        if (!value || typeof value !== 'string') return value;
        if (LocalImageManager.isImageId(value)) return value;
        if (value.startsWith('asset://')) return value;
        if (value.startsWith('blob:')) return value;

        const historyItem = options.historyItem || null;
        const normalized = sanitizeHistoryUrlValue(value, '', { allowLocalCache: true }) || '';
        if (!normalized) return '';

        if (!localCacheActive) {
            if (isLocalCacheUrl(normalized)) {
                const fallback = resolveLocalCacheSourceUrl(normalized);
                if (!fallback) return '';
                const source = sanitizeHistoryUrlValue(fallback, '', { allowLocalCache: false }) || '';
                return normalizeHistoryUrl(source || '');
            }
            return normalizeHistoryUrl(sanitizeHistoryUrlValue(normalized, '', { allowLocalCache: false }) || '');
        }

        let next = normalized;
        if (isLocalCacheUrl(next)) {
            if (isLocalCacheUrlAvailable(next)) {
                return normalizeHistoryUrl(next);
            }
            const fallback = resolveLocalCacheSourceUrl(next);
            next = fallback || next;
        }

        const localTarget = resolveLocalCacheTargetUrl(next, { historyItem });
        if (localTarget) return normalizeHistoryUrl(localTarget);
        if (isComfyLocalUrl(next)) {
            const base = (localServerUrl || '').trim().replace(/\/+$/, '');
            if (base) return `${base}/proxy?url=${encodeURIComponent(next)}`;
        }
        return normalizeHistoryUrl(sanitizeHistoryUrlValue(next, '', { allowLocalCache: true }) || '');
    }, [localCacheActive, isLocalCacheUrl, isLocalCacheUrlAvailable, resolveLocalCacheSourceUrl, sanitizeHistoryUrlValue, resolveLocalCacheTargetUrl, isComfyLocalUrl, localServerUrl]);

    // 统一资产解析渠道 X：所有图片/视频消费方统一调用此函数获取最终 URL
    const resolveAssetChannelUrl = useCallback((value, options = {}) => {
        return applyMediaCachePolicy(value, options);
    }, [applyMediaCachePolicy]);

    const historyUrlProxyMap = useMemo(() => {
        const map = new Map();
        history.forEach((item) => {
            if (!item) return;
            const useProxy = getItemProxyPreference(item);
            const urls = [
                item.url,
                item.originalUrl,
                item.mjOriginalUrl,
                ...(Array.isArray(item.mjImages) ? item.mjImages : []),
                ...(Array.isArray(item.output_images) ? item.output_images : [])
            ].filter(Boolean);
            urls.forEach((url) => {
                if (typeof url !== 'string') return;
                if (!/^https?:/i.test(url)) return;
                map.set(url, useProxy);
            });
        });
        return map;
    }, [history, getItemProxyPreference]);

    const getProxyPreferenceForUrl = useCallback((url, fallback = false) => {
        if (!url) return !!fallback;
        const raw = String(url);
        if (raw.startsWith('data:') || raw.startsWith('blob:')) return false;
        const base = (localServerUrl || '').trim();
        if (base && raw.startsWith(base)) return false;
        if (localCacheActive && isComfyLocalUrl(raw)) return true;
        if (localCacheActive && historyLocalCacheMap.has(raw)) {
            const cached = historyLocalCacheMap.get(raw);
            if (cached && isLocalCacheUrlAvailable(cached)) return false;
        }
        if (historyUrlProxyMap.has(raw)) return !!historyUrlProxyMap.get(raw);
        return !!fallback;
    }, [historyUrlProxyMap, historyLocalCacheMap, localServerUrl, localCacheActive, isLocalCacheUrlAvailable, isComfyLocalUrl]);

    useEffect(() => {
        const nextPath = {
            savePath: localServerConfig.savePath || '',
            imageSavePath: localServerConfig.imageSavePath || '',
            videoSavePath: localServerConfig.videoSavePath || ''
        };
        const prevPath = localCachePathRef.current;
        const changed = prevPath.savePath !== nextPath.savePath
            || prevPath.imageSavePath !== nextPath.imageSavePath
            || prevPath.videoSavePath !== nextPath.videoSavePath;
        localCachePathRef.current = nextPath;
        if (!localCacheEnabled || !changed) return;
        if (!prevPath.savePath && !prevPath.imageSavePath && !prevPath.videoSavePath) return;
        refreshLocalCache({ silent: true, reset: cacheRedownloadOnEnable });
    }, [localServerConfig.savePath, localServerConfig.imageSavePath, localServerConfig.videoSavePath, localCacheEnabled, refreshLocalCache, cacheRedownloadOnEnable]);

    const handleHistoryCacheMissing = useCallback((itemId, failedUrl) => {
        if (!itemId) return;
        sourceReferenceResolveCacheRef.current.clear();
        if (failedUrl) {
            for (const [sourceUrl, cacheUrl] of cachedHistoryUrlRef.current.entries()) {
                if (cacheUrl === failedUrl) {
                    cachedHistoryUrlRef.current.delete(sourceUrl);
                }
            }
            const relPath = extractLocalCacheRelPath(failedUrl);
            if (relPath) {
                localCacheFileIndexRef.current.delete(relPath);
                setLocalCacheIndexTick((prev) => prev + 1);
            }
        }
        setHistory(prev => prev.map(item => {
            if (item.id !== itemId) return item;
            if (!failedUrl) {
                return { ...item, localCacheUrl: null, localFilePath: null, localCacheMap: null };
            }
            let nextMap = item.localCacheMap ? { ...item.localCacheMap } : null;
            if (nextMap) {
                Object.entries(nextMap).forEach(([sourceUrl, cacheUrl]) => {
                    if (cacheUrl === failedUrl || sourceUrl === failedUrl) {
                        delete nextMap[sourceUrl];
                    }
                });
            }
            const nextMapKeys = nextMap ? Object.keys(nextMap) : [];
            const nextLocalCacheUrl = item.localCacheUrl === failedUrl
                ? (nextMapKeys.length > 0 ? nextMap[nextMapKeys[0]] : null)
                : item.localCacheUrl;
            return {
                ...item,
                localCacheUrl: nextLocalCacheUrl || null,
                localFilePath: nextLocalCacheUrl ? item.localFilePath : null,
                localCacheMap: nextMapKeys.length > 0 ? nextMap : null
            };
        }));
    }, []);

    const normalizeHistoryUrl = (value) => {
        if (!value || typeof value !== 'string') return value;
        if (value.startsWith('asset://')) {
            const resolved = resolveAssetBundleUrl(value);
            if (resolved && resolved !== value) return resolved;
            const fallback = getAssetFallbackUrl(value);
            return fallback || value;
        }
        if (value.startsWith('data:')) return normalizeDataUrl(value);
        return value;
    };

    const resolveHistoryUrl = useCallback((item, specificUrl = null) => {
        if (!item) return '';
        if (specificUrl) {
            if (localCacheActive && historyLocalCacheMap && historyLocalCacheMap.has(specificUrl)) {
                const cached = historyLocalCacheMap.get(specificUrl);
                if (cached && isHistoryCacheMappingValid(item, specificUrl, cached) && isLocalCacheUrlAvailable(cached)) return cached;
            }
            if (localCacheActive && item.localCacheMap && item.localCacheMap[specificUrl]) {
                const cached = item.localCacheMap[specificUrl];
                if (cached && isHistoryCacheMappingValid(item, specificUrl, cached) && isLocalCacheUrlAvailable(cached)) return cached;
            }
            const normalized = sanitizeHistoryUrlValue(specificUrl, '', { allowLocalCache: localCacheActive });
            if (!normalized || normalized.startsWith('blob:')) {
                const fallback = sanitizeHistoryUrlValue(
                    getHistoryFallbackUrl(item, { allowLocalCache: localCacheActive }),
                    '',
                    { allowLocalCache: localCacheActive }
                );
                return normalizeHistoryUrl(fallback || '');
            }
            if (!localCacheActive && normalized.startsWith('data:')) {
                const fallback = sanitizeHistoryUrlValue(
                    getHistoryFallbackUrl(item, { allowLocalCache: false }),
                    '',
                    { allowLocalCache: false }
                );
                return normalizeHistoryUrl(fallback || '');
            }
            if (!localCacheActive && isLocalCacheUrl(normalized)) {
                const fallback = sanitizeHistoryUrlValue(
                    getHistoryFallbackUrl(item, { allowLocalCache: false }),
                    '',
                    { allowLocalCache: false }
                );
                return normalizeHistoryUrl(fallback || '');
            }
            if (localCacheActive && isComfyLocalUrl(normalized)) {
                const base = (localServerUrl || '').trim().replace(/\/+$/, '');
                if (base) return `${base}/proxy?url=${encodeURIComponent(normalized)}`;
            }
            return normalizeHistoryUrl(normalized);
        }
        const cacheUrl = localCacheActive
            ? (item.localCacheUrl || (item.localCacheMap ? Object.values(item.localCacheMap)[0] : null))
            : null;
        if (cacheUrl && isLocalCacheUrlAvailable(cacheUrl)) {
            return normalizeHistoryUrl(cacheUrl);
        }
        const fallback = sanitizeHistoryUrlValue(
            getHistoryFallbackUrl(item, { allowLocalCache: localCacheActive }),
            '',
            { allowLocalCache: localCacheActive }
        );
        return normalizeHistoryUrl(fallback || '');
    }, [localCacheActive, historyLocalCacheMap, isLocalCacheUrlAvailable, localCacheIndexTick, sanitizeHistoryUrlValue, getHistoryFallbackUrl, isLocalCacheUrl, isComfyLocalUrl, localServerUrl, isHistoryCacheMappingValid]);

    const resolveHistoryPreviewUrl = useCallback((item, specificUrl = null) => {
        if (!item) return '';
        if (specificUrl) {
            if (localCacheActive && historyLocalCacheMap && historyLocalCacheMap.has(specificUrl)) {
                const cached = historyLocalCacheMap.get(specificUrl);
                if (cached && isHistoryCacheMappingValid(item, specificUrl, cached) && isLocalCacheUrlAvailable(cached)) return cached;
            }
            if (localCacheActive && item.localCacheMap && item.localCacheMap[specificUrl]) {
                const cached = item.localCacheMap[specificUrl];
                if (cached && isHistoryCacheMappingValid(item, specificUrl, cached) && isLocalCacheUrlAvailable(cached)) return cached;
            }
            if (performanceMode !== 'off' && item.mjImages && item.mjThumbnails) {
                const idx = item.mjImages.indexOf(specificUrl);
                if (idx >= 0 && item.mjThumbnails[idx]) {
                    return item.mjThumbnails[idx];
                }
            }
            const normalized = sanitizeHistoryUrlValue(specificUrl, '', { allowLocalCache: localCacheActive });
            if (!normalized || normalized.startsWith('blob:')) {
                const fallback = getHistoryFallbackUrl(item, { allowLocalCache: localCacheActive })
                    || sanitizeHistoryUrlValue(item.thumbnailUrl, '', { allowLocalCache: localCacheActive });
                return normalizeHistoryUrl(sanitizeHistoryUrlValue(fallback || '', '', { allowLocalCache: localCacheActive }) || '');
            }
            if (!localCacheActive && normalized.startsWith('data:')) {
                const fallback = getHistoryFallbackUrl(item, { allowLocalCache: false })
                    || sanitizeHistoryUrlValue(item.thumbnailUrl, '', { allowLocalCache: false });
                return normalizeHistoryUrl(sanitizeHistoryUrlValue(fallback || '', '', { allowLocalCache: false }) || '');
            }
            if (!localCacheActive && isLocalCacheUrl(normalized)) {
                const fallback = getHistoryFallbackUrl(item, { allowLocalCache: false })
                    || sanitizeHistoryUrlValue(item.thumbnailUrl, '', { allowLocalCache: false });
                return normalizeHistoryUrl(sanitizeHistoryUrlValue(fallback || '', '', { allowLocalCache: false }) || '');
            }
            if (localCacheActive && isComfyLocalUrl(normalized)) {
                const base = (localServerUrl || '').trim().replace(/\/+$/, '');
                if (base) return `${base}/proxy?url=${encodeURIComponent(normalized)}`;
            }
            return normalizeHistoryUrl(normalized);
        }
        const cacheUrl = localCacheActive
            ? (item.localCacheUrl || (item.localCacheMap ? Object.values(item.localCacheMap)[0] : null))
            : null;
        if (performanceMode === 'off') {
            if (cacheUrl && isLocalCacheUrlAvailable(cacheUrl)) {
                return normalizeHistoryUrl(cacheUrl);
            }
            const fallback = getHistoryFallbackUrl(item, { allowLocalCache: localCacheActive });
            return normalizeHistoryUrl(fallback || '');
        }
        if (cacheUrl && isLocalCacheUrlAvailable(cacheUrl)) {
            return normalizeHistoryUrl(cacheUrl);
        }
        const fallback = sanitizeHistoryUrlValue(item.thumbnailUrl, '', { allowLocalCache: localCacheActive })
            || getHistoryFallbackUrl(item, { allowLocalCache: localCacheActive });
        return normalizeHistoryUrl(sanitizeHistoryUrlValue(fallback || '', '', { allowLocalCache: localCacheActive }) || '');
    }, [localCacheActive, performanceMode, historyLocalCacheMap, isLocalCacheUrlAvailable, localCacheIndexTick, sanitizeHistoryUrlValue, getHistoryFallbackUrl, isLocalCacheUrl, isComfyLocalUrl, localServerUrl, isHistoryCacheMappingValid]);

    const getHistoryMultiImages = useCallback((item) => {
        if (!item) return null;
        if (Array.isArray(item.mjImages) && item.mjImages.length > 1) return item.mjImages;
        if (Array.isArray(item.output_images) && item.output_images.length > 1) return item.output_images;
        return null;
    }, []);
    const normalizeHistoryNavComparableUrl = useCallback((value) => {
        if (!value || typeof value !== 'string') return '';
        const unwrapProxyUrl = (raw) => {
            try {
                const parsed = new URL(String(raw));
                const isLocalHost = parsed.hostname === '127.0.0.1' || parsed.hostname === 'localhost';
                if (isLocalHost && parsed.pathname === '/proxy') {
                    const target = parsed.searchParams.get('url');
                    if (target) return target;
                }
            } catch (e) { }
            return raw;
        };
        const normalized = sanitizeHistoryUrlValue(unwrapProxyUrl(value), '', { allowLocalCache: true }) || '';
        if (!normalized) return '';
        const mapped = isLocalCacheUrl(normalized) ? (resolveLocalCacheSourceUrl(normalized) || normalized) : normalized;
        try {
            const parsed = new URL(mapped);
            const cleanPath = parsed.pathname || '';
            const cleanSearch = parsed.search || '';
            return `${parsed.origin}${cleanPath}${cleanSearch}`;
        } catch (e) {
            return mapped;
        }
    }, [sanitizeHistoryUrlValue, isLocalCacheUrl, resolveLocalCacheSourceUrl]);

    const getHistoryNavPreview = useCallback((item, options = {}) => {
        if (!item) return { url: '', index: 0 };
        const multiImages = getHistoryMultiImages(item);
        const maxIndex = multiImages ? multiImages.length - 1 : 0;
        const forceFirstImage = !!options.forceFirstImage;
        const rawIndex = forceFirstImage
            ? 0
            : (Number.isInteger(item.selectedMjImageIndex) ? item.selectedMjImageIndex : 0);
        const index = Math.max(0, Math.min(rawIndex, maxIndex));
        const selectedUrl = multiImages ? multiImages[index] : null;
        const resolvedUrl = selectedUrl
            ? resolveHistoryUrl(item, selectedUrl)
            : resolveHistoryUrl(item);
        const fallbackUrl = selectedUrl || item.url || item.originalUrl || item.mjOriginalUrl || '';
        return { url: resolvedUrl || fallbackUrl || '', index };
    }, [getHistoryMultiImages, resolveHistoryUrl]);

    const rebuildHistoryThumbnail = useCallback(async (item, options = {}) => {
        if (!item) return;
        const rawUrls = item.mjImages && item.mjImages.length > 0
            ? item.mjImages
            : [item.url || item.originalUrl || item.mjOriginalUrl].filter(Boolean);
        if (rawUrls.length === 0) {
            showToast('没有可用的图片地址', 'warning');
            return;
        }
        const baseProxy = getItemProxyPreference(item);
        const quality = performanceMode === 'ultra' ? 'ultra' : 'normal';
        rawUrls.forEach(url => {
            if (url) thumbnailCacheRef.current.delete(url);
            const resolved = resolveHistoryUrl(item, url);
            if (resolved) thumbnailCacheRef.current.delete(resolved);
        });

        if (rawUrls.length > 1) {
            const mjThumbnails = await Promise.all(rawUrls.map(async (url) => {
                const resolved = resolveHistoryUrl(item, url);
                if (!resolved) return null;
                const useProxy = getProxyPreferenceForUrl(resolved, baseProxy);
                return await generateThumbnail(resolved, quality, { useProxy });
            }));
            setHistory(prev => prev.map(h => h.id === item.id ? { ...h, mjThumbnails } : h));
        } else {
            const resolved = resolveHistoryUrl(item, rawUrls[0]);
            const useProxy = resolved ? getProxyPreferenceForUrl(resolved, baseProxy) : false;
            const thumbnail = resolved ? await generateThumbnail(resolved, quality, { useProxy }) : null;
            setHistory(prev => prev.map(h => h.id === item.id ? { ...h, thumbnailUrl: thumbnail || null } : h));
        }
        if (!options.silent) {
            showToast('缩略图已更新', 'success');
        }
    }, [generateThumbnail, performanceMode, resolveHistoryUrl, showToast, getItemProxyPreference, getProxyPreferenceForUrl]);

    const rebuildAllHistoryThumbnails = useCallback(async () => {
        const imageItems = history.filter(item =>
            item.type === 'image' && (
                (item.mjImages && item.mjImages.length > 0) ||
                item.url || item.originalUrl || item.mjOriginalUrl
            )
        );
        if (imageItems.length === 0) {
            showToast('没有可重建的图片', 'warning');
            return;
        }
        showToast(`开始重建 ${imageItems.length} 张缩略图`, 'success');
        for (const item of imageItems) {
            await rebuildHistoryThumbnail(item, { silent: true });
        }
        showToast('历史缩略图已全部重建', 'success');
    }, [history, rebuildHistoryThumbnail, showToast]);

    const pickLocalCachePath = useCallback(async (fieldKey, patchKey) => {
        const baseUrl = (localServerUrl || '').replace(/\/+$/, '');
        if (baseUrl) {
            try {
                const res = await fetch(`${baseUrl}/pick-path`);
                if (res.ok) {
                    const data = await res.json();
                    if (data?.path) {
                        const normalized = normalizeLocalPath(data.path);
                        const ok = await updateLocalCacheServerConfig({ [patchKey]: normalized }, { silent: true });
                        if (ok) {
                            showToast('路径已更新', 'success', 2000);
                            refreshLocalCache({ silent: true });
                            return;
                        }
                        showToast('路径更新失败，请确认允许目录', 'error', 2000);
                        return;
                    }
                }
            } catch (e) {
                // fallback to browser picker
            }
        }

        const input = document.createElement('input');
        input.type = 'file';
        input.setAttribute('webkitdirectory', '');
        input.setAttribute('directory', '');
        input.multiple = true;
        input.onchange = async () => {
            const file = input.files && input.files[0];
            if (!file) return;
            const rawPath = file.path || '';
            if (!rawPath) {
                showToast('浏览器无法读取本地路径，请手动输入', 'warning', 3000);
                return;
            }
            const folderPath = rawPath.replace(/[\\/][^\\/]+$/, '');
            const normalized = normalizeLocalPath(folderPath);
            const ok = await updateLocalCacheServerConfig({ [patchKey]: normalized }, { silent: true });
            if (ok) {
                showToast('路径已更新', 'success', 2000);
                refreshLocalCache({ silent: true });
            } else {
                showToast('路径更新失败，请确认允许目录', 'error', 2000);
            }
        };
        input.click();
    }, [localServerUrl, normalizeLocalPath, updateLocalCacheServerConfig, showToast, refreshLocalCache]);

    // V2.6.1 Feature: 性能模式缩略图生成
    useEffect(() => {
        if (performanceMode === 'off') return;

        const generateThumbnailsForHistory = async () => {
            const quality = performanceMode === 'ultra' ? 'ultra' : 'normal';
            const itemsNeedThumbnail = history.filter(item =>
                item.status === 'completed' &&
                item.type === 'image' &&
                (item.url || item.originalUrl || item.mjOriginalUrl) &&
                !item.thumbnailUrl
            );

            const batch = itemsNeedThumbnail.slice(0, 5);
            if (batch.length === 0) return;

            for (const item of batch) {
                try {
                    const sourceUrl = item.url || item.originalUrl || item.mjOriginalUrl;
                    if (!sourceUrl) continue;
                    let thumbnail = thumbnailCacheRef.current.get(sourceUrl);
                    if (!thumbnail) {
                        const useProxy = getProxyPreferenceForUrl(sourceUrl, false);
                        thumbnail = await generateThumbnail(sourceUrl, quality, { useProxy });
                        if (thumbnail) thumbnailCacheRef.current.set(sourceUrl, thumbnail);
                    }

                    let mjThumbnails = null;
                    if (item.mjImages && item.mjImages.length > 0) {
                        mjThumbnails = await Promise.all(item.mjImages.map(async (url) => {
                            if (!url) return null;
                            const cached = thumbnailCacheRef.current.get(url);
                            if (cached) return cached;
                            const useProxy = getProxyPreferenceForUrl(url, false);
                            const thumb = await generateThumbnail(url, quality, { useProxy });
                            if (thumb) thumbnailCacheRef.current.set(url, thumb);
                            return thumb;
                        }));
                    }

                    if (thumbnail || mjThumbnails) {
                        setHistory(prev => prev.map(h =>
                            h.id === item.id
                                ? { ...h, thumbnailUrl: thumbnail || h.thumbnailUrl, mjThumbnails: mjThumbnails || h.mjThumbnails }
                                : h
                        ));
                    }
                } catch (e) {
                    console.warn('[缩略图] 生成失败:', e);
                }
            }
        };

        const timer = setTimeout(generateThumbnailsForHistory, 100);
        return () => clearTimeout(timer);
    }, [performanceMode, history, generateThumbnail]);

    // V2.6.1 Feature: 角色库本地缓存
    useEffect(() => {
        if (!localCacheActive) return;

        const cacheCharacterImages = async () => {
            for (const char of characterLibrary) {
                if (char.localCacheUrl) continue;
                if (!char.profile_picture_url || char.profile_picture_url.startsWith('blob:')) continue;
                try {
                    const result = await saveImageToLocalCache(char.id, char.profile_picture_url, 'characters');
                    if (result) {
                        setCharacterLibrary(prev => prev.map(c =>
                            c.id === char.id ? { ...c, localCacheUrl: result.url, localFilePath: result.path } : c
                        ));
                    }
                } catch (e) {
                    console.warn('[角色库缓存] 缓存失败:', char.username, e);
                }
            }
        };

        const timer = setTimeout(cacheCharacterImages, 2000);
        return () => clearTimeout(timer);
    }, [characterLibrary, localCacheActive, saveImageToLocalCache]);

    // V2.6.1 Feature: 历史记录本地缓存（图片）
    useEffect(() => {
        if (!localCacheActive) return;

        const cacheHistoryImages = async () => {
            if (cacheImageRunRef.current) return;
            cacheImageRunRef.current = true;
            const summary = {
                total: history.length,
                processed: 0,
                skippedStatus: 0,
                skippedVideo: 0,
                skippedEmpty: 0,
                saved: 0,
                failed: 0,
                proxy: 0,
                direct: 0
            };
            try {
                const preferHistoryPath = !!(localServerConfig.imageSavePath || localServerConfig.videoSavePath);
                const expectedSegment = preferHistoryPath ? '/file/history/' : '/file/.tapnow_cache/history/';
                const localBase = (localServerUrl || '').trim().replace(/\/+$/, '');
                if (!localCacheIndexReadyRef.current) {
                    await refreshLocalCacheFileIndex({ silent: true });
                }

                for (const item of history) {
                const status = item?.status;
                const isCacheableStatus = isCompletedLikeStatus(status);
                if (!isCacheableStatus) { summary.skippedStatus++; continue; }
                const candidateUrl = item?.url || item?.originalUrl || item?.mjOriginalUrl || '';
                const isVideoItem = item?.type === 'video' || isVideoUrl(candidateUrl);
                if (isVideoItem) { summary.skippedVideo++; continue; }
                const baseProxy = getItemProxyPreference(item);
                let localCacheUrl = item.localCacheUrl || null;
                let localFilePath = item.localFilePath || null;
                let cacheMap = item.localCacheMap ? { ...item.localCacheMap } : {};
                let cacheMapUpdated = false;

                const firstCacheUrl = localCacheUrl || (Object.keys(cacheMap).length > 0 ? Object.values(cacheMap)[0] : null);
                if (firstCacheUrl) {
                    if (localCacheIndexReadyRef.current && !isLocalCacheUrlAvailable(firstCacheUrl)) {
                        if (cacheMap && Object.keys(cacheMap).length > 0) {
                            Object.entries(cacheMap).forEach(([sourceUrl, cacheUrl]) => {
                                if (cachedHistoryUrlRef.current.get(sourceUrl) === cacheUrl) {
                                    cachedHistoryUrlRef.current.delete(sourceUrl);
                                }
                            });
                        }
                        localCacheUrl = null;
                        localFilePath = null;
                        cacheMap = {};
                        cacheMapUpdated = true;
                        triedCacheIdsRef.current.delete(item.id);
                    }
                }

                const rawImageUrls = item.mjImages && item.mjImages.length > 0
                    ? item.mjImages
                    : (item.output_images && item.output_images.length > 0
                        ? item.output_images
                        : [item.url || item.originalUrl || item.mjOriginalUrl].filter(Boolean));
                const imageUrls = [...new Set(rawImageUrls.filter(Boolean))];

                if (imageUrls.length === 0) { summary.skippedEmpty++; continue; }
                const isMultiImage = imageUrls.length > 1;
                if (isMultiImage) {
                    const mappedCacheValues = imageUrls.map((url) => cacheMap[url]).filter(Boolean);
                    const uniqueMappedCacheValues = new Set(mappedCacheValues);
                    // 修复：多图缓存若全部映射到同一文件，会导致预览/拖拽错图（如 4 号位始终打开 0 号位）
                    if (mappedCacheValues.length >= imageUrls.length && uniqueMappedCacheValues.size <= 1) {
                        cacheMap = {};
                        cacheMapUpdated = true;
                        localCacheUrl = null;
                        localFilePath = null;
                        triedCacheIdsRef.current.delete(item.id);
                    }
                }

                const cachedCount = imageUrls.reduce((count, url) => (cacheMap[url] ? count + 1 : count), 0);

                if (triedCacheIdsRef.current.has(item.id) && cachedCount >= imageUrls.length) continue;
                triedCacheIdsRef.current.add(item.id);
                summary.processed++;

                if (!cacheRedownloadOnEnable && localCacheUrl) {
                    if (imageUrls.length <= 1) {
                        let updated = false;
                        imageUrls.forEach((url) => {
                            if (!url) return;
                            if (!cacheMap[url]) {
                                cacheMap[url] = localCacheUrl;
                                updated = true;
                            }
                        });
                        if (updated || localCacheUrl !== item.localCacheUrl) {
                            const nextCacheMap = Object.keys(cacheMap).length > 0 ? cacheMap : null;
                            setHistory(prev => prev.map(h =>
                                h.id === item.id ? { ...h, localCacheUrl: localCacheUrl || null, localFilePath: localFilePath || null, localCacheMap: nextCacheMap } : h
                            ));
                        }
                        continue;
                    }
                    const mappedCount = imageUrls.reduce((count, url) => (cacheMap[url] ? count + 1 : count), 0);
                    if (mappedCount >= imageUrls.length) {
                        continue;
                    }
                }

                for (let idx = 0; idx < imageUrls.length; idx++) {
                    const imageUrl = imageUrls[idx];
                    if (!imageUrl || imageUrl.startsWith('blob:') || imageUrl.includes('...')) continue;

                    const cacheSeed = imageUrls.length > 1 ? `${item.id}-${idx}` : `${item.id}`;
                    const cacheId = getCacheIdFromUrl(imageUrl, cacheSeed);
                    const expectedId = sanitizeCacheId(cacheId) || cacheId;

                    if (cacheMap[imageUrl] && expectedId && !String(cacheMap[imageUrl]).includes(expectedId)) {
                        delete cacheMap[imageUrl];
                        cacheMapUpdated = true;
                    }

                    if (!cacheRedownloadOnEnable) {
                        // 如果全局缓存映射已存在，直接绑定并跳过远程拉取
                        const globalCached = historyLocalCacheMap && historyLocalCacheMap.get(imageUrl);
                        if (globalCached && isHistoryCacheMappingValid(item, imageUrl, globalCached)) {
                            if (!cacheMap[imageUrl]) {
                                cacheMap[imageUrl] = globalCached;
                                cacheMapUpdated = true;
                            }
                            if (!localCacheUrl) {
                                localCacheUrl = globalCached;
                            }
                            continue;
                        }

                        // 尝试在当前本地缓存目录中按 cacheId 直接命中已有文件，避免重新拉取远端
                        if (localBase && expectedId) {
                            const matchedLocal = getLocalCacheCandidateUrl(expectedId, ['.jpg', '.png', '.webp'], preferHistoryPath);
                            if (matchedLocal) {
                                if (!cacheMap[imageUrl]) {
                                    cacheMap[imageUrl] = matchedLocal;
                                    cacheMapUpdated = true;
                                }
                                if (!localCacheUrl) {
                                    localCacheUrl = matchedLocal;
                                }
                                continue;
                            }
                        }

                        if (cachedHistoryUrlRef.current.has(imageUrl)) {
                            const cachedUrl = cachedHistoryUrlRef.current.get(imageUrl);
                            if (cachedUrl && (expectedId && !String(cachedUrl).includes(expectedId))) {
                                cachedHistoryUrlRef.current.delete(imageUrl);
                            } else {
                                if (cachedUrl && !cacheMap[imageUrl]) {
                                    cacheMap[imageUrl] = cachedUrl;
                                    cacheMapUpdated = true;
                                }
                                if (!localCacheUrl && cachedUrl) {
                                    localCacheUrl = cachedUrl;
                                }
                                continue;
                            }
                        }
                    }

                    try {
                        const useProxy = getProxyPreferenceForUrl(imageUrl, baseProxy);
                        if (useProxy) summary.proxy++; else summary.direct++;
                        const result = await saveImageToLocalCache(cacheId, imageUrl, 'history', { forceId: true, useProxy });
                        if (result) {
                            cachedHistoryUrlRef.current.set(imageUrl, result.url);
                            cacheMap[imageUrl] = result.url;
                            cacheMapUpdated = true;
                            if (!localCacheUrl) {
                                localCacheUrl = result.url;
                                localFilePath = result.path;
                            }
                            summary.saved++;
                        } else {
                            summary.failed++;
                        }
                    } catch (e) {
                        console.warn('[历史缓存] 缓存失败:', item.id, e);
                        summary.failed++;
                    }
                }

                const primaryUrl = imageUrls[0];
                if (primaryUrl) {
                    const primaryCacheUrl = cacheMap[primaryUrl] || null;
                    if (primaryCacheUrl) {
                        localCacheUrl = primaryCacheUrl;
                    } else {
                        localCacheUrl = null;
                        localFilePath = null;
                    }
                }

                    if (cacheMapUpdated || localCacheUrl !== item.localCacheUrl) {
                        const nextCacheMap = Object.keys(cacheMap).length > 0 ? cacheMap : null;
                        setHistory(prev => prev.map(h =>
                            h.id === item.id ? { ...h, localCacheUrl: localCacheUrl || null, localFilePath: localFilePath || null, localCacheMap: nextCacheMap } : h
                        ));
                    }
                }
            } finally {
                cacheImageRunRef.current = false;
            }
        };

        cacheHistoryImages();
        const timer = setTimeout(cacheHistoryImages, 3000);
        return () => clearTimeout(timer);
    }, [history, localCacheActive, localServerConfig.imageSavePath, localServerConfig.videoSavePath, localServerUrl, saveImageToLocalCache, sanitizeCacheId, getCacheIdFromUrl, getItemProxyPreference, getProxyPreferenceForUrl, cacheRefreshTick, historyLocalCacheMap, cacheRedownloadOnEnable, refreshLocalCacheFileIndex, getLocalCacheCandidateUrl, isLocalCacheUrlAvailable, isHistoryCacheMappingValid]);

    // V2.6.1 Feature: 历史记录本地缓存（视频）
    useEffect(() => {
        if (!localCacheActive) return;

        const cacheHistoryVideos = async () => {
            if (cacheVideoRunRef.current) return;
            cacheVideoRunRef.current = true;
            const summary = {
                total: history.length,
                processed: 0,
                skippedStatus: 0,
                skippedNonVideo: 0,
                skippedEmpty: 0,
                saved: 0,
                failed: 0,
                proxy: 0,
                direct: 0
            };
            try {
                const localBase = (localServerUrl || '').trim().replace(/\/+$/, '');
                const savePathRaw = localServerConfig.videoSavePath || localServerConfig.savePath || '';
                const preferHistoryPath = !!(savePathRaw && !String(savePathRaw).includes('.tapnow_cache'));
                const expectedSegment = preferHistoryPath ? '/file/history/' : '/file/.tapnow_cache/history/';
                if (!localCacheIndexReadyRef.current) {
                    await refreshLocalCacheFileIndex({ silent: true });
                }
                for (const item of history) {
                const status = item?.status;
                const isCacheableStatus = isCompletedLikeStatus(status);
                if (!isCacheableStatus) { summary.skippedStatus++; continue; }
                const videoUrl = item?.url || item?.originalUrl || '';
                const isVideoItem = item?.type === 'video' || isVideoUrl(videoUrl);
                if (!isVideoItem) { summary.skippedNonVideo++; continue; }
                const baseProxy = getItemProxyPreference(item);
                let localCacheUrl = item.localCacheUrl || null;
                if (localCacheUrl && !cacheRedownloadOnEnable) {
                    if (localCacheIndexReadyRef.current && !isLocalCacheUrlAvailable(localCacheUrl)) {
                        localCacheUrl = null;
                        setHistory(prev => prev.map(h =>
                            h.id === item.id ? { ...h, localCacheUrl: null, localFilePath: null } : h
                        ));
                    }
                    if (localCacheUrl) continue;
                }
                if (triedCacheIdsRef.current.has(item.id)) continue;
                triedCacheIdsRef.current.add(item.id);
                    if (videoUrl && (videoUrl.includes('localhost:') || videoUrl.includes('127.0.0.1:'))) continue;

                    if (!videoUrl || videoUrl.startsWith('blob:') || videoUrl.includes('...')) { summary.skippedEmpty++; continue; }
                    summary.processed++;

                    if (!cacheRedownloadOnEnable) {
                        const globalCached = historyLocalCacheMap && historyLocalCacheMap.get(videoUrl);
                        if (globalCached) {
                            setHistory(prev => prev.map(h =>
                                h.id === item.id ? { ...h, localCacheUrl: globalCached } : h
                            ));
                            continue;
                        }

                        if (localBase) {
                            const cacheId = getCacheIdFromUrl(videoUrl, item.id);
                            const expectedId = sanitizeCacheId(cacheId) || cacheId;
                            if (expectedId) {
                                const matchedLocal = getLocalCacheCandidateUrl(expectedId, ['.mp4', '.webm', '.mov'], preferHistoryPath);
                                if (matchedLocal) {
                                    setHistory(prev => prev.map(h =>
                                        h.id === item.id ? { ...h, localCacheUrl: matchedLocal } : h
                                    ));
                                    continue;
                                }
                            }
                        }
                    }

                    try {
                        const useProxy = getProxyPreferenceForUrl(videoUrl, baseProxy);
                        if (useProxy) summary.proxy++; else summary.direct++;
                        const result = await saveVideoToLocalCache(item.id, videoUrl, 'history', { useProxy });
                        if (result) {
                            setHistory(prev => prev.map(h =>
                                h.id === item.id ? { ...h, localCacheUrl: result.url, localFilePath: result.path } : h
                            ));
                            summary.saved++;
                        } else {
                            summary.failed++;
                        }
                    } catch (e) {
                        console.warn('[历史缓存] 视频缓存失败:', item.id, e);
                        summary.failed++;
                    }
                }
            } finally {
                cacheVideoRunRef.current = false;
            }
        };

        cacheHistoryVideos();
        const timer = setTimeout(cacheHistoryVideos, 5000);
        return () => clearTimeout(timer);
    }, [history, localCacheActive, localServerConfig.videoSavePath, localServerConfig.savePath, localServerUrl, saveVideoToLocalCache, getItemProxyPreference, getProxyPreferenceForUrl, cacheRefreshTick, historyLocalCacheMap, cacheRedownloadOnEnable, sanitizeCacheId, getCacheIdFromUrl, refreshLocalCacheFileIndex, getLocalCacheCandidateUrl, isLocalCacheUrlAvailable]);

    const canvasRef = useRef(null);
    const lastMousePos = useRef({ x: 0, y: 0 });
    const chatEndRef = useRef(null);
    const chatInputRef = useRef(null);
    const nodesRef = useRef(nodes);
    const selectedNodeIdRef = useRef(selectedNodeId);
    const selectedNodeIdsRef = useRef(selectedNodeIds); // 存储多选节点ID的ref
    const connectionsRef = useRef(connections);
    const frameSelectionRef = useRef({});
    const copiedNodesRef = useRef(null); // 存储复制的节点数据
    const isPanningRef = useRef(false); // 使用ref跟踪画布拖动状态，避免状态丢失
    const panRafRef = useRef(null); // 画布拖动的 requestAnimationFrame
    const pendingPanUpdate = useRef(null); // 待处理的画布拖动更新
    const multiNodeDragStartPos = useRef(null); // 多节点拖动起始位置，用于防止累积误差
    const lastZoomRef = useRef(null); // 跟踪上次的 zoom 值，用于检测缩放切换

    useEffect(() => {
        // 保存配置到 localStorage（不再过滤任何模型）
        localStorage.setItem('tapnow_api_configs', JSON.stringify(apiConfigs));
    }, [apiConfigs]);

    // --- MOVED HELPERS to fix ReferenceError ---
    const deleteNode = useCallback((id) => {
        saveToUndoStack(); // V3.4.6: 保存到撤销栈
        setNodes((prev) => prev.filter((n) => n.id !== id));
        setConnections((prev) => prev.filter((c) => c.from !== id && c.to !== id));
        if (selectedNodeId === id) setSelectedNodeId(null);
    }, [selectedNodeId, saveToUndoStack]);

    const updateNodeSettings = useCallback((id, newSettings) => {
        setNodes((prev) => prev.map((n) => n.id === id ? { ...n, settings: { ...n.settings, ...newSettings } } : n));
    }, []);

    const handleVideoFileUpload = (nodeId, file) => {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (ev) => {
            const content = ev.target.result;
            let videoMeta = { duration: 0, w: 0, h: 0 };
            try { videoMeta = await getVideoMetadata(content); } catch (e) { console.warn('读取视频元信息失败', e); }
            setNodes((prev) => prev.map((n) =>
                n.id === nodeId
                    ? { ...n, content, videoMeta, frames: [], selectedKeyframes: [], extractingFrames: false, videoFileName: file.name }
                    : n
            ));
        };
        reader.readAsDataURL(file);
    };
    // ---------------------

    // 全局 Delete 键删除节点
    useEffect(() => {
        const handleDeleteKey = (e) => {
            // 防止在输入框中触发
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

            // 检查是否按下了 Delete 或 Del 键
            if (e.key === 'Delete' || e.key === 'Del') {
                e.preventDefault();
                e.stopPropagation();

                const currentSelectedId = selectedNodeIdRef.current;
                const currentSelectedIds = selectedNodeIdsRef.current;

                // 删除选中的节点
                if (currentSelectedId) {
                    deleteNode(currentSelectedId);
                    setSelectedNodeId(null);
                } else if (currentSelectedIds && currentSelectedIds.size > 0) {
                    // V3.4.7: 批量删除 - 只保存一次撤销状态 (使用 ref 确保获取最新状态)
                    if (saveToUndoStackRef.current) {
                        saveToUndoStackRef.current();
                    }
                    const idsToDelete = new Set(currentSelectedIds);
                    setNodes(prev => prev.filter(n => !idsToDelete.has(n.id)));
                    setConnections(prev => prev.filter(c => !idsToDelete.has(c.from) && !idsToDelete.has(c.to)));
                    setSelectedNodeIds(new Set());
                }
            }
        };

        window.addEventListener('keydown', handleDeleteKey);
        return () => {
            window.removeEventListener('keydown', handleDeleteKey);
        };
    }, []);
    // 保存角色库到 localStorage（使用防抖优化）
    const debouncedSaveCharacters = useMemo(() => debounce((charactersToSave) => {
        try {
            localStorage.setItem('tapnow_characters', JSON.stringify(charactersToSave));
        } catch (e) {
            console.error('保存角色库失败:', e);
        }
    }, 500), []);

    useEffect(() => {
        debouncedSaveCharacters(characterLibrary);
    }, [characterLibrary, debouncedSaveCharacters]);

    const historyDisplayItems = useMemo(() => {
        const sessionItems = history.filter(item => (item.startTime || 0) >= sessionStartTime);
        const previousItems = history.filter(item => (item.startTime || 0) < sessionStartTime);
        return [...sessionItems, ...previousItems];
    }, [history, sessionStartTime]);
    const isHistoryItemNavigable = useCallback((item) => {
        if (!item) return false;
        const status = item?.status;
        if (!isCompletedLikeStatus(status)) return false;
        const preview = getHistoryNavPreview(item);
        return !!preview?.url;
    }, [getHistoryNavPreview]);
    const historyNavItems = useMemo(
        () => historyDisplayItems.filter(isHistoryItemNavigable),
        [historyDisplayItems, isHistoryItemNavigable]
    );
    const getHistoryNavAnchorIndex = useCallback((currentItem, items) => {
        if (!items || items.length === 0) return -1;
        const currentId = currentItem?.id;
        if (currentId) {
            const idxById = items.findIndex(item => item?.id === currentId);
            if (idxById >= 0) return idxById;
        }
        const currentUrlCandidates = new Set();
        const addCurrentUrlCandidate = (url) => {
            const normalized = normalizeHistoryNavComparableUrl(url);
            if (normalized) currentUrlCandidates.add(normalized);
        };
        addCurrentUrlCandidate(currentItem?.url);
        addCurrentUrlCandidate(currentItem?.originalUrl);
        addCurrentUrlCandidate(currentItem?.mjOriginalUrl);
        if (Array.isArray(currentItem?.mjImages)) {
            currentItem.mjImages.forEach((url) => addCurrentUrlCandidate(url));
        }
        if (Array.isArray(currentItem?.output_images)) {
            currentItem.output_images.forEach((url) => addCurrentUrlCandidate(url));
        }
        if (currentUrlCandidates.size > 0) {
            for (let idx = 0; idx < items.length; idx++) {
                const item = items[idx];
                if (!item) continue;
                const preview = getHistoryNavPreview(item);
                const previewUrl = normalizeHistoryNavComparableUrl(preview?.url);
                if (previewUrl && currentUrlCandidates.has(previewUrl)) return idx;
                const fallbackUrl = normalizeHistoryNavComparableUrl(resolveHistoryUrl(item));
                if (fallbackUrl && currentUrlCandidates.has(fallbackUrl)) return idx;
                const multiImages = getHistoryMultiImages(item) || [];
                for (const rawUrl of multiImages) {
                    const resolved = normalizeHistoryNavComparableUrl(resolveHistoryUrl(item, rawUrl));
                    if (resolved && currentUrlCandidates.has(resolved)) return idx;
                }
            }
        }
        const currentTimeRaw = currentItem?.startTime || currentItem?.created || currentItem?.timestamp;
        const currentTime = Number.isFinite(currentTimeRaw) ? currentTimeRaw : Number.parseFloat(currentTimeRaw);
        if (Number.isFinite(currentTime)) {
            let bestIdx = -1;
            let bestDiff = Infinity;
            items.forEach((item, idx) => {
                const itemTimeRaw = item?.startTime || item?.created || item?.timestamp;
                const itemTime = Number.isFinite(itemTimeRaw) ? itemTimeRaw : Number.parseFloat(itemTimeRaw);
                if (!Number.isFinite(itemTime)) return;
                const diff = Math.abs(itemTime - currentTime);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestIdx = idx;
                }
            });
            if (bestIdx >= 0) return bestIdx;
        }
        if (historyFocusId) {
            const idxByFocus = items.findIndex(item => item?.id === historyFocusId);
            if (idxByFocus >= 0) return idxByFocus;
        }
        return 0;
    }, [historyFocusId, getHistoryNavPreview, normalizeHistoryNavComparableUrl, resolveHistoryUrl, getHistoryMultiImages]);
    const getHistoryNavIndexById = useCallback((id) => {
        if (!id) return -1;
        return historyNavItems.findIndex(item => item?.id === id);
    }, [historyNavItems]);
    const findHistoryNavIndex = useCallback((items, currentIndex, direction) => {
        if (!Array.isArray(items) || items.length === 0) return -1;
        const step = direction < 0 ? -1 : 1;
        let idx = currentIndex;
        while (true) {
            idx += step;
            if (idx < 0 || idx >= items.length) return -1;
            const candidate = items[idx];
            if (isHistoryItemNavigable(candidate)) return idx;
        }
    }, [isHistoryItemNavigable]);

    useEffect(() => {
        const current = lightboxItemRef.current;
        if (!current || current.storyboardContext) {
            lightboxHistorySnapshotRef.current = null;
            lightboxHistoryIndexRef.current = -1;
            return;
        }
        if (!lightboxHistorySnapshotRef.current) {
            const validIds = historyNavItems
                .filter(item => !!getHistoryNavPreview(item).url)
                .map(item => item.id);
            if (current.id && !validIds.includes(current.id)) {
                validIds.unshift(current.id);
            }
            lightboxHistorySnapshotRef.current = validIds;
        }
        if (lightboxHistorySnapshotRef.current) {
            lightboxHistoryIndexRef.current = lightboxHistorySnapshotRef.current.indexOf(current.id);
        }
    }, [lightboxItem?.id, lightboxItem?.storyboardContext, historyNavItems, getHistoryNavPreview]);

    // 当视频 URL 改变时清除错误提示
    useEffect(() => {
        setCreateCharacterVideoError(null);
    }, [createCharacterVideoUrl, createCharacterSelectedTaskId, createCharacterVideoSourceType]);

    // V3.7.28: 历史面板键盘导航 (上下箭头跳转、ESC关闭)
    useEffect(() => {
        if (!historyOpen) {
            setHistoryFocusIndex(-1);
            setHistoryFocusId(null);
            return;
        }

        const handleHistoryKeyDown = (e) => {
            // 不在输入框中触发
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // 如果 Lightbox 打开则不处理
            if (lightboxItem) return;
            if (historyNavItems.length === 0) return;
            let currentIndex = historyFocusId
                ? getHistoryNavIndexById(historyFocusId)
                : -1;
            if (currentIndex < 0) currentIndex = 0;
            if (currentIndex < 0) return;

            if (e.key === 'ArrowUp' || e.key === 'Up') {
                e.preventDefault();
                e.stopPropagation();
                const newIdx = Math.max(0, currentIndex - 1);
                if (newIdx === currentIndex) return;
                const targetItem = historyNavItems[newIdx];
                const preview = getHistoryNavPreview(targetItem);
                if (preview?.url) {
                    setLightboxItem({
                        ...targetItem,
                        url: preview.url,
                        selectedMjImageIndex: preview.index,
                        storyboardContext: null
                    });
                }
                setHistoryFocusId(targetItem?.id || null);
                setHistoryFocusIndex(newIdx);
            } else if (e.key === 'ArrowDown' || e.key === 'Down') {
                e.preventDefault();
                e.stopPropagation();
                const newIdx = Math.min(historyNavItems.length - 1, currentIndex + 1);
                if (newIdx === currentIndex) return;
                const targetItem = historyNavItems[newIdx];
                const preview = getHistoryNavPreview(targetItem);
                if (preview?.url) {
                    setLightboxItem({
                        ...targetItem,
                        url: preview.url,
                        selectedMjImageIndex: preview.index,
                        storyboardContext: null
                    });
                }
                setHistoryFocusId(targetItem?.id || null);
                setHistoryFocusIndex(newIdx);
            } else if (e.key === 'Escape' || e.key === 'Esc') {
                e.preventDefault();
                e.stopPropagation();
                setHistoryOpen(false);
            }
        };

        window.addEventListener('keydown', handleHistoryKeyDown);
        return () => window.removeEventListener('keydown', handleHistoryKeyDown);
    }, [historyOpen, historyNavItems, lightboxItem, getHistoryNavPreview, historyFocusId, historyFocusIndex, getHistoryNavIndexById]);

    useEffect(() => {
        if (!historyOpen) return;
        if (historyNavItems.length === 0) {
            setHistoryFocusIndex(-1);
            setHistoryFocusId(null);
            return;
        }
        const idx = historyFocusId ? getHistoryNavIndexById(historyFocusId) : -1;
        if (idx >= 0) {
            if (idx !== historyFocusIndex) setHistoryFocusIndex(idx);
            return;
        }
        setHistoryFocusIndex(0);
        setHistoryFocusId(historyNavItems[0]?.id || null);
    }, [historyOpen, historyNavItems, historyFocusId, historyFocusIndex, getHistoryNavIndexById]);

    const historyLimit = normalizeHistorySaveLimit(historySaveLimit);
    const historyLimitWarningRef = useRef({ initialized: false, lastCount: 0, lastLimit: historyLimit, toastId: null });

    useEffect(() => {
        const limit = historyLimit;
        const count = history.length;
        const ref = historyLimitWarningRef.current;
        if (!ref.initialized) {
            ref.initialized = true;
            ref.lastCount = count;
            ref.lastLimit = limit;
            return;
        }
        if (!limit || limit <= 0) {
            ref.lastCount = count;
            ref.lastLimit = limit;
            return;
        }
        const threshold = Math.max(1, Math.ceil(limit * 0.9));
        const crossed = ref.lastCount < threshold && count >= threshold;
        const limitChanged = ref.lastLimit !== limit;
        if ((crossed || limitChanged) && count >= threshold) {
            if (!ref.toastId) {
                ref.toastId = showToast(`${t('历史数量已接近上限')} (${count}/${limit})，${t('建议保存资产包或清理历史')}`, 'warning', 300000);
            }
        }
        if (count < threshold && ref.toastId) {
            dismissToast(ref.toastId);
            ref.toastId = null;
        }
        ref.lastCount = count;
        ref.lastLimit = limit;
    }, [history.length, historyLimit, showToast, dismissToast, t]);

    const trimHistoryUrlForStorage = (url) => {
        if (!url) return url;
        if (url.startsWith('data:') && url.length > 5000) return '';
        return url;
    };
    const compactCacheMapForStorage = (cacheMap, limit = 8) => {
        if (!cacheMap || typeof cacheMap !== 'object') return null;
        const entries = Object.entries(cacheMap).filter(([k, v]) => k && v);
        if (entries.length === 0) return null;
        const next = {};
        entries.slice(0, limit).forEach(([k, v]) => {
            next[k] = v;
        });
        return next;
    };

    const compactHistoryItemForStorage = (item) => {
        const saved = { ...item };
        const fallback = resolveSourceReferenceUrl(getHistoryFallbackUrl(saved, { allowLocalCache: false }));
        const toStorageUrl = (url, customFallback = fallback) => {
            const sourceRef = resolveSourceReferenceUrl(url);
            return trimHistoryUrlForStorage(
                sanitizeHistoryUrlValue(sourceRef, customFallback, { allowLocalCache: false })
            );
        };
        if (saved.url) saved.url = toStorageUrl(saved.url);
        if (saved.originalUrl) saved.originalUrl = toStorageUrl(saved.originalUrl);
        if (saved.mjOriginalUrl) saved.mjOriginalUrl = toStorageUrl(saved.mjOriginalUrl);
        if (Array.isArray(saved.output_images)) {
            saved.output_images = saved.output_images
                .slice(0, 12)
                .map((url) => toStorageUrl(url))
                .filter(Boolean);
        }
        if (Array.isArray(saved.mjImages)) {
            const sanitized = saved.mjImages
                .map((url) => sanitizeHistoryUrlValue(resolveSourceReferenceUrl(url), fallback, { allowLocalCache: false }))
                .filter(Boolean);
            if (sanitized.length === 0 && saved.mjOriginalUrl) {
                saved.mjImages = null;
                saved.mjNeedsSplit = true;
            } else {
                saved.mjImages = sanitized.slice(0, 12).map(trimHistoryUrlForStorage);
            }
        }
        if (Array.isArray(saved.mjImages) && saved.mjImages.length > 1) {
            const needsOutputImages = !Array.isArray(saved.output_images) || saved.output_images.length < saved.mjImages.length;
            if (needsOutputImages) {
                saved.output_images = saved.mjImages.slice(0, 12);
            }
        }
        if (Array.isArray(saved.mjThumbnails)) {
            saved.mjThumbnails = saved.mjThumbnails
                .map((url) => sanitizeHistoryUrlValue(resolveSourceReferenceUrl(url), fallback, { allowLocalCache: false }))
                .filter(Boolean)
                .map(trimHistoryUrlForStorage);
        }
        if (saved.thumbnailUrl) {
            saved.thumbnailUrl = toStorageUrl(saved.thumbnailUrl);
        }
        delete saved.mjImageInfo;
        if (saved.localCacheMap && typeof saved.localCacheMap === 'object') {
            const nextCacheMap = {};
            Object.entries(saved.localCacheMap).forEach(([sourceUrl, cacheUrl]) => {
                const normalizedSource = toStorageUrl(sourceUrl, '');
                if (!normalizedSource || !cacheUrl) return;
                nextCacheMap[normalizedSource] = cacheUrl;
            });
            saved.localCacheMap = nextCacheMap;
        }
        saved.localCacheMap = compactCacheMapForStorage(saved.localCacheMap);
        saved.localCacheUrl = saved.localCacheUrl || null;
        saved.localFilePath = saved.localFilePath || null;
        delete saved.apiConfig;
        return saved;
    };

    // localStorage 写入防抖函数
    const debouncedSaveHistory = useMemo(() => debounce((historyToSave) => {
        try {
            localStorage.setItem('tapnow_history', JSON.stringify(historyToSave));
        } catch (e) {
            console.error('保存历史记录失败（可能超出存储配额）:', e);
            // 如果存储失败，尝试减少数据量
            try {
                const reduced = historyToSave.map(item => ({
                    id: item.id,
                    type: item.type,
                    url: trimHistoryUrlForStorage(resolveSourceReferenceUrl(item.url)),
                    prompt: item.prompt?.substring(0, 200) || '',
                    time: item.time,
                    status: item.status,
                    modelName: item.modelName,
                    width: item.width,
                    height: item.height,
                    ratio: item.ratio,
                    mjImages: Array.isArray(item.mjImages) ? item.mjImages.slice(0, 8).map((url) => trimHistoryUrlForStorage(resolveSourceReferenceUrl(url))) : item.mjImages,
                    selectedMjImageIndex: item.selectedMjImageIndex,
                    mjRatio: item.mjRatio,
                    mjNeedsSplit: item.mjNeedsSplit
                }));
                localStorage.setItem('tapnow_history', JSON.stringify(reduced));
            } catch (e2) {
                console.error('减少数据后保存也失败:', e2);
                try {
                    // 最小化保存：只保留必要字段
                    const minimal = historyToSave.map(item => ({
                        id: item.id,
                        type: item.type,
                        url: trimHistoryUrlForStorage(resolveSourceReferenceUrl(item.url)),
                        prompt: item.prompt?.substring(0, 100) || '',
                        time: item.time,
                        status: item.status,
                        modelName: item.modelName
                    }));
                    debouncedSaveHistory(minimal);
                } catch (e3) {
                    console.error('最小化保存也失败:', e3);
                }
            }
        }
    }, 1000), []);

    const persistHistorySnapshot = (historyItems = []) => {
        try {
            const historyToSave = historyItems
                .slice(0, historyLimit)
                .map((item) => compactHistoryItemForStorage(item));
            localStorage.setItem('tapnow_history', JSON.stringify(historyToSave));
            return true;
        } catch (e) {
            console.error('立即保存历史记录失败:', e);
            try {
                const reduced = historyItems.map(item => ({
                    id: item.id,
                    type: item.type,
                    url: trimHistoryUrlForStorage(resolveSourceReferenceUrl(item.url)),
                    prompt: item.prompt?.substring(0, 200) || '',
                    time: item.time,
                    status: item.status,
                    modelName: item.modelName,
                    width: item.width,
                    height: item.height,
                    ratio: item.ratio,
                    output_images: Array.isArray(item.output_images) ? item.output_images.slice(0, 8).map((url) => trimHistoryUrlForStorage(resolveSourceReferenceUrl(url))) : item.output_images,
                    mjImages: Array.isArray(item.mjImages) ? item.mjImages.slice(0, 8).map((url) => trimHistoryUrlForStorage(resolveSourceReferenceUrl(url))) : item.mjImages,
                    selectedMjImageIndex: item.selectedMjImageIndex,
                    mjRatio: item.mjRatio,
                    mjNeedsSplit: item.mjNeedsSplit
                }));
                localStorage.setItem('tapnow_history', JSON.stringify(reduced));
                return true;
            } catch (e2) {
                console.error('立即保存历史记录失败（降级后）:', e2);
                return false;
            }
        }
    };

    const debouncedSaveGlobalKey = useMemo(() => debounce((key) => {
        localStorage.setItem('tapnow_global_key', key);
    }, 1000), []);

    useEffect(() => { debouncedSaveGlobalKey(globalApiKey); }, [globalApiKey, debouncedSaveGlobalKey]);

    // 优化localStorage存储，处理配额超限问题
    useEffect(() => {
        try {
            // 只存储必要的元数据，不存储完整的base64图片和长URL
            const historyToSave = history
                .slice(0, historyLimit)
                .map((item) => {
                    const saved = compactHistoryItemForStorage(item);
                    // V3.4.10: 只对 Midjourney 切割图片清空 mjImages，保留 Jimeng 等其他模型的多图
                    // 判断条件：mjImages 有 4 张图 且 模型为 Midjourney（mj）
                    const isMjModel = item.apiConfig?.modelId?.includes('mj') || item.modelName?.toLowerCase()?.includes('midjourney');
                    if (item.mjImages && item.mjImages.length === 4 && isMjModel) {
                        // Midjourney: 保存切割标记和原图URL，切割后的图片在需要时重新生成
                        saved.mjImages = null; // 不保存 MJ base64 数组
                        saved.mjNeedsSplit = true; // 标记需要重新切割
                        saved.mjOriginalUrl = trimHistoryUrlForStorage(item.mjOriginalUrl || item.url); // 保存原图URL
                    }
                    return saved;
                });
            debouncedSaveHistory(historyToSave);
        } catch (e) {
            console.error('保存历史记录失败（可能超出存储配额）:', e);
            // 如果存储失败，尝试清理旧数据，只保留最近20条
            try {
                const reduced = history.slice(0, 20).map(item => compactHistoryItemForStorage(item));
                debouncedSaveHistory(reduced);
            } catch (e2) {
                console.error('清理后仍无法保存:', e2);
                // 最后尝试：只保存最基本的字段
                try {
                    const minimal = history.slice(0, 10).map(item => ({
                        id: item.id,
                        type: item.type,
                        prompt: item.prompt?.substring(0, 100),
                        time: item.time,
                        status: item.status,
                        modelName: item.modelName
                    }));
                    debouncedSaveHistory(minimal);
                } catch (e3) {
                    console.error('最小化保存也失败:', e3);
                }
            }
        }
    }, [history, debouncedSaveHistory]);
    const debouncedSaveChatSessions = useMemo(() => debounce((sessions) => {
        try { localStorage.setItem('tapnow_chat_sessions', JSON.stringify(sessions)); } catch (e) { }
    }, 1000), []);
    useEffect(() => { debouncedSaveChatSessions(chatSessions); }, [chatSessions, debouncedSaveChatSessions]);
    useEffect(() => {
        nodesRef.current = nodes;
        selectedNodeIdRef.current = selectedNodeId;
        selectedNodeIdsRef.current = selectedNodeIds; // 同步更新多选节点ref
        connectionsRef.current = connections;
        isSelectingRef.current = isSelecting; // 同步更新框选状态ref
    }, [nodes, selectedNodeId, selectedNodeIds, connections, isSelecting]);

    // 使用 useMemo 创建 nodes Map，优化节点查找性能（O(1) 查找）
    const nodesMap = useMemo(() => {
        const map = new Map();
        nodes.forEach(node => {
            map.set(node.id, node);
        });
        return map;
    }, [nodes]);

    const modelLibraryMap = useMemo(() => {
        const map = new Map();
        modelLibrary.forEach((entry) => {
            if (!entry?.id) return;
            map.set(entry.id, {
                ...entry,
                displayName: entry.displayName || entry.modelName || entry.id,
                modelName: entry.modelName || entry.displayName || entry.id,
                type: entry.type || 'Chat',
                apiType: entry.apiType || 'openai',
                ratioLimits: Array.isArray(entry.ratioLimits) ? entry.ratioLimits : null,
                ratioNotes: normalizeValueNotes(entry.ratioNotes),
                ratioNotesEnabled: !!entry.ratioNotesEnabled,
                resolutionLimits: Array.isArray(entry.resolutionLimits) ? entry.resolutionLimits : null,
                resolutionNotes: normalizeResolutionNotes(entry.resolutionNotes),
                resolutionNotesEnabled: !!entry.resolutionNotesEnabled,
                durations: Array.isArray(entry.durations) ? entry.durations : null,
                durationNotes: normalizeValueNotes(entry.durationNotes),
                durationNotesEnabled: !!entry.durationNotesEnabled,
                videoResolutions: Array.isArray(entry.videoResolutions) ? entry.videoResolutions : null,
                videoResolutionNotes: normalizeValueNotes(entry.videoResolutionNotes),
                videoResolutionNotesEnabled: !!entry.videoResolutionNotesEnabled,
                supportsFirstLastFrame: !!entry.supportsFirstLastFrame,
                supportsHD: !!entry.supportsHD,
                omitRatioOnSubmit: !!entry.omitRatioOnSubmit,
                omitResolutionOnSubmit: !!entry.omitResolutionOnSubmit,
                customParams: normalizeCustomParams(entry.customParams),
                asyncConfig: normalizeAsyncConfig(entry.asyncConfig),
                previewOverrideEnabled: !!entry.previewOverrideEnabled,
                previewOverridePatch: normalizePreviewOverridePatch(entry.previewOverridePatch),
                requestTemplate: normalizeRequestTemplate(entry.requestTemplate || getDefaultRequestTemplateForEntry(entry)),
                requestOverrideEnabled: !!entry.requestOverrideEnabled,
                requestOverridePatch: normalizeRequestOverridePatch(entry.requestOverridePatch)
            });
        });
        return map;
    }, [modelLibrary]);

    const hasExpandedLibraryModels = modelLibrary.some(entry => !collapsedLibraryModels.has(entry.id));

    const resolveApiConfig = useCallback((config) => {
        if (!config) return null;
        const libraryEntry = config.libraryId ? modelLibraryMap.get(config.libraryId) : null;
        const resolvedLibrary = libraryEntry || null;
        return {
            ...config,
            modelName: resolvedLibrary?.modelName || config.modelName || config.id,
            displayName: resolvedLibrary?.displayName || config.displayName || config.id,
            type: resolvedLibrary?.type || config.type || 'Chat',
            apiType: resolvedLibrary?.apiType || config.apiType,
            ratioLimits: resolvedLibrary ? resolvedLibrary.ratioLimits : (config.ratioLimits || null),
            ratioNotes: resolvedLibrary ? normalizeValueNotes(resolvedLibrary.ratioNotes) : normalizeValueNotes(config.ratioNotes),
            ratioNotesEnabled: resolvedLibrary ? !!resolvedLibrary.ratioNotesEnabled : !!config.ratioNotesEnabled,
            resolutionLimits: resolvedLibrary ? resolvedLibrary.resolutionLimits : (config.resolutionLimits || null),
            resolutionNotes: resolvedLibrary ? normalizeResolutionNotes(resolvedLibrary.resolutionNotes) : normalizeResolutionNotes(config.resolutionNotes),
            resolutionNotesEnabled: resolvedLibrary ? !!resolvedLibrary.resolutionNotesEnabled : !!config.resolutionNotesEnabled,
            durations: resolvedLibrary ? resolvedLibrary.durations : (config.durations || null),
            durationNotes: resolvedLibrary ? normalizeValueNotes(resolvedLibrary.durationNotes) : normalizeValueNotes(config.durationNotes),
            durationNotesEnabled: resolvedLibrary ? !!resolvedLibrary.durationNotesEnabled : !!config.durationNotesEnabled,
            videoResolutions: resolvedLibrary ? resolvedLibrary.videoResolutions : (config.videoResolutions || null),
            videoResolutionNotes: resolvedLibrary ? normalizeValueNotes(resolvedLibrary.videoResolutionNotes) : normalizeValueNotes(config.videoResolutionNotes),
            videoResolutionNotesEnabled: resolvedLibrary ? !!resolvedLibrary.videoResolutionNotesEnabled : !!config.videoResolutionNotesEnabled,
            supportsFirstLastFrame: resolvedLibrary ? !!resolvedLibrary.supportsFirstLastFrame : !!config.supportsFirstLastFrame,
            supportsHD: resolvedLibrary ? !!resolvedLibrary.supportsHD : !!config.supportsHD,
            omitRatioOnSubmit: resolvedLibrary ? !!resolvedLibrary.omitRatioOnSubmit : !!config.omitRatioOnSubmit,
            omitResolutionOnSubmit: resolvedLibrary ? !!resolvedLibrary.omitResolutionOnSubmit : !!config.omitResolutionOnSubmit,
            customParams: resolvedLibrary ? normalizeCustomParams(resolvedLibrary.customParams) : normalizeCustomParams(config.customParams),
            asyncConfig: normalizeAsyncConfig(resolvedLibrary?.asyncConfig || config.asyncConfig),
            previewOverrideEnabled: resolvedLibrary ? !!resolvedLibrary.previewOverrideEnabled : !!config.previewOverrideEnabled,
            previewOverridePatch: normalizePreviewOverridePatch(resolvedLibrary?.previewOverridePatch || config.previewOverridePatch),
            requestTemplate: normalizeRequestTemplate(resolvedLibrary?.requestTemplate || config.requestTemplate),
            requestOverrideEnabled: resolvedLibrary ? !!resolvedLibrary.requestOverrideEnabled : !!config.requestOverrideEnabled,
            requestOverridePatch: normalizeRequestOverridePatch(resolvedLibrary?.requestOverridePatch || config.requestOverridePatch)
        };
    }, [modelLibraryMap]);

    // 使用 useMemo 创建 apiConfigs Map，优化配置查找性能（O(1) 查找）
    // 使用 _uid 作为唯一键，避免同名模型相互覆盖
    const apiConfigsMap = useMemo(() => {
        const map = new Map();
        apiConfigs.forEach((config) => {
            const resolved = resolveApiConfig(config);
            if (resolved?._uid) {
                map.set(resolved._uid, resolved);
            }
        });
        return map;
    }, [apiConfigs, resolveApiConfig]);

    const apiConfigsById = useMemo(() => {
        const map = new Map();
        apiConfigs.forEach((config) => {
            const resolved = resolveApiConfig(config);
            if (!resolved?.id) return;
            if (!map.has(resolved.id)) map.set(resolved.id, []);
            map.get(resolved.id).push(resolved);
        });
        return map;
    }, [apiConfigs, resolveApiConfig]);

    const getApiConfigByKey = useCallback((modelKey) => {
        if (!modelKey) return null;
        const byUid = apiConfigsMap.get(modelKey);
        if (byUid) return byUid;
        const byId = apiConfigsById.get(modelKey);
        if (!byId || byId.length === 0) return null;
        if (byId.length === 1) return byId[0];
        const noLibrary = byId.find(c => !c.libraryId);
        return noLibrary || byId[0];
    }, [apiConfigsMap, apiConfigsById]);

    const resolveModelKey = useCallback((modelKey) => {
        if (!modelKey) return '';
        if (apiConfigsMap.has(modelKey)) return modelKey;
        const byId = apiConfigsById.get(modelKey);
        if (!byId || byId.length === 0) return modelKey;
        if (byId.length === 1) return byId[0]?._uid || modelKey;
        const noLibrary = byId.find(c => !c.libraryId);
        return noLibrary?._uid || byId[0]?._uid || modelKey;
    }, [apiConfigsMap, apiConfigsById]);

    useEffect(() => {
        if (!apiConfigs.length) return;
        setNodes(prev => {
            let changed = false;
            const nextNodes = prev.map(node => {
                if (!node.settings) return node;
                let settings = node.settings;
                let settingsChanged = false;

                const normalizeSettingModel = (field) => {
                    if (!settings?.[field]) return;
                    const resolved = resolveModelKey(settings[field]);
                    if (resolved && resolved !== settings[field]) {
                        if (!settingsChanged) settings = { ...settings };
                        settings[field] = resolved;
                        settingsChanged = true;
                    }
                };

                normalizeSettingModel('model');
                normalizeSettingModel('chatModel');
                normalizeSettingModel('imageModel');

                if (Array.isArray(settings.shots)) {
                    let shotsChanged = false;
                    const nextShots = settings.shots.map(shot => {
                        if (!shot?.model) return shot;
                        const resolved = resolveModelKey(shot.model);
                        if (resolved && resolved !== shot.model) {
                            shotsChanged = true;
                            return { ...shot, model: resolved };
                        }
                        return shot;
                    });
                    if (shotsChanged) {
                        if (!settingsChanged) settings = { ...settings };
                        settings.shots = nextShots;
                        settingsChanged = true;
                    }
                }

                if (!settingsChanged) return node;
                changed = true;
                return { ...node, settings };
            });
            return changed ? nextNodes : prev;
        });
    }, [apiConfigs.length, resolveModelKey, setNodes]);

    // V3.4.19: 统一获取 API 凭据 - 只从 Provider 获取，不再从 Model 获取
    const getApiCredentials = useCallback((modelId) => {
        const config = getApiConfigByKey(modelId);
        if (!config) {
            return {
                key: globalApiKey,
                url: DEFAULT_BASE_URL.replace(/\/+$/, ''),
                modelName: modelId,
                displayName: modelId,
                apiType: 'openai',
                useProxy: false,
                forceAsync: false
            };
        }

        // V3.4.19: 只从 Provider 获取凭据，不再使用 model 级别的 key/url
        const provider = providers[config.provider];
        // 如果Provider没有key，使用全局key作为最后fallback
        const key = provider?.key || globalApiKey;
        const url = (provider?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');

        return {
            key,
            url,
            modelName: config.modelName,
            displayName: config.displayName,
            provider: config.provider,
            type: config.type,
            apiType: config.apiType || provider?.apiType || 'openai',
            useProxy: !!provider?.useProxy,
            forceAsync: !!provider?.forceAsync
        };
    }, [getApiConfigByKey, providers, globalApiKey]);

    const buildProxyUrl = useCallback((targetUrl, providerKey) => {
        if (!targetUrl) return targetUrl;
        const provider = providers[providerKey];
        if (!provider?.useProxy) return targetUrl;
        const base = (localServerUrl || '').trim().replace(/\/+$/, '');
        if (!base) return targetUrl;
        return `${base}/proxy?url=${encodeURIComponent(targetUrl)}`;
    }, [providers, localServerUrl]);

    const getModelLabel = useCallback((modelId) => {
        if (!modelId) return '选择模型';
        const config = getApiConfigByKey(modelId);
        return config?.displayName || config?.modelName || config?.id || modelId;
    }, [getApiConfigByKey]);
    const getModelLabelWithProvider = useCallback((modelId) => {
        if (!modelId) return '选择模型';
        const config = getApiConfigByKey(modelId);
        const providerKey = config?.provider || '';
        const providerLabel = providerKey || '';
        const modelLabel = config?.modelName || config?.displayName || config?.id || modelId;
        if (providerLabel) return `${providerLabel} / ${modelLabel}`;
        return modelLabel;
    }, [getApiConfigByKey]);

    const getHistoryMeta = useCallback((item) => {
        if (!item) return null;
        const modelKey = item?.apiConfig?.modelId || item?.apiConfig?.id || item?.modelName || item?.modelId;
        const config = modelKey ? getApiConfigByKey(modelKey) : null;
        const ratioValue = item.ratio || item.mjRatio || '';
        const ratioLabel = ratioValue
            ? getNoteLabelWithNotes(ratioValue, !!config?.ratioNotesEnabled, config?.ratioNotes || {})
            : '';
        const isVideo = item.type === 'video';
        const rawResolution = item.resolution || (item.width && item.height ? `${item.width}x${item.height}` : '');
        let resolutionLabel = rawResolution;
        if (rawResolution) {
            const notesEnabled = isVideo ? !!config?.videoResolutionNotesEnabled : !!config?.resolutionNotesEnabled;
            const notes = isVideo ? (config?.videoResolutionNotes || {}) : (config?.resolutionNotes || {});
            const normalized = isVideo ? normalizeVideoResolution(rawResolution) : normalizeResolutionOption(rawResolution);
            const lookupKey = normalized || rawResolution;
            resolutionLabel = getNoteLabelWithNotes(lookupKey, notesEnabled, notes);
        }
        let durationLabel = '';
        if (isVideo && item.duration) {
            const durationValue = String(item.duration).endsWith('s') ? String(item.duration) : `${item.duration}s`;
            durationLabel = getNoteLabelWithNotes(durationValue, !!config?.durationNotesEnabled, config?.durationNotes || {});
        }
        const customParamLabels = [];
        if (item.customParams && Array.isArray(config?.customParams)) {
            config.customParams.forEach((param) => {
                const selected = getCustomParamSelection(param, item.customParams);
                if (selected === '' || selected === undefined || selected === null) return;
                const rawValue = typeof selected === 'string' ? selected.trim() : String(selected);
                const valueNotes = param?.valueNotes || {};
                const note = param?.notesEnabled
                    ? (valueNotes[rawValue] || valueNotes[String(rawValue)] || null)
                    : null;
                if (note) {
                    customParamLabels.push(note);
                    return;
                }
                const label = getNoteLabelWithNotes(rawValue, !!param?.notesEnabled, valueNotes);
                const nameCandidate = param?.name || param?.label || param?.displayName || param?.paramName || param?.key || param?.id || '';
                const name = String(nameCandidate || '').trim();
                if (!name || /^param-/.test(name)) {
                    customParamLabels.push(label);
                } else {
                    customParamLabels.push(`${name}:${label}`);
                }
            });
        }
        if (customParamLabels.length === 0 && item.customParams && typeof item.customParams === 'object' && !Array.isArray(item.customParams)) {
            Object.entries(item.customParams).forEach(([key, value]) => {
                if (!key) return;
                if (value === '' || value === undefined || value === null) return;
                if (/^param-/.test(String(key))) {
                    customParamLabels.push(String(value));
                } else {
                    customParamLabels.push(`${key}:${value}`);
                }
            });
        }
        const fallbackModel = item.modelName || item.apiConfig?.modelId || item.apiConfig?.model || item.model || '未知模型';
        const configLabel = config?.displayName || config?.modelName || config?.id || '';
        let modelLabel = configLabel || fallbackModel;
        if (!modelLabel || /^uid-/.test(modelLabel)) {
            const safeItemName = item.modelName && !/^uid-/.test(item.modelName) ? item.modelName : '';
            modelLabel = config?.modelName || config?.id || safeItemName || fallbackModel || '未知模型';
        }
        if (/^uid-/.test(modelLabel)) {
            modelLabel = '未知模型';
        }
        if (item.modelName && item.provider && item.modelName.toLowerCase() === item.provider.toLowerCase()) {
            modelLabel = configLabel || config?.modelName || config?.id || fallbackModel;
        }
        return { ratioLabel, resolutionLabel, durationLabel, customParamLabels, modelLabel };
    }, [getApiConfigByKey]);

    const renderCustomParamInputs = useCallback((modelId, currentValues, onChange) => {
        const config = getApiConfigByKey(modelId);
        const customParams = Array.isArray(config?.customParams) ? config.customParams : [];
        if (!customParams.length) return null;
        const values = currentValues || {};
        return (
            <div
                className="flex flex-col gap-2"
                onMouseDown={(e) => e.stopPropagation()}
                onClick={(e) => e.stopPropagation()}
                onPointerDown={(e) => e.stopPropagation()}
                onTouchStart={(e) => e.stopPropagation()}
            >
                <div className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('自定义参数')}</div>
                {customParams.map((param, index) => {
                    const paramId = param.id || param.name || `param-${index}`;
                    const selectedValueRaw = getCustomParamSelection(param, values);
                    const selectedValue = selectedValueRaw === null || selectedValueRaw === undefined
                        ? ''
                        : String(selectedValueRaw);
                    const options = Array.isArray(param.values) ? param.values : [];
                    const inputMode = isCustomParamInputMode(param);
                    const filteredOptions = options.filter((option) => !/^(input|输入)$/i.test(String(option || '').trim()));
                    const paramLabel = param?.name || param?.label || param?.displayName || param?.paramName || param?.key || param?.id || '参数';
                    const clearParamSelection = (target) => {
                        if (!target || typeof target !== 'object') return;
                        if (param.id) delete target[param.id];
                        if (param.name) delete target[param.name];
                        if (paramId) delete target[paramId];
                    };
                    return (
                        <div key={paramId} className="flex items-center gap-2">
                            <span
                                className={`text-[10px] min-w-[70px] max-w-[140px] flex-shrink-0 truncate ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-700'}`}
                                title={paramLabel}
                            >
                                {paramLabel}
                            </span>
                            {inputMode ? (
                                <>
                                    <input
                                        type="text"
                                        value={selectedValue || ''}
                                        onChange={(e) => {
                                            const nextValue = e.target.value;
                                            const next = { ...values };
                                            clearParamSelection(next);
                                            if (nextValue) {
                                                next[paramId] = nextValue;
                                            }
                                            onChange(next);
                                        }}
                                        placeholder={t('请输入参数值')}
                                        list={filteredOptions.length > 0 ? `param-suggest-${paramId}` : undefined}
                                        className={`flex-1 px-2 py-1 rounded text-xs border ${theme === 'dark'
                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500'
                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                            }`}
                                        onMouseDown={(e) => e.stopPropagation()}
                                        onClick={(e) => e.stopPropagation()}
                                        onPointerDown={(e) => e.stopPropagation()}
                                        onTouchStart={(e) => e.stopPropagation()}
                                    />
                                    {filteredOptions.length > 0 && (
                                        <datalist id={`param-suggest-${paramId}`}>
                                            {filteredOptions.map((option) => (
                                                <option key={option} value={option} />
                                            ))}
                                        </datalist>
                                    )}
                                </>
                            ) : options.length > 0 ? (
                                <select
                                    value={selectedValue || ''}
                                    onChange={(e) => {
                                        const nextValue = e.target.value;
                                        const next = { ...values };
                                        clearParamSelection(next);
                                        if (nextValue) {
                                            next[paramId] = nextValue;
                                        }
                                        onChange(next);
                                    }}
                                    className={`flex-1 px-2 py-1 rounded text-xs border ${theme === 'dark'
                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                        }`}
                                    onMouseDown={(e) => e.stopPropagation()}
                                    onClick={(e) => e.stopPropagation()}
                                    onPointerDown={(e) => e.stopPropagation()}
                                    onTouchStart={(e) => e.stopPropagation()}
                                >
                                    <option value="">{t('不设置')}</option>
                                    {options.map(option => (
                                        <option key={option} value={option}>{getCustomParamValueLabel(param, option)}</option>
                                    ))}
                                </select>
                            ) : (
                                <input
                                    type="text"
                                    value={selectedValue || ''}
                                    onChange={(e) => {
                                        const nextValue = e.target.value;
                                        const next = { ...values };
                                        clearParamSelection(next);
                                        if (nextValue) {
                                            next[paramId] = nextValue;
                                        }
                                        onChange(next);
                                    }}
                                    placeholder={t('例如: size/quality')}
                                    className={`flex-1 px-2 py-1 rounded text-xs border ${theme === 'dark'
                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500'
                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                        }`}
                                    onMouseDown={(e) => e.stopPropagation()}
                                    onClick={(e) => e.stopPropagation()}
                                    onPointerDown={(e) => e.stopPropagation()}
                                    onTouchStart={(e) => e.stopPropagation()}
                                />
                            )}
                            {param.override && (
                                <span className="text-[9px] px-1.5 py-0.5 rounded bg-emerald-500/15 text-emerald-600 border border-emerald-500/30">
                                    覆盖
                                </span>
                            )}
                        </div>
                    );
                })}
            </div>
        );
    }, [getApiConfigByKey, theme]);

    // V3.4.7: 按 Provider 分组的 API 配置（用于两级菜单）
    const groupedApiConfigs = useMemo(() => {
        const groups = {};

        // 1. 初始化: 确保所有在 providers 中的供应商都显示 (即使没有模型)
        // V3.6.0: 直接使用 key 作为名称（用户可直接修改 key）
        Object.entries(providers).forEach(([key]) => {
            groups[key] = {
                name: key,
                models: []
            };
        });

        // 2. 填充模型
        apiConfigs.forEach(config => {
            if (DELETED_MODEL_IDS.includes(config.id)) return;
            const resolved = resolveApiConfig(config);
            if (!resolved) return;
            const providerKey = resolved.provider || 'Other';
            if (!groups[providerKey]) {
                groups[providerKey] = {
                    name: providerKey,
                    models: []
                };
            }
            groups[providerKey].models.push(resolved);
        });
        return groups;
    }, [apiConfigs, providers, resolveApiConfig]);

    const getRatiosForModel = useCallback((modelId) => {
        if (!modelId) return RATIOS;
        const config = getApiConfigByKey(modelId);
        if (config?.ratioLimits && Array.isArray(config.ratioLimits) && config.ratioLimits.length > 0) {
            const normalized = config.ratioLimits.map((ratio) => String(ratio));
            return normalized.includes('Auto') ? normalized : ['Auto', ...normalized];
        }
        const resolvedId = config?.id || modelId;
        return getDefaultRatiosForModel(resolvedId);
    }, [getApiConfigByKey]);

    const getResolutionsForModel = useCallback((modelId) => {
        if (!modelId) return RESOLUTIONS;
        const config = getApiConfigByKey(modelId);
        if (config?.resolutionLimits && Array.isArray(config.resolutionLimits) && config.resolutionLimits.length > 0) {
            const normalized = config.resolutionLimits
                .map((res) => normalizeResolutionOption(res))
                .filter(Boolean);
            const withAuto = normalized.includes('Auto') ? normalized : ['Auto', ...normalized];
            return Array.from(new Set(withAuto));
        }
        const resolvedId = config?.id || modelId;
        return getDefaultResolutionsForModel(resolvedId);
    }, [getApiConfigByKey]);

    const getVideoResolutionsForModel = useCallback((modelId) => {
        const config = modelId ? getApiConfigByKey(modelId) : null;
        const baseOptions = Array.isArray(config?.videoResolutions) && config.videoResolutions.length > 0
            ? config.videoResolutions
            : VIDEO_RES_OPTIONS;
        const normalized = baseOptions
            .map((res) => normalizeVideoResolution(res))
            .filter(Boolean);
        const withAuto = normalized.includes('Auto') ? normalized : ['Auto', ...normalized];
        return Array.from(new Set(withAuto));
    }, [getApiConfigByKey]);
    const getDefaultCustomParamsForModel = useCallback((modelId, currentSelections = null) => {
        const config = getApiConfigByKey(modelId);
        const customParams = Array.isArray(config?.customParams) ? config.customParams : [];
        if (!customParams.length) return {};
        const next = {};
        customParams.forEach((param, index) => {
            const paramId = param.id || param.name || `param-${index}`;
            if (!paramId) return;
            let value = getCustomParamSelection(param, currentSelections || {});
            if (value === undefined || value === null) value = '';
            value = String(value).trim();
            const options = Array.isArray(param.values) ? param.values : [];
            if (value && options.length > 0 && !isCustomParamInputMode(param) && !options.includes(value)) {
                value = '';
            }
            if (value) next[paramId] = value;
        });
        return next;
    }, [getApiConfigByKey]);
    const getNodeRecommendedHeight = useCallback((nodeType, modelId) => {
        const config = getApiConfigByKey(modelId);
        const customParamCount = Array.isArray(config?.customParams) ? config.customParams.length : 0;
        if (nodeType === 'gen-image') {
            return Math.min(860, 340 + Math.max(0, customParamCount - 1) * 36);
        }
        if (nodeType === 'gen-video') {
            return Math.min(900, 420 + Math.max(0, customParamCount - 1) * 36);
        }
        return 0;
    }, [getApiConfigByKey]);
    const applyNodeModelSelection = useCallback((nodeId, nodeType, modelKey) => {
        if (!nodeId || !modelKey) return;
        const resolvedModel = resolveModelKey(modelKey);
        if (!resolvedModel) return;
        setNodes((prev) => prev.map((node) => {
            if (node.id !== nodeId) return node;
            const nextSettings = { ...(node.settings || {}), model: resolvedModel };
            if (nodeType === 'gen-image') {
                const ratioOptions = getRatiosForModel(resolvedModel);
                const fallbackRatio = ratioOptions.find((value) => value !== 'Auto') || ratioOptions[0] || '1:1';
                const currentRatio = nextSettings.ratio || '';
                nextSettings.ratio = ratioOptions.includes(currentRatio) ? currentRatio : fallbackRatio;
                const resolutionOptions = getResolutionsForModel(resolvedModel);
                const fallbackResolution = resolutionOptions.find((value) => value !== 'Auto') || resolutionOptions[0] || '2K';
                const currentResolution = normalizeImageResolution(nextSettings.resolution || '');
                nextSettings.resolution = resolutionOptions.includes(currentResolution) ? currentResolution : fallbackResolution;
            } else if (nodeType === 'gen-video') {
                const ratioOptions = getRatiosForModel(resolvedModel);
                const fallbackRatio = ratioOptions.find((value) => value !== 'Auto') || ratioOptions[0] || '16:9';
                const currentRatio = nextSettings.ratio || '';
                nextSettings.ratio = ratioOptions.includes(currentRatio) ? currentRatio : fallbackRatio;
                const resolutionOptions = getVideoResolutionsForModel(resolvedModel);
                const fallbackResolution = resolutionOptions.find((value) => value !== 'Auto') || resolutionOptions[0] || '720P';
                const currentResolution = normalizeVideoResolution(nextSettings.resolution || '');
                nextSettings.resolution = resolutionOptions.includes(currentResolution) ? currentResolution : fallbackResolution;
            }
            nextSettings.customParams = getDefaultCustomParamsForModel(resolvedModel, node.settings?.customParams || {});
            const recommendedHeight = getNodeRecommendedHeight(nodeType, resolvedModel);
            const currentHeight = Number(node.height) || 0;
            const nextHeight = recommendedHeight > 0 ? Math.max(currentHeight, recommendedHeight) : currentHeight;
            return {
                ...node,
                settings: nextSettings,
                ...(nextHeight !== currentHeight ? { height: nextHeight } : {})
            };
        }));
    }, [resolveModelKey, getRatiosForModel, getResolutionsForModel, getVideoResolutionsForModel, getDefaultCustomParamsForModel, getNodeRecommendedHeight]);

    // 使用 useMemo 创建 history Map，优化历史记录查找性能（O(1) 查找）
    const historyMap = useMemo(() => {
        const map = new Map();
        history.forEach(item => {
            map.set(item.id, item);
        });
        return map;
    }, [history]);

    // 性能优化：计算可见节点（视口裁剪）
    const visibleNodes = useMemo(() => {
        if (!canvasRef.current) return nodes;

        const rect = canvasRef.current.getBoundingClientRect();
        const padding = 200; // 额外的渲染区域，避免边缘闪烁
        const currentView = viewRef.current;

        // 计算视口在世界坐标系中的范围
        const viewportLeft = (-currentView.x - padding) / currentView.zoom;
        const viewportRight = (rect.width - currentView.x + padding) / currentView.zoom;
        const viewportTop = (-currentView.y - padding) / currentView.zoom;
        const viewportBottom = (rect.height - currentView.y + padding) / currentView.zoom;

        // 过滤出在视口内或附近的节点
        return nodes.filter(node => {
            const nodeRight = node.x + (node.width || 0);
            const nodeBottom = node.y + (node.height || 0);

            // 检查节点是否与视口相交
            return node.x < viewportRight &&
                nodeRight > viewportLeft &&
                node.y < viewportBottom &&
                nodeBottom > viewportTop;
        });
    }, [nodes, view.x, view.y, view.zoom]);

    // 性能优化：根据 zoom 计算 LOD 细节等级
    const getDetailLevel = useCallback((zoom) => {
        if (zoom >= 0.8) return 'high';
        if (zoom >= 0.4) return 'medium';
        return 'low';
    }, []);

    // 同步 viewRef 和 view state
    useEffect(() => {
        viewRef.current = view;
    }, [view]);

    // 使用 useMemo 缓存连接相关的计算，避免重复计算
    const connectionsByNode = useMemo(() => {
        const byNode = {
            to: new Map(), // nodeId -> connections[]
            from: new Map() // nodeId -> connections[]
        };
        connections.forEach(conn => {
            if (!byNode.to.has(conn.to)) {
                byNode.to.set(conn.to, []);
            }
            byNode.to.get(conn.to).push(conn);

            if (!byNode.from.has(conn.from)) {
                byNode.from.set(conn.from, []);
            }
            byNode.from.get(conn.from).push(conn);
        });
        return byNode;
    }, [connections]);


    const getLocalSaveMediaItems = useCallback((targetNodeId) => {
        const items = [];
        const seen = new Set();
        const targetConnections = connectionsByNode.to.get(targetNodeId) || [];

        const pushItem = (url, type = 'image', meta = {}) => {
            if (!url) return;
            const key = `${type}:${url}`;
            if (seen.has(key)) return;
            seen.add(key);
            items.push({ url, type, ...meta });
        };
        const attachProxyMeta = (meta = {}, sourceItem = null, modelKey = null) => {
            if (sourceItem) {
                const provider = sourceItem.provider || sourceItem.apiConfig?.provider || meta.provider;
                const useProxy = getItemProxyPreference(sourceItem);
                return {
                    ...meta,
                    provider,
                    apiConfig: sourceItem.apiConfig || meta.apiConfig,
                    useProxy
                };
            }
            if (modelKey) {
                const config = getApiConfigByKey(modelKey);
                const provider = config?.provider || meta.provider;
                const useProxy = provider ? getItemProxyPreference({ provider }) : false;
                return {
                    ...meta,
                    provider,
                    apiConfig: config ? { modelId: config.id, provider: config.provider } : meta.apiConfig,
                    useProxy
                };
            }
            return meta;
        };

        targetConnections.forEach(conn => {
            const sourceNode = nodesMap.get(conn.from);
            if (!sourceNode) return;

            if (sourceNode.type === 'gen-image' || sourceNode.type === 'gen-video') {
                const latest = history.find(h => h.sourceNodeId === sourceNode.id && h.status === 'completed');
                if (!latest) return;
                const latestPrompt = latest.prompt || sourceNode.settings?.prompt || sourceNode.settings?.videoPrompt || '';
                const proxyMeta = attachProxyMeta({}, latest);
                if (latest.mjImages && latest.mjImages.length > 0) {
                    latest.mjImages.forEach(url => pushItem(url, latest.type || 'image', {
                        prompt: latestPrompt,
                        originalUrl: latest.mjOriginalUrl || latest.originalUrl || url,
                        ...proxyMeta
                    }));
                } else if (latest.output_images && latest.output_images.length > 0) {
                    latest.output_images.forEach(url => pushItem(url, latest.type || 'image', {
                        prompt: latestPrompt,
                        originalUrl: latest.originalUrl || url,
                        ...proxyMeta
                    }));
                } else {
                    const url = latest.url || latest.originalUrl || latest.mjOriginalUrl;
                    if (url) pushItem(url, latest.type || (sourceNode.type === 'gen-video' ? 'video' : 'image'), {
                        prompt: latestPrompt,
                        originalUrl: latest.originalUrl || url,
                        ...proxyMeta
                    });
                }
                return;
            }

            if (sourceNode.type === 'storyboard-node') {
                const shots = sourceNode.settings?.shots || [];
                const mode = sourceNode.settings?.mode || 'video';
                const projectTitle = sourceNode.settings?.projectTitle || '';
                shots.forEach(shot => {
                    if (!shot.outputEnabled) return;
                    const shotProxyMeta = attachProxyMeta({}, null, shot.model);
                    if (mode === 'image') {
                        if (shot.output_images && shot.output_images.length > 0) {
                            shot.output_images.forEach(url => {
                                pushItem(url, 'image', {
                                    prompt: shot.prompt || shot.description || '',
                                    projectTitle,
                                    originalUrl: url,
                                    ...shotProxyMeta
                                });
                            });
                        } else {
                            const idx = shot.selectedImageIndex ?? -1;
                            if (idx >= 0 && shot.output_images && shot.output_images[idx]) {
                                pushItem(shot.output_images[idx], 'image', {
                                    prompt: shot.prompt || shot.description || '',
                                    projectTitle,
                                    originalUrl: shot.output_images[idx],
                                    ...shotProxyMeta
                                });
                            }
                        }
                    } else {
                        const url = shot.output_url || shot.image_url;
                        if (url) pushItem(url, isVideoUrl(url) ? 'video' : 'image', {
                            prompt: shot.prompt || shot.description || '',
                            projectTitle,
                            originalUrl: url,
                            ...shotProxyMeta
                        });
                    }
                });
                return;
            }

            if (sourceNode.type === 'video-input') {
                const selected = sourceNode.selectedKeyframes && sourceNode.selectedKeyframes.length > 0
                    ? sourceNode.selectedKeyframes.map(f => f.url)
                    : [];
                if (selected.length > 0) {
                    selected.forEach(url => pushItem(url, 'image', { name: sourceNode.videoFileName || '', originalUrl: url }));
                } else if (sourceNode.frames && sourceNode.frames.length > 0) {
                    pushItem(sourceNode.frames[0].url, 'image', { name: sourceNode.videoFileName || '', originalUrl: sourceNode.frames[0].url });
                }
                return;
            }

            if (sourceNode.type === 'input-image' || sourceNode.type === 'preview') {
                if (sourceNode.content) pushItem(sourceNode.content, isVideoUrl(sourceNode.content) ? 'video' : 'image', { name: sourceNode.title || '', originalUrl: sourceNode.content });
                if (sourceNode.previewMjImages) {
                    sourceNode.previewMjImages.forEach(url => pushItem(url, 'image', { name: sourceNode.title || '', originalUrl: url }));
                }
                return;
            }
        });

        return items;
    }, [connectionsByNode, nodesMap, history, getItemProxyPreference, getApiConfigByKey]);

    // 实时更新节点计时器
    useEffect(() => {
        const interval = setInterval(() => {
            const now = Date.now();
            const activeTasks = history.filter(h =>
                h.sourceNodeId &&
                h.status === 'generating' &&
                h.startTime
            );

            const newTimers = {};
            activeTasks.forEach(task => {
                const elapsed = Math.floor((now - task.startTime) / 100);
                newTimers[task.sourceNodeId] = elapsed / 10; // 转换为秒，保留1位小数
            });

            setNodeTimers(newTimers);
        }, 500); // V3.5.20-1: 改为 500ms 更新一次，减少 CPU 占用

        return () => clearInterval(interval);
    }, [history]);

    // 检查并重新切割需要切割的Midjourney图片（使用useRef避免重复切割）
    const splittingRef = useRef(new Set());
    useEffect(() => {
        history.forEach(item => {
            if (item.mjNeedsSplit && item.mjOriginalUrl && item.apiConfig?.modelId?.includes('mj') && item.status === 'completed') {
                // 避免重复切割
                if (splittingRef.current.has(item.id)) {
                    return;
                }
                splittingRef.current.add(item.id);

                // 延迟切割，避免阻塞UI
                setTimeout(() => {
                    // 获取比例信息
                    let ratio = item.mjRatio || '1:1';
                    if (item.prompt && item.prompt.includes('--ar ')) {
                        const arMatch = item.prompt.match(/--ar\s+([\d:]+)/);
                        if (arMatch && arMatch[1]) {
                            ratio = arMatch[1];
                        }
                    }


                    // 重新切割图片
                    splitMidjourneyImage(item.mjOriginalUrl, ratio).then((splitImages) => {
                        const imageUrls = splitImages.map(img => typeof img === 'string' ? img : img.url);
                        const firstImage = splitImages[0];
                        const firstUrl = typeof firstImage === 'string' ? firstImage : firstImage.url;

                        setHistory((prev) => prev.map((hItem) =>
                            hItem.id === item.id
                                ? {
                                    ...hItem,
                                    mjImages: imageUrls,
                                    url: firstUrl,
                                    selectedMjImageIndex: 0,
                                    mjRatio: ratio,
                                    mjNeedsSplit: false, // 标记已切割
                                    mjImageInfo: splitImages.map(img => typeof img === 'string' ? null : { width: img.width, height: img.height, ratio: img.ratio })
                                }
                                : hItem
                        ));

                        splittingRef.current.delete(item.id);
                    }).catch((err) => {
                        console.error('Midjourney: 重新切割图片失败:', err);
                        splittingRef.current.delete(item.id);
                        // 保持原图显示，标记需要重新切割
                        setHistory((prev) => prev.map((hItem) =>
                            hItem.id === item.id
                                ? { ...hItem, mjNeedsSplit: true }
                                : hItem
                        ));
                    });
                }, 500); // 延迟500ms，确保UI已完全渲染
            }
        });
    }, [history]);

    const buildLocalSaveFiles = useCallback(async (mediaItems = [], options = {}) => {
        const useProxyResolver = options.useProxyResolver;
        const proxyBaseUrl = options.proxyBaseUrl;
        const files = [];
        const nameCounters = new Map();
        const seenUrls = new Set();
        for (let i = 0; i < mediaItems.length; i++) {
            const item = mediaItems[i];
            const url = item?.url;
            if (!url) continue;
            if (seenUrls.has(url)) continue;
            seenUrls.add(url);
            try {
                let content = url;
                const baseProxy = typeof useProxyResolver === 'function' ? !!useProxyResolver(item) : false;
                const useProxy = getProxyPreferenceForUrl(url, baseProxy);
                if (!url.startsWith('data:')) {
                    const { blob } = await fetchCacheSource(url, { useProxy, proxyBaseUrl, preferLocal: true });
                    content = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.readAsDataURL(blob);
                    });
                }
                const isVideo = item.type === 'video' || url.startsWith('data:video') || isVideoUrl(url);
                const ext = getDataUrlExt(content, isVideo ? '.mp4' : '.png');
                const resolvedProjectTitle = item.projectTitle || (projectName && projectName !== '未命名项目' ? projectName : '');
                const baseLabel = [resolvedProjectTitle, item.prompt].filter(Boolean).join('-')
                    || getFilenameFromUrl(url)
                    || item.name
                    || 'tapnow';
                let baseName = sanitizeCacheId(baseLabel) || 'tapnow';
                baseName = baseName.slice(0, 80);
                const nextIndex = (nameCounters.get(baseName) || 0) + 1;
                nameCounters.set(baseName, nextIndex);
                const rawKey = item.dedupeKey || item.originalUrl || url;
                const dedupeKey = getFilenameFromUrl(rawKey) || rawKey;
                files.push({
                    filename: `${baseName}-${nextIndex}${ext}`,
                    content,
                    sourceUrl: url,
                    dedupeKey,
                    scopedKey: item.scopedKey || '',
                    type: isVideo ? 'video' : 'image'
                });
            } catch (err) {
                console.warn('[保存到本地] 读取资源失败:', err);
            }
        }
        return files;
    }, [fetchCacheSource, getDataUrlExt, getFilenameFromUrl, sanitizeCacheId, projectName, getProxyPreferenceForUrl]);

    const getLocalSaveBaseUrl = useCallback((node) => {
        const raw = (node?.settings?.serverUrl || localServerUrl || '').trim();
        return raw.replace(/\/+$/, '');
    }, [localServerUrl]);

    const runLocalSaveBatch = useCallback(async (node, mediaItems, options = {}) => {
        const silent = options.silent === true;
        const baseUrl = getLocalSaveBaseUrl(node);
        if (!baseUrl) {
            if (!silent) showToast('本地服务地址为空', 'error');
            return;
        }

        const lastSavedKeys = node.settings?.lastSavedUrls || [];
        const subfolderScope = (node.settings?.subfolder || '').trim();
        const dedupeScope = `${baseUrl}::${subfolderScope}`;
        const itemsWithKeys = mediaItems.map((item) => {
            if (!item) return item;
            const rawKey = item.dedupeKey || item.originalUrl || item.url;
            const dedupeKey = rawKey ? (getFilenameFromUrl(rawKey) || rawKey) : '';
            const scopedKey = dedupeKey ? `${dedupeScope}::${dedupeKey}` : '';
            const legacyDuplicate = !subfolderScope && dedupeKey && lastSavedKeys.includes(dedupeKey);
            const isDuplicate = (scopedKey && lastSavedKeys.includes(scopedKey)) || legacyDuplicate;
            return { ...item, dedupeKey, scopedKey, isDuplicate };
        });
        const dedupedItems = itemsWithKeys.filter(item => item?.url && item.scopedKey && !item.isDuplicate);
        const skippedCount = itemsWithKeys.filter(item => item?.url && item.scopedKey && item.isDuplicate).length;
        if (dedupedItems.length === 0) {
            if (!silent) showToast('已保存过，未重复保存', 'success');
            return;
        }

        const files = await buildLocalSaveFiles(dedupedItems, { useProxyResolver: getItemProxyPreference, proxyBaseUrl: baseUrl });
        if (files.length === 0) {
            if (!silent) showToast('没有可保存的文件', 'warning');
            return;
        }

        let res;
        try {
            res = await fetch(`${baseUrl}/save-batch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    files,
                    subfolder: node.settings?.subfolder || ''
                })
            });
        } catch (err) {
            if (!silent) showToast('连接失败，请检查本地服务地址', 'error');
            throw err;
        }

        if (!res.ok) {
            const errText = await res.text();
            throw new Error(errText || '保存失败');
        }

        const result = await res.json();
        const results = result.results || [];
        const savedKeys = results
            .map((item, idx) => item?.success ? (files[idx]?.scopedKey || dedupedItems[idx]?.scopedKey) : null)
            .filter(Boolean);
        const mergedSavedUrls = Array.from(new Set([...(node.settings?.lastSavedUrls || []), ...savedKeys]));
        updateNodeSettings(node.id, {
            lastSavedUrls: mergedSavedUrls,
            lastSaved: new Date().toLocaleString(),
            savedFiles: [...(node.settings?.savedFiles || []), ...results.map(r => r.path).filter(Boolean)]
        });
        const successCount = results.filter(r => r.success).length;
        if (!silent) {
            const skipSuffix = skippedCount > 0 ? `，已跳过 ${skippedCount} 个重复` : '';
            showToast(result.message || `已保存 ${successCount} 个文件${skipSuffix}`, 'success');
        }
    }, [buildLocalSaveFiles, getFilenameFromUrl, getItemProxyPreference, getLocalSaveBaseUrl, showToast]);

    const testLocalSaveServer = useCallback(async (nodeId, rawUrl) => {
        const baseUrl = (rawUrl || localServerUrl || '').trim().replace(/\/+$/, '');
        if (!baseUrl) {
            showToast('请输入本地服务地址', 'warning');
            return;
        }
        updateNodeSettings(nodeId, { serverStatus: 'checking' });
        try {
            const res = await fetch(`${baseUrl}/ping`, { method: 'GET' });
            if (res.ok) {
                updateNodeSettings(nodeId, { serverStatus: 'connected' });
                showToast('本地服务已连接', 'success');
                return;
            }
        } catch (e) { }
        updateNodeSettings(nodeId, { serverStatus: 'disconnected' });
        showToast('本地服务连接失败', 'error');
    }, [localServerUrl, showToast, updateNodeSettings]);

    // V2.6.1 Feature: 自动保存功能 (local-save节点)
    const autoSaveProcessingRef = useRef(new Set());
    useEffect(() => {
        const localSaveNodes = nodes.filter(n => n.type === 'local-save' && n.settings?.autoSave);
        if (localSaveNodes.length === 0) return;

        localSaveNodes.forEach(async (node) => {
            const baseUrl = getLocalSaveBaseUrl(node);
            if (!baseUrl) return;
            const connectedItems = getLocalSaveMediaItems(node.id);
            if (connectedItems.length === 0) return;

            const lastSavedKeys = node.settings?.lastSavedUrls || [];
            const subfolderScope = (node.settings?.subfolder || '').trim();
            const dedupeScope = `${baseUrl}::${subfolderScope}`;
            const newItems = connectedItems.filter(item => {
                const rawKey = item?.originalUrl || item?.url;
                const dedupeKey = rawKey ? (getFilenameFromUrl(rawKey) || rawKey) : '';
                const scopedKey = dedupeKey ? `${dedupeScope}::${dedupeKey}` : '';
                const legacyDuplicate = !subfolderScope && dedupeKey && lastSavedKeys.includes(dedupeKey);
                const isDuplicate = (scopedKey && lastSavedKeys.includes(scopedKey)) || legacyDuplicate;
                return scopedKey && !isDuplicate;
            });
            if (newItems.length === 0) return;

            const processKey = `${node.id}-${newItems.map(item => item.url).join('|')}`;
            if (autoSaveProcessingRef.current.has(processKey)) return;
            autoSaveProcessingRef.current.add(processKey);

            setTimeout(async () => {
                try {
                    await runLocalSaveBatch(node, newItems, { silent: true });
                } catch (err) {
                    console.error('自动保存失败:', err);
                } finally {
                    autoSaveProcessingRef.current.delete(processKey);
                }
            }, 1000);
        });
    }, [nodes, history, getLocalSaveMediaItems, runLocalSaveBatch, getLocalSaveBaseUrl, getFilenameFromUrl]);

    const handleChatResizeStart = (e) => { e.preventDefault(); setIsResizingChat(true); };
    const [isResizingChat, setIsResizingChat] = useState(false);

    const handleChatResizeMove = useCallback((e) => {
        if (!isResizingChat) return;
        const newWidth = window.innerWidth - e.clientX;
        setChatWidth(Math.max(300, Math.min(newWidth, 800)));
    }, [isResizingChat]);

    const handleChatResizeEnd = useCallback(() => {
        setIsResizingChat(false);
    }, []);

    // 屏蔽滚轮事件相关的控制台错误（passive 事件监听器错误）- 双重保护
    useEffect(() => {
        const originalError = console.error;
        const originalWarn = console.warn;

        const shouldFilter = (args) => {
            const msg = args.map(arg => {
                if (typeof arg === 'string') return arg;
                if (arg && arg.toString) return arg.toString();
                return '';
            }).join(' ');
            return msg.includes('Unable to preventDefault') ||
                msg.includes('passive event listener') ||
                (msg.includes('preventDefault') && msg.includes('passive'));
        };

        console.error = function (...args) {
            if (shouldFilter(args)) return;
            originalError.apply(console, args);
        };

        console.warn = function (...args) {
            if (shouldFilter(args)) return;
            originalWarn.apply(console, args);
        };

        return () => {
            console.error = originalError;
            console.warn = originalWarn;
        };
    }, []);

    // 全局禁止 Ctrl+滚轮 缩放（捕获阶段，阻止浏览器缩放）；使用 try-catch 避免控制台报错
    useEffect(() => {
        const preventCtrlZoom = (e) => {
            if (!e.ctrlKey) return;
            try {
                if (e.cancelable) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            } catch (err) {
                // 静默处理 passive 事件监听器的错误
            }
        };

        const opts = { passive: false, capture: true };
        window.addEventListener('wheel', preventCtrlZoom, opts);
        document.addEventListener('wheel', preventCtrlZoom, opts);
        window.addEventListener('mousewheel', preventCtrlZoom, opts);
        document.addEventListener('mousewheel', preventCtrlZoom, opts);

        return () => {
            window.removeEventListener('wheel', preventCtrlZoom, opts);
            document.removeEventListener('wheel', preventCtrlZoom, opts);
            window.removeEventListener('mousewheel', preventCtrlZoom, opts);
            document.removeEventListener('mousewheel', preventCtrlZoom, opts);
        };
    }, []);

    // 使用原生事件监听器绑定 handleWheel，避免 React 合成事件的 passive 问题
    useEffect(() => {
        const canvasElement = canvasRef.current;
        if (!canvasElement) return;

        const wheelHandler = (e) => {
            // 如果按下了 Ctrl 键，直接阻止默认行为并不执行任何操作；使用 try-catch 避免控制台报错
            if (e.ctrlKey) {
                try {
                    if (e.cancelable) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                } catch (err) {
                    // 静默处理 passive 事件监听器的错误
                }
                return;
            }

            // 检查鼠标是否在视频输入、视频拆解或智能分镜表节点内
            const target = e.target;
            let isInsideNode = false;
            let scrollableElement = null;

            // V3.7.28: 优先检查目标是否是可滚动的 textarea
            if (target.tagName === 'TEXTAREA' && (target.scrollHeight > target.clientHeight)) {
                try {
                    if (e.cancelable) {
                        e.preventDefault();
                    }
                } catch (err) { }
                const maxScroll = target.scrollHeight - target.clientHeight;
                const currentScroll = target.scrollTop;
                const newScroll = Math.max(0, Math.min(maxScroll, currentScroll + e.deltaY));
                target.scrollTop = newScroll;
                return;
            }

            // 向上查找父元素，检查是否在 video-input、video-analyze 或 storyboard-node 节点内
            let current = target;
            while (current && current !== canvasElement) {
                if (current.classList) {
                    // 检查是否是智能分镜表容器（通过检查是否有特定的类组合）
                    const isStoryboardContainer = current.classList.contains('flex') &&
                        current.classList.contains('flex-col') &&
                        current.classList.contains('h-full') &&
                        current.classList.contains('rounded-xl') &&
                        current.classList.contains('overflow-hidden');

                    // 检查当前元素或父元素是否包含节点容器类
                    if (current.classList.contains('video-input-container') ||
                        current.classList.contains('video-analyze-container') ||
                        isStoryboardContainer) {
                        isInsideNode = true;

                        // 如果是智能分镜表，查找特定的滚动容器
                        if (isStoryboardContainer) {
                            scrollableElement = current.querySelector('.flex-1.overflow-y-auto.custom-scrollbar');
                            if (!scrollableElement) {
                                scrollableElement = current.querySelector('.flex-1.overflow-y-auto');
                            }
                        } else {
                            // 在当前容器内查找可滚动的元素
                            scrollableElement = current.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                            if (!scrollableElement) {
                                // 如果没找到，检查当前元素本身是否可滚动
                                const style = window.getComputedStyle(current);
                                if (style.overflowY === 'auto' || style.overflowY === 'scroll' ||
                                    current.classList.contains('custom-scrollbar')) {
                                    scrollableElement = current;
                                }
                            }
                        }
                        break;
                    }

                    // 使用 closest 方法查找最近的容器
                    const container = current.closest('.video-input-container, .video-analyze-container');
                    if (container) {
                        isInsideNode = true;
                        scrollableElement = container.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                        if (!scrollableElement) {
                            const style = window.getComputedStyle(container);
                            if (style.overflowY === 'auto' || style.overflowY === 'scroll') {
                                scrollableElement = container;
                            }
                        }
                        break;
                    }

                    // 检查是否是智能分镜表容器
                    const storyboardContainer = current.closest('.flex.flex-col.h-full.rounded-xl.overflow-hidden');
                    if (storyboardContainer) {
                        isInsideNode = true;
                        scrollableElement = storyboardContainer.querySelector('.flex-1.overflow-y-auto.custom-scrollbar');
                        if (!scrollableElement) {
                            scrollableElement = storyboardContainer.querySelector('.flex-1.overflow-y-auto');
                        }
                        break;
                    }
                }
                current = current.parentElement;
            }

            // 如果在节点内且找到可滚动元素，则滚动该元素而不是缩放画布
            if (isInsideNode && scrollableElement) {
                try {
                    if (e.cancelable) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                } catch (err) {
                    // 静默处理 passive 事件监听器的错误
                }
                const maxScroll = scrollableElement.scrollHeight - scrollableElement.clientHeight;
                const currentScroll = scrollableElement.scrollTop;
                const newScroll = Math.max(0, Math.min(maxScroll, currentScroll + e.deltaY));
                scrollableElement.scrollTop = newScroll;
                return;
            }

            // 否则正常缩放画布
            try {
                if (e.cancelable) {
                    e.preventDefault();
                }
            } catch (err) {
                // 静默处理 passive 事件监听器的错误
            }
            const rect = canvasElement.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            setView((prev) => {
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                let newZoom = Math.min(Math.max(prev.zoom * zoomFactor, 0.2), 3);
                const scale = newZoom / prev.zoom;
                return { zoom: newZoom, x: mouseX - (mouseX - prev.x) * scale, y: mouseY - (mouseY - prev.y) * scale };
            });
        };

        // 使用 { passive: false } 确保可以调用 preventDefault
        canvasElement.addEventListener('wheel', wheelHandler, { passive: false });

        return () => {
            canvasElement.removeEventListener('wheel', wheelHandler);
        };
    }, [view]);

    useEffect(() => {
        if (isResizingChat) {
            window.addEventListener('mousemove', handleChatResizeMove);
            window.addEventListener('mouseup', handleChatResizeEnd);
        } else {
            window.removeEventListener('mousemove', handleChatResizeMove);
            window.removeEventListener('mouseup', handleChatResizeEnd);
        }
        return () => {
            window.removeEventListener('mousemove', handleChatResizeMove);
            window.removeEventListener('mouseup', handleChatResizeEnd);
        };
    }, [isResizingChat, handleChatResizeMove, handleChatResizeEnd]);

    const screenToWorld = useCallback((sx, sy) => {
        const rect = canvasRef.current?.getBoundingClientRect();
        const localX = rect ? sx - rect.left : sx;
        const localY = rect ? sy - rect.top : sy;
        return { x: (localX - view.x) / view.zoom, y: (localY - view.y) / view.zoom };
    }, [view]);

    const handleWheel = (e) => {
        // 如果按下了 Ctrl 键，直接阻止默认行为并不执行任何操作；使用 try-catch 避免控制台报错
        if (e.ctrlKey) {
            try {
                if (e.cancelable) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            } catch (err) {
                // 静默处理 passive 事件监听器的错误
            }
            return;
        }

        // 检查鼠标是否在视频输入或视频拆解节点内
        const target = e.target;
        let isInsideNode = false;
        let scrollableElement = null;

        // 向上查找父元素，检查是否在 video-input 或 video-analyze 节点内
        let current = target;
        while (current && current !== e.currentTarget) {
            if (current.classList) {
                // 检查当前元素或父元素是否包含节点容器类
                if (current.classList.contains('video-input-container') ||
                    current.classList.contains('video-analyze-container')) {
                    isInsideNode = true;
                    // 在当前容器内查找可滚动的元素
                    scrollableElement = current.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                    if (!scrollableElement) {
                        // 如果没找到，检查当前元素本身是否可滚动
                        const style = window.getComputedStyle(current);
                        if (style.overflowY === 'auto' || style.overflowY === 'scroll' ||
                            current.classList.contains('custom-scrollbar')) {
                            scrollableElement = current;
                        }
                    }
                    break;
                }
                // 使用 closest 方法查找最近的容器
                const container = current.closest('.video-input-container, .video-analyze-container');
                if (container) {
                    isInsideNode = true;
                    scrollableElement = container.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                    if (!scrollableElement) {
                        const style = window.getComputedStyle(container);
                        if (style.overflowY === 'auto' || style.overflowY === 'scroll') {
                            scrollableElement = container;
                        }
                    }
                    break;
                }
            }
            current = current.parentElement;
        }

        // 如果在节点内且找到可滚动元素，则滚动该元素而不是缩放画布
        if (isInsideNode && scrollableElement) {
            try {
                if (e.cancelable) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            } catch (err) {
                // 静默处理 passive 事件监听器的错误
            }
            const maxScroll = scrollableElement.scrollHeight - scrollableElement.clientHeight;
            const currentScroll = scrollableElement.scrollTop;
            const newScroll = Math.max(0, Math.min(maxScroll, currentScroll + e.deltaY));
            scrollableElement.scrollTop = newScroll;
            return;
        }

        // 否则正常缩放画布
        try {
            if (e.cancelable) {
                e.preventDefault();
            }
        } catch (err) {
            // 静默处理 passive 事件监听器的错误
        }
        const rect = e.currentTarget.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        setView((prev) => {
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            let newZoom = Math.min(Math.max(prev.zoom * zoomFactor, 0.2), 3);
            const scale = newZoom / prev.zoom;
            return { zoom: newZoom, x: mouseX - (mouseX - prev.x) * scale, y: mouseY - (mouseY - prev.y) * scale };
        });
    };

    const handleMouseDown = (e) => {
        if (e.button === 0 || e.button === 1) {
            if (e.currentTarget.id === 'canvas-bg') {
                // Check if clicking on interactive elements
                const target = e.target;
                if (target && (
                    target.tagName === 'INPUT' ||
                    target.tagName === 'TEXTAREA' ||
                    target.tagName === 'SELECT' ||
                    target.tagName === 'BUTTON' ||
                    target.isContentEditable ||
                    target.closest('input, textarea, select, button, [contenteditable="true"]')
                )) {
                    return; // Do not handle drag if clicking on interactive element
                }

                // Auto-clear text selection if we are starting a drag on the canvas background
                // This improves UX by preventing dragging from being "stuck" due to accidental text selection
                const selection = window.getSelection();
                if (selection && selection.toString().length > 0) {
                    selection.removeAllRanges();
                }
                // 检测Ctrl+鼠标左键，开始框选
                if (e.button === 0 && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    setIsSelecting(true);
                    isSelectingRef.current = true; // 设置ref标志
                    setIsPanning(false);
                    const rect = canvasRef.current?.getBoundingClientRect();
                    const startX = e.clientX - (rect?.left || 0);
                    const startY = e.clientY - (rect?.top || 0);
                    setSelectionBox({ startX, startY, endX: startX, endY: startY });
                    setSelectedNodeIds(new Set()); // 清空之前的选择
                    setSelectedNodeId(null);
                    return;
                }
                // 普通拖动画布（只有在不是框选状态时才能拖拽）
                // 修复：无论是否选中节点，只要点击的是 canvas-bg，都应该允许拖动
                if (!isSelectingRef.current) {
                    setIsPanning(true);
                    isPanningRef.current = true; // 同步ref状态
                    setIsDragging(false);
                    lastMousePos.current = { x: e.clientX, y: e.clientY };
                }
            }
        }
    };

    const nodeUpdateRef = useRef(null);
    const nodeUpdateRaf = useRef(null);
    const multiNodeUpdateRef = useRef(null); // 多节点更新ref

    const flushNodeUpdate = useCallback(() => {
        // 优先处理多节点更新
        if (multiNodeUpdateRef.current) {
            const updates = multiNodeUpdateRef.current;
            // 处理大量节点时的性能优化：使用 Map 优化查找（O(1) 而不是 O(n)）
            const nodeIdMap = new Map(updates.map(({ nodeId }) => [nodeId, true]));

            setNodes((prev) => {
                // 对于大量节点（50+），使用更高效的更新策略
                if (prev.length > 50 && updates.length > 10) {
                    // 创建节点索引映射，避免重复查找
                    const nodeIndexMap = new Map();
                    prev.forEach((node, idx) => {
                        if (nodeIdMap.has(node.id)) {
                            nodeIndexMap.set(node.id, idx);
                        }
                    });

                    // 批量更新，减少数组操作
                    const next = [...prev];
                    let hasChanges = false;
                    updates.forEach(({ nodeId, updater }) => {
                        const idx = nodeIndexMap.get(nodeId);
                        if (idx !== undefined) {
                            const updatedNode = updater(next[idx]);
                            if (updatedNode !== next[idx]) {
                                next[idx] = updatedNode;
                                hasChanges = true;
                            }
                        }
                    });
                    return hasChanges ? next : prev;
                } else {
                    // 少量节点时使用原有逻辑
                    const next = [...prev];
                    let hasChanges = false;
                    updates.forEach(({ nodeId, updater }) => {
                        const idx = next.findIndex((n) => n.id === nodeId);
                        if (idx !== -1) {
                            const updatedNode = updater(next[idx]);
                            if (updatedNode !== next[idx]) {
                                next[idx] = updatedNode;
                                hasChanges = true;
                            }
                        }
                    });
                    return hasChanges ? next : prev;
                }
            });
            multiNodeUpdateRef.current = null;
            nodeUpdateRaf.current = null;
            return;
        }

        if (!nodeUpdateRef.current) {
            nodeUpdateRaf.current = null;
            return;
        }
        const { nodeId, updater } = nodeUpdateRef.current;
        setNodes((prev) => {
            const idx = prev.findIndex((n) => n.id === nodeId);
            if (idx === -1) return prev;
            // 使用函数式更新，避免创建新数组的开销
            const updatedNode = updater(prev[idx]);
            // 如果节点没有变化，直接返回原数组（引用相等检查）
            if (updatedNode === prev[idx]) return prev;
            const next = [...prev];
            next[idx] = updatedNode;
            return next;
        });
        nodeUpdateRef.current = null;
        nodeUpdateRaf.current = null;
    }, []);

    const scheduleNodeUpdate = useCallback((nodeId, updater) => {
        nodeUpdateRef.current = { nodeId, updater };
        if (!nodeUpdateRaf.current) {
            nodeUpdateRaf.current = requestAnimationFrame(flushNodeUpdate);
        }
    }, [flushNodeUpdate]);

    const scheduleMultiNodeUpdate = useCallback((updates) => {
        // 处理竞态条件：如果已有待处理的更新，合并而不是覆盖
        // 这样可以确保快速连续操作时不会丢失更新
        if (multiNodeUpdateRef.current && nodeUpdateRaf.current) {
            // 合并更新：对于相同的 nodeId，使用最新的 updater
            const existingUpdates = multiNodeUpdateRef.current;
            const updateMap = new Map();

            // 先添加现有更新
            existingUpdates.forEach(({ nodeId, updater }) => {
                updateMap.set(nodeId, updater);
            });

            // 然后添加新更新（会覆盖相同 nodeId 的旧更新）
            updates.forEach(({ nodeId, updater }) => {
                updateMap.set(nodeId, updater);
            });

            // 转换回数组格式
            multiNodeUpdateRef.current = Array.from(updateMap.entries()).map(([nodeId, updater]) => ({
                nodeId,
                updater
            }));
        } else {
            // 没有待处理的更新，直接设置
            multiNodeUpdateRef.current = updates;
        }

        if (!nodeUpdateRaf.current) {
            nodeUpdateRaf.current = requestAnimationFrame(flushNodeUpdate);
        }
    }, [flushNodeUpdate]);

    useEffect(() => {
        return () => {
            if (nodeUpdateRaf.current) {
                cancelAnimationFrame(nodeUpdateRaf.current);
            }
            if (panRafRef.current) {
                cancelAnimationFrame(panRafRef.current);
            }
        };
    }, []);

    // 使用 requestAnimationFrame 节流框选逻辑
    const selectionRafRef = useRef(null);
    const pendingSelectionUpdate = useRef(null);

    const handleMouseMove = useCallback((e) => {
        const { clientX, clientY } = e;
        const worldPos = screenToWorld(clientX, clientY);
        setMousePos(worldPos);

        // 框选模式 - 使用 requestAnimationFrame 节流
        // 使用ref检查，确保即使Ctrl松开也能继续框选
        if (isSelecting || isSelectingRef.current) {
            // 如果isSelecting为false但ref为true，说明Ctrl松开了，但框选应该继续
            if (!isSelecting) {
                setIsSelecting(true);
            }
            const rect = canvasRef.current?.getBoundingClientRect();
            const endX = clientX - (rect?.left || 0);
            const endY = clientY - (rect?.top || 0);

            // 立即更新框选框位置（视觉反馈）
            setSelectionBox(prev => {
                if (!prev) return null;
                return { ...prev, endX, endY };
            });

            // 节流节点选择计算
            pendingSelectionUpdate.current = { endX, endY, rect };

            if (!selectionRafRef.current) {
                selectionRafRef.current = requestAnimationFrame(() => {
                    if (!pendingSelectionUpdate.current) {
                        selectionRafRef.current = null;
                        return;
                    }

                    const { endX, endY, rect } = pendingSelectionUpdate.current;
                    const currentSelectionBox = selectionBox;
                    if (!currentSelectionBox) {
                        selectionRafRef.current = null;
                        return;
                    }

                    // 计算被框选的节点
                    const boxStartX = Math.min(currentSelectionBox.startX, endX);
                    const boxStartY = Math.min(currentSelectionBox.startY, endY);
                    const boxEndX = Math.max(currentSelectionBox.startX, endX);
                    const boxEndY = Math.max(currentSelectionBox.startY, endY);

                    // 将屏幕坐标转换为世界坐标
                    const worldStart = screenToWorld(boxStartX + (rect?.left || 0), boxStartY + (rect?.top || 0));
                    const worldEnd = screenToWorld(boxEndX + (rect?.left || 0), boxEndY + (rect?.top || 0));

                    // 使用 ref 获取最新的 nodes，避免闭包问题
                    const currentNodes = nodesRef.current;
                    const selected = new Set();
                    currentNodes.forEach(node => {
                        // V3.5.11: 添加默认尺寸，修复缩放后无法框选的问题
                        const nodeRight = node.x + (node.width || 260);
                        const nodeBottom = node.y + (node.height || 200);
                        // 检查节点是否与框选框相交
                        if (node.x < worldEnd.x && nodeRight > worldStart.x &&
                            node.y < worldEnd.y && nodeBottom > worldStart.y) {
                            selected.add(node.id);
                        }
                    });
                    setSelectedNodeIds(selected);

                    pendingSelectionUpdate.current = null;
                    selectionRafRef.current = null;
                });
            }
            return;
        }

        // 只有在不是框选状态时才能拖拽画布
        // 使用 ref 检查，确保即使状态更新延迟也能继续拖动
        if ((isPanning || isPanningRef.current) && !isSelectingRef.current) {
            setIsDragging(true);
            const dx = clientX - lastMousePos.current.x;
            const dy = clientY - lastMousePos.current.y;

            // 添加阈值判断，忽略微小移动（<1px）避免不必要的重渲染
            if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
                return;
            }

            // 使用 requestAnimationFrame 节流画布拖动更新，提升性能
            // 累积移动距离，而不是只保留最后一次
            if (pendingPanUpdate.current) {
                pendingPanUpdate.current.dx += dx;
                pendingPanUpdate.current.dy += dy;
            } else {
                pendingPanUpdate.current = { dx, dy };
            }

            if (!panRafRef.current) {
                panRafRef.current = requestAnimationFrame(() => {
                    if (!pendingPanUpdate.current) {
                        panRafRef.current = null;
                        return;
                    }

                    const { dx, dy } = pendingPanUpdate.current;
                    // 使用函数式更新，避免依赖 view
                    // 使用 Math.round 处理高缩放级别下的浮点数精度问题
                    // 添加 zoom 边界检查，防止极端缩放下的位置漂移
                    setView((prev) => {
                        // 确保 zoom 在有效范围内（0.2-3.0）
                        const safeZoom = Math.max(0.2, Math.min(3.0, prev.zoom));
                        // 在极端缩放下使用更高精度的舍入
                        const precision = safeZoom < 0.5 || safeZoom > 2.5 ? 1000 : 100;
                        return {
                            ...prev,
                            zoom: safeZoom,
                            x: Math.round((prev.x + dx) * precision) / precision,
                            y: Math.round((prev.y + dy) * precision) / precision
                        };
                    });

                    pendingPanUpdate.current = null;
                    panRafRef.current = null;
                });
            }

            lastMousePos.current = { x: clientX, y: clientY };
            return;
        }

        if (resizingNodeId) {
            scheduleNodeUpdate(resizingNodeId, (node) => ({
                ...node,
                width: Math.max(250, worldPos.x - node.x),
                height: Math.max(250, worldPos.y - node.y)
            }));
        } else if (dragNodeId) {
            // 确保 zoom 在有效范围内（0.2-3.0），防止极端缩放下的计算错误
            const safeZoom = Math.max(0.2, Math.min(3.0, view.zoom));
            // 使用 movementX/Y 更流畅，避免频繁计算
            const deltaX = e.movementX / safeZoom;
            const deltaY = e.movementY / safeZoom;
            // 添加阈值，避免微小移动触发更新（提高到1px，减少不必要的更新）
            // 在极端缩放下使用更小的阈值
            const threshold = safeZoom < 0.5 || safeZoom > 2.5 ? 0.5 : 1;
            if (Math.abs(deltaX) < threshold && Math.abs(deltaY) < threshold) {
                return;
            }

            // 使用 ref 获取最新的多选节点集合，避免闭包问题
            const currentSelectedNodeIds = selectedNodeIdsRef.current;
            // 如果有多选节点（大于1个）且被拖动的节点在选中集合中，同时拖动所有选中的节点
            if (currentSelectedNodeIds && currentSelectedNodeIds.size > 1 && currentSelectedNodeIds.has(dragNodeId)) {
                // 拖动多个节点时，使用批量更新
                // 使用累积的起始位置计算，防止累积误差
                const currentNodes = nodesRef.current;
                // 确保 zoom 在有效范围内（0.2-3.0），防止极端缩放下的计算错误
                const currentZoom = Math.max(0.2, Math.min(3.0, view.zoom));
                // 检测缩放切换：如果 zoom 发生变化，重新初始化起始位置，防止状态不一致
                if (!multiNodeDragStartPos.current || (lastZoomRef.current !== null && Math.abs(lastZoomRef.current - currentZoom) > 0.01)) {
                    // 初始化或重新初始化起始位置（缩放切换时）
                    multiNodeDragStartPos.current = {
                        mouseX: clientX,
                        mouseY: clientY,
                        nodes: new Map(Array.from(currentSelectedNodeIds).map(nodeId => {
                            const node = currentNodes.find(n => n.id === nodeId);
                            return node ? [nodeId, { x: node.x, y: node.y }] : null;
                        }).filter(Boolean))
                    };
                }
                lastZoomRef.current = currentZoom;

                // 计算从起始位置到当前位置的总偏移量（世界坐标）
                const totalDeltaX = (clientX - multiNodeDragStartPos.current.mouseX) / currentZoom;
                const totalDeltaY = (clientY - multiNodeDragStartPos.current.mouseY) / currentZoom;

                // 使用起始位置 + 总偏移量，避免累积误差
                const updates = Array.from(multiNodeDragStartPos.current.nodes.entries()).map(([nodeId, startPos]) => ({
                    nodeId,
                    updater: (node) => ({
                        ...node,
                        x: startPos.x + totalDeltaX,
                        y: startPos.y + totalDeltaY
                    })
                }));
                scheduleMultiNodeUpdate(updates);
            } else {
                // 单节点拖动，重置多节点拖动状态
                multiNodeDragStartPos.current = null;
                scheduleNodeUpdate(dragNodeId, (node) => ({
                    ...node,
                    x: node.x + deltaX,
                    y: node.y + deltaY
                }));
            }
        }
    }, [isPanning, isSelecting, selectionBox, dragNodeId, resizingNodeId, screenToWorld, view.zoom, scheduleNodeUpdate, scheduleMultiNodeUpdate]);

    const handleMouseUp = () => {
        // 清理画布拖动的 requestAnimationFrame
        if (panRafRef.current) {
            cancelAnimationFrame(panRafRef.current);
            panRafRef.current = null;
        }
        // 处理待处理的画布拖动更新
        if (pendingPanUpdate.current) {
            const { dx, dy } = pendingPanUpdate.current;
            // 使用 Math.round 处理高缩放级别下的浮点数精度问题
            // 添加 zoom 边界检查，防止极端缩放下的位置漂移
            setView((prev) => {
                // 确保 zoom 在有效范围内（0.2-3.0）
                const safeZoom = Math.max(0.2, Math.min(3.0, prev.zoom));
                // 在极端缩放下使用更高精度的舍入
                const precision = safeZoom < 0.5 || safeZoom > 2.5 ? 1000 : 100;
                return {
                    ...prev,
                    zoom: safeZoom,
                    x: Math.round((prev.x + dx) * precision) / precision,
                    y: Math.round((prev.y + dy) * precision) / precision
                };
            });
            pendingPanUpdate.current = null;
        }

        // 确保多节点更新被刷新（处理待处理的更新）
        if (multiNodeUpdateRef.current && nodeUpdateRaf.current) {
            // 取消当前的 RAF，立即执行更新
            cancelAnimationFrame(nodeUpdateRaf.current);
            flushNodeUpdate();
        }

        // 结束框选
        if (isSelecting || isSelectingRef.current) {
            setIsSelecting(false);
            isSelectingRef.current = false; // 重置 ref 状态
            setSelectionBox(null);
            // 如果只选中一个节点，设置selectedNodeId
            if (selectedNodeIds.size === 1) {
                const nodeId = Array.from(selectedNodeIds)[0];
                setSelectedNodeId(nodeId);
            } else if (selectedNodeIds.size === 0) {
                setSelectedNodeId(null);
            }
            // 确保清理拖动状态
            setIsDragging(false);
            setIsPanning(false);
            isPanningRef.current = false;
            // 清理多节点拖动状态
            multiNodeDragStartPos.current = null;
            // 清理 zoom 跟踪，防止缩放切换导致的状态不一致
            lastZoomRef.current = null;
            return;
        }

        if (isPanning || isPanningRef.current) {
            setIsPanning(false);
            isPanningRef.current = false;
            setIsDragging(false); // 确保清理拖动状态
            if (!connectingSource && !connectingTarget && !dragNodeId && !resizingNodeId) {
                setSelectedNodeId(null);
                setSelectedNodeIds(new Set());
                setContextMenu(prev => ({ ...prev, visible: false }));
                setActiveDropdown(null);
                setHistoryContextMenu(prev => ({ ...prev, visible: false }));
            }
        }
        if (!connectingSource && !connectingTarget) {
            setDragNodeId(null);
            setResizingNodeId(null);
            // 清理多节点拖动状态
            multiNodeDragStartPos.current = null;
            // 清理 zoom 跟踪
            lastZoomRef.current = null;
        }
        // 确保在所有情况下都清理拖动状态
        setIsDragging(false);
        // 重置 isSelectingRef（防止状态残留）
        isSelectingRef.current = false;
        // 重置 lastMousePos，防止状态残留导致后续拖动异常
        // 注意：不重置为 null，而是重置为初始值，保持类型一致
        lastMousePos.current = { x: 0, y: 0 };
    };

    // 优化后的全局指针事件监听：解决拖动中断和连线不跟随的问题
    // 使用 pointermove/pointerup 代替 mousemove/mouseup，性能更好且支持触摸
    useEffect(() => {
        // 定义需要全局监听的状态（使用 ref 确保状态不丢失）
        const isInteracting = isPanning || isPanningRef.current || isDragging || dragNodeId || resizingNodeId || isSelecting || isSelectingRef.current || connectingSource || connectingTarget;

        if (!isInteracting) return;

        const handleGlobalPointerMove = (e) => {
            // 确保在任何交互状态下都更新鼠标位置
            // pointer 事件和 mouse 事件在大多数属性上是兼容的，直接传递即可
            // 如果 movementX/Y 不存在，则使用 0（不影响功能，因为画布拖动使用 clientX/Y 差值）
            if (e.movementX === undefined) {
                e.movementX = 0;
            }
            if (e.movementY === undefined) {
                e.movementY = 0;
            }
            handleMouseMove(e);
        };

        const handleGlobalMouseMove = (e) => {
            // mousemove 事件处理（降级方案）
            handleMouseMove(e);
        };

        const handleGlobalPointerUp = () => {
            handleMouseUp();
        };

        const handleGlobalMouseUp = () => {
            // mouseup 事件处理（降级方案）
            handleMouseUp();
        };

        // V3.5.20-1: 只使用 pointer 事件，移除重复的 mouse 事件监听（现代浏览器都支持 pointer）
        window.addEventListener('pointermove', handleGlobalPointerMove, { passive: false });
        window.addEventListener('pointerup', handleGlobalPointerUp, { passive: false });

        return () => {
            window.removeEventListener('pointermove', handleGlobalPointerMove);
            window.removeEventListener('pointerup', handleGlobalPointerUp);
        };
    }, [isPanning, isDragging, dragNodeId, resizingNodeId, isSelecting, connectingSource, connectingTarget, handleMouseMove, handleMouseUp]);

    const handleNodeMouseUp = useCallback((targetId, e, inputType = 'default') => {
        e.stopPropagation();
        // 从输出端口连接到输入端口（原有逻辑）
        if (connectingSource && connectingSource !== targetId) {
            // 检查是否已存在相同输入点的连接
            const exists = connections.some((c) =>
                c.from === connectingSource &&
                c.to === targetId &&
                (c.inputType || 'default') === inputType
            );
            if (!exists) {
                // 如果连接到特定输入点，先删除该输入点的旧连接
                if (inputType !== 'default') {
                    setConnections((prev) => prev.filter((c) =>
                        !(c.to === targetId && (c.inputType || 'default') === inputType)
                    ));
                }
                setConnections((prev) => [...prev, {
                    id: `conn-${Date.now()}`,
                    from: connectingSource,
                    to: targetId,
                    inputType: inputType !== 'default' ? inputType : undefined
                }]);
            }
        }
        // 从输入端口连接到输出端口（新功能）
        else if (connectingTarget && connectingTarget !== targetId) {
            // 使用connectingInputType而不是inputType参数（因为是从输入端口开始的连接）
            const actualInputType = connectingInputType || inputType;
            // 检查是否已存在相同输入点的连接
            const exists = connections.some((c) =>
                c.from === targetId &&
                c.to === connectingTarget &&
                (c.inputType || 'default') === actualInputType
            );
            if (!exists) {
                // 如果连接到特定输入点，先删除该输入点的旧连接
                if (actualInputType !== 'default') {
                    setConnections((prev) => prev.filter((c) =>
                        !(c.to === connectingTarget && (c.inputType || 'default') === actualInputType)
                    ));
                }
                setConnections((prev) => [...prev, {
                    id: `conn-${Date.now()}`,
                    from: targetId,
                    to: connectingTarget,
                    inputType: actualInputType !== 'default' ? actualInputType : undefined
                }]);
            }
        }
        setConnectingSource(null);
        setConnectingTarget(null);
        setConnectingInputType(null);
        setHoverTargetId(null);
        setIsPanning(false);
        setDragNodeId(null);
        setResizingNodeId(null);
    }, [connectingSource, connectingTarget, connectingInputType, connections]);

    const handleBackgroundClick = (e) => {
        if (connectingSource) {
            const world = screenToWorld(e.clientX, e.clientY);
            setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, sourceNodeId: connectingSource });
            setContextMenuExpanded(false);
            setConnectingSource(null);
        } else if (connectingTarget) {
            // 从输入端口开始的连接，点击背景时弹出参考图窗口
            const world = screenToWorld(e.clientX, e.clientY);
            setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, targetNodeId: connectingTarget, inputType: connectingInputType });
            setContextMenuExpanded(false);
            setConnectingTarget(null);
            setConnectingInputType(null);
        }
    };

    const handleDoubleClick = (e) => {
        if (e.currentTarget.id === 'canvas-bg') {
            const world = screenToWorld(e.clientX, e.clientY);
            setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, sourceNodeId: undefined });
            setContextMenuExpanded(false);
        }
    };

    // 框选节点右键菜单
    const handleCanvasContextMenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const hasSelection = selectedNodeIds.size > 0 || selectedNodeId;
        if (hasSelection) {
            setSelectionContextMenu({ visible: true, x: e.clientX, y: e.clientY });
        }
    };

    // 使用 useMemo 缓存连接图片的计算结果，避免重复计算
    const connectedImagesCache = useMemo(() => {
        const cache = new Map(); // nodeId -> { inputType -> images[] }
        const resolveConnectedUrl = (url) => {
            if (!url) return url;
            return resolveAssetChannelUrl(url);
        };
        connections.forEach(conn => {
            const inputType = conn.inputType || 'default';
            if (!cache.has(conn.to)) {
                cache.set(conn.to, new Map());
            }
            const nodeConnections = cache.get(conn.to);
            if (!nodeConnections.has(inputType)) {
                nodeConnections.set(inputType, []);
            }
            const sourceNode = nodesMap.get(conn.from);
            if (sourceNode) {
                let images = [];
                // 1. video-input: 返回所选关键帧或首帧
                if (sourceNode.type === 'video-input') {
                    const selected = (sourceNode.selectedKeyframes && sourceNode.selectedKeyframes.length > 0)
                        ? sourceNode.selectedKeyframes.map(f => f.url)
                        : [];
                    if (selected.length > 0) {
                        images = selected.map(resolveConnectedUrl);
                    } else if (sourceNode.frames && sourceNode.frames.length > 0) {
                        images = [resolveConnectedUrl(sourceNode.frames[0].url)];
                    }
                }
                // 2. input-image / gen-image / preview: 返回 content 或 mjImages
                else if (sourceNode.type === 'input-image' || sourceNode.type === 'gen-image' || sourceNode.type === 'preview') {
                    if (sourceNode.content) images.push(resolveConnectedUrl(sourceNode.content));
                    if (sourceNode.previewMjImages) images.push(...sourceNode.previewMjImages.map(resolveConnectedUrl));
                }
                // 3. storyboard-node: 返回活跃镜头的结果或参考图
                // V3.7.12: 只输出 outputEnabled=true 且 selectedImageIndex>=0 的镜头
                else if (sourceNode.type === 'storyboard-node') {
                    const shots = sourceNode.settings?.shots || [];
                    const mode = sourceNode.settings?.mode || 'video';

                    // V3.7.12: 遍历所有允许输出的镜头
                    shots.forEach(s => {
                        // V3.7.12: 只处理 outputEnabled=true 的镜头（灰色按钮控制）
                        if (!s.outputEnabled) {
                            return;
                        }

                        // V3.7.12: 图片模式 - 只有选中了图片才输出
                        if (mode === 'image') {
                            const idx = s.selectedImageIndex ?? -1; // 使用 ?? 避免 0 被视为 falsy
                            // 必须选中才输出 (idx >= 0)
                            if (idx >= 0 && s.output_images && s.output_images.length > 0 && s.output_images[idx]) {
                                images.push(resolveConnectedUrl(s.output_images[idx]));
                            } else {
                            }
                        }
                        // 视频模式或回退逻辑
                        else if (s.output_url) {
                            images.push(resolveConnectedUrl(s.output_url));
                        } else if (s.image_url) {
                            images.push(resolveConnectedUrl(s.image_url));
                        }
                    });
                }

                if (images.length > 0) {
                    nodeConnections.get(inputType).push(...images);
                }
            }
        });
        return cache;
        // V3.7.5: 添加 activeShot 为依赖，确保分镜表切换镜头时缓存失效
    }, [connections, nodesMap, nodes, activeShot, resolveAssetChannelUrl]);

    const getConnectedInputImages = useCallback((targetNodeId, inputType = 'default') => {
        const nodeCache = connectedImagesCache.get(targetNodeId);
        if (!nodeCache) return [];
        return nodeCache.get(inputType) || [];
    }, [connectedImagesCache]);
    // 使用 useMemo 缓存 video-input 节点查找结果
    // V3.4.13: 同时支持 input-image 节点（将图片作为单帧处理）
    const connectedVideoInputCache = useMemo(() => {
        const cache = new Map(); // nodeId -> videoInputNode (或虚拟的图片输入)
        connections.forEach(conn => {
            if (!cache.has(conn.to)) {
                const sourceNode = nodesMap.get(conn.from);
                if (sourceNode) {
                    if (sourceNode.type === 'video-input') {
                        cache.set(conn.to, sourceNode);
                    } else if (sourceNode.type === 'input-image') {
                        // V3.4.13: 将图片节点转换为虚拟视频输入格式
                        // 图片作为单帧处理，用于提示词反推
                        // V3.4.15: 移除content条件，空图片也显示关联信息
                        const virtualVideoInput = {
                            ...sourceNode,
                            type: 'input-image-as-video', // 标记为图片转视频
                            videoFileName: '图片输入',
                            videoMeta: { duration: 0 },
                            frames: sourceNode.content ? [{ time: 0, url: sourceNode.content }] : [],
                            selectedKeyframes: sourceNode.content ? [{ time: 0, url: sourceNode.content }] : [],
                            isImageInput: true
                        };
                        cache.set(conn.to, virtualVideoInput);
                    }
                    // V3.7.16: 将 storyboard-node 转换为虚拟视频输入格式
                    // 让下游的智能分镜节点能正确接收上游智能分镜的输出
                    else if (sourceNode.type === 'storyboard-node') {
                        const shots = sourceNode.settings?.shots || [];
                        const mode = sourceNode.settings?.mode || 'video';
                        const projectTitle = sourceNode.settings?.projectTitle || '分镜输出';

                        // 收集已启用且已选择的图片
                        const selectedFrames = [];
                        shots.forEach((s, idx) => {
                            // 只处理 outputEnabled=true 的镜头
                            if (!s.outputEnabled) return;

                            let imgUrl = null;
                            let filename = s.image_filename || `镜头${idx + 1}`;

                            if (mode === 'image') {
                                // 图片模式：使用 output_images 中选中的图片
                                const selectedIdx = s.selectedImageIndex ?? -1;
                                if (selectedIdx >= 0 && s.output_images && s.output_images[selectedIdx]) {
                                    imgUrl = s.output_images[selectedIdx];
                                }
                            } else {
                                // 视频模式：使用首帧或输出URL
                                imgUrl = s.output_url || s.image_url;
                            }

                            if (imgUrl) {
                                selectedFrames.push({
                                    time: idx,
                                    url: imgUrl,
                                    filename: filename
                                });
                            }
                        });

                        const virtualVideoInput = {
                            ...sourceNode,
                            type: 'storyboard-as-video', // 标记为分镜转视频输入
                            videoFileName: projectTitle,
                            videoMeta: { duration: shots.length },
                            frames: selectedFrames,
                            selectedKeyframes: selectedFrames,
                            isStoryboardInput: true
                        };
                        cache.set(conn.to, virtualVideoInput);
                    }
                }
            }
        });
        return cache;
    }, [connections, nodesMap]);

    // 获取连接的 video-input 节点（用于 video-analyze 节点）
    const getConnectedVideoInputNode = useCallback((targetNodeId) => {
        return connectedVideoInputCache.get(targetNodeId) || null;
    }, [connectedVideoInputCache]);

    // 获取连接的 video-analyze 节点（用于 storyboard-node 节点）
    const getConnectedVideoAnalyzeNode = useCallback((targetNodeId) => {
        for (const conn of connections) {
            if (conn.to === targetNodeId) {
                const sourceNode = nodesMap.get(conn.from);
                if (sourceNode && sourceNode.type === 'video-analyze') {
                    return sourceNode;
                }
            }
        }
        return null;
    }, [connections, nodesMap]);

    // 功能2：获取连接的文字节点内容
    const getConnectedTextNodes = useCallback((targetNodeId) => {
        const texts = [];
        connections.forEach(conn => {
            if (conn.to === targetNodeId) {
                const sourceNode = nodesMap.get(conn.from);
                if (sourceNode && sourceNode.type === 'text-node') {
                    const text = sourceNode.settings?.text || '';
                    if (text) texts.push(text);
                }
            }
        });
        return texts;
    }, [connections, nodesMap]);

    // 使用 useMemo 缓存特定输入点的图片URL
    const connectedImageForInputCache = useMemo(() => {
        const cache = new Map(); // `${nodeId}:${inputType}` -> imageUrl
        connections.forEach(conn => {
            const inputType = conn.inputType || 'default';
            const key = `${conn.to}:${inputType}`;
            if (!cache.has(key)) {
                const sourceNode = nodesMap.get(conn.from);
                if (sourceNode) {
                    let imageUrl = null;
                    if (sourceNode.type === 'video-input') {
                        const selected = sourceNode.selectedKeyframes && sourceNode.selectedKeyframes.length > 0
                            ? sourceNode.selectedKeyframes[0].url
                            : null;
                        if (selected) {
                            imageUrl = selected;
                        } else if (sourceNode.frames && sourceNode.frames[0]) {
                            imageUrl = sourceNode.frames[0].url;
                        }
                    } else if (sourceNode.type === 'input-image' && sourceNode.content) {
                        imageUrl = sourceNode.content;
                    }
                    if (imageUrl) {
                        cache.set(key, imageUrl);
                    }
                }
            }
        });
        return cache;
        // V3.5.20-1: 使用 nodes 数组作为依赖，React 会进行浅比较
    }, [connections, nodesMap, nodes]);

    // 获取连接到特定输入点的图片URL
    const getConnectedImageForInput = useCallback((targetNodeId, inputType) => {
        const key = `${targetNodeId}:${inputType || 'default'}`;
        return connectedImageForInputCache.get(key) || null;
    }, [connectedImageForInputCache]);


    // 将生成结果同步到连接的预览节点
    const updatePreviewFromTask = (taskId, url, contentType = 'image', sourceNodeIdOverride = null, mjImages = null, filename = null) => {
        if (!url && (!mjImages || mjImages.length === 0)) return;
        // 找到对应的源节点ID
        let sourceNodeId = sourceNodeIdOverride;
        if (!sourceNodeId) {
            const historyItem = historyMap.get(taskId);
            sourceNodeId = historyItem?.sourceNodeId;
        }
        if (!sourceNodeId) {
            console.warn('[Tapnow] updatePreviewFromTask: 未找到 sourceNodeId for taskId:', taskId);
            return;
        }

        // 检查是否是从分镜表触发的生成，如果是则回填到分镜表
        // 使用 setTimeout 确保在下一个事件循环中执行，此时 nodes 和 connections 已更新
        setTimeout(() => {
            const sourceNode = nodesMap.get(sourceNodeId);
            if (sourceNode && (sourceNode.type === 'gen-image' || sourceNode.type === 'gen-video')) {
                // 查找连接到该生成节点的分镜表节点
                const storyboardConnections = connections.filter(c => c.to === sourceNodeId);
                for (const conn of storyboardConnections) {
                    const fromNode = nodesMap.get(conn.from);
                    const storyboardNode = fromNode && fromNode.type === 'storyboard-node' ? fromNode : null;
                    if (storyboardNode && storyboardNode.settings?.shots) {
                        // 查找状态为 generating 的 shot，回填结果
                        const generatingShot = storyboardNode.settings.shots.find(s => s.status === 'generating');
                        if (generatingShot) {
                            const finalUrl = url || (mjImages && mjImages.length > 0 ? mjImages[0] : null);
                            if (finalUrl) {
                                updateShot(storyboardNode.id, generatingShot.id, {
                                    image_url: finalUrl,
                                    image_filename: filename || generatingShot.image_filename,
                                    status: 'done'
                                });
                                break; // 只回填第一个找到的
                            }
                        }
                    }
                }
            }
        }, 0);

        // 使用 ref 获取最新的 connections 状态，避免闭包问题
        const latestConnections = connectionsRef.current;

        // 使用函数式更新，确保获取最新的 connections 状态
        setNodes((prevNodes) => {
            // 使用 ref 中的最新 connections
            const targetIds = latestConnections
                .filter((c) => c.from === sourceNodeId)
                .map((c) => c.to);

            if (!targetIds.length) return prevNodes;

            return prevNodes.map((n) =>
                targetIds.includes(n.id) && n.type === 'preview'
                    ? {
                        ...n,
                        content: url || (mjImages && mjImages.length > 0 ? mjImages[0] : url),
                        previewType: contentType,
                        previewMjImages: mjImages,
                        previewFilename: filename || n.previewFilename || ''
                    }
                    : n
            );
        });
    };

    const deleteHistoryItem = (id) => {
        setHistory(prev => {
            const filtered = prev.filter(item => item.id !== id);
            // 立即保存到 localStorage，不等待防抖
            try {
                localStorage.setItem('tapnow_history', JSON.stringify(filtered));
            } catch (e) {
                console.error('立即保存历史记录失败:', e);
            }
            return filtered;
        });
        if (historyContextMenu.item && historyContextMenu.item.id === id) {
            setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
        }
    };

    const addModelLibraryEntry = () => {
        const newId = `model-${Date.now()}`;
        const entryBase = {
            id: newId,
            displayName: newId,
            modelName: newId,
            type: 'Image',
            ratioLimits: null,
            ratioNotes: {},
            ratioNotesEnabled: false,
            resolutionLimits: null,
            resolutionNotes: {},
            resolutionNotesEnabled: false,
            durations: null,
            durationNotes: {},
            durationNotesEnabled: false,
            videoResolutions: null,
            videoResolutionNotes: {},
            videoResolutionNotesEnabled: false,
            supportsFirstLastFrame: false,
            supportsHD: false,
            omitRatioOnSubmit: false,
            omitResolutionOnSubmit: false,
            apiType: 'openai',
            customParams: [],
            asyncConfig: null,
            previewOverrideEnabled: false,
            previewOverridePatch: null,
            requestOverrideEnabled: false,
            requestOverridePatch: null
        };
        const newEntry = {
            ...entryBase,
            requestTemplate: getDefaultRequestTemplateForEntry(entryBase)
        };
        setModelLibrary(prev => [...prev, newEntry]);
        setEditingLibraryModels(prev => {
            const next = new Set(prev);
            next.add(newId);
            return next;
        });
        setCollapsedLibraryModels(prev => {
            const next = new Set(prev);
            next.add(newId);
            return next;
        });
    };

    const duplicateModelLibraryEntry = (entryId) => {
        const source = modelLibrary.find(entry => entry.id === entryId);
        if (!source) return;
        const baseId = `${source.id}-copy`;
        let newId = baseId;
        let counter = 1;
        while (modelLibrary.some(entry => entry.id === newId)) {
            newId = `${baseId}-${counter++}`;
        }
        const cloned = JSON.parse(JSON.stringify(source));
        const displayBase = cloned.displayName || cloned.modelName || cloned.id || newId;
        const duplicatedParams = Array.isArray(cloned.customParams)
            ? cloned.customParams.map((param) => ({ ...param, id: '' }))
            : [];
        const newEntry = {
            ...cloned,
            id: newId,
            displayName: `${displayBase}（复制）`,
            modelName: cloned.modelName || cloned.id || newId,
            customParams: normalizeCustomParams(duplicatedParams),
            requestTemplate: normalizeRequestTemplate(cloned.requestTemplate || getDefaultRequestTemplateForEntry(cloned)),
            previewOverridePatch: normalizePreviewOverridePatch(cloned.previewOverridePatch),
            requestOverridePatch: normalizeRequestOverridePatch(cloned.requestOverridePatch)
        };
        setModelLibrary(prev => [...prev, newEntry]);
        setEditingLibraryModels(prev => {
            const next = new Set(prev);
            next.add(newId);
            return next;
        });
        setCollapsedLibraryModels(prev => {
            const next = new Set(prev);
            next.delete(newId);
            return next;
        });
    };

    const isLibraryNotesCollapsed = useCallback((entryId, fieldKey) => {
        const key = `${entryId}:${fieldKey}`;
        return !!libraryNotesCollapsed[key];
    }, [libraryNotesCollapsed]);

    const toggleLibraryNotesCollapsed = useCallback((entryId, fieldKey) => {
        const key = `${entryId}:${fieldKey}`;
        setLibraryNotesCollapsed(prev => ({
            ...prev,
            [key]: !prev[key]
        }));
    }, [extractLocalCacheRelPath]);

    const isLibrarySectionCollapsed = useCallback((entryId, sectionKey) => {
        const key = `${entryId}:${sectionKey}`;
        return !!librarySectionCollapsed[key];
    }, [librarySectionCollapsed]);

    const toggleLibrarySectionCollapsed = useCallback((entryId, sectionKey) => {
        const key = `${entryId}:${sectionKey}`;
        setLibrarySectionCollapsed(prev => ({
            ...prev,
            [key]: !prev[key]
        }));
    }, []);

    const addModelLibraryCustomParam = (entryId) => {
        if (!entryId) return;
        setModelLibrary(prev => prev.map((entry) => {
            if (entry.id !== entryId) return entry;
            const nextParams = Array.isArray(entry.customParams) ? [...entry.customParams] : [];
            if (nextParams.length >= MAX_CUSTOM_PARAMS) {
                showToast(`自定义参数最多 ${MAX_CUSTOM_PARAMS} 个`, 'warning', 2000);
                return entry;
            }
            nextParams.push({
                id: `param-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
                name: '',
                values: [],
                override: false,
                notesEnabled: false,
                valueNotes: {},
                defaultValue: ''
            });
            return { ...entry, customParams: nextParams };
        }));
    };

    const updateModelLibraryCustomParam = (entryId, paramId, updates) => {
        if (!entryId || !paramId) return;
        setModelLibrary(prev => prev.map((entry) => {
            if (entry.id !== entryId) return entry;
            const nextParams = Array.isArray(entry.customParams) ? entry.customParams.map((param) => (
                param.id === paramId ? { ...param, ...updates } : param
            )) : [];
            return { ...entry, customParams: nextParams };
        }));
    };

    const deleteModelLibraryCustomParam = (entryId, paramId) => {
        if (!entryId || !paramId) return;
        setModelLibrary(prev => prev.map((entry) => {
            if (entry.id !== entryId) return entry;
            const nextParams = Array.isArray(entry.customParams)
                ? entry.customParams.filter((param) => param.id !== paramId)
                : [];
            return { ...entry, customParams: nextParams };
        }));
    };

    const updateModelLibraryEntry = (id, updates) => {
        if (!id) return;
        setModelLibrary(prev => prev.map(entry => entry.id === id ? { ...entry, ...updates } : entry));
    };

    const deleteModelLibraryEntry = (id) => {
        if (!id) return;
        setModelLibrary(prev => prev.filter(entry => entry.id !== id));
        setApiConfigs(prev => prev.map(config => config.libraryId === id ? { ...config, libraryId: null } : config));
        setEditingLibraryModels(prev => {
            const next = new Set(prev);
            next.delete(id);
            return next;
        });
        setCollapsedLibraryModels(prev => {
            const next = new Set(prev);
            next.delete(id);
            return next;
        });
        setLibraryPreviewModels(prev => {
            const next = new Set(prev);
            next.delete(id);
            return next;
        });
        setLibraryPreviewEditing(prev => {
            if (!prev.has(id)) return prev;
            const next = new Set(prev);
            next.delete(id);
            return next;
        });
        setLibraryPreviewDrafts(prev => {
            if (!prev[id]) return prev;
            const { [id]: _removed, ...rest } = prev;
            return rest;
        });
        setLibraryRequestPreviewEditing(prev => {
            if (!prev.has(id)) return prev;
            const next = new Set(prev);
            next.delete(id);
            return next;
        });
        setLibraryRequestPreviewDrafts(prev => {
            if (!prev[id]) return prev;
            const { [id]: _removed, ...rest } = prev;
            return rest;
        });
        setLibraryRequestTemplateDrafts(prev => {
            if (!prev[id]) return prev;
            const { [id]: _removed, ...rest } = prev;
            return rest;
        });
    };

    const setApiModelEditing = useCallback((uid, enabled) => {
        if (!uid) return;
        setEditingApiModels(prev => {
            const next = new Set(prev);
            if (enabled) next.add(uid);
            else next.delete(uid);
            return next;
        });
    }, []);

    const setLibraryModelEditing = useCallback((id, enabled) => {
        if (!id) return;
        setEditingLibraryModels(prev => {
            const next = new Set(prev);
            if (enabled) next.add(id);
            else next.delete(id);
            return next;
        });
        if (enabled) {
            setCollapsedLibraryModels(prev => {
                const next = new Set(prev);
                next.delete(id);
                return next;
            });
        }
    }, []);

    const toggleLibraryModelCollapse = useCallback((id) => {
        if (!id) return;
        setCollapsedLibraryModels(prev => {
            const next = new Set(prev);
            if (next.has(id)) next.delete(id);
            else next.add(id);
            return next;
        });
    }, []);

    const toggleLibraryPreview = useCallback((id) => {
        if (!id) return;
        setLibraryPreviewModels(prev => {
            const next = new Set(prev);
            if (next.has(id)) {
                next.delete(id);
            } else {
                next.add(id);
            }
            return next;
        });
        setLibraryPreviewEditing(prev => {
            if (!prev.has(id)) return prev;
            const next = new Set(prev);
            next.delete(id);
            return next;
        });
        setLibraryPreviewDrafts(prev => {
            if (!prev[id]) return prev;
            const { [id]: _removed, ...rest } = prev;
            return rest;
        });
        setLibraryRequestPreviewEditing(prev => {
            if (!prev.has(id)) return prev;
            const next = new Set(prev);
            next.delete(id);
            return next;
        });
        setLibraryRequestPreviewDrafts(prev => {
            if (!prev[id]) return prev;
            const { [id]: _removed, ...rest } = prev;
            return rest;
        });
    }, []);

    const toggleLibraryAsyncPreview = useCallback((id) => {
        if (!id) return;
        setLibraryAsyncPreviewModels(prev => {
            const next = new Set(prev);
            if (next.has(id)) next.delete(id);
            else next.add(id);
            return next;
        });
    }, []);

    // V3.6.0: 添加新模型（简化格式）
    const addNewModel = () => {
        const uid = `uid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newConfig = {
            id: `new-model-${Date.now()}`,
            provider: 'openai',
            type: 'Chat',
            _uid: uid
        };
        setApiConfigs([...apiConfigs, newConfig]);
        setApiModelEditing(uid, true);
    };
    // V3.6.0: 更新模型配置，支持 id 变更
    const updateApiConfig = (uid, updates) => setApiConfigs((prev) => prev.map((c) => {
        if (c._uid === uid) {
            return { ...c, ...updates };
        }
        return c;
    }));
    const deleteApiConfig = (uid) => {
        setApiConfigs((prev) => prev.filter((c) => c._uid !== uid));
        setEditingApiModels(prev => {
            const next = new Set(prev);
            next.delete(uid);
            return next;
        });
    };

    const testApiConnection = async (modelKey) => {
        const config = getApiConfigByKey(modelKey);
        const statusKey = config?._uid || modelKey;
        setApiTesting(statusKey);
        setApiStatus((prev) => ({ ...prev, [statusKey]: 'idle' }));

        // V3.4.8: 使用 getApiCredentials 获取 Provider 配置
        const { key: apiKey, url: baseUrl } = getApiCredentials(modelKey);

        if (!apiKey) {
            setApiStatus((prev) => ({ ...prev, [statusKey]: 'error' }));
            setApiTesting(null);
            return;
        }

        try {
            const response = await fetch(`${baseUrl}/v1/models`, {
                method: 'GET',
                headers: { Authorization: `Bearer ${apiKey}` },
            });
            if (response.ok) setApiStatus((prev) => ({ ...prev, [statusKey]: 'success' }));
            else setApiStatus((prev) => ({ ...prev, [statusKey]: 'error' }));
        } catch {
            setApiStatus((prev) => ({ ...prev, [statusKey]: 'error' }));
        }
        setApiTesting(null);
    };

    const getStatusColor = (modelId) => {
        if (!modelId) return 'bg-zinc-600';
        const status = apiStatus[modelId];
        if (status === 'success') return 'bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.8)]';
        if (status === 'error') return 'bg-red-500';
        // V3.4.8: 使用 getApiCredentials 检查是否有 key
        const { key } = getApiCredentials(modelId);
        return key ? 'bg-zinc-400' : 'bg-zinc-700';
    };

    const currentSession = useMemo(() => chatSessions.find(s => s.id === currentChatId) || chatSessions[0], [chatSessions, currentChatId]);

    const scrollToBottom = () => {
        chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    useEffect(() => {
        scrollToBottom();
    }, [currentSession?.messages, isChatOpen]);

    const createNewChat = () => {
        const newId = `chat-${Date.now()}`;
        const newSession = { id: newId, title: t('新对话'), messages: [] };
        setChatSessions(prev => [newSession, ...prev]);
        setCurrentChatId(newId);
    };

    const deleteChatSession = (e, id) => {
        e.stopPropagation();
        const newSessions = chatSessions.filter(s => s.id !== id);
        if (newSessions.length === 0) {
            const defaultSession = { id: 'default', title: t('新对话'), messages: [] };
            setChatSessions([defaultSession]);
            setCurrentChatId('default');
        } else {
            setChatSessions(newSessions);
            if (currentChatId === id) setCurrentChatId(newSessions[0].id);
        }
    };

    const appendChatFiles = useCallback((files) => {
        const fileList = Array.from(files || []);
        fileList.forEach(file => {
            const reader = new FileReader();
            reader.onload = (ev) => {
                const content = ev.target.result;
                const fileExt = file.name.split('.').pop()?.toLowerCase() || '';

                // 判断文件类型
                const isImage = file.type.startsWith('image/');
                const isVideo = file.type.startsWith('video/');
                const isAudio = file.type.startsWith('audio/');
                const isPDF = file.type === 'application/pdf' || fileExt === 'pdf';
                const isDoc = ['doc', 'docx'].includes(fileExt) || file.type.includes('word');
                const isExcel = ['xls', 'xlsx'].includes(fileExt) || file.type.includes('excel') || file.type.includes('spreadsheet');
                const isCode = ['js', 'jsx', 'ts', 'tsx', 'py', 'java', 'cpp', 'c', 'html', 'css', 'json', 'xml', 'yaml', 'yml', 'md', 'txt', 'sh', 'bash'].includes(fileExt);

                setChatFiles(prev => [...prev, {
                    name: file.name,
                    type: file.type,
                    content: content,
                    isImage,
                    isVideo,
                    isAudio,
                    isPDF,
                    isDoc,
                    isExcel,
                    isCode,
                    fileExt
                }]);
            };

            // 根据文件类型选择读取方式
            if (file.type.startsWith('image/') || file.type.startsWith('video/') || file.type.startsWith('audio/')) {
                reader.readAsDataURL(file);
            } else if (file.type === 'application/pdf') {
                // PDF 也转换为 data URL
                reader.readAsDataURL(file);
            } else if (file.name.match(/\.(txt|md|js|jsx|ts|tsx|py|html|css|json|csv|xml|yaml|yml|sh|bash|java|cpp|c)$/i)) {
                // 代码和文本文件读取为文本
                reader.readAsText(file);
            } else {
                // 其他文件（如 Word、Excel）也尝试读取为 data URL
                reader.readAsDataURL(file);
            }
        });
    }, [setChatFiles]);

    const handleChatFileUpload = (e) => {
        appendChatFiles(e.target.files);
        e.target.value = '';
    };

    const removeChatFile = (index) => {
        setChatFiles(prev => prev.filter((_, i) => i !== index));
    };

    const extractImageUrlsFromText = (text) => {
        if (!text || typeof text !== 'string') return [];
        const urls = new Set();
        const markdownMatches = text.match(/!\[[^\]]*]\(([^)]+)\)/g) || [];
        markdownMatches.forEach((match) => {
            const inner = match.match(/\(([^)]+)\)/);
            if (inner?.[1]) urls.add(inner[1].trim());
        });
        const dataMatches = text.match(/data:image\/[^;]+;base64,[A-Za-z0-9+/=]+/g) || [];
        dataMatches.forEach((match) => urls.add(match));
        const urlMatches = text.match(/https?:\/\/[^\s)]+/g) || [];
        urlMatches.forEach((match) => {
            const cleaned = match.replace(/[),.]+$/, '');
            if (cleaned.match(/\.(png|jpg|jpeg|webp|gif|bmp|svg)(\?|#|$)/i)) {
                urls.add(cleaned);
            }
        });
        return Array.from(urls);
    };

    const extractChatImageUrls = (data, textContent) => {
        const urls = new Set();
        const pushUrl = (value, mimeHint = 'image/png') => {
            if (!value) return;
            if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) return;
                if (trimmed.startsWith('data:image/')) {
                    urls.add(trimmed);
                    return;
                }
                if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
                    urls.add(trimmed);
                    return;
                }
                const base64Like = /^[A-Za-z0-9+/=]+$/.test(trimmed);
                if (base64Like && trimmed.length > 64) {
                    const mimeType = detectBase64ImageMime(trimmed, mimeHint);
                    urls.add(`data:${mimeType};base64,${trimmed}`);
                }
                return;
            }
            if (typeof value === 'object') {
                const url = value.url || value.image_url || value.imageUrl || value.file_uri || value.fileUri || value.uri;
                if (url) {
                    urls.add(url);
                    return;
                }
                const raw = value.data || value.base64 || value.b64;
                if (raw) {
                    const mimeType = detectBase64ImageMime(raw, value.mime_type || value.mimeType || mimeHint);
                    urls.add(`data:${mimeType};base64,${raw}`);
                }
            }
        };

        const messageCandidates = [
            data?.choices?.[0]?.message,
            data?.data?.choices?.[0]?.message
        ];
        messageCandidates.forEach((message) => {
            if (!message) return;
            const content = message.content;
            if (Array.isArray(content)) {
                content.forEach((part) => {
                    if (!part) return;
                    if (part.type === 'image_url') pushUrl(part.image_url?.url || part.image_url || part.imageUrl);
                    if (part.type === 'image') pushUrl(part.image || part.image_url || part.imageUrl);
                    if (part.inline_data || part.inlineData) {
                        const inline = part.inline_data || part.inlineData;
                        if (inline?.data) pushUrl(inline.data, inline.mime_type || inline.mimeType || 'image/png');
                    }
                });
            }
        });

        const arrayCandidates = [
            data?.images,
            data?.output_images,
            data?.data?.output_images,
            data?.data?.images
        ];
        arrayCandidates.forEach((arr) => {
            if (!Array.isArray(arr)) return;
            arr.forEach((item) => pushUrl(item?.url || item?.image_url || item?.imageUrl || item));
        });

        extractImageUrlsFromText(textContent).forEach((url) => urls.add(url));
        return Array.from(urls);
    };

    const sendChatMessage = async () => {
        if ((!chatInput.trim() && chatFiles.length === 0) || isChatSending) return;

        // V3.4.8: 使用 getApiCredentials 获取 Provider 配置
        const config = getApiConfigByKey(chatModel);
        const { key: apiKey, url: baseUrl, modelName } = getApiCredentials(chatModel);

        if (!apiKey) {
            alert(t('请先在 API 设置中配置 Key'));
            setSettingsOpen(true);
            return;
        }

        // 确保使用当前激活的会话（避免新建对话后第一条消息被写入旧会话）
        const chatIdToUse = currentChatId || chatSessions[0]?.id;
        const sessionToUse = chatSessions.find(s => s.id === chatIdToUse) || chatSessions[0];
        const currentSessionMessages = sessionToUse?.messages || [];
        if (sessionToUse && sessionToUse.id !== currentChatId) setCurrentChatId(sessionToUse.id);

        setIsChatSending(true);

        const newUserMsg = {
            id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            role: 'user',
            content: chatInput,
            files: [...chatFiles],
            timestamp: Date.now(),
            modelId: chatModel // 保存发送消息时使用的模型ID
        };

        setChatSessions(prev => prev.map(s => {
            if (s.id === chatIdToUse) {
                return { ...s, messages: [...s.messages, newUserMsg], title: s.messages.length === 0 ? chatInput.slice(0, 20) : s.title };
            }
            return s;
        }));
        setChatInput('');
        setChatFiles([]);

        // 构建带上下文的对话历史，帮助模型回顾上下文
        // 使用当前会话的消息加上新消息
        const allMessages = [...currentSessionMessages, newUserMsg];
        const MAX_HISTORY_MESSAGES = 20;
        const recentMessages = allMessages.length > MAX_HISTORY_MESSAGES
            ? allMessages.slice(-MAX_HISTORY_MESSAGES)
            : allMessages;

        let apiMessages = [
            {
                role: 'system',
                content: t('你是一名多模态AI助手，需要结合整个对话的上下文进行连续回答。')
            },
            ...recentMessages.map(m => ({
                role: m.role,
                content: m.content
            }))
        ];

        const currentContent = [];
        if (newUserMsg.content) currentContent.push({ type: "text", text: newUserMsg.content });

        newUserMsg.files.forEach(f => {
            const isGeminiLike = (config?.modelName ?? '').toLowerCase().includes('gemini');

            if (f.isImage) {
                currentContent.push({
                    type: "image_url",
                    image_url: { url: f.content }
                });
            } else if (f.isVideo) {
                if (isGeminiLike) {
                    // Gemini 视频分析：按官方规范也走 image_url，url 直接指向 mp4
                    currentContent.push({
                        type: "image_url",
                        image_url: { url: f.content }
                    });
                } else {
                    currentContent.push({
                        type: "text",
                        text: `\n[User attached video: ${f.name}]\n`
                    });
                }
            } else if (f.isAudio) {
                currentContent.push({
                    type: "text",
                    text: `\n[User attached audio: ${f.name}]\n`
                });
            } else if (f.isPDF || f.isDoc || f.isExcel) {
                // PDF、Word、Excel 等文档文件，发送文件名和类型信息
                currentContent.push({
                    type: "text",
                    text: `\n[User attached document: ${f.name} (${f.isPDF ? 'PDF' : f.isDoc ? 'Word' : 'Excel'})]\n`
                });
            } else if (f.isCode || (f.content && typeof f.content === 'string' && f.content.length < 50000)) {
                // 代码文件或文本文件，直接发送内容
                currentContent.push({
                    type: "text",
                    text: `\n[File: ${f.name}]\n\`\`\`${f.fileExt || 'text'}\n${f.content}\n\`\`\`\n`
                });
            } else {
                // 其他文件或二进制文件
                currentContent.push({
                    type: "text",
                    text: `\n[User attached file: ${f.name}]\n`
                });
            }
        });

        apiMessages.push({ role: 'user', content: currentContent });

        try {
            const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: modelName || chatModel, // V3.7.23: 使用 getApiCredentials 返回的 modelName
                    messages: apiMessages,
                    stream: false
                })
            });

            if (!response.ok) {
                const errText = await response.text();
                throw new Error(errText || `API Error: ${response.status}`);
            }

            const data = await response.json();
            // 支持多种响应格式
            let aiContent = null;
            const primaryMessage = data?.choices?.[0]?.message || data?.data?.choices?.[0]?.message;
            if (primaryMessage?.content !== undefined) {
                if (Array.isArray(primaryMessage.content)) {
                    aiContent = primaryMessage.content
                        .map(part => (typeof part?.text === 'string' ? part.text : ''))
                        .filter(Boolean)
                        .join('\n');
                } else {
                    aiContent = primaryMessage.content;
                }
            } else if (data.content) {
                // 直接 content 字段
                aiContent = data.content;
            } else if (data.text) {
                // text 字段
                aiContent = data.text;
            } else if (data.message) {
                // message 字段
                aiContent = typeof data.message === 'string' ? data.message : data.message.content;
            } else if (data.result) {
                // result 字段
                aiContent = typeof data.result === 'string' ? data.result : data.result.content;
            } else if (data.data?.content) {
                // 嵌套 data.content 格式
                aiContent = data.data.content;
            } else if (data.data?.text) {
                // 嵌套 data.text 格式
                aiContent = data.data.text;
            } else if (data.data?.message) {
                // 嵌套 data.message 格式
                aiContent = typeof data.data.message === 'string' ? data.data.message : data.data.message.content;
            } else if (data.data?.result) {
                // 嵌套 data.result 格式
                aiContent = typeof data.data.result === 'string' ? data.data.result : data.data.result.content;
            }

            if (aiContent && typeof aiContent !== 'string') {
                aiContent = JSON.stringify(aiContent);
            }
            if (!aiContent || aiContent.trim() === '') {
                console.error('[聊天] API 响应内容为空:', data);
                aiContent = "No response";
            }

            const newAssistantMsg = {
                id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                role: 'assistant',
                content: aiContent,
                timestamp: Date.now(),
                modelId: chatModel // 保存回复消息时使用的模型ID
            };

            setChatSessions(prev => prev.map(s => {
                if (s.id === currentChatId) {
                    return { ...s, messages: [...s.messages, newAssistantMsg] };
                }
                return s;
            }));

            const chatImageUrls = extractChatImageUrls(data, aiContent);
            if (chatImageUrls.length > 0) {
                const now = Date.now();
                const primaryUrl = chatImageUrls[0];
                const displayName = config?.displayName || modelName || chatModel;
                const useProxy = typeof config?.useProxy === 'boolean'
                    ? config.useProxy
                    : !!(config?.provider && providers?.[config.provider]?.useProxy);
                setHistory((prev) => [{
                    id: `chat-${now}-${Math.random().toString(36).slice(2, 8)}`,
                    type: 'image',
                    url: primaryUrl,
                    prompt: newUserMsg.content || 'Chat Image',
                    time: new Date(now).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                    status: 'completed',
                    progress: 100,
                    modelName: displayName,
                    apiConfig: { modelId: chatModel, baseUrl, apiKey, provider: config?.provider, useProxy },
                    provider: config?.provider,
                    useProxy,
                    startTime: now,
                    durationMs: 0,
                    output_images: chatImageUrls,
                    mjImages: chatImageUrls.length > 1 ? chatImageUrls : null,
                    selectedMjImageIndex: 0
                }, ...prev]);
            }

        } catch (error) {
            console.error("Chat Error", error);
            const errorMsg = {
                id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                role: 'assistant',
                content: `Error: ${error.message}`,
                isError: true,
                timestamp: Date.now()
            };

            setChatSessions(prev => prev.map(s => {
                if (s.id === currentChatId) {
                    return { ...s, messages: [...s.messages, errorMsg] };
                }
                return s;
            }));
        } finally {
            setIsChatSending(false);
        }
    };

    // 压缩/缩放图片用于Midjourney上传（Discord对图片有尺寸和大小限制）
    const prepareImageForMidjourneyUpload = async (imageUrl, maxSize = 2048, maxFileSizeMB = 8) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = () => {
                const originalWidth = img.width;
                const originalHeight = img.height;

                // 计算缩放后的尺寸，保持宽高比
                let newWidth = originalWidth;
                let newHeight = originalHeight;

                if (originalWidth > maxSize || originalHeight > maxSize) {
                    const scale = maxSize / Math.max(originalWidth, originalHeight);
                    newWidth = Math.floor(originalWidth * scale);
                    newHeight = Math.floor(originalHeight * scale);
                }

                // 创建canvas并绘制
                const canvas = document.createElement('canvas');
                canvas.width = newWidth;
                canvas.height = newHeight;
                const ctx = canvas.getContext('2d');

                // 使用高质量绘制
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, newWidth, newHeight);

                // 转换为base64，使用JPEG格式压缩
                // 从高质量开始，如果文件太大则降低质量
                let quality = 0.92;
                let dataUrl = canvas.toDataURL('image/jpeg', quality);

                // 检查文件大小（base64编码后的大小约为原始大小的133%）
                const base64Length = dataUrl.split(',')[1]?.length || 0;
                const fileSizeMB = (base64Length * 3 / 4) / (1024 * 1024);

                // 如果文件太大，降低质量
                if (fileSizeMB > maxFileSizeMB) {
                    quality = 0.75;
                    dataUrl = canvas.toDataURL('image/jpeg', quality);
                    const newBase64Length = dataUrl.split(',')[1]?.length || 0;
                    const newFileSizeMB = (newBase64Length * 3 / 4) / (1024 * 1024);
                }

                resolve(dataUrl);
            };

            img.onerror = (error) => {
                console.error('Midjourney: 图片加载失败', error);
                // 如果加载失败，返回原图
                resolve(imageUrl);
            };

            img.src = imageUrl;
        });
    };

    // 上传图片到Midjourney并获取HTTP URL（用于oref和sref指令）
    const uploadMidjourneyImages = async (base64Array, baseUrl, apiKey) => {
        try {
            // 先处理所有图片：压缩/缩放
            const processedImages = await Promise.all(
                base64Array.map(async (imageUrl, index) => {
                    // 如果是data URL，先压缩/缩放
                    if (imageUrl.startsWith('data:')) {
                        try {
                            const processed = await prepareImageForMidjourneyUpload(imageUrl, 2048, 8);
                            return processed;
                        } catch (error) {
                            console.error(`Midjourney: 图片[${index}]处理失败，使用原图`, error);
                            return imageUrl;
                        }
                    } else {
                        // 如果是HTTP URL，需要先转换为data URL再处理
                        try {
                            const useProxy = getProxyPreferenceForUrl(imageUrl, false);
                            const blob = await getBlobFromUrl(imageUrl, { useProxy });
                            const dataUrl = await blobToDataURL(blob);
                            const processed = await prepareImageForMidjourneyUpload(dataUrl, 2048, 8);
                            return processed;
                        } catch (error) {
                            console.error(`Midjourney: 图片[${index}]从URL处理失败`, error);
                            throw error;
                        }
                    }
                })
            );

            // 清理base64数组，确保每个元素都是纯base64字符串
            const cleanedBase64Array = processedImages.map((base64, index) => {
                // 如果是data URL，提取base64部分
                let cleaned = base64;
                if (typeof cleaned !== 'string') {
                    throw new Error(`base64[${index}]不是字符串类型`);
                }

                // 如果是data URL，提取base64部分
                if (cleaned.includes(',')) {
                    // 直接提取逗号后的部分（base64数据）
                    cleaned = cleaned.split(',')[1];
                } else if (cleaned.startsWith('data:')) {
                    // 如果没有逗号但有data:前缀，使用正则提取
                    cleaned = cleaned.replace(/^data:[^;]*;base64,?/i, '');
                }

                // 严格清理：移除所有非base64字符（包括空白字符和不可见字符）
                // 只保留有效的base64字符：A-Z, a-z, 0-9, +, /, =
                const beforeClean = cleaned.length;
                cleaned = cleaned.replace(/[^A-Za-z0-9+/=]/g, '');
                const afterClean = cleaned.length;
                if (beforeClean !== afterClean) {
                }

                if (!cleaned || cleaned.length < 100) {
                    throw new Error(`base64[${index}]无效或太短，长度: ${cleaned?.length || 0}`);
                }

                // 验证base64格式：只包含 base64 字符（A-Z, a-z, 0-9, +, /, =）
                // 注意：base64字符串可能以0-2个=结尾作为填充
                const base64Regex = /^[A-Za-z0-9+/]+={0,2}$/;
                if (!base64Regex.test(cleaned)) {
                    console.error(`Midjourney: base64[${index}]格式验证失败，长度: ${cleaned.length}, 前50字符: ${cleaned.substring(0, 50)}`);
                    throw new Error(`invalid_base64_format: base64[${index}]格式无效`);
                }

                // 验证base64长度是否为4的倍数（base64编码要求）
                // 如果不是4的倍数，添加填充
                const padding = cleaned.length % 4;
                if (padding !== 0) {
                    // 移除现有的填充字符，然后重新添加正确的填充
                    cleaned = cleaned.replace(/=+$/, '');
                    cleaned += '='.repeat(4 - padding);

                    // 填充后再次验证
                    if (!base64Regex.test(cleaned)) {
                        console.error(`Midjourney: base64[${index}]填充后验证失败，长度: ${cleaned.length}`);
                        throw new Error(`invalid_base64_format: base64[${index}]填充后格式无效`);
                    }
                }

                // 测试base64是否能正确解码（确保base64有效）
                try {
                    const testDecode = atob(cleaned);
                    if (!testDecode || testDecode.length === 0) {
                        throw new Error('base64解码结果为空');
                    }
                } catch (decodeError) {
                    console.error(`Midjourney: base64[${index}]解码测试失败:`, decodeError);
                    throw new Error(`invalid_base64_format: base64[${index}]无法解码`);
                }

                // 根据API文档，base64Array需要完整的data URL格式：data:image/png;base64,xxx
                // 而不是纯base64字符串
                const dataUrl = `data:image/jpeg;base64,${cleaned}`;
                return dataUrl;
            });

            // 使用Midjourney的上传接口：/mj/submit/upload-discord-images
            const uploadEndpoint = `${baseUrl}/mj/submit/upload-discord-images`;


            // 最终验证所有data URL字符串（现在返回的是完整的data URL格式）
            cleanedBase64Array.forEach((dataUrl, idx) => {
                if (!dataUrl || typeof dataUrl !== 'string') {
                    throw new Error(`base64[${idx}]无效或不是字符串`);
                }
                // 验证是否是data URL格式：data:image/xxx;base64,xxx
                if (!dataUrl.startsWith('data:image/')) {
                    throw new Error(`base64[${idx}]不是有效的data URL格式`);
                }
                // 提取base64部分进行验证
                let base64Part = '';
                if (dataUrl.includes(',')) {
                    base64Part = dataUrl.split(',')[1];
                } else {
                    throw new Error(`base64[${idx}]data URL格式不正确，缺少逗号`);
                }

                if (!base64Part || base64Part.length < 100) {
                    throw new Error(`base64[${idx}]无效或太短`);
                }
                // 验证base64格式
                const base64Regex = /^[A-Za-z0-9+/]+={0,2}$/;
                if (!base64Regex.test(base64Part)) {
                    console.error(`Midjourney: base64[${idx}]最终验证失败，包含非法字符`);
                    throw new Error(`base64[${idx}]格式无效`);
                }
                // 验证长度是4的倍数
                if (base64Part.length % 4 !== 0) {
                    throw new Error(`base64[${idx}]长度不是4的倍数: ${base64Part.length}`);
                }
                // 再次测试解码
                try {
                    atob(base64Part);
                } catch (e) {
                    throw new Error(`base64[${idx}]无法解码: ${e.message}`);
                }
            });

            // 构建请求体
            const requestBody = {
                base64Array: cleanedBase64Array
            };

            // 验证JSON序列化后的数据
            const jsonString = JSON.stringify(requestBody);

            const uploadResp = await fetch(uploadEndpoint, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: jsonString
            });

            if (!uploadResp.ok) {
                let errorText = '';
                try {
                    errorText = await uploadResp.text();
                    // 尝试解析为JSON
                    try {
                        const errorJson = JSON.parse(errorText);
                        throw new Error(`上传失败: ${uploadResp.status} - ${errorJson.description || errorJson.message || errorText}`);
                    } catch {
                        throw new Error(`上传失败: ${uploadResp.status} - ${errorText}`);
                    }
                } catch (error) {
                    throw new Error(`上传失败: ${uploadResp.status} - ${error.message || errorText}`);
                }
            }

            const uploadData = await uploadResp.json();

            // 检查响应格式
            if (uploadData.code === 1 && uploadData.result && Array.isArray(uploadData.result)) {
                return uploadData.result; // 返回URL数组
            } else {
                const errorMsg = uploadData.description || uploadData.message || '上传失败：响应格式错误';
                console.error('Midjourney: 上传失败，响应:', uploadData);
                throw new Error(errorMsg);
            }
        } catch (error) {
            console.error('Midjourney: 图片上传失败:', error);
            throw error;
        }
    };

    // 上传单个图片到图床并获取HTTP URL（用于Midjourney的oref和sref指令，以及拓展图片）
    const uploadImageToGetHttpUrl = async (imageUrl, baseUrl, apiKey) => {
        try {
            const resolvedInput = await resolveSpecialUrl(imageUrl);
            if (resolvedInput) imageUrl = resolvedInput;
            // 如果是HTTP/HTTPS URL，直接返回
            if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                return imageUrl;
            }

            // 如果是 Blob URL，需要转换为 Base64 再上传
            if (imageUrl.startsWith('blob:')) {
                const base64Data = await getBase64FromUrl(imageUrl);
                // 继续使用 data URL 的处理逻辑
                imageUrl = `data:image/png;base64,${base64Data}`;
            }

            // 如果是data URL，需要上传
            if (imageUrl.startsWith('data:')) {
                // 提取base64数据（去掉 data:image/png;base64, 前缀）
                // 确保正确提取纯base64字符串
                let base64Data = imageUrl;
                if (base64Data.includes(',')) {
                    base64Data = base64Data.split(',')[1];
                } else {
                    // 如果没有逗号，尝试去掉 data: 前缀
                    base64Data = base64Data.replace(/^data:[^;]*;base64,?/i, '');
                }
                // 先清理所有非base64字符（包括所有空白字符和不可见字符）
                // 这是最严格的方式：只保留有效的base64字符
                base64Data = base64Data.replace(/[^A-Za-z0-9+/=]/g, '');

                if (!base64Data || base64Data.length < 100) {
                    console.error('拓展图片: base64数据无效或太短，长度:', base64Data?.length);
                    return null;
                }

                // 验证base64格式：只包含 base64 字符（A-Z, a-z, 0-9, +, /, =）
                const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                if (!base64Regex.test(base64Data)) {
                    console.error('拓展图片: base64数据格式验证失败，包含非法字符');
                    // 再次清理（理论上不应该到这里）
                    base64Data = base64Data.replace(/[^A-Za-z0-9+/=]/g, '');
                    if (!base64Regex.test(base64Data)) {
                        console.error('拓展图片: 清理后仍无效，放弃上传');
                        return null;
                    }
                }

                // 验证base64长度是否为4的倍数（base64编码要求）
                const padding = base64Data.length % 4;
                if (padding !== 0) {
                    console.warn('拓展图片: base64长度不是4的倍数，添加填充:', padding);
                    base64Data += '='.repeat(4 - padding);
                }

                // 最终验证
                if (!base64Regex.test(base64Data)) {
                    console.error('拓展图片: 最终验证失败');
                    return null;
                }


                // 优先使用 Midjourney 官方上传接口
                try {
                    // 确保 baseUrl 格式正确（移除末尾斜杠）
                    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
                    const uploadEndpoint = `${cleanBaseUrl}/mj/submit/upload-discord-images`;
                    const uploadPayload = {
                        base64Array: [base64Data]
                    };


                    const uploadResp = await fetch(uploadEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(uploadPayload)
                    });

                    const responseText = await uploadResp.text();

                    if (uploadResp.ok) {
                        let uploadData;
                        try {
                            uploadData = JSON.parse(responseText);
                        } catch (parseError) {
                            console.error('拓展图片: Midjourney 上传响应解析失败', parseError, '响应内容:', responseText.substring(0, 200));
                            throw new Error('响应不是有效的JSON格式');
                        }

                        console.log('拓展图片: 响应详细信息:', {
                            code: uploadData.code,
                            description: uploadData.description,
                            result: uploadData.result,
                            resultType: typeof uploadData.result,
                            isArray: Array.isArray(uploadData.result),
                            hasData: !!uploadData.data,
                            hasUrl: !!uploadData.url
                        });

                        // 检查响应格式
                        if (uploadData.code === 1) {
                            // 尝试多种可能的响应格式
                            let httpUrl = null;

                            // 格式1: result 是数组
                            if (uploadData.result && Array.isArray(uploadData.result) && uploadData.result.length > 0) {
                                httpUrl = uploadData.result[0];
                            }
                            // 格式2: result 是字符串
                            else if (uploadData.result && typeof uploadData.result === 'string') {
                                httpUrl = uploadData.result;
                            }
                            // 格式3: data 字段
                            else if (uploadData.data && Array.isArray(uploadData.data) && uploadData.data.length > 0) {
                                httpUrl = uploadData.data[0];
                            }
                            // 格式4: url 字段
                            else if (uploadData.url) {
                                httpUrl = uploadData.url;
                            }

                            if (httpUrl && (httpUrl.startsWith('http://') || httpUrl.startsWith('https://'))) {
                                return httpUrl;
                            } else {
                                console.warn('拓展图片: Midjourney 返回的URL格式不正确或为空', {
                                    httpUrl,
                                    code: uploadData.code,
                                    description: uploadData.description,
                                    result: uploadData.result,
                                    data: uploadData.data,
                                    url: uploadData.url
                                });
                            }
                        } else {
                            console.warn('拓展图片: Midjourney 上传失败', {
                                code: uploadData.code,
                                description: uploadData.description,
                                fullResponse: uploadData
                            });
                        }
                    } else {
                        console.warn('拓展图片: Midjourney 上传失败', uploadResp.status, '响应内容:', responseText.substring(0, 200));
                    }
                } catch (e) {
                    console.error('拓展图片: Midjourney 上传接口调用失败', e);
                }

                // 如果 Midjourney 上传失败，尝试使用图床服务作为备选
                const mimeMatch = imageUrl.match(/data:([^;]+);base64/);
                const mimeType = mimeMatch ? mimeMatch[1] : 'image/png';

                // 将base64转换为Blob
                const byteCharacters = atob(base64Data);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: mimeType });

                const imageBedServices = [
                    // sm.ms图床
                    {
                        name: 'sm.ms',
                        url: 'https://sm.ms/api/v2/upload',
                        fieldName: 'smfile',
                        parseResponse: (data) => data.success && data.data?.url ? data.data.url : null
                    }
                ];

                for (const service of imageBedServices) {
                    if (service.skip) continue;

                    try {
                        const formData = new FormData();
                        formData.append(service.fieldName, blob, 'image.png');

                        const resp = await fetch(service.url, {
                            method: 'POST',
                            body: formData
                        });

                        if (resp.ok) {
                            const data = await resp.json();
                            const httpUrl = service.parseResponse(data);
                            if (httpUrl && (httpUrl.startsWith('http://') || httpUrl.startsWith('https://'))) {
                                return httpUrl;
                            }
                        }
                    } catch (e) {
                        console.warn(`拓展图片: ${service.name}图床上传失败:`, e);
                        continue;
                    }
                }

                // 如果所有上传方式都失败，返回null
                console.warn('拓展图片: 所有上传方式都失败，无法获取HTTP URL');
                return null;
            }

            // 其他格式，直接返回
            return imageUrl;
        } catch (error) {
            console.error('拓展图片: 上传图片失败:', error);
            return null;
        }
    };

    // 缩放图片到合理尺寸（用于Veo接口，避免图片过大）
    const resizeImageForVeo = async (imageUrl, maxWidth = 1920, maxHeight = 1920) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = () => {
                const originalWidth = img.width;
                const originalHeight = img.height;

                // 如果图片尺寸已经小于等于目标尺寸，直接返回原图
                if (originalWidth <= maxWidth && originalHeight <= maxHeight) {
                    if (imageUrl.startsWith('data:')) {
                        resolve(imageUrl);
                    } else {
                        // 如果是URL，转换为data URL
                        getBase64FromUrl(imageUrl).then(base64 => {
                            resolve(`data:image/png;base64,${base64}`);
                        }).catch(reject);
                    }
                    return;
                }

                // 计算缩放后的尺寸，保持宽高比
                let newWidth = originalWidth;
                let newHeight = originalHeight;

                if (originalWidth > maxWidth || originalHeight > maxHeight) {
                    const scale = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);
                    newWidth = Math.round(originalWidth * scale);
                    newHeight = Math.round(originalHeight * scale);

                    // 确保尺寸是偶数（某些编码器要求）
                    newWidth = newWidth % 2 === 0 ? newWidth : newWidth - 1;
                    newHeight = newHeight % 2 === 0 ? newHeight : newHeight - 1;
                }


                // 使用canvas缩放图片
                const canvas = document.createElement('canvas');
                canvas.width = newWidth;
                canvas.height = newHeight;
                const ctx = canvas.getContext('2d');

                // 使用高质量缩放
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, newWidth, newHeight);

                // 转换为data URL
                const dataUrl = canvas.toDataURL('image/png', 0.95);
                resolve(dataUrl);
            };

            img.onerror = (e) => {
                console.error('Veo: 图片加载失败', e);
                reject(new Error('图片加载失败'));
            };

            // 设置图片源
            if (imageUrl.startsWith('data:')) {
                img.src = imageUrl;
            } else if (imageUrl.startsWith('blob:')) {
                img.src = imageUrl;
            } else {
                // 对于其他URL，先转换为blob再加载（避免CORS问题）
                const useProxy = getProxyPreferenceForUrl(imageUrl, false);
                getBlobFromUrl(imageUrl, { useProxy }).then(blob => {
                    const blobUrl = URL.createObjectURL(blob);
                    img.src = blobUrl;
                }).catch(reject);
            }
        });
    };

    const disconnectConnection = useCallback((connectionId) => {
        setConnections(prev => {
            const filtered = prev.filter(conn => conn.id !== connectionId);
            // 触发节点重新渲染，确保引用成功区域正确更新
            return filtered;
        });
    }, []);

    const normalizeHistoryVideoUrl = (url, type) => {
        if (!url) return '';
        if (LocalImageManager.isImageId(url) || url.startsWith('asset://') || url.startsWith('blob:')) return url;
        if (type === 'video' && !isVideoUrl(url)) {
            return url + (url.includes('?') ? '&' : '?') + 'force_video_display=true';
        }
        return url;
    };

    const getHistoryDragPayload = (e) => {
        const rawPayload = e.dataTransfer.getData('application/x-tapnow-history');
        if (!rawPayload) return null;
        try {
            return JSON.parse(rawPayload);
        } catch (err) {
            console.warn('[Drag] Failed to parse history payload', err);
            return null;
        }
    };

    const exportApiModelConfig = useCallback((config) => {
        if (!config) return;
        const { _uid, key, url, isCustom, ...rest } = config;
        const payload = { ...rest };
        const rawName = payload.id || payload.modelName || 'model';
        const safeName = String(rawName).replace(/[^\w.-]+/g, '_');
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const fileName = `tapnow-model-${safeName}.json`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(link.href);
    }, []);
    const exportModelLibraryEntry = useCallback((entry) => {
        if (!entry) return;
        const normalized = normalizeModelLibraryEntry(entry);
        if (!normalized) return;
        const safeName = String(normalized.id || 'model').replace(/[^\w.-]+/g, '_');
        const blob = new Blob([JSON.stringify(normalized, null, 2)], { type: 'application/json' });
        const fileName = `tapnow-model-library-${safeName}.json`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(link.href);
        showToast('模型库模型已导出', 'success', 2000);
    }, [showToast]);

    const importApiModelConfigs = useCallback((providerKey) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                const rawList = Array.isArray(data)
                    ? data
                    : Array.isArray(data?.models)
                        ? data.models
                        : [data];
                const normalized = rawList
                    .map((item) => {
                        if (!item || typeof item !== 'object') return null;
                        const cleaned = { ...item };
                        delete cleaned._uid;
                        delete cleaned.key;
                        delete cleaned.url;
                        delete cleaned.isCustom;
                        const id = cleaned.id || cleaned.modelName;
                        if (!id) return null;
                        return {
                            ...cleaned,
                            id,
                            provider: providerKey || cleaned.provider,
                            type: cleaned.type || 'Chat',
                            modelName: cleaned.modelName || id,
                            displayName: cleaned.displayName || cleaned.modelName || id,
                            customParams: normalizeCustomParams(cleaned.customParams),
                            _uid: `uid-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`
                        };
                    })
                    .filter(Boolean);
                if (normalized.length === 0) {
                    showToast('未找到可导入的模型配置', 'warning', 2000);
                    return;
                }
                setApiConfigs(prev => [...prev, ...normalized]);
                showToast(`已导入 ${normalized.length} 个模型`, 'success', 3000);
            } catch (err) {
                showToast(`导入失败: ${err.message}`, 'error', 3000);
            }
        };
        input.click();
    }, [showToast]);
    const importModelLibraryEntries = useCallback(() => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                const rawList = Array.isArray(data)
                    ? data
                    : Array.isArray(data?.modelLibrary)
                        ? data.modelLibrary
                        : [data];
                const normalized = rawList
                    .map((entry, idx) => normalizeModelLibraryEntry(entry, idx))
                    .filter(Boolean);
                if (normalized.length === 0) {
                    showToast('未识别到可导入的模型库配置', 'warning', 2000);
                    return;
                }
                setModelLibrary((prev) => {
                    const existingIds = new Set(prev.map(item => item.id));
                    const next = [...prev];
                    normalized.forEach((entry) => {
                        let id = entry.id;
                        if (existingIds.has(id)) {
                            id = `${id}-${Math.random().toString(36).slice(2, 6)}`;
                        }
                        existingIds.add(id);
                        next.push({ ...entry, id });
                    });
                    return next;
                });
                showToast('模型库导入完成', 'success', 2000);
            } catch (err) {
                showToast('模型库导入失败：JSON 无效', 'error', 2000);
            }
        };
        input.click();
    }, [showToast]);

    const resolveHistoryPayloadUrl = useCallback((payload, specificUrl = null) => {
        if (!payload) return '';
        const candidates = [specificUrl, payload.url, payload.originalUrl, payload.mjOriginalUrl]
            .filter((url) => typeof url === 'string' && url);
        const historyItem = payload.itemId ? historyMap.get(payload.itemId) : null;
        if (historyItem) {
            for (const url of candidates) {
                const resolved = resolveAssetChannelUrl(resolveHistoryUrl(historyItem, url), { historyItem });
                if (resolved) return resolved;
            }
            const fallback = resolveAssetChannelUrl(resolveHistoryUrl(historyItem), { historyItem });
            if (fallback) return fallback;
        }
        for (const url of candidates) {
            const resolved = resolveAssetChannelUrl(url);
            if (resolved) return resolved;
        }
        return '';
    }, [historyMap, resolveHistoryUrl, resolveAssetChannelUrl]);

    const resolveHistoryPayloadImages = useCallback((payload) => {
        if (!payload || !Array.isArray(payload.mjImages) || payload.mjImages.length === 0) return null;
        const historyItem = payload.itemId ? historyMap.get(payload.itemId) : null;
        const resolved = historyItem
            ? payload.mjImages.map((url) => resolveAssetChannelUrl(resolveHistoryUrl(historyItem, url), { historyItem }))
            : payload.mjImages.map((url) => resolveAssetChannelUrl(url));
        const filtered = resolved.filter(Boolean);
        return filtered.length > 0 ? filtered : null;
    }, [historyMap, resolveHistoryUrl, resolveAssetChannelUrl]);

    const resolveDroppedUrlCandidate = useCallback((url, type = null) => {
        const normalized = resolveAssetChannelUrl(url);
        if (!normalized) return '';
        return normalizeHistoryVideoUrl(normalized, type);
    }, [resolveAssetChannelUrl]);

    const rewriteAssetRouteValue = useCallback((value) => {
        if (typeof value === 'string') {
            const next = resolveAssetChannelUrl(value);
            return next || '';
        }
        if (Array.isArray(value)) {
            let changed = false;
            const mapped = value.map((entry) => {
                const next = rewriteAssetRouteValue(entry);
                if (next !== entry) changed = true;
                return next;
            });
            return changed ? mapped : value;
        }
        if (!value || typeof value !== 'object') return value;
        let changed = false;
        let nextObj = value;
        Object.keys(value).forEach((key) => {
            const current = value[key];
            const next = rewriteAssetRouteValue(current);
            if (next === current) return;
            if (!changed) nextObj = { ...value };
            nextObj[key] = next;
            changed = true;
        });
        return changed ? nextObj : value;
    }, [resolveAssetChannelUrl]);

    useEffect(() => {
        setNodes((prev) => {
            let changed = false;
            const next = prev.map((node) => {
                const sanitized = rewriteAssetRouteValue(node);
                if (sanitized !== node) changed = true;
                return sanitized;
            });
            return changed ? next : prev;
        });
        setChatFiles((prev) => {
            let changed = false;
            const next = prev.map((file) => {
                if (!file || typeof file !== 'object') return file;
                const nextContent = rewriteAssetRouteValue(file.content);
                if (nextContent === file.content) return file;
                changed = true;
                return { ...file, content: nextContent };
            });
            return changed ? next : prev;
        });
    }, [localCacheEnabled, localCacheActive, localCacheIndexTick, cacheRefreshTick, rewriteAssetRouteValue]);

    const getDragUrlCandidate = (e) => {
        const uriList = e.dataTransfer.getData('text/uri-list') || '';
        const uriCandidate = uriList.split('\n').find(line => line && !line.startsWith('#')) || '';
        const plainText = e.dataTransfer.getData('text/plain') || '';
        const urlCandidate = (uriCandidate || plainText).trim();
        if (!urlCandidate) return '';
        if (/^(https?:|data:image\/|data:video\/|blob:|file:)/i.test(urlCandidate)) return urlCandidate;
        return '';
    };

    const handleDrop = async (nodeId, e) => {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.remove('drag-over');

        const payload = getHistoryDragPayload(e);
        if (payload) {
            const dragUrl = resolveDroppedUrlCandidate(resolveHistoryPayloadUrl(payload), payload.type);
            if (dragUrl) {
                const isVideo = payload.type === 'video' || isVideoUrl(dragUrl);
                let dimensions = null;
                if (!isVideo) {
                    try {
                        const metaUrl = await resolveUrlForMediaMeta(dragUrl);
                        dimensions = await getImageDimensions(metaUrl);
                    } catch { }
                }
                saveToUndoStack();
                setNodes((prev) => prev.map((n) => n.id === nodeId
                    ? { ...n, content: dragUrl, dimensions: isVideo ? null : dimensions }
                    : n));
                return;
            }
        }

        const dragUrlCandidate = resolveDroppedUrlCandidate(getDragUrlCandidate(e));
        if (dragUrlCandidate) {
            const isVideo = isVideoUrl(dragUrlCandidate);
            let dimensions = null;
            if (!isVideo) {
                try {
                    const metaUrl = await resolveUrlForMediaMeta(dragUrlCandidate);
                    dimensions = await getImageDimensions(metaUrl);
                } catch { }
            }
            saveToUndoStack();
            setNodes((prev) => prev.map((n) => n.id === nodeId
                ? { ...n, content: dragUrlCandidate, dimensions: isVideo ? null : dimensions }
                : n));
            return;
        }

        const files = Array.from(e.dataTransfer.files);
        const imageFiles = files.filter(file => file.type.startsWith('image/'));
        if (imageFiles.length > 0) {
            const file = imageFiles[0];
            const reader = new FileReader();
            reader.onload = async (ev) => {
                const content = ev.target.result;
                let dimensions = { w: 0, h: 0 };
                try { dimensions = await getImageDimensions(content); } catch (e) { }
                // V3.4.7: 保存撤销状态（图片更换是可撤销的操作）
                saveToUndoStack();
                setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, content: content, dimensions } : n));
            };
            reader.readAsDataURL(file);
        }
    };

    const appendReferenceImagesToNode = useCallback(async (nodeId, files) => {
        const node = nodesMap.get(nodeId);
        if (!node) return;
        const imageFiles = Array.from(files || []).filter(file => file.type.startsWith('image/'));
        if (imageFiles.length === 0) return;

        const newImages = await Promise.all(imageFiles.map((file) => new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(file);
        })));

        updateNodeSettings(nodeId, {
            referenceImages: [...(node.settings?.referenceImages || []), ...newImages]
        });
    }, [nodesMap, updateNodeSettings]);

    const handleDescReferenceDrop = (nodeId, e) => {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.remove('drag-over');
        if (e.dataTransfer?.files?.length) {
            appendReferenceImagesToNode(nodeId, e.dataTransfer.files);
        }
    };

    const handleDescReferenceSelect = (nodeId, e) => {
        const files = e.target.files;
        if (files && files.length > 0) {
            appendReferenceImagesToNode(nodeId, files);
        }
        e.target.value = '';
    };

    const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.add('drag-over'); };
    const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.remove('drag-over'); };

    const handlePreviewDrop = (nodeId, e) => {
        e.preventDefault();
        e.stopPropagation();
        const payload = getHistoryDragPayload(e);
        let dragUrl = '';
        let previewImages = null;
        let previewType = 'image';

        if (payload) {
            dragUrl = resolveDroppedUrlCandidate(resolveHistoryPayloadUrl(payload), payload.type);
            if (payload.mjImages && payload.mjImages.length > 1) {
                previewImages = resolveHistoryPayloadImages(payload);
                const selectedIndex = payload.selectedIndex ?? 0;
                const candidate = previewImages && previewImages[selectedIndex] ? previewImages[selectedIndex] : (previewImages ? previewImages[0] : '');
                dragUrl = candidate || dragUrl;
            }
            if (payload.type === 'video' || isVideoUrl(dragUrl)) previewType = 'video';
        }

        if (!dragUrl) {
            const candidate = getDragUrlCandidate(e);
            if (candidate) {
                dragUrl = resolveDroppedUrlCandidate(candidate);
                previewType = isVideoUrl(dragUrl) ? 'video' : 'image';
            }
        }

        if (!dragUrl) return;

        setNodes(prev => prev.map(n =>
            n.id === nodeId
                ? { ...n, content: dragUrl, previewType, previewMjImages: previewImages }
                : n
        ));
    };

    const handleCanvasDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleCanvasDrop = async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.currentTarget.id !== 'canvas-bg') return;

        const payload = getHistoryDragPayload(e);
        let dragUrl = '';
        let isVideo = false;
        if (payload) {
            dragUrl = resolveDroppedUrlCandidate(resolveHistoryPayloadUrl(payload), payload.type);
            isVideo = payload.type === 'video' || isVideoUrl(dragUrl);
        }
        if (!dragUrl) {
            const candidate = getDragUrlCandidate(e);
            if (candidate) {
                dragUrl = resolveDroppedUrlCandidate(candidate);
                isVideo = isVideoUrl(dragUrl);
            }
        }
        if (!dragUrl) return;

        const world = screenToWorld(e.clientX, e.clientY);
        if (isVideo) {
            addNode('video-input', world.x, world.y, null, dragUrl);
            return;
        }

        let dims = undefined;
        try {
            const real = await getImageDimensions(dragUrl);
            if (real?.w && real?.h) dims = { w: real.w, h: real.h };
        } catch { }
        addNode('input-image', world.x, world.y, null, dragUrl, dims);
    };

    const handleChatDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();

        const payload = getHistoryDragPayload(e);
        if (payload) {
            const resolvedUrl = resolveDroppedUrlCandidate(resolveHistoryPayloadUrl(payload), payload.type);
            if (resolvedUrl) {
                const isVideo = payload.type === 'video' || isVideoUrl(resolvedUrl);
                const isImage = !isVideo;
                const fileExt = isImage ? 'png' : 'mp4';
                const mimeType = isImage ? 'image/png' : 'video/mp4';
                setChatFiles(prev => [...prev, {
                    name: `Generated-${payload.itemId || Date.now()}.${fileExt}`,
                    type: mimeType,
                    content: resolvedUrl,
                    isImage,
                    isVideo,
                    isAudio: false,
                    fromHistory: true,
                    fileExt
                }]);
                setIsChatOpen(true);
            }
            return;
        }

        const candidate = getDragUrlCandidate(e);
        if (candidate) {
            const resolvedCandidate = resolveDroppedUrlCandidate(candidate);
            if (!resolvedCandidate) return;
            const isVideo = isVideoUrl(resolvedCandidate);
            const isImage = !isVideo;
            const fileExt = isImage ? 'png' : 'mp4';
            const mimeType = isImage ? 'image/png' : 'video/mp4';
            setChatFiles(prev => [...prev, {
                name: `Dropped-${Date.now()}.${fileExt}`,
                type: mimeType,
                content: resolvedCandidate,
                isImage,
                isVideo,
                isAudio: false,
                fromHistory: false,
                fileExt
            }]);
            setIsChatOpen(true);
            return;
        }

        if (e.dataTransfer?.files?.length) {
            appendChatFiles(e.dataTransfer.files);
            setIsChatOpen(true);
        }
    };

    // 将HTML表格转换为Markdown表格格式
    const convertTableToMarkdown = (table) => {
        const rows = Array.from(table.querySelectorAll('tr'));
        if (rows.length === 0) return '';

        const markdownRows = rows.map((row, rowIndex) => {
            const cells = Array.from(row.querySelectorAll('td, th'));
            const cellTexts = cells.map(cell => {
                const text = cell.textContent.trim().replace(/\|/g, '\\|').replace(/\n/g, ' ');
                return text || ' ';
            });
            return '| ' + cellTexts.join(' | ') + ' |';
        });

        // 添加分隔行（第二行）
        if (markdownRows.length > 0) {
            const firstRowCells = markdownRows[0].split('|').filter(c => c.trim()).length - 2;
            const separator = '| ' + Array(firstRowCells).fill('---').join(' | ') + ' |';
            markdownRows.splice(1, 0, separator);
        }

        return '\n' + markdownRows.join('\n') + '\n';
    };

    // 优化后的复制粘贴逻辑
    useEffect(() => {
        // 复制功能（Ctrl+C / Cmd+C）
        const handleCopy = async (e) => {
            const target = e.target;
            const isTextInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;

            // 优先级1：文本输入框 - 如果有选中文本，使用浏览器默认行为
            if (isTextInput) {
                const selection = window.getSelection();
                if (selection && selection.toString().trim()) {
                    // 有选中文本，让浏览器默认处理
                    return;
                }
                // 没有选中文本，不触发任何动作
                e.preventDefault();
                return;
            }

            // 优先级2和3：节点复制（包括所有类型的节点）
            const currentSelectedId = selectedNodeIdRef.current;
            const currentSelectedIds = selectedNodeIdsRef.current;
            const selectedIds = currentSelectedId ? [currentSelectedId] : (currentSelectedIds && currentSelectedIds.size > 0 ? Array.from(currentSelectedIds) : []);

            if (selectedIds.length > 0) {
                e.preventDefault();
                e.stopPropagation();
                const selectedNodes = nodesRef.current.filter(n => selectedIds.includes(n.id));
                const relatedConnections = connectionsRef.current.filter(c =>
                    selectedIds.includes(c.from) || selectedIds.includes(c.to)
                );

                // 只保存选中的节点之间的连接
                const internalConnections = relatedConnections.filter(c =>
                    selectedIds.includes(c.from) && selectedIds.includes(c.to)
                );

                copiedNodesRef.current = {
                    nodes: selectedNodes.map(n => ({ ...n })),
                    connections: internalConnections.map(c => ({ ...c })),
                    timestamp: Date.now()
                };

                // 可选：给用户反馈
            }
        };

        // 粘贴功能（Ctrl+V / Cmd+V）
        const handlePaste = async (e) => {
            const target = e.target;
            const isTextInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;

            // 优先级1：文本输入框 - 使用浏览器默认行为
            if (isTextInput) {
                // 让浏览器默认处理文本粘贴
                return;
            }

            // 优先级2：图像节点截图粘贴
            const currentSelectedId = selectedNodeIdRef.current;
            let targetNode = null;
            if (currentSelectedId) {
                targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
            }
            // 如果选中了图像或视频节点，尝试粘贴图像/视频
            if (targetNode && (targetNode.type === 'input-image' || targetNode.type === 'video-input')) {
                const items = Array.from(e.clipboardData.items);
                const imageItem = items.find(item => item.type.startsWith('image/'));
                const videoItem = items.find(item => item.type.startsWith('video/'));

                if (imageItem && targetNode.type === 'input-image') {
                    e.preventDefault();
                    const file = imageItem.getAsFile();
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            const content = ev.target.result;
                            let dimensions = { w: 0, h: 0 };
                            try {
                                dimensions = await getImageDimensions(content);
                            } catch (e) { }
                            // V3.4.7: 保存撤销状态（图片粘贴是可撤销的操作）
                            saveToUndoStack();
                            setNodes((prev) => prev.map((n) =>
                                n.id === targetNode.id
                                    ? { ...n, content: content, dimensions }
                                    : n
                            ));
                        };
                        reader.readAsDataURL(file);
                    }
                    return;
                } else if (videoItem && targetNode.type === 'video-input') {
                    e.preventDefault();
                    const file = videoItem.getAsFile();
                    if (file) {
                        handleVideoFileUpload(targetNode.id, file);
                    }
                    return;
                }
            }

            // 优先级3：节点粘贴
            if (copiedNodesRef.current && copiedNodesRef.current.nodes && copiedNodesRef.current.nodes.length > 0) {
                e.preventDefault();
                e.stopPropagation();
                const copied = copiedNodesRef.current;

                // 计算粘贴位置：使用视图中心或鼠标位置
                const canvasElement = canvasRef.current;
                let pasteX = 0, pasteY = 0;
                if (canvasElement) {
                    const rect = canvasElement.getBoundingClientRect();
                    const centerX = (rect.left + rect.width / 2 - view.x) / view.zoom;
                    const centerY = (rect.top + rect.height / 2 - view.y) / view.zoom;
                    pasteX = centerX;
                    pasteY = centerY;
                }

                // 计算原节点的中心点
                const originalNodes = copied.nodes;
                if (originalNodes.length === 0) return;

                const minX = Math.min(...originalNodes.map(n => n.x || 0));
                const minY = Math.min(...originalNodes.map(n => n.y || 0));
                const maxX = Math.max(...originalNodes.map(n => (n.x || 0) + (n.width || 0)));
                const maxY = Math.max(...originalNodes.map(n => (n.y || 0) + (n.height || 0)));
                const originalCenterX = (minX + maxX) / 2;
                const originalCenterY = (minY + maxY) / 2;

                // 计算偏移量，使新节点中心对齐到粘贴位置
                const offsetX = pasteX - originalCenterX;
                const offsetY = pasteY - originalCenterY;

                // 创建新节点ID映射
                const idMap = new Map();
                const baseTime = Date.now();
                copied.nodes.forEach((node, index) => {
                    const newId = `node-${baseTime}-${index}-${Math.random().toString(36).substr(2, 9)}`;
                    idMap.set(node.id, newId);
                });

                // 创建新节点
                const newNodes = copied.nodes.map(node => ({
                    ...node,
                    id: idMap.get(node.id),
                    x: node.x + offsetX,
                    y: node.y + offsetY
                }));

                // 创建新连接（只保留两个端点都在新节点中的连接）
                const newConnections = (copied.connections || [])
                    .filter(conn => conn && idMap.has(conn.from) && idMap.has(conn.to))
                    .map((conn, index) => ({
                        ...conn,
                        id: `conn-${baseTime}-${index}-${Math.random().toString(36).substr(2, 9)}`,
                        from: idMap.get(conn.from),
                        to: idMap.get(conn.to)
                    }));


                // V3.4.7: 保存撤销状态（粘贴节点是可撤销的操作）
                saveToUndoStack();
                setNodes(prev => [...prev, ...newNodes]);
                setConnections(prev => [...prev, ...newConnections]);

                // 选中粘贴的节点
                if (newNodes.length === 1) {
                    setSelectedNodeId(newNodes[0].id);
                    setSelectedNodeIds(new Set([newNodes[0].id]));
                } else if (newNodes.length > 1) {
                    setSelectedNodeId(null);
                    setSelectedNodeIds(new Set(newNodes.map(n => n.id)));
                }

            }
        };

        // 添加keydown事件监听，确保Ctrl+V/Cmd+V能触发节点粘贴
        const handleKeyDown = (e) => {
            const target = e.target;
            const isTextInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;

            // 如果不在文本输入框中，且按下了Ctrl+V或Cmd+V
            if (!isTextInput && (e.ctrlKey || e.metaKey) && e.key === 'v') {
                // 先检查是否选中了图像节点，如果是，让paste事件处理图像粘贴
                const currentSelectedId = selectedNodeIdRef.current;
                if (currentSelectedId) {
                    const targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
                    if (targetNode && (targetNode.type === 'input-image' || targetNode.type === 'video-input')) {
                        // 选中了图像节点，让paste事件处理，不在这里处理
                        return;
                    }
                }

                // 检查是否有复制的节点
                if (copiedNodesRef.current && copiedNodesRef.current.nodes && copiedNodesRef.current.nodes.length > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    // 直接调用粘贴逻辑
                    const copied = copiedNodesRef.current;

                    // 计算粘贴位置：使用视图中心
                    const canvasElement = canvasRef.current;
                    let pasteX = 0, pasteY = 0;
                    if (canvasElement) {
                        const rect = canvasElement.getBoundingClientRect();
                        const centerX = (rect.left + rect.width / 2 - view.x) / view.zoom;
                        const centerY = (rect.top + rect.height / 2 - view.y) / view.zoom;
                        pasteX = centerX;
                        pasteY = centerY;
                    }

                    // 计算原节点的中心点
                    const originalNodes = copied.nodes;
                    if (originalNodes.length === 0) return;

                    const minX = Math.min(...originalNodes.map(n => n.x || 0));
                    const minY = Math.min(...originalNodes.map(n => n.y || 0));
                    const maxX = Math.max(...originalNodes.map(n => (n.x || 0) + (n.width || 0)));
                    const maxY = Math.max(...originalNodes.map(n => (n.y || 0) + (n.height || 0)));
                    const originalCenterX = (minX + maxX) / 2;
                    const originalCenterY = (minY + maxY) / 2;

                    // 计算偏移量
                    const offsetX = pasteX - originalCenterX;
                    const offsetY = pasteY - originalCenterY;

                    // 创建新节点ID映射
                    const idMap = new Map();
                    const baseTime = Date.now();
                    copied.nodes.forEach((node, index) => {
                        const newId = `node-${baseTime}-${index}-${Math.random().toString(36).substr(2, 9)}`;
                        idMap.set(node.id, newId);
                    });

                    // 创建新节点
                    const newNodes = copied.nodes.map(node => ({
                        ...node,
                        id: idMap.get(node.id),
                        x: node.x + offsetX,
                        y: node.y + offsetY
                    }));

                    // 创建新连接（只保留两个端点都在新节点中的连接）
                    const newConnections = (copied.connections || [])
                        .filter(conn => conn && idMap.has(conn.from) && idMap.has(conn.to))
                        .map((conn, index) => ({
                            ...conn,
                            id: `conn-${baseTime}-${index}-${Math.random().toString(36).substr(2, 9)}`,
                            from: idMap.get(conn.from),
                            to: idMap.get(conn.to)
                        }));

                    // V3.4.7: 保存撤销状态（粘贴节点是可撤销的操作）
                    saveToUndoStack();
                    setNodes(prev => [...prev, ...newNodes]);
                    setConnections(prev => [...prev, ...newConnections]);

                    // 选中粘贴的节点
                    if (newNodes.length === 1) {
                        setSelectedNodeId(newNodes[0].id);
                        setSelectedNodeIds(new Set([newNodes[0].id]));
                    } else if (newNodes.length > 1) {
                        setSelectedNodeId(null);
                        setSelectedNodeIds(new Set(newNodes.map(n => n.id)));
                    }

                }
            }
        };

        window.addEventListener('copy', handleCopy);
        window.addEventListener('paste', handlePaste);
        window.addEventListener('keydown', handleKeyDown);

        return () => {
            window.removeEventListener('copy', handleCopy);
            window.removeEventListener('paste', handlePaste);
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [updateNodeSettings, handleVideoFileUpload, setNodes, setConnections, setSelectedNodeId, setSelectedNodeIds, view]);

    const pollVeoJob = async (jobId, taskId, baseUrl, apiKey, w, h, attempt = 0) => {
        const maxAttempts = 90; // 增加到90次，支持最长360秒（6分钟）的生成时间
        const delayMs = 4000;

        if (attempt > maxAttempts) {
            setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: 'Veo 轮询超时' } : hItem));

            // 检查是否是分镜表的任务，如果是则更新状态为 draft
            const storyboardTask = storyboardTaskMapRef.current.get(taskId);
            if (storyboardTask) {
                updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                    status: 'draft'
                });
                // 清理任务映射
                storyboardTaskMapRef.current.delete(taskId);
            }
            return;
        }

        fetch(`${baseUrl}/v2/videos/generations/${jobId}`, {
            method: 'GET',
            headers: { Authorization: `Bearer ${apiKey}` },
        })
            .then(async (resp) => {
                const text = await resp.text();
                let data;
                try { data = JSON.parse(text); } catch (err) { setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs); return; }

                const status = data?.data?.status || data?.status || data?.data?.task_status;
                const progress = data?.data?.progress || data?.progress || '0%';
                const failReason = data?.data?.fail_reason || data?.fail_reason || '';

                // 处理成功状态
                if (status === 'SUCCESS' || status === 'succeeded' || status === 'FINISHED' || status === 'completed') {
                    const videoUrl = data?.data?.output || data?.output || data?.data?.video_url || data?.video_url || data?.data?.data?.output;
                    if (!videoUrl) {
                        console.warn('[Tapnow] Veo: 任务成功但未找到视频URL', data);
                        setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: '未找到视频URL' } : hItem));
                        return;
                    }
                    const endTime = Date.now();
                    // 在更新 history 之前，先获取 sourceNodeId 和 ratio
                    // 使用函数式更新来确保获取最新的 historyItem
                    setHistory((prev) => {
                        const historyItem = prev.find(h => h.id === taskId);
                        const sourceNodeId = historyItem?.sourceNodeId;
                        const originalRatio = historyItem?.ratio;
                        const durationMs = endTime - (historyItem?.startTime || endTime);


                        // 对于 veo3.1，尝试从实际视频获取真实尺寸
                        let finalW = w, finalH = h;

                        // 异步获取视频尺寸并更新（使用 Promise）
                        (async () => {
                            try {
                                const videoMeta = await getVideoMetadata(videoUrl);
                                if (videoMeta && videoMeta.w > 0 && videoMeta.h > 0) {
                                    const actualW = videoMeta.w;
                                    const actualH = videoMeta.h;

                                    // 验证实际尺寸是否匹配请求的 aspect_ratio
                                    if (originalRatio === '16:9') {
                                        const actualRatio = actualW / actualH;
                                        const expectedRatio = 16 / 9;
                                        if (Math.abs(actualRatio - expectedRatio) > 0.1) {
                                            console.warn(`[Tapnow] Veo: 视频实际比例 ${actualRatio.toFixed(2)} 不匹配请求的 16:9 (${expectedRatio.toFixed(2)})，后端返回了错误的比例！`);
                                            console.warn(`[Tapnow] Veo: 实际尺寸: ${actualW}x${actualH}, 请求比例: 16:9`);
                                            console.warn(`[Tapnow] Veo: 强制使用请求的 16:9 比例，调整尺寸为: ${w}x${Math.round(w / (16 / 9))}`);
                                            // 如果后端返回了错误的比例，强制使用请求的比例
                                            finalW = w;
                                            finalH = Math.round(w / (16 / 9));
                                        } else {
                                            finalW = actualW;
                                            finalH = actualH;
                                        }
                                    } else if (originalRatio === '9:16') {
                                        const actualRatio = actualW / actualH;
                                        const expectedRatio = 9 / 16;
                                        if (Math.abs(actualRatio - expectedRatio) > 0.1) {
                                            console.warn(`[Tapnow] Veo: 视频实际比例 ${actualRatio.toFixed(2)} 不匹配请求的 9:16 (${expectedRatio.toFixed(2)})，后端返回了错误的比例！`);
                                            console.warn(`[Tapnow] Veo: 实际尺寸: ${actualW}x${actualH}, 请求比例: 9:16`);
                                            console.warn(`[Tapnow] Veo: 强制使用请求的 9:16 比例，调整尺寸为: ${Math.round(h * (9 / 16))}x${h}`);
                                            // 如果后端返回了错误的比例，强制使用请求的比例
                                            finalW = Math.round(h * (9 / 16));
                                            finalH = h;
                                        } else {
                                            finalW = actualW;
                                            finalH = actualH;
                                        }
                                    } else {
                                        // 如果没有指定比例，使用实际尺寸
                                        finalW = actualW;
                                        finalH = actualH;
                                    }

                                    // 更新历史记录
                                    setHistory((prevHistory) => {
                                        return prevHistory.map((hItem) =>
                                            hItem.id === taskId
                                                ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: finalW, height: finalH, durationMs, ratio: originalRatio || hItem.ratio }
                                                : hItem
                                        );
                                    });

                                    // 检查是否是分镜表的任务，如果是则回填到分镜表
                                    const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                                    if (storyboardTask) {
                                        updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                            video_url: videoUrl,
                                            status: 'done',
                                            durationCost: durationMs / 1000 // Save duration in seconds
                                        });
                                        // 清理任务映射
                                        storyboardTaskMapRef.current.delete(taskId);
                                    } else {
                                        // 更新预览窗口（非分镜表任务）
                                        if (sourceNodeId) {
                                            setTimeout(() => {
                                                updatePreviewFromTask(taskId, videoUrl, 'video', sourceNodeId);
                                            }, 0);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('[Tapnow] Veo: 无法获取视频实际尺寸，使用请求尺寸', e);
                                // 如果无法获取实际尺寸，使用请求的尺寸并根据 aspect_ratio 调整
                                let fallbackW = w, fallbackH = h;
                                if (originalRatio === '16:9') {
                                    const aspectRatioValue = fallbackW / fallbackH;
                                    if (Math.abs(aspectRatioValue - 16 / 9) > 0.1) {
                                        fallbackH = Math.round(fallbackW / (16 / 9));
                                    }
                                } else if (originalRatio === '9:16') {
                                    const aspectRatioValue = fallbackW / fallbackH;
                                    if (Math.abs(aspectRatioValue - 9 / 16) > 0.1) {
                                        fallbackW = Math.round(fallbackH * (9 / 16));
                                    }
                                }

                                // 更新历史记录
                                setHistory((prevHistory) => {
                                    return prevHistory.map((hItem) =>
                                        hItem.id === taskId
                                            ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: fallbackW, height: fallbackH, durationMs, ratio: originalRatio || hItem.ratio }
                                            : hItem
                                    );
                                });

                                // 检查是否是分镜表的任务，如果是则回填到分镜表
                                const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                                if (storyboardTask) {
                                    updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                        video_url: videoUrl,
                                        status: 'done',
                                        durationCost: durationMs / 1000 // Save duration in seconds
                                    });
                                    // 清理任务映射
                                    storyboardTaskMapRef.current.delete(taskId);
                                } else {
                                    // 更新预览窗口（非分镜表任务）
                                    if (sourceNodeId) {
                                        setTimeout(() => {
                                            updatePreviewFromTask(taskId, videoUrl, 'video', sourceNodeId);
                                        }, 0);
                                    }
                                }
                            }
                        })();

                        // 先返回原始状态，等待异步操作完成后再更新
                        return prev;
                    });
                    return;
                }

                // 处理失败状态
                if (status === 'FAILED' || status === 'ERROR' || status === 'CANCELLED') {
                    let errorMsg = `任务失败: ${status}`;
                    if (failReason) {
                        try {
                            const reasonObj = typeof failReason === 'string' ? JSON.parse(failReason) : failReason;
                            errorMsg = reasonObj?.message || reasonObj?.code || failReason;
                        } catch (e) {
                            errorMsg = failReason || errorMsg;
                        }
                    }
                    console.error('[Tapnow] Veo: 任务失败', { status, failReason, errorMsg });
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg } : hItem));

                    // V3.7.33: Save duration even on failure for storyboard
                    const endTime = Date.now();
                    // Need to find startTime from history
                    // Since specific history item isn't easily accessible here without searching 'prev', we rely on storyboardTaskMapRef if possible or just use current time approx
                    // Better to calculate approximate duration if history lookup is hard within state updater, but we can do it outside
                    // NOTE: pollVeoJob doesn't have easy access to historyMap like pollSoraJob above (which used it).
                    // We can conceptually assume startTime was passed or we just check the item.
                    // Let's use a functional update for history to find it, but we need to run side effect.
                    // For now, simpler approach: we don't have perfect duration for Veo failure here easily without reading history. 
                    // Let's defer to avoiding complex lookup inside loop. 
                    // Wait, we can use the ref map to check if it's a storyboard task first.
                    const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                    if (storyboardTask) {
                        // For Veo/Jimeng, we don't have local historyMap cache updated in pollVeoJob scope usually? 
                        // Actually historyMap is just a ref or state? It was used in pollSoraJob as `historyMap.get(taskId)`.
                        // `historyMap` is defined in App component scope? Yes, `const [historyMap, setHistoryMap] = useState(new Map());` NO, it's usually derived or ref.
                        // Checked file: `historyMap` was used in pollSoraJob. Let's assume it's available.
                        // If not, we can't easily get startTime.
                        // Fallback: We can't get accurate duration easily. BUT user wants persistent time.
                        // Maybe just mark as failed. If we can't get duration, we can't show it.
                        // Let's try to access historyMap.
                        const historyItem = historyMap.get(taskId);
                        const durationMs = historyItem ? (Date.now() - historyItem.startTime) : 0;

                        updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                            status: 'failed',
                            errorMsg,
                            durationCost: durationMs / 1000
                        });
                        storyboardTaskMapRef.current.delete(taskId);
                    }
                    return;
                }

                // 处理 NOT_START 状态：可能是任务还在队列中，继续等待
                if (status === 'NOT_START' || status === 'PENDING' || status === 'QUEUED') {
                    // 对于 NOT_START 状态，进度更新更慢一些，避免频繁更新
                    const currentProgress = parseInt(progress) || 0;
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? {
                        ...hItem,
                        status: 'generating',
                        progress: Math.max(5, currentProgress),
                        errorMsg: status === 'NOT_START' ? '任务已创建，等待处理中...' : undefined
                    } : hItem));
                    setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs);
                    return;
                }

                // 其他状态（如 PROCESSING、GENERATING 等）：继续轮询
                const currentProgress = parseInt(progress) || Math.min(95, (attempt * 2) + 10);
                setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'generating', progress: currentProgress } : hItem));
                setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs);
            })
            .catch((err) => setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs));
    };

    const pollSoraJob = (jobId, taskId, baseUrl, apiKey, w, h, modelId = '', attempt = 0) => {
        // V3.5.15 debug: Prevent polling with null/undefined jobId
        if (!jobId || jobId === 'null' || jobId === 'undefined') {
            console.error(`[Poll Error] Invalid JobId: ${jobId} for task ${taskId}`);
            setHistory(prev => prev.map(hItem => hItem.id === taskId ? {
                ...hItem,
                status: 'failed',
                errorMsg: 'Task failed: No Job ID returned',
                durationMs: Date.now() - (hItem.startTime || Date.now()) // Stop timer
            } : hItem));
            return;
        }

        // Sora 2 Pro 需要更长的等待时间（30分钟），其他模型保持原有设置（约6.5分钟）
        const maxAttempts = modelId === 'sora-2-pro' ? 360 : 80;
        const delayMs = 5000;

        if (attempt > maxAttempts) {
            setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: 'Sora 轮询超时' } : hItem));

            // 检查是否是分镜表的任务，如果是则更新状态为 draft
            const storyboardTask = storyboardTaskMapRef.current.get(taskId);
            if (storyboardTask) {
                updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                    status: 'draft'
                });
                // 清理任务映射
                storyboardTaskMapRef.current.delete(taskId);
            }
            return;
        }

        const pollEndpoint = modelId?.includes('grok')
            ? `${baseUrl}/v2/videos/generations/${encodeURIComponent(jobId)}`
            : `${baseUrl}/v1/videos/${encodeURIComponent(jobId)}`;

        fetch(pollEndpoint, {
            method: 'GET',
            headers: { Authorization: `Bearer ${apiKey}` },
        })
            .then(resp => {
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                }
                return resp.text();
            })
            .then((text) => {
                let data;
                try {
                    data = JSON.parse(text);
                } catch (err) {
                    console.error('[Tapnow] Sora/Grok Poll JSON 解析失败:', err, text);
                    setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs);
                    return;
                }

                const status = data?.data?.status || data?.status || data?.data?.task_status || data?.task_status;

                if (status === 'SUCCESS' || status === 'succeeded' || status === 'FINISHED' || status === 'completed') {
                    const videoUrl = data?.data?.output || data?.output || data?.data?.video_url || data?.data?.url || data?.video_url || data?.url;
                    if (!videoUrl) {
                        setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: '未找到视频URL' } : hItem));
                        return;
                    }
                    const endTime = Date.now();
                    // 在更新 history 之前，先获取 sourceNodeId
                    const historyItem = historyMap.get(taskId);
                    const sourceNodeId = historyItem?.sourceNodeId;
                    const durationMs = endTime - (historyItem?.startTime || endTime);
                    // 使用 setHistory 的回调来确保获取最新的 historyItem
                    setHistory((prev) => {
                        const updated = prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: w, height: h, durationMs } : hItem);
                        // 检查是否是分镜表的任务，如果是则回填到分镜表
                        const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                        if (storyboardTask) {
                            updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                video_url: videoUrl,
                                status: 'done',
                                durationCost: durationMs / 1000 // Save duration in seconds
                            });
                            // 清理任务映射
                            storyboardTaskMapRef.current.delete(taskId);
                        } else {
                            // 更新预览窗口（非分镜表任务）
                            const updatedItem = updated.find(h => h.id === taskId);
                            if (updatedItem?.sourceNodeId) {
                                setTimeout(() => {
                                    updatePreviewFromTask(taskId, videoUrl, 'video', updatedItem.sourceNodeId);
                                }, 0);
                            } else {
                                console.warn('[Tapnow] Sora: 未找到 sourceNodeId', { taskId, updatedItem });
                            }
                        }
                        return updated;
                    });
                    return;
                }

                if (status === 'FAILED' || status === 'ERROR' || status === 'CANCELLED') {
                    setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: `任务失败: ${status}` } : hItem));

                    // V3.7.33: Save duration even on failure for storyboard
                    const endTime = Date.now();
                    const historyItem = historyMap.get(taskId);
                    const durationMs = endTime - (historyItem?.startTime || endTime);

                    const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                    if (storyboardTask) {
                        updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                            status: 'failed',
                            errorMsg: `任务失败: ${status}`,
                            durationCost: durationMs / 1000
                        });
                        storyboardTaskMapRef.current.delete(taskId);
                    }
                    return;
                }

                setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'generating', progress: Math.min(95, (hItem.progress || 10) + 2) } : hItem));
                setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs);
            })
            .catch(err => {
                console.error('[Tapnow] Sora/Grok Poll 请求失败:', err);
                // 如果是网络错误，继续重试；如果是其他错误，标记为失败
                if (attempt < maxAttempts - 5) {
                    // 前75次尝试继续重试
                    setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs);
                } else {
                    // 最后5次尝试失败后，标记为失败
                    setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: `轮询失败: ${err.message || '网络错误'}` } : hItem));
                }
            });
    };

    // 切割Midjourney返回的4张图（2x2网格）
    // 压缩图片以减少存储大小
    const compressImage = (dataUrl, maxWidth = 1024, quality = 0.8) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // 计算压缩后的尺寸
                let width = img.width;
                let height = img.height;
                if (width > maxWidth || height > maxWidth) {
                    const scale = maxWidth / Math.max(width, height);
                    width = Math.floor(width * scale);
                    height = Math.floor(height * scale);
                }

                canvas.width = width;
                canvas.height = height;

                // 绘制并压缩
                ctx.drawImage(img, 0, 0, width, height);
                // 使用JPEG格式压缩，减少文件大小
                const compressed = canvas.toDataURL('image/jpeg', quality);
                resolve(compressed);
            };
            img.onerror = () => resolve(dataUrl); // 如果压缩失败，返回原图
            img.src = dataUrl;
        });
    };

    const splitMidjourneyImage = async (imageUrl, ratio = '1:1') => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';

            // 设置超时，防止图片加载卡死
            const timeout = setTimeout(() => {
                reject(new Error('图片加载超时'));
            }, 30000); // 30秒超时

            img.onload = () => {
                clearTimeout(timeout);
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // Midjourney返回的是2x2网格，每张图是原图的1/4
                    // 计算每张图的尺寸（使用Math.floor确保整数像素）
                    const singleWidth = Math.floor(img.width / 2);
                    const singleHeight = Math.floor(img.height / 2);

                    // 计算实际每张图的比例
                    const actualRatio = singleWidth / singleHeight;

                    const images = [];

                    // 切割4张图：左上、右上、左下、右下
                    for (let row = 0; row < 2; row++) {
                        for (let col = 0; col < 2; col++) {
                            // 计算裁剪区域（确保不超出边界）
                            const cropX = Math.max(0, Math.min(col * singleWidth, img.width - singleWidth));
                            const cropY = Math.max(0, Math.min(row * singleHeight, img.height - singleHeight));
                            const cropW = Math.min(singleWidth, img.width - cropX);
                            const cropH = Math.min(singleHeight, img.height - cropY);

                            // 设置canvas尺寸
                            canvas.width = cropW;
                            canvas.height = cropH;

                            // 清空canvas并设置白色背景（防止透明区域）
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(0, 0, cropW, cropH);

                            // 提取图片区域
                            ctx.drawImage(
                                img,
                                cropX, cropY, cropW, cropH,
                                0, 0, cropW, cropH
                            );

                            // 使用PNG格式，保持图片质量
                            const dataUrl = canvas.toDataURL('image/png');
                            images.push({
                                url: dataUrl,
                                width: cropW,
                                height: cropH,
                                ratio: actualRatio
                            });
                        }
                    }

                    resolve(images);
                } catch (error) {
                    console.error('Midjourney: 切割图片时出错:', error);
                    reject(error);
                }
            };

            img.onerror = (e) => {
                clearTimeout(timeout);
                console.error('Midjourney: Failed to load image for splitting:', e);
                reject(new Error('图片加载失败'));
            };

            img.src = imageUrl;
        });
    };

    // 异步图像生成任务轮询函数
    const pollImageTask = (taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, attempt = 0, isBananaModel = false) => {
        // banana模型使用800秒超时（160次 * 5秒），其他模型使用25分钟（300次 * 5秒）
        const maxAttempts = isBananaModel ? 160 : 300;
        const baseDelayMs = 5000; // 基础轮询间隔5秒
        const delayMs = baseDelayMs;
        const isLikelyImageValue = (value) => {
            if (!value || typeof value !== 'string') return false;
            const trimmed = value.trim();
            if (!trimmed) return false;
            if (trimmed.startsWith('http://') || trimmed.startsWith('https://') || trimmed.startsWith('data:')) return true;
            if (LocalImageManager?.isImageId && LocalImageManager.isImageId(trimmed)) return true;
            const base64Like = /^[A-Za-z0-9+/=_-]+$/.test(trimmed);
            return base64Like && trimmed.length > 64;
        };

        if (attempt > maxAttempts) {
            const timeoutSeconds = isBananaModel ? 800 : 1500;
            setHistory((prev) => prev.map((hItem) =>
                hItem.id === taskId
                    ? { ...hItem, status: 'failed', errorMsg: `图像生成轮询超时（已等待${timeoutSeconds}秒）` }
                    : hItem
            ));
            return;
        }

        const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
        const pollUrl = `${cleanBaseUrl}/v1/images/tasks/${taskIdForPoll}`;

        fetch(pollUrl, {
            method: 'GET',
            headers: {
                Authorization: `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            },
        })
            .then(async (resp) => {
                if (resp.status === 401 || resp.status === 402 || resp.status === 403) {
                    const reason = resp.status === 402 ? '积分耗尽 (402)' : (resp.status === 401 ? '认证失效 (401)' : '访问被拒绝 (403)');
                    setHistory((prev) => prev.map((hItem) => {
                        if (hItem.id !== taskId) return hItem;
                        const durationMs = Date.now() - (hItem.startTime || Date.now());
                        const errorMsg = `图像轮询失败: ${reason}`;
                        const storyboardTask = storyboardTaskMapRef.current.get(taskId) || parseStoryboardSourceNodeId(hItem.sourceNodeId || sourceNodeId);
                        if (storyboardTask?.isImageMode) {
                            updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                status: 'failed',
                                errorMsg,
                                durationCost: durationMs / 1000
                            });
                            storyboardTaskMapRef.current.delete(taskId);
                        }
                        return { ...hItem, status: 'failed', errorMsg };
                    }));
                    return;
                }
                const text = await resp.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (err) {
                    console.error('[Async Image] Failed to parse response:', err);
                    setTimeout(() => pollImageTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, attempt + 1, isBananaModel), delayMs);
                    return;
                }


                // 根据API规范，响应格式可能有多种：
                // 1. { code, message, data: { status, images: [...] } }
                // 2. { status: "SUCCESS", data: { data: [{ url: "..." }] } }
                // 3. { task_id: "...", status: "SUCCESS", data: { data: [{ url: "..." }] } }
                const status = (data?.data?.status || data?.status || '').toUpperCase();
                console.log('[Async Image] 提取的状态:', status, '原始数据:', {
                    hasData: !!data?.data,
                    hasDataData: !!data?.data?.data,
                    hasDataStatus: !!data?.data?.status,
                    hasStatus: !!data?.status,
                    dataKeys: data ? Object.keys(data) : []
                });

                let images = [];

                // 尝试多种方式提取图片数据（按优先级顺序）
                // 方式1：data.data.data（嵌套格式，最常见）
                if (data?.data?.data && Array.isArray(data.data.data) && data.data.data.length > 0) {
                    images = data.data.data;
                }
                // 方式2：data.data.images
                else if (data?.data?.images && Array.isArray(data.data.images) && data.data.images.length > 0) {
                    images = data.data.images;
                }
                // 方式3：data.images
                else if (data?.images && Array.isArray(data.images) && data.images.length > 0) {
                    images = data.images;
                }
                // 方式4：data.data（标准OpenAI格式）
                else if (data?.data && Array.isArray(data.data) && data.data.length > 0) {
                    images = data.data;
                }

                // 如果还是没有找到图片，尝试从revised_prompt中提取URL（备用方案）
                if (images.length === 0) {
                    // 尝试从data.data.data[0].revised_prompt中提取
                    if (data?.data?.data && Array.isArray(data.data.data) && data.data.data.length > 0) {
                        const firstItem = data.data.data[0];
                        if (firstItem?.revised_prompt) {
                            const urlMatch = firstItem.revised_prompt.match(/!\[.*?\]\((https?:\/\/[^\s\)]+)\)/);
                            if (urlMatch && urlMatch[1]) {
                                images = [{ url: urlMatch[1] }];
                            }
                        }
                    }
                    // 尝试从data.data.revised_prompt中提取
                    if (images.length === 0 && data?.data?.revised_prompt) {
                        const urlMatch = data.data.revised_prompt.match(/!\[.*?\]\((https?:\/\/[^\s\)]+)\)/);
                        if (urlMatch && urlMatch[1]) {
                            images = [{ url: urlMatch[1] }];
                        }
                    }
                    // 最后尝试：如果data.data.data存在但images为空，可能是数据结构问题，直接使用data.data.data
                    if (images.length === 0 && data?.data?.data && Array.isArray(data.data.data) && data.data.data.length > 0) {
                        // 检查每个元素是否有url字段
                        const itemsWithUrl = data.data.data.filter(item => item?.url || item?.image_url || item?.imageUrl);
                        if (itemsWithUrl.length > 0) {
                            images = itemsWithUrl;
                        }
                    }

                    // 如果任务状态是SUCCESS但还没找到图片，立即执行深度搜索（不等待后续处理）
                    if (images.length === 0 && (status === 'COMPLETED' || status === 'SUCCESS' || status === 'FINISHED' || status === 'DONE')) {
                        // 优化后的深度搜索函数：优先检查常见路径，减少递归深度
                        const deepSearchForUrl = (obj, depth = 0, visited = new WeakSet()) => {
                            if (depth > 5) return null; // 防止无限递归
                            if (!obj || typeof obj !== 'object') return null;

                            // 防止循环引用
                            if (visited.has(obj)) return null;
                            visited.add(obj);

                            // 优先检查当前对象的常见字段（避免不必要的递归）
                            const urlFields = ['url', 'image_url', 'imageUrl', 'image', 'src', 'link', 'href'];
                            for (const field of urlFields) {
                                if (isLikelyImageValue(obj[field])) {
                                    return obj[field];
                                }
                            }

                            // 如果是数组，优先检查第一个元素
                            if (Array.isArray(obj) && obj.length > 0) {
                                const result = deepSearchForUrl(obj[0], depth + 1, visited);
                                if (result) return result;
                            }

                            // 递归搜索所有属性（但跳过已检查的常见字段）
                            for (const key in obj) {
                                if (obj.hasOwnProperty(key) && !urlFields.includes(key)) {
                                    const result = deepSearchForUrl(obj[key], depth + 1, visited);
                                    if (result) return result;
                                }
                            }

                            return null;
                        };

                        const foundUrl = deepSearchForUrl(data);
                        if (foundUrl) {
                            images = [{ url: foundUrl }];
                        } else {
                            console.warn('[Async Image] 深度搜索未找到图片URL，响应数据结构:', JSON.stringify(data, null, 2).substring(0, 500));
                        }
                    }
                }

                const errorMsg = data?.message || data?.error || data?.fail_reason || '';
                const completedStatuses = new Set(['COMPLETED', 'SUCCESS', 'FINISHED', 'DONE']);
                const failedStatuses = new Set(['FAILED', 'ERROR', 'CANCELLED', 'FAILURE']);
                const isCompletedStatus = completedStatuses.has(status);
                const isFailedStatus = failedStatuses.has(status);
                let rawImageUrls = [];
                let resolvedImageUrls = [];
                if (isCompletedStatus && images && images.length > 0) {
                    rawImageUrls = images.flatMap((img) => {
                        if (!img) return [];
                        if (typeof img === 'string') return [img];
                        const candidates = [
                            img.url,
                            img.image_url,
                            img.imageUrl,
                            img.object_url,
                            img.objectUrl,
                            img.path,
                            img.uri,
                            img.file_uri,
                            img.fileUri,
                            img.b64_json,
                            img.base64,
                            img.data
                        ];
                        return candidates.filter(Boolean);
                    });
                    if (rawImageUrls.length > 0) {
                        try {
                            resolvedImageUrls = await normalizeImageUrls(rawImageUrls);
                        } catch (e) {
                            resolvedImageUrls = [];
                        }
                        if (resolvedImageUrls.length === 0) resolvedImageUrls = rawImageUrls;
                    }
                }

                // 更新历史记录
                setHistory((prev) => {
                    const updated = prev.map((hItem) => {
                        if (hItem.id !== taskId) return hItem;

                        // 保存sourceNodeId，用于后续更新预览窗口
                        const savedSourceNodeId = hItem.sourceNodeId || sourceNodeId;

                        // 支持多种成功状态值
                        if (isCompletedStatus) {
                            if (resolvedImageUrls.length > 0) {
                                const primaryUrl = resolvedImageUrls[0];

                                // 优先使用后端返回的实际花费时间（如果存在）
                                // 后端可能返回的字段：duration, cost_time, elapsed_time, time_cost, spent_time 等（单位可能是秒或毫秒）
                                let durationMs = null;
                                const backendDuration = data?.data?.duration || data?.data?.cost_time || data?.data?.elapsed_time ||
                                    data?.data?.time_cost || data?.data?.spent_time || data?.duration ||
                                    data?.cost_time || data?.elapsed_time || data?.time_cost || data?.spent_time;

                                if (backendDuration !== null && backendDuration !== undefined) {
                                    // 如果后端返回的是秒（数字<10000），转换为毫秒；否则认为是毫秒
                                    if (typeof backendDuration === 'number') {
                                        durationMs = backendDuration < 10000 ? backendDuration * 1000 : backendDuration;
                                    } else if (typeof backendDuration === 'string') {
                                        // 尝试解析字符串格式的时间（如 "49.0s", "107.0s"）
                                        const match = backendDuration.match(/(\d+\.?\d*)\s*(s|ms|秒|毫秒)/i);
                                        if (match) {
                                            const value = parseFloat(match[1]);
                                            const unit = match[2].toLowerCase();
                                            durationMs = (unit === 's' || unit === '秒') ? value * 1000 : value;
                                        } else {
                                            const parsed = parseFloat(backendDuration);
                                            if (!isNaN(parsed)) {
                                                durationMs = parsed < 10000 ? parsed * 1000 : parsed;
                                            }
                                        }
                                    }
                                }

                                // 如果后端没有返回时间，使用前端计算的时间
                                if (durationMs === null) {
                                    const endTime = Date.now();
                                    durationMs = endTime - (hItem.startTime || endTime);
                                }

                                console.log('[Async Image] 任务完成，准备更新UI:', {
                                    taskId,
                                    url: primaryUrl,
                                    sourceNodeId: savedSourceNodeId,
                                    imageCount: resolvedImageUrls.length,
                                    durationMs,
                                    backendDuration,
                                    frontendCalculated: durationMs === null ? null : (Date.now() - (hItem.startTime || Date.now()))
                                });

                                // V3.6.1: 检查是否是分镜表的图片任务
                                const hasStoryboardTask = storyboardTaskMapRef.current.has(taskId);
                                if (hasStoryboardTask) {
                                    const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                                    if (storyboardTask && storyboardTask.isImageMode) {
                                        // V3.7.29: 传递所有图片，与同步生成保持一致
                                        updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                            output_images: resolvedImageUrls, // V3.7.29: 所有图片
                                            output_url: primaryUrl,   // 兼容旧逻辑
                                            selectedImageIndex: 0,    // 默认选中第一张
                                            outputEnabled: false,     // 用户手动选择满意的
                                            status: 'done',
                                            durationCost: durationMs / 1000
                                        });
                                        // 清理任务映射
                                        storyboardTaskMapRef.current.delete(taskId);
                                    } else {
                                        console.warn('[V3.7.30 Async Debug] 分镜表任务未找到或不是图片模式，无法回填');
                                    }
                                }

                                const fallbackStoryboard = !hasStoryboardTask
                                    ? parseStoryboardSourceNodeId(savedSourceNodeId || hItem.sourceNodeId)
                                    : null;
                                if (fallbackStoryboard?.isImageMode) {
                                    updateShot(fallbackStoryboard.nodeId, fallbackStoryboard.shotId, {
                                        output_images: resolvedImageUrls,
                                        output_url: primaryUrl,
                                        selectedImageIndex: 0,
                                        outputEnabled: false,
                                        status: 'done',
                                        durationCost: durationMs / 1000
                                    });
                                }

                                // 更新预览窗口（立即执行，不等待）
                                // 即使savedSourceNodeId为空，也尝试调用updatePreviewFromTask，它会从history中查找
                                const nodeIdToUse = savedSourceNodeId || hItem.sourceNodeId;
                                console.log('[Async Image] 准备更新预览窗口', {
                                    taskId,
                                    url: primaryUrl,
                                    sourceNodeId: nodeIdToUse,
                                    savedSourceNodeId,
                                    hItemSourceNodeId: hItem.sourceNodeId,
                                    imageCount: resolvedImageUrls.length
                                });
                                // 使用requestAnimationFrame确保在下一个渲染周期更新，但比setTimeout更快
                                requestAnimationFrame(() => {
                                    updatePreviewFromTask(taskId, primaryUrl, 'image', nodeIdToUse, resolvedImageUrls.length > 1 ? resolvedImageUrls : null);
                                });

                                return {
                                    ...hItem,
                                    status: 'completed',
                                    progress: 100,
                                    url: primaryUrl,
                                    width: w,
                                    height: h,
                                    durationMs,
                                    errorMsg: null,
                                    sourceNodeId: savedSourceNodeId || hItem.sourceNodeId, // 确保sourceNodeId被保留
                                    output_images: resolvedImageUrls,
                                    ...(resolvedImageUrls.length > 1 ? { mjImages: resolvedImageUrls, selectedMjImageIndex: 0 } : {})
                                };
                            }

                            // 如果所有方法都失败，标记为失败
                            return {
                                ...hItem,
                                status: 'failed',
                                errorMsg: errorMsg || '任务完成但未返回图片，请检查控制台日志查看详细响应数据'
                            };
                        }

                        if (isFailedStatus) {
                            // 任务失败
                            // V3.7.33: Handle failure duration for storyboard
                            if (storyboardTaskMapRef.current.has(taskId)) {
                                const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                                const endTime = Date.now();
                                const durationMs = endTime - (hItem.startTime || endTime);

                                updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                    status: 'failed',
                                    errorMsg: errorMsg || `任务失败: ${status}`,
                                    durationCost: durationMs / 1000
                                });
                                storyboardTaskMapRef.current.delete(taskId);
                            }

                            return {
                                ...hItem,
                                status: 'failed',
                                errorMsg: errorMsg || `任务失败: ${status}`
                            };
                        }

                        if (status === 'PENDING' || status === 'PROCESSING' || status === 'GENERATING' || status === 'IN_PROGRESS' || status === 'RUNNING') {
                            // 任务进行中，根据轮询次数和进度信息计算进度
                            let progress = 10 + (attempt * 2); // 基础进度

                            // 如果有进度百分比，使用实际进度
                            if (data?.data?.progress) {
                                const progressStr = String(data.data.progress);
                                if (progressStr.includes('%')) {
                                    progress = parseInt(progressStr.replace('%', ''), 10) || progress;
                                } else if (typeof data.data.progress === 'number') {
                                    progress = data.data.progress;
                                }
                            } else if (data?.progress) {
                                const progressStr = String(data.progress);
                                if (progressStr.includes('%')) {
                                    progress = parseInt(progressStr.replace('%', ''), 10) || progress;
                                } else if (typeof data.progress === 'number') {
                                    progress = data.progress;
                                }
                            }

                            progress = Math.min(95, Math.max(10, progress)); // 限制在10-95%之间

                            return {
                                ...hItem,
                                status: 'generating',
                                progress,
                                errorMsg: null
                            };
                        }

                        // 未知状态，继续轮询，但进度缓慢增加
                        const progress = Math.min(90, 10 + (attempt * 1.5));
                        return {
                            ...hItem,
                            status: 'generating',
                            progress,
                            errorMsg: null
                        };
                    });

                    // 获取更新后的进度，用于动态调整轮询间隔
                    const updatedItem = updated.find(h => h.id === taskId);
                    const currentProgress = updatedItem?.progress || 10;

                    return updated;
                });

                // 如果任务未完成，继续轮询
                // 动态调整轮询间隔：任务接近完成时缩短间隔，确保能快速检测到完成状态
                const currentStatus = (data?.data?.status || data?.status || '').toUpperCase();
                const isCompleted = currentStatus === 'COMPLETED' || currentStatus === 'SUCCESS' || currentStatus === 'FINISHED' || currentStatus === 'DONE';
                const isFailed = currentStatus === 'FAILED' || currentStatus === 'ERROR' || currentStatus === 'CANCELLED' || currentStatus === 'FAILURE';

                if (!isCompleted && !isFailed) {
                    // 动态轮询间隔策略：
                    // 1. 任务进度>90%：1秒间隔（快速检测完成）
                    // 2. 任务进度>70%：2秒间隔（加快检测）
                    // 3. 任务进度>50%：3秒间隔（中等速度）
                    // 4. 任务进行中（<50%）：5秒间隔（基础间隔）
                    // 5. 长时间运行（>50次轮询且非banana模型）：10秒间隔（节省资源）

                    // 从更新后的history中获取最新进度来计算延迟
                    setHistory((prev) => {
                        const latestItem = prev.find(h => h.id === taskId);
                        const progress = latestItem?.progress || 10;

                        let adjustedDelay = baseDelayMs;
                        if (progress >= 90) {
                            adjustedDelay = 1000; // 1秒：任务接近完成，快速检测
                        } else if (progress >= 70) {
                            adjustedDelay = 2000; // 2秒：任务进行中后期，加快检测
                        } else if (progress >= 50) {
                            adjustedDelay = 3000; // 3秒：任务进行中，中等速度
                        } else if (attempt > 50 && !isBananaModel) {
                            adjustedDelay = 10000; // 10秒：长时间运行，节省资源
                        }

                        // 在回调外执行setTimeout，避免闭包问题
                        setTimeout(() => {
                            pollImageTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, attempt + 1, isBananaModel);
                        }, adjustedDelay);

                        return prev; // 不修改，只是读取
                    });
                }
            })
            .catch((err) => {
                console.error('[Async Image] Poll error:', err);
                setTimeout(() => pollImageTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, attempt + 1, isBananaModel), baseDelayMs);
            });
    };

    const buildAsyncRequest = (asyncRequest, vars, providerKey) => {
        if (!asyncRequest || !asyncRequest.endpoint) return null;
        const templateRequest = buildRequestFromTemplate(asyncRequest, vars, { bodyType: asyncRequest.bodyType });
        if (!templateRequest || !templateRequest.url) return null;
        const providerBaseUrl = (vars?.provider?.baseUrl || '').replace(/\/+$/, '');
        let fullUrl = templateRequest.url;
        if (!/^https?:/i.test(fullUrl)) {
            fullUrl = `${providerBaseUrl}${fullUrl.startsWith('/') ? '' : '/'}${fullUrl}`;
        }
        fullUrl = buildProxyUrl(fullUrl, providerKey);
        const headers = templateRequest.headers && typeof templateRequest.headers === 'object'
            ? { ...templateRequest.headers }
            : {};
        if (vars?.provider?.key && !headers.Authorization && !headers.authorization) {
            headers.Authorization = `Bearer ${vars.provider.key}`;
        }
        const method = (templateRequest.method || asyncRequest.method || 'GET').toString().toUpperCase();
        let body = templateRequest.body;
        let bodyType = (templateRequest.bodyType || asyncRequest.bodyType || 'json').toString().toLowerCase();
        if (bodyType === 'multipart') {
            body = coerceFormDataFromObject(body);
            delete headers['Content-Type'];
            delete headers['content-type'];
        } else if (bodyType === 'raw') {
            if (typeof body !== 'string') {
                body = JSON.stringify(body ?? {});
            }
        } else if (bodyType === 'json') {
            if (!(body instanceof FormData) && typeof body !== 'string') {
                body = JSON.stringify(body ?? {});
            }
            if (!headers['Content-Type'] && !headers['content-type']) {
                headers['Content-Type'] = 'application/json';
            }
        }
        if (method === 'GET' || method === 'HEAD') {
            body = undefined;
        }
        return {
            url: fullUrl,
            method,
            headers,
            body
        };
    };

    const pollAsyncTask = (taskId, requestId, asyncConfig, baseVars, w, h, sourceNodeId, providerKey, attempt = 0) => {
        const maxAttempts = Number.isFinite(asyncConfig?.maxAttempts) ? asyncConfig.maxAttempts : 300;
        const delayMs = Number.isFinite(asyncConfig?.pollIntervalMs) ? asyncConfig.pollIntervalMs : 3000;
        if (attempt > maxAttempts) {
            setHistory((prev) => prev.map((hItem) =>
                hItem.id === taskId
                    ? { ...hItem, status: 'failed', errorMsg: '异步任务轮询超时' }
                    : hItem
            ));
            return;
        }
        if (!asyncConfig?.statusRequest?.endpoint) {
            setHistory((prev) => prev.map((hItem) =>
                hItem.id === taskId
                    ? { ...hItem, status: 'failed', errorMsg: '异步任务未配置状态查询接口' }
                    : hItem
            ));
            return;
        }
        const vars = { ...baseVars, requestId };
        const statusReq = buildAsyncRequest(asyncConfig.statusRequest, vars, providerKey);
        if (!statusReq) {
            setHistory((prev) => prev.map((hItem) =>
                hItem.id === taskId
                    ? { ...hItem, status: 'failed', errorMsg: '异步任务状态请求构建失败' }
                    : hItem
            ));
            return;
        }

        fetch(statusReq.url, { method: statusReq.method, headers: statusReq.headers, body: statusReq.body })
            .then(async (resp) => {
                if (resp.status === 401 || resp.status === 402 || resp.status === 403) {
                    const reason = resp.status === 402 ? '积分耗尽 (402)' : (resp.status === 401 ? '认证失效 (401)' : '访问被拒绝 (403)');
                    const errorMsg = `异步任务轮询失败: ${reason}`;
                    setHistory((prev) => prev.map((hItem) => {
                        if (hItem.id !== taskId) return hItem;
                        const durationMs = Date.now() - (hItem.startTime || Date.now());
                        const storyboardTask = storyboardTaskMapRef.current.get(taskId) || parseStoryboardSourceNodeId(hItem.sourceNodeId || sourceNodeId);
                        if (storyboardTask?.isImageMode) {
                            updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                status: 'failed',
                                errorMsg,
                                durationCost: durationMs / 1000
                            });
                            storyboardTaskMapRef.current.delete(taskId);
                        }
                        return { ...hItem, status: 'failed', errorMsg };
                    }));
                    return;
                }
                const text = await resp.text();
                let statusData;
                try {
                    statusData = text ? JSON.parse(text) : {};
                } catch (err) {
                    console.warn('[Async Task] 状态响应解析失败', err);
                    setTimeout(() => pollAsyncTask(taskId, requestId, asyncConfig, baseVars, w, h, sourceNodeId, providerKey, attempt + 1), delayMs);
                    return;
                }

                const statusRaw = getValueByPath(statusData, asyncConfig.statusPath);
                const statusValue = normalizeAsyncStatusValue(statusRaw);
                const isCompleted = asyncConfig.successValues.includes(statusValue);
                const isFailed = asyncConfig.failureValues.includes(statusValue);
                const errorMessage = asyncConfig.errorPath ? (getValueByPath(statusData, asyncConfig.errorPath) || '') : '';

                if (isCompleted) {
                    let outputsData = statusData;
                    if (asyncConfig.outputsRequest?.endpoint) {
                        const outputsReq = buildAsyncRequest(asyncConfig.outputsRequest, vars, providerKey);
                        if (!outputsReq) {
                            throw new Error('异步任务结果请求构建失败');
                        }
                        const outputsResp = await fetch(outputsReq.url, { method: outputsReq.method, headers: outputsReq.headers, body: outputsReq.body });
                        if (outputsResp.status === 401 || outputsResp.status === 402 || outputsResp.status === 403) {
                            const reason = outputsResp.status === 402 ? '积分耗尽 (402)' : (outputsResp.status === 401 ? '认证失效 (401)' : '访问被拒绝 (403)');
                            const errorMsg = `异步任务结果查询失败: ${reason}`;
                            setHistory((prev) => prev.map((hItem) => {
                                if (hItem.id !== taskId) return hItem;
                                const durationMs = Date.now() - (hItem.startTime || Date.now());
                                const storyboardTask = storyboardTaskMapRef.current.get(taskId) || parseStoryboardSourceNodeId(hItem.sourceNodeId || sourceNodeId);
                                if (storyboardTask?.isImageMode) {
                                    updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                        status: 'failed',
                                        errorMsg,
                                        durationCost: durationMs / 1000
                                    });
                                    storyboardTaskMapRef.current.delete(taskId);
                                }
                                return { ...hItem, status: 'failed', errorMsg };
                            }));
                            return;
                        }
                        const outputsText = await outputsResp.text();
                        outputsData = outputsText ? JSON.parse(outputsText) : {};
                    }
                    let outputsValue = asyncConfig.outputsPath ? getValueByPath(outputsData, asyncConfig.outputsPath) : outputsData;
                    let imageUrls = extractAsyncOutputUrls(outputsValue, asyncConfig.outputsUrlField);
                    if (imageUrls.length === 0) {
                        const fallbackOutputs = getValueByPathAny(outputsData, ['data.outputs', 'outputs', 'data.images', 'images']);
                        if (fallbackOutputs && fallbackOutputs !== outputsValue) {
                            outputsValue = fallbackOutputs;
                            imageUrls = extractAsyncOutputUrls(outputsValue, asyncConfig.outputsUrlField);
                        }
                    }

                    if (imageUrls.length === 0) {
                        const deepCandidates = collectDeepImageValues(outputsData);
                        if (deepCandidates.length > 0) {
                            imageUrls = deepCandidates;
                        }
                    }

                    if (imageUrls.length === 0) {
                        throw new Error('异步任务未返回结果');
                    }
                    let resolvedImageUrls = [];
                    try {
                        resolvedImageUrls = await normalizeImageUrls(imageUrls);
                    } catch (e) {
                        resolvedImageUrls = [];
                    }
                    if (resolvedImageUrls.length === 0) resolvedImageUrls = imageUrls;

                    setHistory((prev) => {
                        const updated = prev.map((hItem) => {
                            if (hItem.id !== taskId) return hItem;
                            const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                            const hasStoryboardTask = !!storyboardTask;
                            const endTime = Date.now();
                            const durationMs = endTime - (hItem.startTime || endTime);

                            if (hasStoryboardTask) {
                                if (storyboardTask.isImageMode) {
                                    updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                        output_images: resolvedImageUrls,
                                        output_url: resolvedImageUrls[0],
                                        selectedImageIndex: 0,
                                        outputEnabled: false,
                                        status: 'done',
                                        durationCost: durationMs / 1000
                                    });
                                    storyboardTaskMapRef.current.delete(taskId);
                                }
                            } else {
                                const fallbackStoryboard = parseStoryboardSourceNodeId(hItem.sourceNodeId || sourceNodeId);
                                if (fallbackStoryboard?.isImageMode) {
                                    updateShot(fallbackStoryboard.nodeId, fallbackStoryboard.shotId, {
                                        output_images: resolvedImageUrls,
                                        output_url: resolvedImageUrls[0],
                                        selectedImageIndex: 0,
                                        outputEnabled: false,
                                        status: 'done',
                                        durationCost: durationMs / 1000
                                    });
                                }
                            }

                            const updatedItem = {
                                ...hItem,
                                status: 'completed',
                                progress: 100,
                                url: resolvedImageUrls[0],
                                width: w,
                                height: h,
                                durationMs,
                                output_images: resolvedImageUrls,
                                mjImages: resolvedImageUrls.length > 1 ? resolvedImageUrls : null,
                                selectedMjImageIndex: 0
                            };

                            if (updatedItem.sourceNodeId && !hasStoryboardTask) {
                                setTimeout(() => {
                                    updatePreviewFromTask(taskId, resolvedImageUrls[0], 'image', updatedItem.sourceNodeId, updatedItem.mjImages);
                                }, 0);
                            }
                            return updatedItem;
                        });
                        return updated;
                    });
                    return;
                }

                if (isFailed) {
                    setHistory((prev) => prev.map((hItem) => {
                        if (hItem.id !== taskId) return hItem;
                        const durationMs = Date.now() - (hItem.startTime || Date.now());
                        const errorMsg = errorMessage || `任务失败: ${statusValue || 'FAILED'}`;
                        const storyboardTask = storyboardTaskMapRef.current.get(taskId) || parseStoryboardSourceNodeId(hItem.sourceNodeId || sourceNodeId);
                        if (storyboardTask?.isImageMode) {
                            updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                status: 'failed',
                                errorMsg,
                                durationCost: durationMs / 1000
                            });
                            storyboardTaskMapRef.current.delete(taskId);
                        }
                        return { ...hItem, status: 'failed', errorMsg };
                    }));
                    return;
                }

                setHistory((prev) => prev.map((hItem) => {
                    if (hItem.id !== taskId) return hItem;
                    const progress = Math.min(95, Math.max(10, 10 + attempt * 2));
                    return { ...hItem, status: 'generating', progress, errorMsg: null };
                }));

                setTimeout(() => pollAsyncTask(taskId, requestId, asyncConfig, baseVars, w, h, sourceNodeId, providerKey, attempt + 1), delayMs);
            })
            .catch((err) => {
                console.error('[Async Task] Poll error:', err);
                setTimeout(() => pollAsyncTask(taskId, requestId, asyncConfig, baseVars, w, h, sourceNodeId, providerKey, attempt + 1), delayMs);
            });
    };

    // ModelScope 异步任务轮询函数
    const pollModelScopeTask = (taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, providerKey, useProxy, attempt = 0) => {
        const maxAttempts = 300;
        const baseDelayMs = 5000;

        if (attempt > maxAttempts) {
            setHistory((prev) => prev.map((hItem) =>
                hItem.id === taskId
                    ? { ...hItem, status: 'failed', errorMsg: 'ModelScope 轮询超时' }
                    : hItem
            ));
            return;
        }

        const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
        const pollUrl = `${cleanBaseUrl}/v1/tasks/${taskIdForPoll}`;
        const headers = {
            Authorization: `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        };
        if (useProxy) {
            headers['X-ModelScope-Task-Type'] = 'image_generation';
        }

        const finalUrl = useProxy ? buildProxyUrl(pollUrl, providerKey) : pollUrl;

        fetch(finalUrl, { method: 'GET', headers })
            .then(async (resp) => {
                if (resp.status === 401 || resp.status === 402 || resp.status === 403) {
                    const reason = resp.status === 402 ? '积分耗尽 (402)' : (resp.status === 401 ? '认证失效 (401)' : '访问被拒绝 (403)');
                    const errorMsg = `ModelScope 轮询失败: ${reason}`;
                    setHistory((prev) => prev.map((hItem) => {
                        if (hItem.id !== taskId) return hItem;
                        const durationMs = Date.now() - (hItem.startTime || Date.now());
                        const storyboardTask = storyboardTaskMapRef.current.get(taskId) || parseStoryboardSourceNodeId(hItem.sourceNodeId || sourceNodeId);
                        if (storyboardTask?.isImageMode) {
                            updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                status: 'failed',
                                errorMsg,
                                durationCost: durationMs / 1000
                            });
                            storyboardTaskMapRef.current.delete(taskId);
                        }
                        return { ...hItem, status: 'failed', errorMsg };
                    }));
                    return;
                }
                const text = await resp.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (err) {
                    console.error('[ModelScope] Failed to parse response:', err);
                    setTimeout(() => pollModelScopeTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, providerKey, useProxy, attempt + 1), baseDelayMs);
                    return;
                }

                const statusRaw = data?.task_status || data?.data?.task_status || data?.output?.task_status || data?.status || data?.data?.status || '';
                const status = String(statusRaw).toUpperCase();
                const rawImages = data?.output_images || data?.output?.output_images || data?.data?.output_images || data?.output?.images || data?.data?.output?.output_images || [];
                const imageUrls = Array.isArray(rawImages)
                    ? rawImages.map((img) => {
                        if (typeof img === 'string') return img;
                        return img?.url || img?.image_url || img?.imageUrl || img?.path || '';
                    }).filter(Boolean)
                    : [];
                const errorMsg = data?.message || data?.error || data?.data?.message || data?.output?.error || '';

                const completedStatuses = new Set(['SUCCEED', 'SUCCESS', 'COMPLETED', 'FINISHED', 'DONE']);
                const failedStatuses = new Set(['FAILED', 'ERROR', 'CANCELLED', 'FAILURE']);
                const isCompleted = completedStatuses.has(status);
                const isFailed = failedStatuses.has(status);
                let resolvedImageUrls = [];
                if (isCompleted && imageUrls.length > 0) {
                    try {
                        resolvedImageUrls = await normalizeImageUrls(imageUrls);
                    } catch (e) {
                        resolvedImageUrls = [];
                    }
                    if (resolvedImageUrls.length === 0) resolvedImageUrls = imageUrls;
                }

                setHistory((prev) => prev.map((hItem) => {
                    if (hItem.id !== taskId) return hItem;
                    const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                    const hasStoryboardTask = !!storyboardTask;

                    if (isCompleted) {
                        if (resolvedImageUrls.length === 0) {
                            return { ...hItem, status: 'failed', errorMsg: 'ModelScope 返回为空' };
                        }

                        const primaryUrl = resolvedImageUrls[0];
                        const endTime = Date.now();
                        const durationMs = endTime - (hItem.startTime || endTime);

                        if (hasStoryboardTask) {
                            if (storyboardTask.isImageMode) {
                                updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                    output_images: resolvedImageUrls,
                                    output_url: primaryUrl,
                                    selectedImageIndex: 0,
                                    outputEnabled: false,
                                    status: 'done',
                                    durationCost: durationMs / 1000
                                });
                                storyboardTaskMapRef.current.delete(taskId);
                            } else {
                                console.warn('[ModelScope] 分镜表任务未找到或不是图片模式，无法回填');
                            }
                        }

                        const updatedItem = {
                            ...hItem,
                            status: 'completed',
                            progress: 100,
                            url: primaryUrl,
                            width: w,
                            height: h,
                            durationMs,
                            output_images: resolvedImageUrls,
                            selectedMjImageIndex: 0
                        };

                        if (updatedItem.sourceNodeId && !hasStoryboardTask) {
                            setTimeout(() => {
                                updatePreviewFromTask(taskId, primaryUrl, 'image', updatedItem.sourceNodeId, resolvedImageUrls);
                            }, 0);
                        }

                        return updatedItem;
                    }

                    if (isFailed) {
                        if (hasStoryboardTask) {
                            if (storyboardTask.isImageMode) {
                                updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                    status: 'failed',
                                    errorMsg: errorMsg || `任务失败: ${status || 'FAILED'}`,
                                    durationCost: (Date.now() - (hItem.startTime || Date.now())) / 1000
                                });
                                storyboardTaskMapRef.current.delete(taskId);
                            }
                        }

                        return {
                            ...hItem,
                            status: 'failed',
                            errorMsg: errorMsg || `任务失败: ${status || 'FAILED'}`
                        };
                    }

                    const progress = Math.min(95, Math.max(10, 10 + attempt * 2));
                    return {
                        ...hItem,
                        status: 'generating',
                        progress,
                        errorMsg: null
                    };
                }));

                if (!isCompleted && !isFailed) {
                    setTimeout(() => pollModelScopeTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, providerKey, useProxy, attempt + 1), baseDelayMs);
                }
            })
            .catch((err) => {
                console.error('[ModelScope] Poll error:', err);
                setTimeout(() => pollModelScopeTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, providerKey, useProxy, attempt + 1), baseDelayMs);
            });
    };

    // Midjourney任务轮询函数
    const pollMidjourneyJob = (jobId, taskId, baseUrl, apiKey, mjMode = 'fast', w, h, attempt = 0) => {
        const maxAttempts = 120; // 最多轮询120次（约10分钟，假设每次5秒）
        const delayMs = 5000; // 每5秒轮询一次

        if (attempt > maxAttempts) {
            setHistory((prev) => prev.map((hItem) =>
                hItem.id === taskId
                    ? { ...hItem, status: 'failed', errorMsg: 'Midjourney 轮询超时' }
                    : hItem
            ));
            return;
        }

        fetch(`${baseUrl}/${mjMode}/mj/task/${jobId}/fetch`, {
            method: 'GET',
            headers: {
                Authorization: `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            },
        })
            .then((resp) => resp.text())
            .then((text) => {
                let data;
                try {
                    data = JSON.parse(text);
                } catch (err) {
                    console.error('Midjourney: Failed to parse response:', err);
                    setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs);
                    return;
                }


                const status = data?.status || '';
                const progress = data?.progress || '0%';
                const imageUrl = data?.imageUrl || '';
                const failReason = data?.failReason || '';
                const buttons = data?.buttons || [];

                // 解析进度百分比
                let progressNum = 0;
                if (typeof progress === 'string' && progress.includes('%')) {
                    progressNum = parseInt(progress.replace('%', ''), 10) || 0;
                } else if (typeof progress === 'number') {
                    progressNum = progress;
                }

                // 更新历史记录
                setHistory((prev) => prev.map((hItem) => {
                    if (hItem.id === taskId) {
                        let newStatus = hItem.status;
                        let newErrorMsg = hItem.errorMsg;
                        let newProgress = progressNum;

                        if (status === 'SUCCESS' || status === 'FINISHED') {
                            newStatus = 'completed';
                            newProgress = 100;
                            newErrorMsg = null;

                            // 如果是Midjourney任务且有图片URL，切割成4张图（拓展图片任务不需要切割）
                            if (imageUrl && hItem.apiConfig?.modelId?.includes('mj') && hItem.apiConfig?.modelId !== 'mj-zoom') {
                                // 获取比例信息（从prompt中提取或使用默认值）
                                let ratio = '1:1';
                                if (hItem.prompt && hItem.prompt.includes('--ar ')) {
                                    const arMatch = hItem.prompt.match(/--ar\s+([\d:]+)/);
                                    if (arMatch && arMatch[1]) {
                                        ratio = arMatch[1];
                                    }
                                }

                                // 异步切割图片，不阻塞状态更新
                                // 先更新状态，显示原图，避免白屏
                                setHistory((prev) => prev.map((hItem) =>
                                    hItem.id === taskId
                                        ? { ...hItem, url: imageUrl, mjRatio: ratio, mjOriginalUrl: imageUrl, mjNeedsSplit: true }
                                        : hItem
                                ));

                                // 立即将完整原图同步到预览窗口（不裁剪）
                                // 直接传入 sourceNodeId，避免依赖可能未更新的 history 状态
                                // 使用 setTimeout 确保在下一个事件循环中执行，避免状态更新冲突
                                const sourceNodeIdForPreview = hItem.sourceNodeId;
                                if (sourceNodeIdForPreview) {
                                    setTimeout(() => {
                                        updatePreviewFromTask(taskId, imageUrl, 'image', sourceNodeIdForPreview);
                                    }, 0);
                                } else {
                                    console.warn('[Tapnow] Midjourney: 未找到 sourceNodeId，无法更新预览窗口', { taskId, hItem });
                                }

                                // 延迟切割，确保UI先更新显示原图，避免白屏
                                setTimeout(() => {
                                    splitMidjourneyImage(imageUrl, ratio).then((splitImages) => {
                                        // 提取URL数组（兼容新旧格式）
                                        const imageUrls = splitImages.map(img => typeof img === 'string' ? img : img.url);
                                        const firstImage = splitImages[0];
                                        const firstUrl = typeof firstImage === 'string' ? firstImage : firstImage.url;

                                        setHistory((prev) => prev.map((hItem) =>
                                            hItem.id === taskId
                                                ? {
                                                    ...hItem,
                                                    mjImages: imageUrls,
                                                    url: firstUrl,
                                                    selectedMjImageIndex: 0,
                                                    mjRatio: ratio,
                                                    mjOriginalUrl: imageUrl, // 保存原图URL
                                                    mjNeedsSplit: false, // 标记已切割
                                                    mjImageInfo: splitImages.map(img => typeof img === 'string' ? null : { width: img.width, height: img.height, ratio: img.ratio })
                                                }
                                                : hItem
                                        ));
                                    }).catch((err) => {
                                        console.error('Midjourney: Failed to split image:', err);
                                        // 如果切割失败，保持原图显示，标记需要重新切割
                                        setHistory((prev) => prev.map((hItem) =>
                                            hItem.id === taskId
                                                ? { ...hItem, url: imageUrl, mjRatio: ratio, mjOriginalUrl: imageUrl, mjNeedsSplit: true }
                                                : hItem
                                        ));
                                    });
                                }, 300); // 延迟300ms，确保原图已完全显示

                                // 计算并保存用时
                                const endTime = Date.now();
                                const durationMs = endTime - (hItem.startTime || endTime);

                                // 先更新状态，图片切割异步进行
                                return {
                                    ...hItem,
                                    status: newStatus,
                                    progress: newProgress,
                                    errorMsg: newErrorMsg,
                                    url: imageUrl, // 临时使用原图，切割完成后会更新
                                    width: w,
                                    height: h,
                                    mjButtons: buttons,
                                    mjOriginalUrl: imageUrl, // 保存完整原图URL
                                    durationMs: durationMs
                                };
                            }
                        } else if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                            newStatus = 'failed';
                            newErrorMsg = failReason || `任务失败: ${status}`;
                        } else if (status === 'NOT_START' || status === 'SUBMITTED' || status === 'IN_PROGRESS' || status === 'MODAL') {
                            newStatus = 'generating';
                            newErrorMsg = null;
                            // 如果进度为0%，至少显示5%
                            if (newProgress === 0) newProgress = 5;
                        } else {
                            newStatus = 'generating';
                            newErrorMsg = null;
                            // 渐进式更新进度
                            newProgress = Math.min(95, (hItem.progress || 5) + 2);
                        }


                        const updatedItem = {
                            ...hItem,
                            status: newStatus,
                            progress: newProgress,
                            errorMsg: newErrorMsg,
                            url: imageUrl || hItem.url,
                            width: w,
                            height: h,
                            mjButtons: buttons // 保存按钮信息，用于后续操作
                        };

                        // 如果任务成功且有图片URL，将结果同步到预览节点（使用完整原图，不裁剪）
                        // 注意：Midjourney任务已经在切割逻辑中处理了预览窗口更新，这里只处理非Midjourney任务
                        // 拓展图片任务（mj-zoom）也需要同步到节点
                        if ((status === 'SUCCESS' || status === 'FINISHED') && imageUrl && (!hItem.apiConfig?.modelId?.includes('mj') || hItem.apiConfig?.modelId === 'mj-zoom')) {
                            // 直接传入 sourceNodeId，避免依赖可能未更新的 history 状态
                            if (hItem.sourceNodeId) {
                                // 如果是拓展图片任务，更新拓展图片节点；否则更新预览窗口
                                if (hItem.apiConfig?.modelId === 'mj-zoom') {
                                    setNodes((prev) => prev.map((n) =>
                                        n.id === hItem.sourceNodeId && n.type === 'expand-image'
                                            ? { ...n, content: imageUrl }
                                            : n
                                    ));
                                } else {
                                    updatePreviewFromTask(taskId, imageUrl, 'image', hItem.sourceNodeId);
                                }
                            } else {
                                console.warn('[Tapnow] 图片生成: 未找到 sourceNodeId', { taskId, hItem });
                            }

                            // 计算并保存用时
                            const endTime = Date.now();
                            const durationMs = endTime - (hItem.startTime || endTime);
                            updatedItem.durationMs = durationMs;
                        }

                        return updatedItem;
                    }
                    return hItem;
                }));

                // 如果任务完成或失败，停止轮询
                if (status === 'SUCCESS' || status === 'FINISHED') {
                    return;
                }

                if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                    return;
                }

                // 继续轮询
                setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs);
            })
            .catch((err) => {
                console.error(`[Tapnow] Midjourney Poll Fetch Error for task ${taskId}:`, err);
                setHistory((prev) => prev.map((hItem) =>
                    hItem.id === taskId
                        ? { ...hItem, status: 'failed', errorMsg: `轮询请求失败: ${err.message}` }
                        : hItem
                ));
                // 即使出错也继续重试（最多重试3次）
                if (attempt < 3) {
                    setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs);
                }
            });
    };

    // 处理蒙版用于 Inpainting：将"透明背景上的白色笔触"转换为"白色背景上的透明区域"
    const processMaskForInpainting = async (maskContent) => {
        if (!maskContent) return null;

        try {
            // 加载蒙版图片
            const maskImg = new Image();
            maskImg.crossOrigin = 'anonymous';
            await new Promise((resolve, reject) => {
                maskImg.onload = resolve;
                maskImg.onerror = reject;
                maskImg.src = maskContent;
            });

            // 创建新 Canvas
            const canvas = document.createElement('canvas');
            canvas.width = maskImg.width;
            canvas.height = maskImg.height;
            const ctx = canvas.getContext('2d');

            // 填充黑色背景（代表保留区域，不透明 Alpha=1）
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 使用 destination-out 混合模式：绘制原蒙版，将用户涂抹的区域"挖空"变成透明（代表重绘区域，Alpha=0）
            ctx.globalCompositeOperation = 'destination-out';
            ctx.drawImage(maskImg, 0, 0);

            // 将 Canvas 转换为 Blob（PNG 格式保留透明度）
            return new Promise((resolve, reject) => {
                canvas.toBlob((blob) => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        reject(new Error('蒙版转换失败'));
                    }
                }, 'image/png');
            });
        } catch (error) {
            console.error('[Inpainting] 蒙版处理失败:', error);
            return null;
        }
    };

    const startGeneration = async (prompt, type, sourceImages, nodeId, options = {}) => {
        // V3.5.20: 优先解析 IndexedDB 图片键 (img_xxx)
        // 解决 "Failed to fetch" 错误，确保所有 img_ 键都转换为 Blob URL
        let resolvedSourceImages = [];
        const rawSourceImages = Array.isArray(sourceImages) ? sourceImages : (sourceImages ? [sourceImages] : []);

        if (rawSourceImages.length > 0) {
            try {
                resolvedSourceImages = await Promise.all(rawSourceImages.map(async (img) => {
                    const resolved = await resolveSpecialUrl(img);
                    if (resolved && resolved !== img) return resolved;
                    if (LocalImageManager.isImageId(img)) {
                        const fallback = getAssetFallbackUrl(img);
                        if (fallback) return fallback;
                        console.warn(`[startGeneration] Failed to resolve IDB image: ${img}`);
                    }
                    return img;
                }));
            } catch (e) {
                console.error('[startGeneration] Error resolving images:', e);
                resolvedSourceImages = rawSourceImages;
            }
        }

        const connectedImages = resolvedSourceImages;
        const sourceImage = connectedImages.length > 0 ? connectedImages[0] : undefined;


        if (!prompt && !sourceImage) { alert(t('请输入提示词或连接参考图片')); return; }

        // 检查是否是分镜表的虚拟节点ID（格式：storyboard-${nodeId}-shot-${shotId}）
        let node = null;
        if (nodeId && nodeId.startsWith('storyboard-') && nodeId.includes('-shot-')) {
            // 这是分镜表的任务，不需要查找实际节点
            node = null;
        } else {
            node = nodes.find((n) => n.id === nodeId);
        }

        // 处理蒙版：先检查当前节点，如果没有则从上游节点查找
        let finalMaskBlob = null;
        let finalMaskContent = node?.maskContent;
        if (!finalMaskContent) {
            // 查找连接到当前节点的源节点（优先查找 default 输入，如果没有则查找所有输入）
            let incomingConn = connections.find(c => c.to === nodeId && (!c.inputType || c.inputType === 'default'));
            if (!incomingConn) {
                // 如果没有 default 连接，查找任何连接到该节点的连接
                incomingConn = connections.find(c => c.to === nodeId);
            }
            if (incomingConn) {
                // 使用 nodesMap 进行 O(1) 查找
                const sourceNode = nodesMap.get(incomingConn.from);
                if (sourceNode && sourceNode.maskContent) {
                    finalMaskContent = sourceNode.maskContent;
                }
            }
        } else {
        }

        // 如果存在蒙版，处理蒙版（反转逻辑）
        if (finalMaskContent) {
            finalMaskBlob = await processMaskForInpainting(finalMaskContent);
            if (finalMaskBlob) {
            } else {
                console.warn('[Inpainting] 蒙版处理失败，将使用原始蒙版');
            }
        }

        // 规范化 prompt：确保角色引用 @{username} 前后有空格（仅对 Sora 2 模型）
        const normalizePromptForSora = (text, modelId) => {
            if (!text || !modelId || (!modelId.includes('sora') && modelId !== 'sora-2' && modelId !== 'sora-2-pro')) {
                return text;
            }
            // 先处理不带大括号的格式 @username，转换为 @{username}
            text = text.replace(/@([a-zA-Z0-9_\.]+)(?![a-zA-Z0-9_\.])/g, (match, username) => {
                return `@{${username}}`;
            });
            // 然后处理带大括号的格式 @{username}，确保前后有空格
            return text.replace(/@\{([^\}]+)\}/g, (match, username) => {
                return ` @{${username}} `;
            }).replace(/\s{2,}/g, ' ').trim(); // 清理多余空格
        };
        // 优先使用 options 中的 model，其次使用节点设置，最后使用默认值
        const modelId = options.model || node?.settings?.model || (type === 'image' ? 'nano-banana' : 'sora-2');
        const customParamSelections = options.customParams || node?.settings?.customParams || null;
        // V3.4.19: 使用统一的 getApiCredentials 获取凭据（只从Provider获取）
        const credentials = getApiCredentials(modelId);
        let apiKeyRaw = credentials.key;

        // 支持逗号分隔的多个API Key (Load Balancing)
        let apiKey = apiKeyRaw;
        if (apiKeyRaw && apiKeyRaw.includes(',')) {
            const allKeys = apiKeyRaw.split(',').map(k => k.trim()).filter(k => k);
            // 使用 ref 获取最新黑名单，过滤已黑名单的 key
            const currentBlacklist = apiBlacklistRef.current || {};

            // V3.5.1 Debug: 详细日志输出

            const availableKeys = allKeys.filter(k => !currentBlacklist[k]);

            if (availableKeys.length > 0) {
                // 从可用 key 中随机选择
                apiKey = availableKeys[Math.floor(Math.random() * availableKeys.length)];
            } else if (allKeys.length > 0) {
                // 所有 key 都在黑名单，降级到随机选择（避免完全失败）
                apiKey = allKeys[Math.floor(Math.random() * allKeys.length)];
                console.warn(`⚠️ [Load Balancing] All ${allKeys.length} keys are blacklisted, using random selection`);
            }
        }

        // [Debug] Log selected API key (masked)
        if (apiKey) {
            console.log(`[API Select] Using Key ending in ...${apiKey.slice(-4)}`);
        }
        let baseUrlRaw = credentials.url;

        // 支持逗号分隔的多个API地址 (Load Balancing)
        let baseUrl = baseUrlRaw;
        if (baseUrlRaw.includes(',')) {
            const urls = baseUrlRaw.split(',').map(u => u.trim()).filter(u => u);
            if (urls.length > 0) {
                // 随机选择一个
                baseUrl = urls[Math.floor(Math.random() * urls.length)];
            }
        }

        if (!apiKey) { alert(t('请先在设置中配置 API Key')); setSettingsOpen(true); return; }

        // 规范化 prompt（确保角色引用 @{username} 前后有空格，仅对 Sora 2 模型）
        if (prompt && (modelId.includes('sora') || modelId === 'sora-2' || modelId === 'sora-2-pro')) {
            // 先处理不带大括号的格式 @username，转换为 @{username}
            prompt = prompt.replace(/@([a-zA-Z0-9_\.]+)(?![a-zA-Z0-9_\.])/g, (match, username) => {
                return `@{${username}}`;
            });
            // 然后处理带大括号的格式 @{username}，确保前后有空格
            prompt = prompt.replace(/@\{([^\}]+)\}/g, (match, username) => {
                return ` @{${username}} `;
            }).replace(/\s{2,}/g, ' ').trim(); // 清理多余空格
        }

        // 优先使用 options 中的 ratio，其次使用节点设置，最后使用默认值
        let ratio = options.ratio || node?.settings?.ratio || (modelId.includes('grok') ? '3:2' : '1:1');
        // V3.5.0: 覆盖分辨率设置 (Jimeng/Grok)
        let resolution = options.resolution || node?.settings?.resolution || (type === 'video' ? '720P' : '2K');
        let resolutionForCalc = resolution;
        if (type === 'image') {
            resolution = normalizeImageResolution(resolution);
            resolutionForCalc = resolution;
        }
        if (type === 'video') {
            resolution = normalizeVideoResolution(resolution);
            resolutionForCalc = resolution === 'Auto' ? '720P' : resolution;
        }
        let { sizeStr, w, h } = getModelParams(modelId, ratio, resolutionForCalc);

        // Auto Resolution Logic (Direct Source, No Scaling, Just Alignment)
        // Fix: Only use source dimensions if Ratio is ALSO Auto. If user picks a ratio (e.g. 1:1), respect that.
        if (resolution === 'Auto' && ratio === 'Auto' && sourceImage) {
            try {
                const dims = await getImageDimensions(sourceImage);
                // Force original size (aligned to 64) without downscaling
                const safeW = Math.round(dims.w / 64) * 64;
                const safeH = Math.round(dims.h / 64) * 64;

                w = safeW;
                h = safeH;
                sizeStr = `${safeW}x${safeH}`;
            } catch (e) { console.error("Auto Res Error", e); }
        } else {
            if (!w || !h) {
                const def = calculateResolution(ratio, resolution);
                w = def.w;
                h = def.h;
                sizeStr = def.str;
            }
        }

        // 当有参考图且选择了 Auto + (1K/2K/4K) 时：
        // 希望保持原图纵横比，只在原图分辨率基础上等比放大到目标级别（而不是变成固定 1:1 或 16:9）
        if (sourceImage && ratio === 'Auto' && ['1K', '2K', '4K'].includes(resolution)) {
            try {
                const dims = await getImageDimensions(sourceImage);
                const longSideTarget = resolution === '4K'
                    ? 4096
                    : resolution === '2K'
                        ? 2048
                        : 1024;

                const maxSide = Math.max(dims.w, dims.h) || 1;
                const scale = longSideTarget / maxSide;
                let newW = Math.round((dims.w * scale) / 16) * 16;
                let newH = Math.round((dims.h * scale) / 16) * 16;

                // 双保险，避免数值异常
                newW = Math.max(16, newW);
                newH = Math.max(16, newH);

                w = newW;
                h = newH;
                sizeStr = `${newW}x${newH}`;
            } catch (e) {
                console.error('Auto+K Upscale Error', e);
            }
        }

        // 优先使用 options 中的 duration，其次使用节点设置，最后使用默认值
        let duration = options.duration ? String(options.duration).replace('s', '') : (node?.settings?.duration?.replace('s', '') || '5');
        if (modelId.includes('veo')) duration = '8';
        if (type === 'video') {
            const durationConfig = getApiConfigByKey(modelId);
            const rawDurationOptions = Array.isArray(durationConfig?.durations) ? durationConfig.durations : null;
            const normalizedDurationOptions = rawDurationOptions
                ? rawDurationOptions.map((d) => String(d || '').replace(/[^\d]/g, '')).filter(Boolean)
                : null;
            const isJimengVideoModel = durationConfig?.provider === 'jimeng' || modelId.includes('jimeng') || (durationConfig?.modelName ?? '').includes('jimeng');
            const isJimengSora2Model = isJimengVideoModel && (modelId.includes('sora2') || (durationConfig?.modelName ?? '').includes('sora2'));
            if (isJimengVideoModel) {
                const allowed = (normalizedDurationOptions && normalizedDurationOptions.length > 0)
                    ? normalizedDurationOptions
                    : (isJimengSora2Model ? ['4', '8', '12'] : ['5', '10']);
                if (!allowed.includes(String(duration))) {
                    duration = allowed[0] || duration;
                }
            }
        }

        // V3.7.27: 确保 taskId 唯一性（避免同一毫秒内多个任务冲突）
        const taskId = options._existingTaskId || `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

        // 获取正确的模型显示名称（用于历史记录）
        const getModelDisplayName = () => {
            const config = getApiConfigByKey(modelId);
            // 如果是 jimeng 模型，直接返回 modelId (如 jimeng-4.5, jimeng-video-3.0)
            if (modelId.includes('jimeng')) return modelId;
            // 其他模型优先使用 displayName，再回退到 modelName/id
            return config?.displayName || config?.modelName || config?.id || modelId;
        };

        const now = Date.now();
        const actualSourceNodeId = node?.id || nodeId || null;
        const useProxy = !!credentials.useProxy;

        // V3.5.31: Skip history creation on retry to prevent duplicate tasks
        if (!options._isRetry) {
            setHistory((prev) => [{
                id: taskId, type, url: '',
                prompt: prompt || (sourceImage ? `Img2${type === 'image' ? 'Img' : 'Vid'}` : 'Untitled'),
                time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                status: 'generating', progress: 5, modelName: getModelDisplayName(), width: w, height: h,
                remoteTaskId: null,
                apiConfig: { modelId, baseUrl, apiKey, provider: credentials.provider, useProxy },
                provider: credentials.provider,
                useProxy,
                sourceNodeId: actualSourceNodeId,
                startTime: now,
                durationMs: null,
                ratio: ratio, // 保存比例信息，用于后续验证返回结果
                resolution: resolution, // V3.7.26: 保存分辨率
                duration: type === 'video' ? duration : null,
                hasInputImages: connectedImages.length > 0, // V3.7.26: 是否有参考图（用于判断文→图还是图→图）
                customParams: customParamSelections || null
            }, ...prev]);
        }

        // 检查是否是分镜表的任务
        // V3.6.1: 支持两种格式：
        // - 视频模式: storyboard-${nodeId}-shot-${shotId}
        // - 图片模式: storyboard-img-${nodeId}-shot-${shotId}
        if (actualSourceNodeId && actualSourceNodeId.startsWith('storyboard-') && actualSourceNodeId.includes('-shot-')) {
            const parts = actualSourceNodeId.split('-shot-');
            if (parts.length === 2) {
                const shotId = parts[1];
                // V3.6.1: 区分图片和视频模式
                const isImageMode = parts[0].startsWith('storyboard-img-');
                const storyboardNodeId = isImageMode
                    ? parts[0].replace('storyboard-img-', '')
                    : parts[0].replace('storyboard-', '');
                // 记录任务映射，包含模式信息
                const taskInfo = {
                    nodeId: storyboardNodeId,
                    shotId: shotId,
                    isImageMode: isImageMode  // V3.6.1: 记录任务类型
                };
                storyboardTaskMapRef.current.set(taskId, taskInfo);
                storyboardHistoryMapRef.current.set(taskId, taskInfo);
            }
        }

        // V3.5.31: Skip opening history panel on retry
        if (!options._isRetry) {
            // 优化：延迟打开历史面板，避免与 setHistory 同时触发造成卡顿
            requestAnimationFrame(() => {
                setTimeout(() => {
                    setHistoryOpen(true);
                }, 0);
            });
        }

        try {
            if (type === 'image') {
                let endpoint = `${baseUrl}/v1/images/generations`;
                let payload;
                let useMultipart = false;
                // V3.4.20: 获取模型配置用于后续判断
                const config = getApiConfigByKey(modelId);
                const customParams = Array.isArray(config?.customParams) ? config.customParams : [];
                const providerKey = config?.provider;
                const apiType = credentials.apiType || providers[providerKey]?.apiType || 'openai';
                const useProxy = !!credentials.useProxy;
                const forceAsync = !!credentials.forceAsync;
                const omitRatioOnSubmit = !!config?.omitRatioOnSubmit;
                const omitResolutionOnSubmit = !!config?.omitResolutionOnSubmit;
                const requestTemplate = normalizeRequestTemplate(config?.requestTemplate);
                const requestOverrideEnabled = !!config?.requestOverrideEnabled;
                const requestOverridePatch = normalizeRequestOverridePatch(config?.requestOverridePatch);
                const requestTemplateEnabled = !!requestTemplate?.enabled;
                const isModelScope = apiType === 'modelscope';
                const isGeminiNative = apiType === 'gemini';
                const isChatImage = config?.type === 'ChatImage';
                const useAsync = isModelScope ? forceAsync : false;
                const resolveSourceProxy = (url) => getProxyPreferenceForUrl(url, useProxy);
                const asyncConfig = normalizeAsyncConfig(config?.asyncConfig)
                    || ((baseUrl && String(baseUrl).includes('127.0.0.1:9527')) ? normalizeAsyncConfig(ASYNC_CONFIG_TEMPLATE) : null);
                const isLocalMiddlewareTarget = (() => {
                    try {
                        const parsed = new URL(String(baseUrl || ''));
                        const isLocalHost = parsed.hostname === '127.0.0.1' || parsed.hostname === 'localhost';
                        return isLocalHost && parsed.port === '9527';
                    } catch (e) {
                        const raw = String(baseUrl || '');
                        return raw.includes('127.0.0.1:9527') || raw.includes('localhost:9527');
                    }
                })();
                const normalizeRequestInputUrl = (rawUrl) => {
                    if (!rawUrl || typeof rawUrl !== 'string') return '';
                    let next = sanitizeHistoryUrlValue(rawUrl, '', { allowLocalCache: true }) || '';
                    if (!next) return '';
                    try {
                        const parsed = new URL(String(next));
                        const isLocalHost = parsed.hostname === '127.0.0.1' || parsed.hostname === 'localhost';
                        if (isLocalHost && parsed.pathname === '/proxy') {
                            const unwrapped = parsed.searchParams.get('url');
                            if (unwrapped) next = unwrapped;
                        }
                    } catch (e) { }
                    if (isLocalCacheUrl(next)) {
                        const source = resolveLocalCacheSourceUrl(next);
                        if (source) next = source;
                        else if (!isLocalMiddlewareTarget) return '';
                    }
                    if (!isLocalMiddlewareTarget && isComfyLocalUrl(next)) {
                        return '';
                    }
                    return next;
                };
                const normalizeRequestInputUrlAsync = async (rawUrl) => {
                    const normalized = normalizeRequestInputUrl(rawUrl);
                    if (!normalized) return '';
                    if (LocalImageManager.isImageId(normalized) || normalized.startsWith('asset://')) {
                        try {
                            const resolved = await resolveSpecialUrl(normalized);
                            if (resolved && typeof resolved === 'string') {
                                return resolved.startsWith('data:')
                                    ? normalizeDataUrl(resolved)
                                    : resolved;
                            }
                        } catch (e) { }
                        return '';
                    }
                    return normalized;
                };
                const rewriteTemplateInputMapUrls = (mapValue) => {
                    if (!mapValue || typeof mapValue !== 'object' || Array.isArray(mapValue)) return mapValue;
                    let changed = false;
                    const nextMap = { ...mapValue };
                    Object.entries(mapValue).forEach(([key, val]) => {
                        if (typeof val !== 'string') return;
                        const trimmed = val.trim();
                        if (!trimmed) return;
                        const looksLikeUrl = /^(https?:|data:|blob:)/i.test(trimmed)
                            || isLocalCacheUrl(trimmed)
                            || isComfyLocalUrl(trimmed)
                            || trimmed.includes('/proxy?url=')
                            || trimmed.startsWith('asset://')
                            || LocalImageManager.isImageId(trimmed);
                        if (!looksLikeUrl) return;
                        if (LocalImageManager.isImageId(trimmed)) {
                            nextMap[key] = '';
                            changed = true;
                            return;
                        }
                        const normalized = normalizeRequestInputUrl(trimmed);
                        if (!normalized) {
                            nextMap[key] = '';
                            changed = true;
                            return;
                        }
                        if (normalized === val) return;
                        nextMap[key] = normalized;
                        changed = true;
                    });
                    return changed ? nextMap : mapValue;
                };
                const sanitizeTemplateInputMap = (mapValue) => {
                    if (!mapValue || typeof mapValue !== 'object' || Array.isArray(mapValue)) return mapValue;
                    const rewritten = rewriteTemplateInputMapUrls(mapValue);
                    const nextMap = {};
                    Object.entries(rewritten).forEach(([key, val]) => {
                        if (val === '' || val === null || val === undefined) return;
                        nextMap[key] = val;
                    });
                    return nextMap;
                };
                const sanitizeTemplateBodyInputs = (value) => {
                    if (!value || typeof value !== 'object') return value;
                    if (Array.isArray(value)) {
                        let changed = false;
                        const next = value.map((entry) => {
                            const sanitized = sanitizeTemplateBodyInputs(entry);
                            if (sanitized !== entry) changed = true;
                            return sanitized;
                        }).filter((entry) => {
                            if (entry === '' || entry === null || entry === undefined) {
                                changed = true;
                                return false;
                            }
                            return true;
                        });
                        return changed ? next : value;
                    }
                    let changed = false;
                    const nextObj = {};
                    Object.entries(value).forEach(([key, val]) => {
                        let nextVal = val;
                        if (key === 'input_values' || key === 'inputs') {
                            nextVal = sanitizeTemplateInputMap(val);
                        } else {
                            nextVal = sanitizeTemplateBodyInputs(val);
                        }
                        if (nextVal === '' || nextVal === null || nextVal === undefined) {
                            changed = true;
                            return;
                        }
                        if (nextVal !== val) changed = true;
                        nextObj[key] = nextVal;
                    });
                    return changed ? nextObj : value;
                };
                const sanitizeTemplateRequestBody = (bodyValue) => {
                    if (!bodyValue) return bodyValue;
                    if (bodyValue instanceof FormData) return bodyValue;
                    if (typeof bodyValue === 'string') {
                        const trimmed = bodyValue.trim();
                        if (!trimmed || (!trimmed.startsWith('{') && !trimmed.startsWith('['))) return bodyValue;
                        try {
                            const parsed = JSON.parse(trimmed);
                            const sanitized = sanitizeTemplateBodyInputs(parsed);
                            if (sanitized === parsed) return bodyValue;
                            return JSON.stringify(sanitized);
                        } catch (e) {
                            return bodyValue;
                        }
                    }
                    if (typeof bodyValue === 'object') {
                        return sanitizeTemplateBodyInputs(bodyValue);
                    }
                    return bodyValue;
                };

                // --- 模型特征定义 (融合 V2.5-3 和 V2.5-4) ---
                // isBananaLike: 用于旧版/通用香蕉模型 (排除 nano-banana-2)
                const isBananaLike = (modelId.includes('banana') || modelId.includes('edit') || modelId.includes('qwen')) && !(modelId.includes('nano-banana-2') || (config?.modelName ?? '').includes('nano-banana-2'));
                const isOpenAIImage = modelId.includes('gpt') || (config?.modelName ?? '').includes('gpt-image') || (config?.provider ?? '').toLowerCase().includes('gpt-4o image');
                const isFluxKontext = modelId.includes('flux') || (config?.modelName ?? '').includes('flux-kontext');
                // isNanoBanana2: V2.5-4 新增的异步模型标识
                const isNanoBanana2 = (config?.modelName ?? '').includes('nano-banana-2') || modelId.includes('nano-banana-2');
                const isMidjourney = !requestTemplateEnabled
                    && (modelId.includes('mj') || (config?.provider ?? '').toLowerCase().includes('midjourney'));
                const isJimeng = modelId.includes('jimeng') || (config?.modelName ?? '').includes('jimeng') || config?.provider === 'jimeng';

                // 辅助函数
                const getJimengModelName = () => {
                    if (modelId.includes('jimeng-4.5')) return 'jimeng-4.5';
                    if (modelId.includes('jimeng-4.1')) return 'jimeng-4.1';
                    if (modelId.includes('jimeng-4.0')) return 'jimeng-4.0';
                    if (modelId.includes('jimeng-3.1')) return 'jimeng-3.1';
                    if (modelId.includes('jimeng-3.0')) return 'jimeng-3.0';
                    if (config?.modelName?.includes('jimeng')) {
                        return config.modelName;
                    }
                    return 'jimeng-4.5'; // 默认使用最新版本
                };

                const getImageSizeFlag = () => {
                    if (!isNanoBanana2) return undefined;
                    if (resolution === '4K') return '4K';
                    if (resolution === '2K') return '2K';
                    return '1K';
                };
                const imageSizeFlag = getImageSizeFlag();
                const hasExplicitSize = isExplicitImageResolution(resolution);
                const aspect = ratio === 'Auto' || hasExplicitSize ? undefined : ratio;

                // --- 核心逻辑分支 ---

                // 0. Chat Image (使用 Chat 格式返回图片)
                if (isChatImage) {
                    endpoint = '/v1/chat/completions';
                    const contentParts = [];
                    if (prompt) contentParts.push({ type: 'text', text: prompt });
                    const inputImages = connectedImages.length > 0
                        ? connectedImages
                        : (sourceImage ? [sourceImage] : []);
                    inputImages.forEach((img) => {
                        if (!img) return;
                        contentParts.push({ type: 'image_url', image_url: { url: img } });
                    });
                    if (contentParts.length === 0) {
                        contentParts.push({ type: 'text', text: t('生成图片') });
                    }
                    payload = {
                        model: config?.modelName || modelId,
                        messages: [{ role: 'user', content: contentParts }],
                        stream: false
                    };
                }
                // 0. ModelScope Z-Image (异步任务)
                else if (isModelScope) {
                    const modelName = config?.modelName || 'Tongyi-MAI/Z-Image-Turbo';
                    endpoint = `${baseUrl}/v1/images/generations`;
                    payload = {
                        model: modelName,
                        prompt: prompt || '',
                        n: 1,
                        size: sizeStr,
                        ...(useAsync ? { async_mode: true } : {})
                    };
                    if (aspect) payload.aspect_ratio = aspect;
                }
                // 0.5 Gemini Native (Yunwu/VibeCoding)
                else if (isGeminiNative) {
                    const modelName = config?.modelName || 'gemini-3-pro-image-preview';
                    const parts = [];
                    if (prompt) parts.push({ text: prompt });

                    const inputImages = connectedImages.length > 0
                        ? connectedImages
                        : (sourceImage ? [sourceImage] : []);

                    const getGeminiMimeType = (imageUrl) => {
                        if (!imageUrl) return 'image/png';
                        if (imageUrl.startsWith('data:')) {
                            const match = imageUrl.match(/^data:([^;]+);/i);
                            if (match && match[1]) return match[1];
                        }
                        const ext = getUrlExt(imageUrl, '.png');
                        if (ext === '.jpg' || ext === '.jpeg') return 'image/jpeg';
                        if (ext === '.webp') return 'image/webp';
                        if (ext === '.gif') return 'image/gif';
                        return 'image/png';
                    };

                    for (const img of inputImages) {
                        const base64 = await getBase64FromUrl(img, { useProxy: resolveSourceProxy(img) });
                        const mimeType = getGeminiMimeType(img);
                        parts.push({
                            inline_data: {
                                mime_type: mimeType,
                                data: base64
                            }
                        });
                    }

                    const imageConfig = {};
                    if (aspect) imageConfig.aspectRatio = aspect;
                    if (resolution && resolution !== 'Auto') imageConfig.imageSize = resolution;

                    payload = {
                        contents: [{ role: 'user', parts }],
                        generationConfig: {
                            responseModalities: ['TEXT', 'IMAGE'],
                            ...(Object.keys(imageConfig).length > 0 ? { imageConfig } : {})
                        }
                    };

                    const keyParam = apiKey ? `?key=${encodeURIComponent(apiKey)}` : '';
                    endpoint = `${baseUrl}/v1beta/models/${modelName}:generateContent${keyParam}`;
                }
                // 1. 旧版 Banana/Edit (必须有参考图) - 修复: 只有在有图时才进入此逻辑
                else if (connectedImages.length > 0 && isBananaLike) {
                    endpoint = `${baseUrl}/v1/images/edits`;
                    useMultipart = true;
                    const formData = new FormData();
                    formData.append('model', config?.modelName || 'nano-banana');
                    formData.append('prompt', prompt || 'enhance');
                    formData.append('n', '1');
                    formData.append('size', sizeStr);
                    if (aspect) formData.append('aspect_ratio', aspect);
                    if (imageSizeFlag) formData.append('image_size', imageSizeFlag);

                    const blobPromises = connectedImages.map(url => getBlobFromUrl(url, { useProxy: resolveSourceProxy(url) }));
                    const blobs = await Promise.all(blobPromises);
                    blobs.forEach((blob, i) => {
                        formData.append('image', blob, `input_${i}.png`);
                    });

                    // 尝试添加蒙版 (V2.5-4特性)
                    if (finalMaskBlob) {
                        formData.append('mask', finalMaskBlob, 'mask.png');
                    }

                    payload = formData;
                }
                // 2. Flux Kontext
                else if (isFluxKontext) {
                    endpoint = `${baseUrl}/v1/images/edits`;
                    useMultipart = true;
                    const formData = new FormData();
                    formData.append('model', config?.modelName || 'flux-kontext-pro');
                    formData.append('prompt', prompt || '');
                    if (aspect) formData.append('aspect_ratio', aspect);
                    if (sizeStr) formData.append('size', sizeStr);

                    const refs = connectedImages.length > 0 ? connectedImages : (sourceImage ? [sourceImage] : []);
                    if (refs.length > 0) {
                        const blobPromises = refs.map(url => getBlobFromUrl(url, { useProxy: resolveSourceProxy(url) }));
                        const blobs = await Promise.all(blobPromises);
                        blobs.forEach((blob, i) => formData.append('image', blob, `flux_ref_${i}.png`));
                    }
                    if (finalMaskBlob) {
                        formData.append('mask', finalMaskBlob, 'mask.png');
                    }
                    payload = formData;
                }
                // 3. OpenAI Image
                else if (isOpenAIImage) {
                    let finalPrompt = prompt || '';
                    const jsonBody = {
                        model: config?.modelName || 'gpt-4o-image',
                        prompt: finalPrompt,
                        n: 1,
                        size: sizeStr,
                        response_format: 'url'
                    };
                    if (aspect) jsonBody.aspect_ratio = aspect;

                    if (connectedImages.length > 0) {
                        const b64Promises = connectedImages.map(url => getBase64FromUrl(url, { useProxy: resolveSourceProxy(url) }));
                        const b64s = await Promise.all(b64Promises);
                        jsonBody.image = b64s.map(b => `data:image/png;base64,${b}`);
                    }
                    payload = jsonBody;
                }
                // 4. [关键] Nano Banana 2 (V2.5-4 核心逻辑，包含异步处理)
                else if (isNanoBanana2) {
                    const useAsync = true; // 保持异步开启
                    if (connectedImages.length > 0) {
                        endpoint = `${baseUrl}/v1/images/edits${useAsync ? '?async=true' : ''}`;
                        useMultipart = true;
                        const formData = new FormData();
                        formData.append('model', config?.modelName || 'nano-banana-2');
                        formData.append('prompt', prompt || '');
                        formData.append('response_format', 'url');
                        if (aspect) formData.append('aspect_ratio', aspect);
                        if (imageSizeFlag) formData.append('image_size', imageSizeFlag);

                        const blobPromises = connectedImages.map(url => getBlobFromUrl(url, { useProxy: resolveSourceProxy(url) }));
                        const blobs = await Promise.all(blobPromises);
                        blobs.forEach((blob, i) => {
                            formData.append('image', blob, `input_${i}.png`);
                        });
                        if (finalMaskBlob) {
                            formData.append('mask', finalMaskBlob, 'mask.png');
                        }
                        payload = formData;
                    } else {
                        endpoint = `${baseUrl}/v1/images/generations${useAsync ? '?async=true' : ''}`;
                        const jsonBody = {
                            model: config?.modelName || 'nano-banana-2',
                            prompt: prompt || '',
                            response_format: 'url',
                            ...(aspect ? { aspect_ratio: aspect } : {}),
                            ...(imageSizeFlag ? { image_size: imageSizeFlag } : {}),
                        };
                        if (sourceImage) {
                            const trimmedImg = sourceImage.trim();
                            if (trimmedImg.startsWith('http')) {
                                jsonBody.image = [trimmedImg];
                            } else if (trimmedImg.startsWith('data:')) {
                                jsonBody.image = [trimmedImg];
                            } else {
                                const b64 = await getBase64FromUrl(trimmedImg, { useProxy: resolveSourceProxy(trimmedImg) });
                                jsonBody.image = [`data:image/png;base64,${b64}`];
                            }
                        }
                        payload = jsonBody;
                    }
                }
                // 5. Midjourney (V2.5-4 逻辑，支持 oref/sref)
                else if (isMidjourney) {
                    const mjMode = node?.settings?.mjMode || 'fast';
                    const mjVersion = node?.settings?.mjVersion || '--v 7';
                    let mjPrompt = prompt || '';
                    if (ratio && ratio !== 'Auto') {
                        if (!mjPrompt.includes('--ar ')) {
                            mjPrompt = `${mjPrompt} --ar ${ratio}`.trim();
                        }
                    }
                    const orefConnected = getConnectedImageForInput(nodeId, 'oref');
                    const srefConnected = getConnectedImageForInput(nodeId, 'sref');

                    const imagesToUpload = [];
                    const imageIndexMap = new Map();
                    let orefImageUrl = null;
                    let srefImageUrl = null;
                    let defaultImageUrls = [];

                    const orefUrl = orefConnected || (node?.settings?.mjOref && node.settings.mjOref.trim());
                    if (orefUrl && orefUrl.trim()) {
                        let finalOrefUrl = orefUrl.trim();
                        if (finalOrefUrl.startsWith('http')) { orefImageUrl = finalOrefUrl; }
                        else if (finalOrefUrl.startsWith('data:')) { imagesToUpload.push(finalOrefUrl); imageIndexMap.set('oref', imagesToUpload.length - 1); }
                        else { orefImageUrl = finalOrefUrl; }
                    }
                    const srefUrl = srefConnected || (node?.settings?.mjSref && node.settings.mjSref.trim());
                    if (srefUrl && srefUrl.trim()) {
                        let finalSrefUrl = srefUrl.trim();
                        if (finalSrefUrl.startsWith('http')) { srefImageUrl = finalSrefUrl; }
                        else if (finalSrefUrl.startsWith('data:')) { imagesToUpload.push(finalSrefUrl); imageIndexMap.set('sref', imagesToUpload.length - 1); }
                        else { srefImageUrl = finalSrefUrl; }
                    }
                    if (connectedImages.length > 0) {
                        for (const img of connectedImages) {
                            const isOrefImage = orefConnected && img === orefConnected;
                            const isSrefImage = srefConnected && img === srefConnected;
                            if (!isOrefImage && !isSrefImage) {
                                if (img.startsWith('http')) { defaultImageUrls.push(img); }
                                else if (img.startsWith('data:')) { imagesToUpload.push(img); imageIndexMap.set(`default_${defaultImageUrls.length}`, imagesToUpload.length - 1); defaultImageUrls.push(null); }
                                else { defaultImageUrls.push(img); }
                            }
                        }
                    }
                    if (imagesToUpload.length > 0) {
                        try {
                            const uploadedUrls = await uploadMidjourneyImages(imagesToUpload, baseUrl, apiKey);
                            if (imageIndexMap.has('oref')) orefImageUrl = uploadedUrls[imageIndexMap.get('oref')];
                            if (imageIndexMap.has('sref')) srefImageUrl = uploadedUrls[imageIndexMap.get('sref')];
                            for (let i = 0; i < defaultImageUrls.length; i++) {
                                if (defaultImageUrls[i] === null) {
                                    const key = `default_${i}`;
                                    if (imageIndexMap.has(key)) defaultImageUrls[i] = uploadedUrls[imageIndexMap.get(key)];
                                }
                            }
                        } catch (error) {
                            setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', progress: 0, errorMsg: `图片上传失败: ${error.message}` } : hItem));
                            return;
                        }
                    }
                    defaultImageUrls = defaultImageUrls.filter(url => url !== null);
                    let finalMjPrompt = '';
                    if (defaultImageUrls.length > 0) finalMjPrompt = defaultImageUrls.join(' ') + ' ';
                    finalMjPrompt += mjPrompt.trim();
                    if (!finalMjPrompt.includes('--v ') && !finalMjPrompt.includes('--niji ')) finalMjPrompt = `${finalMjPrompt} ${mjVersion}`.trim();
                    if (ratio && ratio !== 'Auto' && !finalMjPrompt.includes('--ar ')) finalMjPrompt = `${finalMjPrompt} --ar ${ratio}`.trim();
                    if (orefImageUrl && !finalMjPrompt.includes('--oref ')) finalMjPrompt = `${finalMjPrompt} --oref ${orefImageUrl}`.trim();
                    if (node?.settings?.mjOw && node.settings.mjOw > 0 && !finalMjPrompt.includes('--ow ')) finalMjPrompt = `${finalMjPrompt} --ow ${Math.min(1000, Math.max(1, node.settings.mjOw))}`.trim();
                    if (srefImageUrl && !finalMjPrompt.includes('--sref ')) finalMjPrompt = `${finalMjPrompt} --sref ${srefImageUrl}`.trim();

                    endpoint = `${baseUrl}/${mjMode}/mj/submit/imagine`;
                    payload = { prompt: finalMjPrompt, base64Array: [] };

                    const mjResp = await fetch(endpoint, { method: 'POST', headers: { Authorization: `Bearer ${apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    const mjText = await mjResp.text();
                    if (!mjResp.ok) throw new Error(mjText || `Midjourney API error: ${mjResp.status}`);
                    let mjData = JSON.parse(mjText);
                    if (mjData.code !== 1 && mjData.code !== 22) throw new Error(mjData.description || `Midjourney提交失败: code ${mjData.code}`);
                    const remoteTaskId = mjData.result;
                    if (!remoteTaskId) throw new Error('未获取到任务ID');
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, remoteTaskId, status: 'generating', progress: 5 } : hItem));
                    pollMidjourneyJob(remoteTaskId, taskId, baseUrl, apiKey, mjMode, w, h);
                    return;
                }
                // 6. 即梦 (Jimeng) - [修复] 恢复 V2.5-3 的稳定逻辑
                else if (isJimeng) {
                    if (connectedImages.length > 0) {
                        // 图生图 (使用 compositions)
                        endpoint = `${baseUrl}/v1/images/compositions`;
                        if (!prompt || prompt.trim() === '') throw new Error('图生图功能需要提供提示词');

                        let jimengRatio = ratio;
                        let jimengResolution = '2k';

                        if (ratio === 'Auto' && sourceImage) {
                            try {
                                const sourceDims = await getImageDimensions(sourceImage);
                                // V3.7.19: 计算最接近的标准比例，而不是直接使用原始比例
                                const supportedRatios = [
                                    { name: '1:1', value: 1 },
                                    { name: '4:3', value: 4 / 3 },
                                    { name: '3:4', value: 3 / 4 },
                                    { name: '16:9', value: 16 / 9 },
                                    { name: '9:16', value: 9 / 16 },
                                    { name: '3:2', value: 3 / 2 },
                                    { name: '2:3', value: 2 / 3 },
                                    { name: '21:9', value: 21 / 9 }
                                ];
                                const actualRatio = sourceDims.w / sourceDims.h;
                                // 找到最接近的支持比例
                                let closestRatio = supportedRatios[0];
                                let minDiff = Math.abs(actualRatio - closestRatio.value);
                                for (const r of supportedRatios) {
                                    const diff = Math.abs(actualRatio - r.value);
                                    if (diff < minDiff) {
                                        minDiff = diff;
                                        closestRatio = r;
                                    }
                                }
                                jimengRatio = closestRatio.name;

                                if (resolution === 'Auto') {
                                    const maxSide = Math.max(sourceDims.w, sourceDims.h);
                                    jimengResolution = maxSide <= 1024 ? '1k' : (maxSide <= 2048 ? '2k' : '4k');
                                }
                            } catch (e) { jimengRatio = '1:1'; }
                        } else {
                            jimengRatio = ratio === 'Auto' ? '1:1' : ratio;
                        }

                        if (resolution !== 'Auto') {
                            if (resolution === '1K') jimengResolution = '1k';
                            else if (resolution === '2K') jimengResolution = '2k';
                            else if (resolution === '4K') jimengResolution = '4k';
                        }

                        const maskDataUrl = finalMaskBlob ? await blobToDataURL(finalMaskBlob) : null;
                        const imagePromises = connectedImages.map(async (imgUrl) => {
                            try {
                                return await getDataUrlFromUrl(imgUrl, { useProxy: resolveSourceProxy(imgUrl) });
                            } catch (e) {
                                if (imgUrl.startsWith('blob:')) {
                                    console.error('[Jimeng] Blob URL 恢复失败:', e);
                                    throw new Error('引用图片已失效（Blob URL），请重新添加图片到画布');
                                }
                                throw new Error(`图片加载失败: ${e.message}。请尝试重新添加图片到画布`);
                            }
                        });
                        const base64Images = await Promise.all(imagePromises);
                        const jimengModelName = getJimengModelName();

                        payload = {
                            model: jimengModelName,
                            prompt: prompt.trim(),
                            images: base64Images,
                            ratio: jimengRatio,
                            resolution: jimengResolution,
                            response_format: 'url'
                        };
                        if (maskDataUrl) payload.mask = maskDataUrl;
                    } else {
                        // 文生图 (使用 generations)
                        endpoint = `${baseUrl}/v1/images/generations`;
                        const jimengRatio = ratio === 'Auto' ? '1:1' : ratio;
                        let jimengResolution = '2k';
                        if (resolution === '1K') jimengResolution = '1k';
                        else if (resolution === '2K') jimengResolution = '2k';
                        else if (resolution === '4K') jimengResolution = '4k';

                        if (!prompt || prompt.trim() === '') throw new Error('提示词不能为空');

                        const jimengModelName = getJimengModelName();
                        payload = {
                            model: jimengModelName,
                            prompt: prompt.trim(),
                            ratio: jimengRatio,
                            resolution: jimengResolution,
                            response_format: 'url'
                        };
                    }
                }
                // 7. [修复] 通用兜底 (修复 Banana T2I 问题)
                // 这部分是 V2.5-4 缺失的，导致普通 Banana 模型和其他通用 OpenAI 格式模型无法进行文生图
                else {
                    payload = {
                        model: config?.modelName || modelId,
                        prompt,
                        n: 1,
                        size: sizeStr,
                        response_format: 'url'
                    };
                }

                payload = applyCustomParamsToPayload(payload, customParams, customParamSelections);
                if (config?.previewOverrideEnabled && config.previewOverridePatch) {
                    payload = applyPreviewOverridePatch(payload, config.previewOverridePatch);
                }

                const getTemplateImageSources = async (inputImages = []) => {
                    const imageSources = [];
                    for (const rawUrl of inputImages) {
                        let normalized = await normalizeRequestInputUrlAsync(rawUrl);
                        if (!normalized) continue;
                        // 本地中间件下优先内联远程 URL，避免目标侧无法拉取带签名/防盗链图片
                        if (isLocalMiddlewareTarget && /^https?:/i.test(normalized)) {
                            try {
                                const base64 = await getBase64FromUrl(normalized, { useProxy: resolveSourceProxy(normalized) });
                                if (base64) {
                                    const ext = getUrlExt(normalized, '.png');
                                    const mime = ext === '.jpg' || ext === '.jpeg'
                                        ? 'image/jpeg'
                                        : ext === '.webp'
                                            ? 'image/webp'
                                            : 'image/png';
                                    normalized = `data:${mime};base64,${base64}`;
                                }
                            } catch (e) {
                                // 失败时保留 URL 继续尝试，避免完全阻断
                            }
                        }
                        imageSources.push(normalized);
                    }
                    return imageSources;
                };

                const buildAsyncTemplateVars = async () => {
                    const vars = {
                        modelName: config?.modelName || modelId,
                        prompt: prompt || '',
                        ratio: omitRatioOnSubmit ? '' : ratio,
                        resolution: omitResolutionOnSubmit ? '' : resolution,
                        size: (omitRatioOnSubmit || omitResolutionOnSubmit) ? '' : sizeStr,
                        duration: type === 'video' ? duration : undefined,
                        durationNumber: normalizeDurationValue(duration, 5),
                        seed: node?.settings?.seed,
                        n: 1,
                        provider: {
                            key: apiKey,
                            baseUrl,
                            id: credentials.provider,
                            useProxy
                        }
                    };
                    const inputImages = connectedImages.length > 0
                        ? connectedImages
                        : (sourceImage ? [sourceImage] : []);
                    const imageSources = await getTemplateImageSources(inputImages);
                    if (imageSources.length > 0) {
                        vars.imageUrl = imageSources[0];
                        vars.imageUrls = imageSources;
                        vars.imagesUrl = imageSources;
                        vars.imagesUrls = imageSources;
                        imageSources.forEach((url, idx) => {
                            const index = idx + 1;
                            vars[`imageUrl${index}`] = url;
                            vars[`image${index}Url`] = url;
                        });
                    }
                    if (finalMaskBlob) {
                        vars.maskBlob = finalMaskBlob;
                    }
                    if (customParams.length > 0 && customParamSelections) {
                        customParams.forEach((param) => {
                            const name = String(param?.name || '').trim();
                            if (!name) return;
                            const value = getCustomParamSelection(param, customParamSelections);
                            if (value === '' || value === undefined || value === null) {
                                const fallback = getImageSourceFallbackByParam(name, imageSources);
                                if (fallback) {
                                    vars[name] = fallback;
                                }
                                return;
                            }
                            vars[name] = value;
                        });
                    }
                    return vars;
                };

                let requestOverride = null;
                if (requestTemplate?.enabled) {
                    const buildRequestTemplateVars = async () => {
                        const vars = {
                            modelName: config?.modelName || modelId,
                            prompt: prompt || '',
                            ratio: omitRatioOnSubmit ? '' : ratio,
                            resolution: omitResolutionOnSubmit ? '' : resolution,
                            size: (omitRatioOnSubmit || omitResolutionOnSubmit) ? '' : sizeStr,
                            duration: type === 'video' ? duration : undefined,
                            durationNumber: normalizeDurationValue(duration, 5),
                            seed: node?.settings?.seed,
                            n: 1,
                            provider: {
                                key: apiKey,
                                baseUrl,
                                id: credentials.provider,
                                useProxy
                            }
                        };
                        const inputImages = connectedImages.length > 0
                            ? connectedImages
                            : (sourceImage ? [sourceImage] : []);
                        const imageSources = await getTemplateImageSources(inputImages);
                        if (imageSources.length > 0) {
                            vars.imageUrl = imageSources[0];
                            vars.imageUrls = imageSources;
                            vars.imagesUrl = imageSources;
                            vars.imagesUrls = imageSources;
                            imageSources.forEach((url, idx) => {
                                const index = idx + 1;
                                vars[`imageUrl${index}`] = url;
                                vars[`image${index}Url`] = url;
                            });
                        }
                        if (finalMaskBlob) {
                            vars.maskBlob = finalMaskBlob;
                            try {
                                vars.maskDataUrl = await blobToDataURL(finalMaskBlob);
                                vars.maskDataURL = vars.maskDataUrl;
                            } catch (e) { }
                        }
                        const templateText = JSON.stringify(requestTemplate || {});
                        const needsBlob = (requestTemplate?.bodyType || '').toLowerCase() === 'multipart'
                            || /:blob\s*}}/.test(templateText);
                        const needsDataUrl = /:blob\s*}}/.test(templateText);
                        if (needsBlob && imageSources.length > 0) {
                            const blobs = await Promise.all(imageSources.map((url) => getBlobFromUrl(url, { useProxy: resolveSourceProxy(url) })));
                            vars.imageBlob = blobs[0];
                            vars.imageBlobs = blobs;
                            vars.imagesBlob = blobs;
                            blobs.forEach((blob, idx) => {
                                const index = idx + 1;
                                vars[`imageBlob${index}`] = blob;
                                vars[`image${index}Blob`] = blob;
                            });
                        }
                        if (needsDataUrl && imageSources.length > 0) {
                            const dataUrls = await Promise.all(imageSources.map(async (url) => {
                                if (!url) return '';
                                if (url.startsWith('data:')) return url;
                                const base64 = await getBase64FromUrl(url, { useProxy: resolveSourceProxy(url) });
                                const ext = getUrlExt(url, '.png');
                                const mime = ext === '.jpg' || ext === '.jpeg'
                                    ? 'image/jpeg'
                                    : ext === '.webp'
                                        ? 'image/webp'
                                        : 'image/png';
                                return `data:${mime};base64,${base64}`;
                            }));
                            vars.imageDataUrl = dataUrls[0];
                            vars.imageDataURL = dataUrls[0];
                            vars.imageDataUrls = dataUrls;
                            vars.imagesDataUrl = dataUrls;
                            vars.imagesDataURL = dataUrls;
                            dataUrls.forEach((dataUrl, idx) => {
                                const index = idx + 1;
                                vars[`imageDataUrl${index}`] = dataUrl;
                                vars[`imageDataURL${index}`] = dataUrl;
                                vars[`image${index}DataUrl`] = dataUrl;
                                vars[`image${index}DataURL`] = dataUrl;
                            });
                        }
                        if (customParams.length > 0 && customParamSelections) {
                            customParams.forEach((param) => {
                                const name = String(param?.name || '').trim();
                                if (!name) return;
                                const value = getCustomParamSelection(param, customParamSelections);
                                if (value === '' || value === undefined || value === null) {
                                    const fallback = getImageSourceFallbackByParam(name, imageSources);
                                    if (fallback) {
                                        vars[name] = fallback;
                                    }
                                    return;
                                }
                                vars[name] = value;
                            });
                        }
                        return vars;
                    };
                    try {
                        const templateVars = await buildRequestTemplateVars();
                        const templateRequest = buildRequestFromTemplate(requestTemplate, templateVars, { bodyType: requestTemplate.bodyType });
                        if (templateRequest && templateRequest.url) {
                            templateRequest.body = sanitizeTemplateRequestBody(templateRequest.body);
                            requestOverride = requestOverrideEnabled && requestOverridePatch
                                ? applyRequestOverridePatch({ ...templateRequest }, requestOverridePatch)
                                : templateRequest;
                        }
                    } catch (e) {
                        console.warn('[RequestTemplate] 构建失败，已回退默认请求:', e);
                        requestOverride = null;
                    }
                }

                // --- 发送请求逻辑 (通用) (Supports Failover) ---
                // --- 发送请求逻辑 (通用) (Supports Failover) ---

                // Helper to perform fetch
                const performFetch = async (currentApiKey, currentBaseUrl) => {
                    const overrideUrl = requestOverride?.url || endpoint;
                    const overrideMethod = (requestOverride?.method || 'POST').toString().toUpperCase();
                    let overrideBodyType = (requestOverride?.bodyType || (useMultipart ? 'multipart' : 'json')).toString().toLowerCase();
                    const overrideHeaders = requestOverride?.headers && typeof requestOverride.headers === 'object'
                        ? { ...requestOverride.headers }
                        : {};
                    let requestBody = requestOverride && requestOverride.body !== undefined ? requestOverride.body : payload;
                    requestBody = sanitizeTemplateRequestBody(requestBody);
                    if (requestBody instanceof FormData) {
                        overrideBodyType = 'multipart';
                    }

                    if (currentApiKey && !overrideHeaders.Authorization && !overrideHeaders.authorization) {
                        overrideHeaders.Authorization = `Bearer ${currentApiKey}`;
                    }
                    if (overrideBodyType === 'json' && !overrideHeaders['Content-Type'] && !overrideHeaders['content-type']) {
                        overrideHeaders['Content-Type'] = 'application/json';
                    }
                    if (isModelScope && useProxy && useAsync) {
                        overrideHeaders['X-ModelScope-Async-Mode'] = 'true';
                    }

                    let fullUrl;
                    if (overrideUrl.startsWith('http')) {
                        if (currentBaseUrl !== baseUrl && overrideUrl.includes(baseUrl)) {
                            fullUrl = overrideUrl.replace(baseUrl, currentBaseUrl);
                        } else {
                            fullUrl = overrideUrl;
                        }
                    } else {
                        const cleanBaseUrl = currentBaseUrl.replace(/\/+$/, '');
                        fullUrl = `${cleanBaseUrl}${overrideUrl.startsWith('/') ? overrideUrl : '/' + overrideUrl}`;
                    }

                    if (overrideBodyType === 'multipart') {
                        requestBody = coerceFormDataFromObject(requestBody);
                        delete overrideHeaders['Content-Type'];
                        delete overrideHeaders['content-type'];
                    } else if (overrideBodyType === 'raw') {
                        if (typeof requestBody !== 'string') {
                            requestBody = JSON.stringify(requestBody ?? {});
                        }
                    } else if (overrideBodyType === 'json') {
                        if (!(requestBody instanceof FormData) && typeof requestBody !== 'string') {
                            requestBody = JSON.stringify(requestBody ?? {});
                        }
                    }

                    const finalUrl = buildProxyUrl(fullUrl, providerKey);
                    return await fetch(finalUrl, {
                        method: overrideMethod,
                        headers: overrideHeaders,
                        body: requestBody,
                    });
                };

                const apiKeysList = apiKeyRaw && apiKeyRaw.includes(',')
                    ? apiKeyRaw.split(',').map(k => k.trim()).filter(k => k)
                    : [apiKeyRaw || globalApiKey];
                const baseUrlsList = baseUrlRaw.includes(',')
                    ? baseUrlRaw.split(',').map(u => u.trim()).filter(u => u)
                    : [(baseUrlRaw || DEFAULT_BASE_URL).replace(/\/+$/, '')];

                const shuffleArray = (array) => {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                    return array;
                };

                if (apiKeysList.length > 1) shuffleArray(apiKeysList);
                if (baseUrlsList.length > 1) shuffleArray(baseUrlsList);

                let resp;
                let data; // Store parsed data directly
                let text; // Store text body
                let lastError;
                let success = false;

                // 使用 ref 获取最新黑名单（解决并发请求竞态）
                const currentBlacklist = apiBlacklistRef.current || {};
                const combinations = [];
                for (const k of apiKeysList) {
                    if (currentBlacklist[k]) {
                        continue;
                    }
                    // V3.7.23: 跳过暂停列表中的 key
                    if (isKeySuspended(k)) {
                        continue;
                    }
                    for (const u of baseUrlsList) {
                        combinations.push({ key: k, url: u });
                    }
                }

                if (combinations.length === 0 && apiKeysList.length > 0) {
                    console.warn('[Blacklist] All specified keys are blacklisted. Trying anyway with all available keys to avoid total failure.');
                    for (const k of apiKeysList) {
                        for (const u of baseUrlsList) {
                            combinations.push({ key: k, url: u });
                        }
                    }
                }

                if (combinations.length > 1) shuffleArray(combinations);

                for (const combo of combinations) {
                    try {
                        resp = await performFetch(combo.key, combo.url);

                        // Strict Network Level Failures (401/402/403)
                        if (resp.status === 401 || resp.status === 402 || resp.status === 403) {
                            const reason = resp.status === 402 ? '积分耗尽 (402)' : (resp.status === 401 ? '认证失效 (401)' : '访问被拒绝 (403)');
                            console.warn(`[API Failover] Key ending in ...${combo.key.slice(-4)} failed with status ${resp.status}. Trying next...`);
                            addToBlacklist(combo.key, reason);
                            lastError = new Error(`API returned ${resp.status}: ${reason}`);
                            continue;
                        }

                        // Business Logic Level Failures (Jimeng 1006, etc)
                        // Note: resp.text() consumes the body, so we must store it.
                        text = await resp.text();
                        try {
                            data = JSON.parse(text);
                        } catch (e) {
                            // If JSON parse fails but status was 200, it's a critical error, likely invalid response.
                            // But usually we just throw error later.
                        }

                        // Debug: 检查响应数据
                        if (isJimeng && data) {
                        }

                        // 从代理包装的响应中提取真实错误码（代理返回 code=-2001，真实错误在 message 中）
                        let realErrorCode = data?.code;
                        if (data?.message && typeof data.message === 'string') {
                            const match = data.message.match(/错误码:\s*(\d+)/);
                            if (match) {
                                realErrorCode = parseInt(match[1], 10);
                            }
                        }

                        // V3.7.23: 详细错误日志
                        if (isJimeng && data && (data.code !== 0 || realErrorCode)) {
                        }

                        // V3.7.23: 参数错误 (1000) - 致命错误，不应重试
                        if (isJimeng && (realErrorCode === 1000 || (data?.message && data.message.toLowerCase().includes('invalid parameter')))) {
                            console.error(`⛔ [API Fatal] 参数错误 (1000): ${data.message}`);
                            throw new Error(`参数错误: ${data.message || 'Invalid parameter'} (错误码 1000)`);
                        }

                        // V3.7.23: 登录失效 (34010105) - 暂停列表，不入黑名单
                        if (isJimeng && (realErrorCode === 34010105 || (data?.message && data.message.includes('34010105')))) {
                            console.warn(`⏳ [API Suspend] Key ending in ...${combo.key.slice(-4)} 登录失效 (34010105)，暂停 60 分钟`);
                            addToSuspendList(combo.key, '登录失效 (34010105)', 60 * 60 * 1000);
                            lastError = new Error(`登录失效: 请刷新 session (错误码 34010105)`);
                            continue; // 尝试下一个 key
                        }

                        // V3.7.23: 积分耗尽 (1006) - 仅精确匹配 realErrorCode===1006 才入黑名单
                        if (isJimeng && realErrorCode === 1006) {
                            // 熔断检查
                            record1006Error();
                            if (checkCircuitBreaker()) {
                                throw new Error(`⚡ 熔断保护: 短时间内多个账号积分耗尽，已暂停请求。请检查账号状态。`);
                            }
                            const reason = '积分耗尽 (1006)';
                            console.warn(`🚫 [API Blacklist] Key ending in ...${combo.key.slice(-4)} 积分耗尽 (1006)`);
                            addToBlacklist(combo.key, reason);
                            lastError = new Error(`Jimeng Error: ${data.message || 'Not enough credits'}`);
                            continue; // Failover!
                        }

                        success = true;
                        break;

                    } catch (err) {
                        // V3.7.23: 参数错误和熔断错误不应被捕获后继续
                        if (err.message.includes(t('参数错误')) || err.message.includes(t('熔断保护'))) {
                            throw err; // 重新抛出致命错误
                        }
                        console.warn(`[API Failover] Network/Parse request failed for ...${combo.key.slice(-4)}. Error: ${err.message}`);
                        lastError = err;
                    }
                }

                if (!success || (!resp && !text)) {
                    const errorMsg = lastError ? lastError.message : "All API combinations failed.";
                    throw new Error(errorMsg);
                }

                // If success, we already have `text` and `data`.
                // BUT logic below expects `resp.text()` to be called or `text` to be available.
                // We shouldn't call resp.text() again.
                // Let's ensure the variables match what follows.

                // Data is already parsed inside the loop if success=true
                if (!data && text) {
                    try { data = JSON.parse(text); } catch (e) { throw new Error(`响应解析失败: ${text.substring(0, 100)}`); }
                }

                if (!resp.ok) {
                    let errorMsg = data?.message || data?.error?.message || text;
                    if (isOpenAIImage && resp.status === 500) {
                        const detailedError = data?.error?.message || data?.error || data?.message || text;
                        errorMsg = `GPT - 4o 图片生成失败(500错误): ${detailedError} \n\n请检查：\n1.API Key 是否正确\n2.模型名称是否正确(${config?.modelName || 'gpt-4o-image'}) \n3.提示词是否符合要求\n4.服务是否正常运行`;
                        setHistory((prev) => prev.map((hItem) =>
                            hItem.id === taskId
                                ? { ...hItem, status: 'failed', progress: 0, errorMsg }
                                : hItem
                        ));
                    }
                    throw new Error(errorMsg);
                }

                // 处理即梦特定错误码
                if (isJimeng && data?.code !== undefined && data.code !== 0 && data.code !== 1 && data.code !== 200) {
                    throw new Error(data.message || `即梦API错误: ${data.code} `);
                }

                const immediateImageCandidates = collectImmediateImageUrls(data);

                // [保留 V2.5-4 特性] 处理异步任务 (Nano Banana 2)
                // 如果响应中包含 task_id，进入异步轮询模式
                if (isNanoBanana2 && (data?.task_id || (typeof data?.data === 'string' && data.data.startsWith('task-')))) {
                    const taskIdForPoll = data.task_id || data.data;
                    setHistory((prev) => prev.map((hItem) =>
                        hItem.id === taskId ? { ...hItem, status: 'generating', progress: 10, remoteTaskId: taskIdForPoll } : hItem
                    ));
                    pollImageTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, actualSourceNodeId, 0, true);
                    return;
                }

                if (asyncConfig?.enabled) {
                    const requestId = getValueByPathAny(data, asyncConfig.requestIdPaths);
                    if (requestId && immediateImageCandidates.length === 0) {
                        const asyncVars = await buildAsyncTemplateVars();
                        asyncVars.requestId = requestId;
                        setHistory((prev) => prev.map((hItem) =>
                            hItem.id === taskId ? { ...hItem, status: 'generating', progress: 10, remoteTaskId: requestId } : hItem
                        ));
                        pollAsyncTask(taskId, requestId, asyncConfig, asyncVars, w, h, actualSourceNodeId, providerKey, 0);
                        return;
                    }
                }
                if (!asyncConfig?.enabled && baseUrl && (String(baseUrl).includes('127.0.0.1:9527') || String(baseUrl).includes('localhost:9527'))) {
                    const requestId = getValueByPathAny(data, ['requestId', 'request_id', 'data.requestId', 'data.request_id', 'taskId', 'task_id', 'job_id']);
                    if (requestId && immediateImageCandidates.length === 0) {
                        const fallbackConfig = normalizeAsyncConfig(ASYNC_CONFIG_TEMPLATE);
                        if (fallbackConfig) {
                            const asyncVars = await buildAsyncTemplateVars();
                            asyncVars.requestId = requestId;
                            setHistory((prev) => prev.map((hItem) =>
                                hItem.id === taskId ? { ...hItem, status: 'generating', progress: 10, remoteTaskId: requestId } : hItem
                            ));
                            pollAsyncTask(taskId, requestId, fallbackConfig, asyncVars, w, h, actualSourceNodeId, providerKey, 0);
                            return;
                        }
                    }
                }

                let imageUrls = immediateImageCandidates.length > 0 ? [...immediateImageCandidates] : [];
                if (imageUrls.length === 0 && isChatImage) {
                    let chatContent = null;
                    const primaryMessage = data?.choices?.[0]?.message || data?.data?.choices?.[0]?.message;
                    if (primaryMessage?.content !== undefined) {
                        if (Array.isArray(primaryMessage.content)) {
                            chatContent = primaryMessage.content
                                .map(part => (typeof part?.text === 'string' ? part.text : ''))
                                .filter(Boolean)
                                .join('\n');
                        } else {
                            chatContent = primaryMessage.content;
                        }
                    } else if (data?.content) {
                        chatContent = data.content;
                    } else if (data?.text) {
                        chatContent = data.text;
                    } else if (data?.message) {
                        chatContent = typeof data.message === 'string' ? data.message : data.message.content;
                    } else if (data?.result) {
                        chatContent = typeof data.result === 'string' ? data.result : data.result.content;
                    } else if (data?.data?.content) {
                        chatContent = data.data.content;
                    } else if (data?.data?.text) {
                        chatContent = data.data.text;
                    } else if (data?.data?.message) {
                        chatContent = typeof data.data.message === 'string' ? data.data.message : data.data.message.content;
                    } else if (data?.data?.result) {
                        chatContent = typeof data.data.result === 'string' ? data.data.result : data.data.result.content;
                    }
                    if (chatContent && typeof chatContent !== 'string') {
                        chatContent = JSON.stringify(chatContent);
                    }
                    imageUrls = extractChatImageUrls(data, chatContent || '');
                } else if (imageUrls.length === 0 && isModelScope) {
                    const taskIdForPoll = data?.task_id || data?.taskId || data?.data?.task_id || data?.output?.task_id || data?.output?.taskId;
                    const rawImages = data?.output_images || data?.output?.output_images || data?.data?.output_images || data?.output?.images || data?.data?.output?.output_images || [];
                    imageUrls = Array.isArray(rawImages)
                        ? rawImages.map((img) => {
                            if (typeof img === 'string') return img;
                            return img?.url || img?.image_url || img?.imageUrl || img?.path || '';
                        }).filter(Boolean)
                        : [];

                    if (taskIdForPoll && imageUrls.length === 0) {
                        setHistory((prev) => prev.map((hItem) =>
                            hItem.id === taskId ? { ...hItem, status: 'generating', progress: 10, remoteTaskId: taskIdForPoll } : hItem
                        ));
                        pollModelScopeTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, actualSourceNodeId, providerKey, useProxy, 0);
                        return;
                    }
                } else if (imageUrls.length === 0 && isGeminiNative) {
                    const collected = new Set();
                    const pushUrl = (value, mimeHint = 'image/png') => {
                        if (!value) return;
                        if (typeof value === 'string') {
                            const trimmed = value.trim();
                            if (!trimmed) return;
                            if (trimmed.startsWith('data:') || trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
                                collected.add(trimmed);
                                return;
                            }
                            const base64Like = /^[A-Za-z0-9+/=]+$/.test(trimmed);
                            if (base64Like && trimmed.length > 64) {
                                const mimeType = detectBase64ImageMime(trimmed, mimeHint);
                                collected.add(`data:${mimeType};base64,${trimmed}`);
                            }
                            return;
                        }
                        if (typeof value === 'object') {
                            const url = value.url
                                || value.image_url
                                || value.imageUrl
                                || value.object_url
                                || value.objectUrl
                                || value.file_uri
                                || value.fileUri
                                || value.uri;
                            if (url) {
                                collected.add(url);
                                return;
                            }
                            const data = value.data || value.base64 || value.b64;
                            if (data) {
                                const mimeType = detectBase64ImageMime(data, value.mime_type || value.mimeType || mimeHint);
                                collected.add(`data:${mimeType};base64,${data}`);
                            }
                        }
                    };
                    const extractFromText = (text) => {
                        if (!text || typeof text !== 'string') return;
                        const dataMatches = text.match(/data:image\/[^;]+;base64,[A-Za-z0-9+/=]+/g) || [];
                        dataMatches.forEach((match) => collected.add(match));
                        const urlMatches = text.match(/https?:\/\/[^\s)]+/g) || [];
                        urlMatches.forEach((match) => {
                            if (match.match(/\.(png|jpg|jpeg|webp|gif)(\?|#|$)/i)) {
                                collected.add(match);
                            }
                        });
                    };
                    const candidateSources = [
                        data?.candidates,
                        data?.data?.candidates,
                        data?.response?.candidates,
                        data?.result?.candidates,
                        data?.data?.result?.candidates,
                        data?.output?.candidates
                    ];
                    candidateSources.forEach((candidateList) => {
                        if (!Array.isArray(candidateList)) return;
                        candidateList.forEach((candidate) => {
                            const parts = Array.isArray(candidate?.content?.parts)
                                ? candidate.content.parts
                                : (Array.isArray(candidate?.parts) ? candidate.parts : []);
                            parts.forEach((part) => {
                                const inline = part?.inline_data || part?.inlineData;
                                if (inline?.data) {
                                    const mimeType = inline.mime_type || inline.mimeType || 'image/png';
                                    const rawData = inline.data;
                                    const dataUrl = rawData.startsWith('data:')
                                        ? rawData
                                        : `data:${mimeType};base64,${rawData}`;
                                    collected.add(dataUrl);
                                }
                                const fileData = part?.file_data || part?.fileData;
                                if (fileData) {
                                    const fileUrl = fileData.file_uri || fileData.fileUri || fileData.uri;
                                    if (fileUrl) collected.add(fileUrl);
                                }
                                if (part?.data) pushUrl(part.data, part?.mime_type || part?.mimeType || 'image/png');
                                if (part?.image_url || part?.imageUrl) pushUrl(part.image_url || part.imageUrl);
                                if (part?.text) extractFromText(part.text);
                            });
                        });
                    });

                    const fallbackCollections = [
                        data?.images,
                        data?.image,
                        data?.outputs,
                        data?.data?.images,
                        data?.data?.image,
                        data?.data?.outputs,
                        data?.result?.images,
                        data?.result?.image,
                        data?.result?.output_images,
                        data?.result?.output?.output_images,
                        data?.data?.result?.images,
                        data?.data?.result?.output_images,
                        data?.data?.result?.output?.output_images,
                        data?.output_images,
                        data?.output?.images,
                        data?.output?.output_images,
                        data?.data?.output_images,
                        data?.data?.output?.output_images
                    ];
                    fallbackCollections.forEach((entry) => {
                        if (Array.isArray(entry)) {
                            entry.forEach((item) => pushUrl(item));
                        } else if (entry) {
                            pushUrl(entry);
                        }
                    });

                    imageUrls = Array.from(collected).filter(Boolean);
                }

                // 处理同步返回结果 (标准 OpenAI 格式或嵌套格式)
                if (imageUrls.length === 0) {
                    if (data?.data && Array.isArray(data.data)) {
                        // 标准 OpenAI 格式
                        imageUrls = data.data.map(item => {
                            if (typeof item === 'string') return item;
                            if (!item) return null;
                            return item.url
                                || item.image_url
                                || item.imageUrl
                                || (item.b64_json ? `data:${detectBase64ImageMime(item.b64_json)};base64,${item.b64_json}` : null)
                                || (item.base64 ? `data:${detectBase64ImageMime(item.base64)};base64,${item.base64}` : null);
                        }).filter(url => typeof url === 'string');
                    } else if (data?.data?.data && Array.isArray(data.data.data)) {
                        // 嵌套格式
                        imageUrls = data.data.data.map(item => {
                            if (typeof item === 'string') return item;
                            if (!item) return null;
                            return item.url
                                || item.image_url
                                || item.imageUrl
                                || (item.b64_json ? `data:${detectBase64ImageMime(item.b64_json)};base64,${item.b64_json}` : null)
                                || (item.base64 ? `data:${detectBase64ImageMime(item.base64)};base64,${item.base64}` : null);
                        }).filter(Boolean);
                    }
                }

                if (imageUrls.length === 0) {
                    const deepCandidates = collectDeepImageValues(data);
                    if (deepCandidates.length > 0) {
                        imageUrls = deepCandidates;
                    }
                }

                if (imageUrls.length === 0) {
                    console.warn('[Image Parse] 未找到图片URL', {
                        keys: data && typeof data === 'object' ? Object.keys(data) : [],
                        data
                    });
                    throw new Error('未能在响应中找到图片URL');
                }

                imageUrls = await normalizeImageUrls(imageUrls);
                if (imageUrls.length === 0) {
                    console.warn('[Image Parse] 图片URL规范化后为空');
                    throw new Error('图片返回结果无效');
                }

                const primaryUrl = imageUrls[0];
                const endTime = Date.now();
                const durationMs = endTime - now;

                // V3.6.1: 检查是否是分镜表的图片任务
                // V3.7.9: 保存所有生成的图片到 output_images 数组
                // V3.7.30: 添加调试日志
                const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                const fallbackStoryboard = !storyboardTask ? parseStoryboardSourceNodeId(actualSourceNodeId) : null;
                if (storyboardTask) {
                    if (storyboardTask.isImageMode) {
                        updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                            output_images: imageUrls, // V3.7.9: 保存所有图片
                            output_url: imageUrls[0], // 兼容旧逻辑
                            selectedImageIndex: 0, // V3.7.9: 默认选中第一张
                            outputEnabled: false, // V3.7.25: 默认不勾选，用户手动选择满意的
                            status: 'done',
                            durationCost: durationMs / 1000
                        });
                    } else {
                        console.warn('[V3.7.30 Debug] 分镜表任务未找到或不是图片模式，无法回填');
                    }
                    // 清理任务映射
                    storyboardTaskMapRef.current.delete(taskId);
                } else if (fallbackStoryboard?.isImageMode) {
                    updateShot(fallbackStoryboard.nodeId, fallbackStoryboard.shotId, {
                        output_images: imageUrls,
                        output_url: imageUrls[0],
                        selectedImageIndex: 0,
                        outputEnabled: false,
                        status: 'done',
                        durationCost: durationMs / 1000
                    });
                }

                setHistory((prev) => {
                    const updated = prev.map((hItem) => {
                        if (hItem.id === taskId) {
                            const updatedItem = {
                                ...hItem,
                                status: 'completed',
                                progress: 100,
                                url: primaryUrl,
                                width: w,
                                height: h,
                                durationMs,
                                output_images: imageUrls,
                                mjImages: imageUrls.length > 1 ? imageUrls : null,
                                selectedMjImageIndex: 0
                            };

                            // 更新预览窗口（非分镜表任务）
                            if (updatedItem.sourceNodeId && !storyboardTask) {
                                setTimeout(() => {
                                    updatePreviewFromTask(taskId, primaryUrl, 'image', updatedItem.sourceNodeId, updatedItem.mjImages);
                                }, 0);
                            }
                            return updatedItem;
                        }
                        return hItem;
                    });
                    return updated;
                });
                return;
            } // Close if (type === 'image')

            if (type === 'video') {
                // V3.4.20: Explicitly define config for video generation block
                const config = getApiConfigByKey(modelId);
                const customParams = Array.isArray(config?.customParams) ? config.customParams : [];
                const providerKey = config?.provider || credentials.provider;
                const modelName = config?.modelName || '';
                const isJimengVideo = providerKey === 'jimeng'
                    || modelId.includes('jimeng')
                    || modelName.includes('jimeng')
                    || modelId.includes('dreamina')
                    || modelName.includes('dreamina');
                const isJimengSora2 = isJimengVideo && (modelId.includes('sora2') || modelName.includes('sora2'));
                const isOpenAISora = !isJimengVideo && (modelId.includes('sora') || modelName.includes('sora'));
                const isGrokVideo = providerKey === 'grok' || modelId.includes('grok') || modelName.includes('grok');
                const useProxy = !!credentials.useProxy;
                const requestTemplate = normalizeRequestTemplate(config?.requestTemplate);
                const requestOverrideEnabled = !!config?.requestOverrideEnabled;
                const requestOverridePatch = normalizeRequestOverridePatch(config?.requestOverridePatch);
                const resolveSourceProxy = (url) => getProxyPreferenceForUrl(url, useProxy);
                const applyVideoCustomParams = (payload) => {
                    const updated = applyCustomParamsToPayload(payload, customParams, customParamSelections);
                    if (config?.previewOverrideEnabled && config.previewOverridePatch) {
                        applyPreviewOverridePatch(updated, config.previewOverridePatch);
                    }
                    return updated;
                };
                // Veo 3.x 图生视频：按 /v2/videos/generations 规范发送 JSON，使用 images 数组而不是 input_image
                if (modelId.includes('veo')) {
                    const endpoint = `${baseUrl}/v2/videos/generations`;

                    // 根据文档：images 支持 url 或 base64
                    // 对于Veo接口，如果图片过大，自动缩放到合理尺寸（1920x1080等）
                    // 首尾帧：当开启“首尾帧”时，优先使用 veo_start / veo_end 两个输入点，顺序为 [首帧, 尾帧]，最多 2 张
                    const currentNodeForVeo = nodesMap.get(nodeId);
                    const supportsFirstLastFrame = !!config?.supportsFirstLastFrame;
                    const useFirstLastFrame = supportsFirstLastFrame && !!(currentNodeForVeo?.settings?.useFirstLastFrame || currentNodeForVeo?.settings?.veoFramesMode);
                    const veoStartFrame = useFirstLastFrame ? getConnectedImageForInput(nodeId, 'veo_start') : null;
                    const veoEndFrame = useFirstLastFrame ? getConnectedImageForInput(nodeId, 'veo_end') : null;
                    const veoFrameImages = [veoStartFrame, veoEndFrame].filter(Boolean);
                    const effectiveConnectedImages = (veoFrameImages.length > 0 ? veoFrameImages : connectedImages).slice(0, 2);
                    const effectiveSourceImage = (veoFrameImages.length > 0 ? veoFrameImages[0] : sourceImage);
                    let images = [];
                    if (effectiveConnectedImages && effectiveConnectedImages.length > 0) {
                        // 处理多张图片：先缩放，再转换为data URL
                        images = await Promise.all(effectiveConnectedImages
                            .filter(img => img && typeof img === 'string' && img.trim().length > 0)
                            .map(async (img) => {
                                const trimmedImg = img.trim();

                                // 如果是 http/https URL，先检查尺寸，如果太大就缩放
                                if (trimmedImg.startsWith('http://') || trimmedImg.startsWith('https://')) {
                                    // 对于URL，先尝试获取尺寸，如果太大就缩放
                                    try {
                                        const dims = await getImageDimensions(trimmedImg);
                                        if (dims.w > 1920 || dims.h > 1920) {
                                            const resized = await resizeImageForVeo(trimmedImg, 1920, 1920);
                                            return resized;
                                        }
                                        // 尺寸合适，直接使用URL
                                        return trimmedImg;
                                    } catch (e) {
                                        console.warn('Veo: 无法获取图片尺寸，尝试直接使用URL', e);
                                        return trimmedImg;
                                    }
                                }

                                // 对于 data URL、blob URL 或其他格式，统一缩放处理
                                try {
                                    // 先获取尺寸
                                    const dims = await getImageDimensions(trimmedImg);
                                    if (dims.w > 1920 || dims.h > 1920) {
                                        const resized = await resizeImageForVeo(trimmedImg, 1920, 1920);
                                        return resized;
                                    }
                                    // 尺寸合适，转换为data URL格式
                                    if (trimmedImg.startsWith('data:')) {
                                        return trimmedImg;
                                    } else if (trimmedImg.startsWith('blob:')) {
                                        const base64 = await getBase64FromUrl(trimmedImg, { useProxy: resolveSourceProxy(trimmedImg) });
                                        return `data:image/png;base64,${base64}`;
                                    } else if (trimmedImg.length > 100 && !trimmedImg.includes('://') && !trimmedImg.startsWith('data:')) {
                                        return `data:image/png;base64,${trimmedImg}`;
                                    } else {
                                        const base64 = await getBase64FromUrl(trimmedImg, { useProxy: resolveSourceProxy(trimmedImg) });
                                        return `data:image/png;base64,${base64}`;
                                    }
                                } catch (e) {
                                    console.error('Veo: Failed to process image:', e);
                                    throw new Error(`无法处理图片格式: ${trimmedImg.substring(0, 50)}...`);
                                }
                            }));
                    } else if (effectiveSourceImage) {
                        // 单张图片处理：先检查尺寸，如果太大就缩放
                        const trimmedSource = effectiveSourceImage.trim();

                        try {
                            // 先获取图片尺寸
                            const dims = await getImageDimensions(trimmedSource);

                            // 如果图片过大，先缩放
                            if (dims.w > 1920 || dims.h > 1920) {
                                const resized = await resizeImageForVeo(trimmedSource, 1920, 1920);
                                images = [resized];
                            } else {
                                // 尺寸合适，根据格式处理
                                if (trimmedSource.startsWith('http://') || trimmedSource.startsWith('https://')) {
                                    images = [trimmedSource];
                                } else if (trimmedSource.startsWith('data:')) {
                                    images = [trimmedSource];
                                } else if (trimmedSource.startsWith('blob:')) {
                                    const base64 = await getBase64FromUrl(trimmedSource, { useProxy: resolveSourceProxy(trimmedSource) });
                                    images = [`data:image/png;base64,${base64}`];
                                } else {
                                    if (trimmedSource.length > 100 && !trimmedSource.includes('://') && !trimmedSource.startsWith('data:')) {
                                        images = [`data:image/png;base64,${trimmedSource}`];
                                    } else {
                                        const base64 = await getBase64FromUrl(trimmedSource, { useProxy: resolveSourceProxy(trimmedSource) });
                                        images = [`data:image/png;base64,${base64}`];
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Veo: Failed to process source image:', e);
                            throw new Error(`无法处理图片格式: ${e.message} `);
                        }
                    }

                    // 构建 Veo 请求 payload
                    // 根据文档，images 是 required 字段，文生视频时传空数组，图生视频时传图片数据
                    // 图生视频时，确保 images 数组不为空
                    if (images.length === 0 && (effectiveConnectedImages?.length > 0 || effectiveSourceImage)) {
                        console.error('Veo: 图片处理失败，images 数组为空', { effectiveConnectedImages, effectiveSourceImage });
                        throw new Error('图片处理失败：无法获取图片数据');
                    }

                    // 验证图片数据格式：过滤掉无效数据，但不阻止请求发送
                    const validImages = images.filter((img, idx) => {
                        if (!img || typeof img !== 'string') {
                            console.warn(`Veo: 跳过无效图片（索引 ${idx}）: 不是字符串`);
                            return false;
                        }
                        if (img === 'base64_data' || img.trim() === 'base64_data') {
                            console.warn(`Veo: 跳过占位符图片（索引 ${idx}）: base64_data`);
                            return false;
                        }
                        return true;
                    });

                    if (validImages.length === 0 && (effectiveConnectedImages?.length > 0 || effectiveSourceImage)) {
                        console.error('Veo: 所有图片数据都无效', { images, effectiveConnectedImages, effectiveSourceImage });
                        throw new Error('图片数据格式错误：所有图片数据都无效');
                    }

                    // 对于 veo3.1 系列模型，确保 aspect_ratio 格式正确（只支持 '16:9' 和 '9:16'）
                    let aspectRatio = null;
                    if (ratio && ratio !== 'Auto') {
                        // 确保比例格式符合 API 要求
                        if (ratio === '16:9' || ratio === '9:16') {
                            aspectRatio = ratio;
                        } else {
                            // 对于其他比例，根据实际宽高计算最接近的比例
                            const aspectRatioValue = w / h;
                            if (Math.abs(aspectRatioValue - 16 / 9) < Math.abs(aspectRatioValue - 9 / 16)) {
                                aspectRatio = '16:9';
                            } else {
                                aspectRatio = '9:16';
                            }
                        }
                    }

                    const veoPayload = {
                        model: config?.modelName || 'veo3.1',
                        prompt,
                        enhance_prompt: false,
                        images: validImages.length > 0 ? validImages : [], // 使用验证后的图片数组
                        // 按接口说明：不传 aspect_ratio 时自动根据参考图匹配；只有非 Auto 时才显式传
                        ...(aspectRatio ? { aspect_ratio: aspectRatio } : {})
                    };
                    applyVideoCustomParams(veoPayload);

                    // 详细调试日志
                    console.log('Veo: 准备发送请求', {
                        endpoint,
                        model: veoPayload.model,
                        prompt: veoPayload.prompt?.substring(0, 50) + '...',
                        imagesCount: veoPayload.images.length,
                        firstImageType: veoPayload.images[0] ?
                            (veoPayload.images[0].startsWith('http') ? 'HTTP URL' :
                                veoPayload.images[0].startsWith('data:') ? 'Data URL' :
                                    'Unknown') : 'empty',
                        firstImagePreview: veoPayload.images[0] ?
                            (veoPayload.images[0].startsWith('http') ?
                                veoPayload.images[0].substring(0, 80) :
                                veoPayload.images[0].substring(0, 100)) : 'empty',
                        aspect_ratio: veoPayload.aspect_ratio,
                        payloadSize: JSON.stringify(veoPayload).length
                    });

                    try {
                        const resp = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                Authorization: `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(veoPayload)
                        });

                        const text = await resp.text();

                        if (!resp.ok) {
                            console.error('Veo: 请求失败', { status: resp.status, text });
                            throw new Error(text || `Veo error: ${resp.status} `);
                        }

                        const data = JSON.parse(text);
                        const jobId = data?.data?.id || data?.id || data?.task_id || data?.data?.task_id;

                        if (!jobId) {
                            console.error('Veo: 未找到 JobId', data);
                            throw new Error('Veo No JobId');
                        }

                        setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'generating', progress: 10 } : h));
                        pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h);
                        return;
                    } catch (error) {
                        console.error('Veo: 请求发送失败', error);
                        setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'failed', errorMsg: error.message || '请求发送失败' } : h));
                        throw error;
                    }
                }

                let endpoint = '';
                let body;
                const headers = { Authorization: `Bearer ${apiKey}` };
                // 统一将时长转为纯数字秒，避免后端期望 int 时收到字符串
                const durationValueNum = (() => {
                    if (duration === null || duration === undefined) return 8;
                    const cleaned = String(duration).trim().replace(/[^\d]/g, '');
                    const parsed = parseInt(cleaned, 10);
                    return Number.isFinite(parsed) && parsed > 0 ? parsed : 8;
                })();

                // --- Grok-3 Video Logic (Pure JSON Strategy to fix Int type error, align spec /v2/videos/generations) ---
                if (isGrokVideo) {
                    const endpoint = `${baseUrl}/v2/videos/generations`;
                    // 1. 强制转换为整数 (解决 Go 后端类型错误)
                    const durationInt = parseInt(duration, 10);
                    const aspectRatioStr = ratio && ratio !== 'Auto' ? ratio : '3:2'; // 按官方枚举优先 3:2/2:3/1:1
                    const resolutionStr = (resolution && resolution !== 'Auto') ? resolution : '1080P'; // 官方支持 720P/1080P


                    // 2. 准备基础 Payload
                    const payload = {
                        model: config?.modelName || 'grok-video-3',
                        prompt: prompt,
                        ratio: aspectRatioStr,
                        resolution: resolutionStr
                    };
                    if (Number.isFinite(durationInt) && durationInt > 0) {
                        payload.duration = durationInt;
                    }

                    // 3. 处理图片：转为 Base64 字符串
                    if (sourceImage) {
                        try {
                            let base64Data = '';

                            if (sourceImage.startsWith('data:')) {
                                base64Data = sourceImage; // 已经是 Base64
                            } else {
                                // 下载 blob 或 url 并转换
                                const blob = await getBlobFromUrl(sourceImage, { useProxy: resolveSourceProxy(sourceImage) });
                                base64Data = await new Promise((resolve, reject) => {
                                    const reader = new FileReader();
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(blob);
                                });
                            }

                            // 将完整的 data URI 放入 images 数组（官方字段）
                            payload.images = [base64Data];
                        } catch (e) {
                            console.error('Grok Image Conversion Failed:', e);
                            alert(t('图片处理失败，请检查图片链接或跨域设置'));
                            return;
                        }
                    }

                    // 4. 发送纯 JSON 请求
                    applyVideoCustomParams(payload);
                    const resp = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json' // 必须是 JSON
                        },
                        body: JSON.stringify(payload)
                    });

                    const text = await resp.text();

                    // 5. 错误处理
                    if (!resp.ok) {
                        console.error('[Grok API Error]', text);
                        throw new Error(text || `Grok API error: ${resp.status} `);
                    }

                    // 6. 解析响应
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (e) {
                        throw new Error('API 返回了非 JSON 格式数据');
                    }

                    // 兼容多种 ID 返回格式
                    const jobId = data?.data?.id || data?.id || data?.task_id;
                    if (!jobId) {
                        console.error('Grok No Task ID:', data);
                        throw new Error('API 未返回 Task ID');
                    }

                    // 7. 进入轮询 (Grok 兼容 Sora 查询接口)
                    setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'generating', progress: 10, remoteTaskId: jobId } : h));
                    pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId);

                    return; // 阻断后续代码执行
                }

                // Generic Video Logic (Sora/Kling/etc) - Force Multipart for Image Input with correct field names
                if (isJimengVideo) {
                    endpoint = `${baseUrl}/v1/videos/generations`;
                    const allowedDurations = Array.isArray(config?.durations)
                        ? config.durations.map((d) => normalizeDurationValue(d, durationValueNum)).filter((d) => Number.isFinite(d))
                        : (isJimengSora2 ? [4, 8, 12] : [5, 10]);
                    const baseDuration = normalizeJimengVideoDuration(durationValueNum, allowedDurations);
                    const ratioOptions = isJimengSora2
                        ? { defaultRatio: 'auto', allowedRatios: ['16:9', '9:16', 'auto'] }
                        : { defaultRatio: '1:1' };
                    const jimengRatio = normalizeJimengVideoRatio(ratio, ratioOptions);
                    const modelKey = config?.modelName || modelId || 'jimeng-video-3.0';
                    const supportsResolution = supportsJimengVideoResolution(modelKey);
                    const jimengResolution = supportsResolution ? normalizeJimengVideoResolution(resolution) : '';

                    const supportsFirstLastFrame = !!config?.supportsFirstLastFrame;
                    const useFirstLastFrame = supportsFirstLastFrame && !!(node?.settings?.useFirstLastFrame || node?.settings?.veoFramesMode);
                    const startFrame = useFirstLastFrame ? getConnectedImageForInput(nodeId, 'veo_start') : null;
                    const endFrame = useFirstLastFrame ? getConnectedImageForInput(nodeId, 'veo_end') : null;
                    const frameImages = [startFrame, endFrame].filter(Boolean);
                    const fallbackImages = connectedImages.filter(Boolean);
                    const baseImages = frameImages.length > 0 ? frameImages : fallbackImages;
                    const jimengImages = baseImages.slice(0, isJimengSora2 ? 1 : 2);
                    if (!prompt || !prompt.trim()) throw new Error('提示词不能为空');

                    if (jimengImages.length > 0) {
                        const formData = new FormData();
                        formData.append('model', modelKey);
                        formData.append('prompt', prompt);
                        formData.append('duration', String(baseDuration));
                        formData.append('ratio', jimengRatio);
                        if (supportsResolution && jimengResolution) formData.append('resolution', jimengResolution);

                        const jimengBlobs = await Promise.all(jimengImages.map(async (img) => {
                            const blob = await getBlobFromUrl(img, { useProxy: resolveSourceProxy(img) });
                            return await coerceImageBlobForJimeng(blob);
                        }));
                        if (jimengBlobs[0]) formData.append('image_file_1', jimengBlobs[0], 'first.png');
                        if (jimengBlobs[1]) formData.append('image_file_2', jimengBlobs[1], 'last.png');

                        applyVideoCustomParams(formData);
                        if (isJimengSora2) {
                            formData.delete('image_file_2');
                            formData.delete('image_file_3');
                        }

                        const durationOverride = normalizeJimengVideoDuration(formData.get('duration'), allowedDurations);
                        if (durationOverride) formData.set('duration', String(durationOverride));

                        const ratioOverride = normalizeJimengVideoRatio(formData.get('ratio') || jimengRatio || ratioOptions.defaultRatio, ratioOptions);
                        if (isJimengSora2 && ratioOverride === 'auto') {
                            formData.delete('ratio');
                        } else {
                            formData.set('ratio', ratioOverride);
                        }

                        const resolutionOverride = supportsResolution
                            ? normalizeJimengVideoResolution(formData.get('resolution') || jimengResolution)
                            : '';
                        if (supportsResolution && resolutionOverride) {
                            formData.set('resolution', resolutionOverride);
                        } else {
                            formData.delete('resolution');
                        }
                        console.log('[Jimeng Video] request', {
                            model: modelKey,
                            mode: 'image',
                            images: jimengImages.length,
                            duration: formData.get('duration'),
                            ratio: formData.get('ratio') || 'auto',
                            resolution: formData.get('resolution') || 'n/a'
                        });
                        body = formData;
                    } else {
                        headers['Content-Type'] = 'application/json';
                        const payload = {
                            model: modelKey,
                            prompt: prompt,
                            duration: baseDuration
                        };
                        if (!(isJimengSora2 && jimengRatio === 'auto')) {
                            payload.ratio = jimengRatio;
                        }
                        if (supportsResolution && jimengResolution) payload.resolution = jimengResolution;
                        applyVideoCustomParams(payload);

                        const durationOverride = normalizeJimengVideoDuration(payload.duration, allowedDurations);
                        if (durationOverride) payload.duration = durationOverride;

                        const ratioOverride = normalizeJimengVideoRatio(payload.ratio || jimengRatio || ratioOptions.defaultRatio, ratioOptions);
                        if (isJimengSora2 && ratioOverride === 'auto') {
                            delete payload.ratio;
                        } else {
                            payload.ratio = ratioOverride;
                        }

                        const resolutionOverride = supportsResolution
                            ? normalizeJimengVideoResolution(payload.resolution || jimengResolution)
                            : '';
                        if (supportsResolution && resolutionOverride) {
                            payload.resolution = resolutionOverride;
                        } else {
                            delete payload.resolution;
                        }
                        console.log('[Jimeng Video] request', {
                            model: modelKey,
                            mode: 'text',
                            images: 0,
                            duration: payload.duration,
                            ratio: payload.ratio || 'auto',
                            resolution: payload.resolution || 'n/a'
                        });
                        body = JSON.stringify(payload);
                    }
                } else if (sourceImage) {
                    const formData = new FormData();
                    const blob = await getBlobFromUrl(sourceImage, { useProxy: resolveSourceProxy(sourceImage) });

                    if (isOpenAISora) {
                        endpoint = `${baseUrl}/v1/videos/generations`;
                        // 发送前移除大括号：将 @{username} 转换为 @username
                        let finalPrompt = prompt.replace(/@\{([^\}]+)\}/g, (match, username) => {
                            return `@${username} `;
                        });
                        formData.append('model', config?.modelName || 'sora-2');
                        formData.append('prompt', finalPrompt);
                        formData.append('seconds', duration);
                        formData.append('size', sizeStr);
                        // Sora 2 HD 模式支持
                        if (config?.supportsHD && (options.isHD || node?.settings?.isHD)) {
                            formData.append('quality', 'hd');
                        }
                        // Sora sometimes uses input_reference or image, append both for safety
                        formData.append('input_reference', blob, 'ref.png');
                        formData.append('image', blob, 'ref.png');
                    } else if (isGrokVideo) {
                        endpoint = `${baseUrl}/v1/videos/generations`;
                        formData.append('model', config?.modelName || 'grok-video-3');
                        formData.append('prompt', prompt);
                        formData.append('aspect_ratio', ratio);
                        formData.append('duration', durationValueNum);
                        formData.append('image', blob, 'input.png');
                    } else {
                        endpoint = `${baseUrl}/v1/videos/generations`;
                        formData.append('model', config?.modelName);
                        formData.append('prompt', prompt);
                        formData.append('image', blob, 'input.png');
                        formData.append('size', sizeStr); // Ensure size is passed for generic
                    }
                    applyVideoCustomParams(formData);
                    body = formData;
                } else {
                    headers['Content-Type'] = 'application/json';
                    if (isOpenAISora) {
                        delete headers['Content-Type'];
                        endpoint = `${baseUrl}/v1/videos/generations`;
                        const formData = new FormData();
                        // 发送前移除大括号：将 @{username} 转换为 @username
                        let finalPrompt = prompt.replace(/@\{([^\}]+)\}/g, (match, username) => {
                            return `@${username} `;
                        });
                        formData.append('model', config?.modelName || 'sora-2');
                        formData.append('prompt', finalPrompt);
                        formData.append('seconds', duration);
                        formData.append('size', sizeStr);
                        // Sora 2 HD 模式支持
                        if (config?.supportsHD && (options.isHD || node?.settings?.isHD)) {
                            formData.append('quality', 'hd');
                        }
                        applyVideoCustomParams(formData);
                        body = formData;
                    } else if (isGrokVideo) {
                        endpoint = `${baseUrl}/v1/videos/generations`;
                        const payload = {
                            model: config?.modelName || 'grok-video-3',
                            prompt,
                            aspect_ratio: ratio,
                            duration: durationValueNum
                        };
                        applyVideoCustomParams(payload);
                        body = JSON.stringify(payload);
                    } else {
                        endpoint = `${baseUrl}/v1/videos/generations`;
                        const payload = { model: config?.modelName, prompt, resolution: sizeStr };
                        applyVideoCustomParams(payload);
                        body = JSON.stringify(payload);
                    }
                }

                let requestOverride = null;
                if (requestTemplate?.enabled) {
                    const buildRequestTemplateVars = async () => {
                        const vars = {
                            modelName: config?.modelName || modelId,
                            prompt: prompt || '',
                            ratio,
                            resolution,
                            size: sizeStr,
                            duration: durationValueNum,
                            durationNumber: durationValueNum,
                            seed: node?.settings?.seed,
                            provider: {
                                key: apiKey,
                                baseUrl,
                                id: credentials.provider,
                                useProxy
                            }
                        };
                        if (isJimengVideo) {
                            const allowedDurations = Array.isArray(config?.durations)
                                ? config.durations.map((d) => normalizeDurationValue(d, durationValueNum)).filter((d) => Number.isFinite(d))
                                : (isJimengSora2 ? [4, 8, 12] : [5, 10]);
                            const ratioOptions = isJimengSora2
                                ? { defaultRatio: 'auto', allowedRatios: ['16:9', '9:16', 'auto'] }
                                : { defaultRatio: '1:1' };
                            const jimengDuration = normalizeJimengVideoDuration(durationValueNum, allowedDurations);
                            const rawJimengRatio = normalizeJimengVideoRatio(ratio, ratioOptions);
                            const jimengRatio = (isJimengSora2 && rawJimengRatio === 'auto') ? undefined : rawJimengRatio;
                            const supportsResolution = supportsJimengVideoResolution(config?.modelName || modelId || '');
                            const rawResolution = supportsResolution ? normalizeJimengVideoResolution(resolution) : '';
                            const jimengResolution = supportsResolution && rawResolution ? rawResolution : undefined;
                            vars.jimengDuration = jimengDuration;
                            vars.jimengRatio = jimengRatio;
                            vars.jimengResolution = jimengResolution;
                        }
                        const inputImages = connectedImages.length > 0
                            ? connectedImages
                            : (sourceImage ? [sourceImage] : []);
                        const imageSources = inputImages.filter(Boolean);
                        const supportsFirstLastFrame = !!config?.supportsFirstLastFrame;
                        const useFirstLastFrame = supportsFirstLastFrame && !!(node?.settings?.useFirstLastFrame || node?.settings?.veoFramesMode);
                        const startFrame = useFirstLastFrame ? getConnectedImageForInput(nodeId, 'veo_start') : null;
                        const endFrame = useFirstLastFrame ? getConnectedImageForInput(nodeId, 'veo_end') : null;
                        const firstFrameSource = startFrame || imageSources[0] || null;
                        const lastFrameSource = endFrame || imageSources[1] || null;
                        if (imageSources.length > 0) {
                            vars.imageUrl = imageSources[0];
                            vars.imageUrls = imageSources;
                            vars.imagesUrl = imageSources;
                            vars.imagesUrls = imageSources;
                        }
                        vars.firstFrameUrl = firstFrameSource;
                        vars.lastFrameUrl = lastFrameSource;
                        const templateText = JSON.stringify(requestTemplate || {});
                        const needsBlob = (requestTemplate?.bodyType || '').toLowerCase() === 'multipart'
                            || /:blob\s*}}/.test(templateText);
                        const needsDataUrl = /:blob\s*}}/.test(templateText);
                        if (needsBlob && imageSources.length > 0) {
                            const blobMap = new Map();
                            const blobs = await Promise.all(imageSources.map(async (url) => {
                                const blob = await getBlobFromUrl(url, { useProxy: resolveSourceProxy(url) });
                                const normalized = isJimengVideo ? await coerceImageBlobForJimeng(blob) : blob;
                                blobMap.set(url, normalized);
                                return normalized;
                            }));
                            const ensureBlob = async (sourceUrl) => {
                                if (!sourceUrl) return null;
                                if (blobMap.has(sourceUrl)) return blobMap.get(sourceUrl);
                                const blob = await getBlobFromUrl(sourceUrl, { useProxy: resolveSourceProxy(sourceUrl) });
                                const normalized = isJimengVideo ? await coerceImageBlobForJimeng(blob) : blob;
                                blobMap.set(sourceUrl, normalized);
                                return normalized;
                            };
                            vars.imageBlob = blobs[0];
                            vars.imageBlobs = blobs;
                            vars.imagesBlob = blobs;
                            vars.firstFrameBlob = await ensureBlob(firstFrameSource);
                            vars.lastFrameBlob = await ensureBlob(lastFrameSource);
                        }
                        if (needsDataUrl && imageSources.length > 0) {
                            const dataUrlMap = new Map();
                            const dataUrls = await Promise.all(imageSources.map(async (url) => {
                                if (!url) return '';
                                if (url.startsWith('data:')) return url;
                                const base64 = await getBase64FromUrl(url, { useProxy: resolveSourceProxy(url) });
                                const ext = getUrlExt(url, '.png');
                                const mime = ext === '.jpg' || ext === '.jpeg'
                                    ? 'image/jpeg'
                                    : ext === '.webp'
                                        ? 'image/webp'
                                        : 'image/png';
                                const dataUrl = `data:${mime};base64,${base64}`;
                                dataUrlMap.set(url, dataUrl);
                                return dataUrl;
                            }));
                            vars.imageDataUrl = dataUrls[0];
                            vars.imageDataURL = dataUrls[0];
                            vars.imageDataUrls = dataUrls;
                            vars.imagesDataUrl = dataUrls;
                            vars.imagesDataURL = dataUrls;
                            const ensureDataUrl = async (sourceUrl) => {
                                if (!sourceUrl) return '';
                                if (dataUrlMap.has(sourceUrl)) return dataUrlMap.get(sourceUrl);
                                if (sourceUrl.startsWith('data:')) return sourceUrl;
                                const base64 = await getBase64FromUrl(sourceUrl, { useProxy: resolveSourceProxy(sourceUrl) });
                                const ext = getUrlExt(sourceUrl, '.png');
                                const mime = ext === '.jpg' || ext === '.jpeg'
                                    ? 'image/jpeg'
                                    : ext === '.webp'
                                        ? 'image/webp'
                                        : 'image/png';
                                const dataUrl = `data:${mime};base64,${base64}`;
                                dataUrlMap.set(sourceUrl, dataUrl);
                                return dataUrl;
                            };
                            vars.firstFrameDataUrl = await ensureDataUrl(firstFrameSource);
                            vars.firstFrameDataURL = vars.firstFrameDataUrl;
                            vars.lastFrameDataUrl = await ensureDataUrl(lastFrameSource);
                            vars.lastFrameDataURL = vars.lastFrameDataUrl;
                        }
                        if (customParams.length > 0 && customParamSelections) {
                            customParams.forEach((param) => {
                                const name = String(param?.name || '').trim();
                                if (!name) return;
                                const value = getCustomParamSelection(param, customParamSelections);
                                if (value === '' || value === undefined || value === null) return;
                                vars[name] = value;
                            });
                        }
                        return vars;
                    };
                    try {
                        const templateVars = await buildRequestTemplateVars();
                        const templateRequest = buildRequestFromTemplate(requestTemplate, templateVars, { bodyType: requestTemplate.bodyType });
                        if (templateRequest && templateRequest.url) {
                            requestOverride = requestOverrideEnabled && requestOverridePatch
                                ? applyRequestOverridePatch({ ...templateRequest }, requestOverridePatch)
                                : templateRequest;
                        }
                    } catch (e) {
                        console.warn('[RequestTemplate] 构建失败，已回退默认请求:', e);
                        requestOverride = null;
                    }
                }

                const overrideUrl = requestOverride?.url || endpoint;
                const overrideMethod = (requestOverride?.method || 'POST').toString().toUpperCase();
                let overrideBodyType = (requestOverride?.bodyType || (body instanceof FormData ? 'multipart' : 'json')).toString().toLowerCase();
                const overrideHeaders = requestOverride?.headers && typeof requestOverride.headers === 'object'
                    ? { ...requestOverride.headers }
                    : { ...headers };
                let requestBody = requestOverride && requestOverride.body !== undefined ? requestOverride.body : body;
                if (requestBody instanceof FormData) {
                    overrideBodyType = 'multipart';
                }

                if (apiKey && !overrideHeaders.Authorization && !overrideHeaders.authorization) {
                    overrideHeaders.Authorization = `Bearer ${apiKey}`;
                }
                if (overrideBodyType === 'json' && !overrideHeaders['Content-Type'] && !overrideHeaders['content-type']) {
                    overrideHeaders['Content-Type'] = 'application/json';
                }
                if (overrideBodyType === 'multipart') {
                    requestBody = coerceFormDataFromObject(requestBody);
                    delete overrideHeaders['Content-Type'];
                    delete overrideHeaders['content-type'];
                } else if (overrideBodyType === 'raw') {
                    if (typeof requestBody !== 'string') {
                        requestBody = JSON.stringify(requestBody ?? {});
                    }
                } else if (overrideBodyType === 'json') {
                    if (!(requestBody instanceof FormData) && typeof requestBody !== 'string') {
                        requestBody = JSON.stringify(requestBody ?? {});
                    }
                }

                let finalEndpoint = overrideUrl;
                if (!finalEndpoint.startsWith('http')) {
                    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
                    finalEndpoint = `${cleanBaseUrl}${finalEndpoint.startsWith('/') ? finalEndpoint : '/' + finalEndpoint}`;
                }

                const resp = await fetch(finalEndpoint, { method: overrideMethod, headers: overrideHeaders, body: requestBody });
                const text = await resp.text();
                if (!resp.ok) throw new Error(text || `Video API error: ${resp.status} `);
                const data = JSON.parse(text);

                // V3.7.22: 使用精确匹配提取错误码，避免误判
                const errorCode = data?.code || data?.data?.code;
                const errorMessage = data?.message || data?.data?.message || '';

                // 从消息中提取真实错误码 (格式: "错误码: 1006")
                let realErrorCode = errorCode;
                const errorCodeMatch = errorMessage.match(/错误码[：:]\s*(\d+)/);
                if (errorCodeMatch) {
                    realErrorCode = parseInt(errorCodeMatch[1], 10);
                }

                // V3.7.22: 参数错误 (1000) - 立即停止，不重试
                const is1000Error = realErrorCode === 1000;
                if (is1000Error) {
                    console.error(`⛔ [Video API] 参数错误 (1000): ${errorMessage}`);
                    throw new Error(`视频参数错误: ${errorMessage || 'Invalid parameter'} (错误码 1000)`);
                }

                // 使用精确匹配检测 1006 (积分耗尽)
                const is1006Error = realErrorCode === 1006;
                const isLoginError = errorCode === -2001 && errorMessage.includes('34010105');

                // V3.5.31: Handle Jimeng API generation failure (code -2008, status 30, error 2060)
                const isGenerationError = errorCode === -2008 || errorMessage.includes('2060');
                if (isGenerationError) {
                    // 提取更详细的错误信息
                    let detailedMsg = '❌ 视频生成失败';
                    if (errorMessage.includes('状态码: 30')) {
                        detailedMsg += '\\n\\n⚠️ 可能原因：\\n• 图片格式不支持\\n• 图片分辨率过低或过高\\n• 服务端繁忙，请稍后重试\\n• 内容审核未通过';
                    }
                    if (errorMessage.includes('2060')) {
                        detailedMsg += '\\n\\n错误码: 2060 (内部处理失败)';
                    }
                    throw new Error(detailedMsg);
                }

                if (is1006Error || isLoginError) {
                    const reason = is1006Error ? '积分耗尽 (1006)' : '登录失效 (34010105)';
                    console.warn(`🚫 [Video API] Key ending in ...${apiKey.slice(-4)} failed: ${reason}. Adding to blacklist.`);
                    addToBlacklist(apiKey, reason);
                    // Throw with special marker for retry
                    const retryError = new Error(`RETRY_WITH_NEW_KEY: ${errorMessage}`);
                    retryError.shouldRetry = true;
                    throw retryError;
                }

                // V3.4.26: Support data.data array format (e.g., [{"url": "..."}])
                const immediateUrl = data?.video_url || data?.url || data?.data?.video_url || data?.data?.url || (Array.isArray(data?.data) && data.data[0]?.url);
                if (immediateUrl) {
                    const endTime = Date.now();
                    // 在更新 history 之前，先获取 sourceNodeId
                    const historyItem = historyMap.get(taskId);
                    const sourceNodeId = historyItem?.sourceNodeId;
                    const durationMs = endTime - (historyItem?.startTime || endTime);
                    // 使用 setHistory 的回调来确保获取最新的 historyItem
                    setHistory((prev) => {
                        const updated = prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'completed', progress: 100, url: immediateUrl, width: w, height: h, durationMs } : hItem);
                        // 检查是否是分镜表的任务，如果是则回填到分镜表
                        const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                        if (storyboardTask) {
                            updateShot(storyboardTask.nodeId, storyboardTask.shotId, {
                                video_url: immediateUrl,
                                status: 'done',
                                durationCost: durationMs / 1000 // Save duration in seconds
                            });
                            // 清理任务映射
                            storyboardTaskMapRef.current.delete(taskId);
                        } else {
                            // 更新预览窗口（非分镜表任务）
                            const updatedItem = updated.find(h => h.id === taskId);
                            if (updatedItem?.sourceNodeId) {
                                setTimeout(() => {
                                    updatePreviewFromTask(taskId, immediateUrl, 'video', updatedItem.sourceNodeId);
                                }, 0);
                            } else {
                                console.warn('[Tapnow] 视频立即返回: 未找到 sourceNodeId', { taskId, updatedItem });
                            }
                        }
                        return updated;
                    });
                    return;
                }
                const jobId = data?.data?.id || data?.id || data?.task_id || data?.data?.task_id || data?.job_id || data?.data?.job_id;
                if (!jobId) throw new Error(`No Task/Job ID returned. Response: ${JSON.stringify(data).substring(0, 200)}`);

                if (modelId.includes('veo')) pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h);
                else pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId);
            } // Close if (type === 'video')
        } catch (err) {
            // V3.5.12: If error has shouldRetry flag, recursively retry with new key
            if (err.shouldRetry) {
                // V3.5.31: Pass _isRetry and _existingTaskId to prevent duplicate history items
                return startGeneration(prompt, type, sourceImages, nodeId, { ...options, _isRetry: true, _existingTaskId: taskId });
            }

            console.error('[CONSOLE_ERROR]', err);
            // V3.5.12: Calculate duration for timer stop
            const endTime = Date.now();
            const currentItem = history.find(h => h.id === taskId);
            const durationMs = currentItem?.startTime ? endTime - currentItem.startTime : 0;

            // 尝试解析错误信息，提取更友好的错误消息
            let errorMsg = err?.message || '生成失败';
            try {
                // 如果错误信息是 JSON 字符串，尝试解析
                if (typeof errorMsg === 'string' && errorMsg.trim().startsWith('{')) {
                    const errorData = JSON.parse(errorMsg);
                    if (errorData?.error?.message) {
                        errorMsg = errorData.error.message;
                    } else if (errorData?.error) {
                        errorMsg = typeof errorData.error === 'string' ? errorData.error : JSON.stringify(errorData.error);
                    } else if (errorData?.message) {
                        errorMsg = errorData.message;
                    }
                }

                // 检查是否是后端服务模块缺失错误，优化错误信息显示
                if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                    // 检查是否已经包含优化后的错误信息，避免重复
                    if (!errorMsg.includes('即梦API代理服务缺少必要模块') && !errorMsg.includes('❌')) {
                        // 提取原始错误信息（去掉可能的重复前缀）
                        const originalError = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                        errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalError} \n\n🔧 解决方案：\n1.停止jimeng - api.exe并重新下载最新版本\n2.或使用Docker：docker pull ghcr.io / iptag / jimeng - api: latest`;
                    } else if (!errorMsg.includes('🔧')) {
                        // 如果已经有基本错误信息但没有解决方案，添加解决方案
                        errorMsg = errorMsg + '\n\n🔧 解决方案：\n1. 停止jimeng-api.exe并重新下载最新版本\n2. 或使用Docker：docker pull ghcr.io/iptag/jimeng-api:latest';
                    }
                }
            } catch (e) {
                // 如果解析失败，使用原始错误信息
                // 但仍然检查是否是模块缺失错误
                if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                    // 检查是否已经包含优化后的错误信息
                    if (!errorMsg.includes('即梦API代理服务缺少必要模块') && !errorMsg.includes('❌')) {
                        errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n🔧 解决方案：\n1.停止jimeng - api.exe并重新下载最新版本\n2.或使用Docker：docker pull ghcr.io / iptag / jimeng - api: latest`;
                    }
                }
            }
            // V3.5.12: Include durationMs to stop timer when failed
            setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg, durationMs } : hItem));
        }
    };

    const handleToggleTheme = () => {
        setTheme((prev) => {
            if (prev === 'dark') return 'light';
            if (prev === 'light') return 'solarized';
            return 'dark';
        });
    };

    const getDataUrlFromUrl = async (url, options = {}) => {
        if (!url) return url;
        if (url.startsWith('data:')) return url;
        const cachedUrl = localCacheActive
            ? (historyLocalCacheMap.get(url)
                || (cachedHistoryUrlRef.current.has(url) ? cachedHistoryUrlRef.current.get(url) : null))
            : null;
        const resolvedUrl = cachedUrl || url;
        const useProxy = getProxyPreferenceForUrl(resolvedUrl, options.useProxy === true);
        const blob = await getBlobFromUrl(resolvedUrl, { useProxy });
        return await blobToDataURL(blob);
    };

    // 功能1：批量下载选中的图片/视频节点
    const handleBatchDownload = async () => {
        // 使用ref获取最新的状态，避免闭包问题
        const currentNodes = nodesRef.current;
        const currentSelectedId = selectedNodeIdRef.current;
        const currentSelectedIds = selectedNodeIdsRef.current;

        const selectedNodes = currentNodes.filter(node =>
            (currentSelectedId === node.id || (currentSelectedIds && currentSelectedIds.has(node.id))) &&
            (node.type === 'input-image' || node.type === 'video-input' || node.type === 'preview') &&
            node.content
        );

        if (selectedNodes.length === 0) {
            alert(t('请先选择要下载的图片或视频节点'));
            return;
        }

        for (const node of selectedNodes) {
            try {
                const url = node.content;
                // 检查URL是否有效
                if (!url || (typeof url !== 'string' && !url.startsWith('data:'))) {
                    console.warn(`节点 ${node.id} 的内容URL无效: `, url);
                    continue;
                }
                const useProxy = getProxyPreferenceForUrl(url, false);
                const blob = await getBlobFromUrl(url, { useProxy });
                const blobUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = blobUrl;

                // 判断文件扩展名：对于预览窗口，根据previewType判断；对于其他节点，根据URL或节点类型判断
                let extension = '.png';
                if (node.type === 'preview') {
                    // 预览窗口：根据previewType判断
                    if (node.previewType === 'video') {
                        extension = '.mp4';
                    } else {
                        extension = isVideoUrl(url) ? '.mp4' : '.png';
                    }
                } else if (node.type === 'video-input') {
                    extension = '.mp4';
                } else {
                    extension = isVideoUrl(url) ? '.mp4' : '.png';
                }

                const filename = `${node.id}${extension} `;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(blobUrl);
                // 添加小延迟避免浏览器阻止多个下载
                await new Promise(resolve => setTimeout(resolve, 100));
            } catch (error) {
                console.error(`下载节点 ${node.id} 失败: `, error);
                // 不中断其他节点的下载，继续处理下一个
            }
        }
    };

    // 获取东八区时间戳（用于项目数据）
    const getCSTTimestamp = () => {
        const now = new Date();
        // 获取UTC时间并加上8小时（东八区）
        const cstTime = new Date(now.getTime() + (8 * 60 * 60 * 1000));
        return cstTime.toISOString();
    };

    // 获取东八区时间戳（用于文件名）
    const getCSTFilenameTimestamp = () => {
        const now = new Date();
        const cstTime = new Date(now.getTime() + (8 * 60 * 60 * 1000));
        const year = cstTime.getUTCFullYear();
        const month = String(cstTime.getUTCMonth() + 1).padStart(2, '0');
        const day = String(cstTime.getUTCDate()).padStart(2, '0');
        const hours = String(cstTime.getUTCHours()).padStart(2, '0');
        const minutes = String(cstTime.getUTCMinutes()).padStart(2, '0');
        const seconds = String(cstTime.getUTCSeconds()).padStart(2, '0');
        return `${year} -${month} -${day}T${hours} -${minutes} -${seconds} `;
    };

    const isLikelyAssetUrl = (value) => {
        if (!value || typeof value !== 'string') return false;
        if (value.startsWith('data:image/') || value.startsWith('data:video/')) return true;
        if (value.startsWith('blob:')) return true;
        return /\.(png|jpg|jpeg|webp|gif|mp4|webm|mov)(\?|$)/i.test(value);
    };
    const collectAssetUrlsFromObject = (obj, collector) => {
        if (!obj) return;
        if (typeof obj === 'string') {
            if (isLikelyAssetUrl(obj)) collector.add(obj);
            return;
        }
        if (Array.isArray(obj)) {
            obj.forEach((item) => collectAssetUrlsFromObject(item, collector));
            return;
        }
        if (typeof obj === 'object') {
            Object.values(obj).forEach((val) => collectAssetUrlsFromObject(val, collector));
        }
    };
    const replaceAssetUrlsInObject = (obj, assetMap) => {
        if (!obj) return obj;
        if (typeof obj === 'string') {
            const mapped = assetMap.get(obj);
            return mapped ? `asset://${mapped}` : obj;
        }
        if (Array.isArray(obj)) {
            return obj.map((item) => replaceAssetUrlsInObject(item, assetMap));
        }
        if (typeof obj === 'object') {
            const next = {};
            Object.entries(obj).forEach(([key, val]) => {
                next[key] = replaceAssetUrlsInObject(val, assetMap);
            });
            return next;
        }
        return obj;
    };

    const saveProjectAsBundle = async (projectData, options = {}) => {
        const zip = new JSZip();
        const assetMap = new Map();
        const assetManifest = {};
        const assetFolder = 'assets';
        const progress = typeof options.onProgress === 'function' ? options.onProgress : null;
        const historyItems = Array.isArray(options.historyItems) ? options.historyItems : history;
        const assetCandidates = new Set();
        const trackCandidate = (url) => {
            if (!url || typeof url !== 'string') return;
            assetCandidates.add(url);
        };
        historyItems.forEach((item) => {
            if (!item) return;
            if (Array.isArray(item.mjImages)) item.mjImages.forEach(trackCandidate);
            if (Array.isArray(item.output_images)) item.output_images.forEach(trackCandidate);
            [item.url, item.originalUrl, item.mjOriginalUrl, item.thumbnailUrl, item.localCacheUrl].forEach(trackCandidate);
            if (item.localCacheMap) {
                Object.keys(item.localCacheMap).forEach(trackCandidate);
            }
        });
        collectAssetUrlsFromObject(nodes, assetCandidates);
        collectAssetUrlsFromObject(characterLibrary, assetCandidates);
        collectAssetUrlsFromObject(chatSessions, assetCandidates);
        const totalAssets = Math.max(assetCandidates.size, 1);
        let processedCount = 0;
        const processedUrls = new Set();
        const reportProgress = () => {
            if (!progress) return;
            progress({ current: processedCount, total: totalAssets, filename: options.filename || '' });
        };
        reportProgress();
        let assetIndex = 0;
        const addAsset = async (sourceUrl, resolvedUrl, meta = {}) => {
            if (!sourceUrl || assetMap.has(sourceUrl) || processedUrls.has(sourceUrl)) return;
            processedUrls.add(sourceUrl);
            processedCount = processedUrls.size;
            reportProgress();
            const fetchUrl = resolvedUrl || sourceUrl;
            try {
                let blob;
                if (fetchUrl.startsWith('data:')) {
                    blob = dataUrlToBlob(fetchUrl);
                } else {
                    const { blob: fetched } = await fetchCacheSource(fetchUrl, {
                        useProxy: meta.useProxy === true,
                        preferLocal: true
                    });
                    blob = fetched;
                }
                if (!blob || blob.size === 0) return;
                const extFromUrl = getUrlExt(fetchUrl, '');
                const extFromData = fetchUrl.startsWith('data:') ? getDataUrlExt(fetchUrl, '') : '';
                const ext = (extFromData || extFromUrl || (blob.type ? `.${blob.type.split('/')[1]}` : '')) || (meta.type === 'video' ? '.mp4' : '.png');
                const baseId = sanitizeCacheId(meta.cacheId || getCacheIdFromUrl(sourceUrl, meta.itemId || 'asset')) || `asset_${assetIndex++}`;
                const filename = `${baseId}${meta.suffix || ''}${ext}`;
                const assetPath = `${assetFolder}/${filename}`;
                zip.file(assetPath, blob);
                assetMap.set(sourceUrl, assetPath);
                assetManifest[sourceUrl] = assetPath;
                if (resolvedUrl && resolvedUrl !== sourceUrl) {
                    assetMap.set(resolvedUrl, assetPath);
                    assetManifest[resolvedUrl] = assetPath;
                }
            } catch (e) {
                console.warn('打包资源失败:', sourceUrl, e);
            }
        };

        // 1) 历史记录资产
        for (const item of historyItems) {
            if (!item) continue;
            const baseProxy = getItemProxyPreference(item);
            const addFromList = async (list, suffixPrefix = '') => {
                if (!Array.isArray(list)) return;
                for (let i = 0; i < list.length; i++) {
                    const rawUrl = list[i];
                    if (!rawUrl || typeof rawUrl !== 'string') continue;
                    const resolved = resolveHistoryUrl(item, rawUrl) || rawUrl;
                    const useProxy = getProxyPreferenceForUrl(resolved, baseProxy);
                    await addAsset(rawUrl, resolved, { useProxy, itemId: item.id, cacheId: getCacheIdFromUrl(rawUrl, item.id), suffix: suffixPrefix ? `${suffixPrefix}${i + 1}` : `_${i + 1}`, type: item.type });
                }
            };
            await addFromList(item.mjImages, '_mj_');
            await addFromList(item.output_images, '_out_');
            const singleUrls = [item.url, item.originalUrl, item.mjOriginalUrl, item.thumbnailUrl, item.localCacheUrl].filter(Boolean);
            for (const rawUrl of singleUrls) {
                const resolved = resolveHistoryUrl(item, rawUrl) || rawUrl;
                const useProxy = getProxyPreferenceForUrl(resolved, baseProxy);
                await addAsset(rawUrl, resolved, { useProxy, itemId: item.id, cacheId: getCacheIdFromUrl(rawUrl, item.id), type: item.type });
            }
            if (item.localCacheMap) {
                for (const [rawUrl, cacheUrl] of Object.entries(item.localCacheMap)) {
                    const useProxy = getProxyPreferenceForUrl(cacheUrl, baseProxy);
                    await addAsset(rawUrl, cacheUrl, { useProxy, itemId: item.id, cacheId: getCacheIdFromUrl(rawUrl, item.id), type: item.type });
                }
            }
        }

        // 2) 节点与角色库资产（兜底扫描）
        const genericAssets = new Set();
        collectAssetUrlsFromObject(nodes, genericAssets);
        collectAssetUrlsFromObject(characterLibrary, genericAssets);
        collectAssetUrlsFromObject(chatSessions, genericAssets);
        for (const rawUrl of genericAssets) {
            if (!rawUrl) continue;
            await addAsset(rawUrl, rawUrl, { useProxy: false, cacheId: getCacheIdFromUrl(rawUrl, 'node'), type: isVideoUrl(rawUrl) ? 'video' : 'image' });
        }

        // 3) 写入 project.json（资产 URL 替换为 asset://）
        const bundleProjectData = replaceAssetUrlsInObject(projectData, assetMap);
        bundleProjectData.assetBundle = true;
        bundleProjectData.assetManifest = assetManifest;

        zip.file('project.json', JSON.stringify(bundleProjectData, (key, value) => (value === undefined ? null : value), 2));
        zip.file('manifest.json', JSON.stringify({ assets: assetManifest }, null, 2));

        const content = await zip.generateAsync({ type: 'blob', streamFiles: true });
        const timestamp = getCSTFilenameTimestamp();
        const bundleName = `${projectName || '未命名项目'}_${timestamp}.zip`;
        if (options.handle) {
            const writable = await options.handle.createWritable();
            await writable.write(content);
            await writable.close();
        } else {
            saveAs(content, bundleName);
        }
        return bundleName;
    };

    const clearAutoSaveStorage = useCallback(async () => {
        try { localStorage.removeItem(AUTOSAVE_LOCAL_KEY); } catch (e) { }
        try { writeAutoSaveMeta(null); } catch (e) { }
        try {
            const db = await openAutoSaveDb();
            await new Promise((resolve) => {
                const tx = db.transaction(AUTOSAVE_IDB_STORE, 'readwrite');
                const store = tx.objectStore(AUTOSAVE_IDB_STORE);
                const req = store.delete(AUTOSAVE_IDB_KEY);
                req.onsuccess = () => resolve(true);
                req.onerror = () => resolve(false);
                tx.oncomplete = () => db.close();
                tx.onerror = () => db.close();
            });
        } catch (e) { }
    }, []);

    const resetProjectState = useCallback(async (options = {}) => {
        setNodes([]);
        setConnections([]);
        setHistory([]);
        setHistorySelection(new Set());
        setSelectedNodeId(null);
        setSelectedNodeIds(new Set());
        setUndoStack([]);
        setRedoStack([]);
        setLightboxItem(null);
        setProjectName('未命名项目');
        setView({ ...DEFAULT_VIEW });
        setChatSessions([{ id: 'default', title: t('新对话'), messages: [] }]);
        setCurrentChatId('default');
        setChatInput('');
        setChatFiles([]);
        setCharacterLibrary([]);
        setBatchQueue([]);
        setBatchGroups([]);
        if (!options.keepAssetBundle) resetAssetBundleState();
        if (!options.keepAutoSave) await clearAutoSaveStorage();
        try { localStorage.removeItem('tapnow_project_name'); } catch (e) { }
    }, [resetAssetBundleState, clearAutoSaveStorage]);

    // 功能5：保存项目到JSON文件（流式写入，支持超大文件）
    const handleSaveProject = async () => {
        // 方案B：统一使用资产包（Zip）保存，避免 base64 膨胀与失败
        const shouldSaveHistoryAssets = saveHistoryAssets;
        const historySnapshot = history.slice(0, normalizeHistorySaveLimit(historySaveLimit));
        const saveProjectJsonWithoutAssets = async (options = {}) => {
            const preferLegacyDownload = !!options.preferLegacyDownload;
            const payload = {
                version: '2.5.7',
                projectName,
                theme,
                nodes,
                connections,
                view,
                history: historySnapshot.map((item) => compactHistoryItemForStorage(item)),
                chatSessions,
                characterLibrary,
                modelLibrary,
                timestamp: getCSTTimestamp(),
                assetBundle: false
            };
            const jsonText = JSON.stringify(payload, (key, value) => (value === undefined ? null : value), 2);
            const timestamp = getCSTFilenameTimestamp();
            const filename = `${projectName || '未命名项目'}_${timestamp}.json`;
            if (window.showSaveFilePicker && !preferLegacyDownload) {
                const handle = await window.showSaveFilePicker({
                    suggestedName: filename,
                    types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }],
                });
                const writable = await handle.createWritable();
                await writable.write(jsonText);
                await writable.close();
            } else {
                const blob = new Blob([jsonText], { type: 'application/json' });
                saveAs(blob, filename);
            }
        };
        if (shouldSaveHistoryAssets) {
            const runBundleSave = async (projectData, bundleName, handle) => {
                setDownloadProgress({ active: true, current: 0, total: 1, filename: bundleName });
                try {
                    await saveProjectAsBundle(projectData, {
                        handle,
                        filename: bundleName,
                        historyItems: historySnapshot,
                        onProgress: ({ current, total, filename }) => {
                            setDownloadProgress({
                                active: true,
                                current,
                                total: Math.max(total || 0, 1),
                                filename: filename || bundleName
                            });
                        }
                    });
                } finally {
                    setDownloadProgress(prev => ({ ...prev, active: false }));
                }
            };
            try {
                if (window.showSaveFilePicker) {
                    const timestamp = getCSTFilenameTimestamp();
                    const bundleName = `${projectName || '未命名项目'}_${timestamp}.zip`;
                    const handle = await window.showSaveFilePicker({
                        suggestedName: bundleName,
                        types: [{ description: 'Tapnow Bundle', accept: { 'application/zip': ['.zip'] } }],
                    });
                    const projectData = {
                        version: '2.5.7',
                        projectName,
                        theme,
                        nodes,
                        connections,
                        view,
                        history: historySnapshot,
                        chatSessions,
                        characterLibrary,
                        modelLibrary,
                        timestamp: getCSTTimestamp()
                    };
                    await runBundleSave(projectData, bundleName, handle);
                    alert(t('项目已打包保存！'));
                    return;
                }
                const timestamp = getCSTFilenameTimestamp();
                const bundleName = `${projectName || '未命名项目'}_${timestamp}.zip`;
                const projectData = {
                    version: '2.5.7',
                    projectName,
                    theme,
                    nodes,
                    connections,
                    view,
                    history: historySnapshot,
                    chatSessions,
                    characterLibrary,
                    modelLibrary,
                    timestamp: getCSTTimestamp()
                };
                await runBundleSave(projectData, bundleName);
                alert(t('项目已打包保存！'));
                return;
            } catch (e) {
                console.error('项目打包保存失败:', e);
                const msg = e?.message || String(e || '');
                if (String(msg).toLowerCase().includes('quota')) {
                    const shouldFallback = confirm(`项目打包保存失败: ${msg}\n\n是否自动降级为“仅保存项目JSON（不打包资产）”？\n\n降级后可保证保存成功率，但不会打包图片/视频二进制资产。`);
                    if (shouldFallback) {
                        try {
                            // 降级路径通常已经离开用户手势上下文，避免再次调用 showSaveFilePicker
                            await saveProjectJsonWithoutAssets({ preferLegacyDownload: true });
                            alert('已降级为 JSON 保存（不含资产），保存完成。');
                            return;
                        } catch (fallbackError) {
                            const fallbackMsg = fallbackError?.message || String(fallbackError || '');
                            alert(`降级保存失败: ${fallbackMsg}\n\n建议操作：\n1) 进一步降低“历史保存上限”\n2) 清理历史后再保存`);
                            return;
                        }
                    }
                    alert(`项目打包保存失败: ${msg}\n\n建议操作：\n1) 适当降低“历史保存上限”\n2) 或关闭“保存资产包（Zip）”后再保存`);
                } else {
                    alert(`项目打包保存失败: ${msg}`);
                }
                return;
            }
        }
        const convertHistoryAssetUrl = async (url, item, force = false) => {
            if (!url || typeof url !== 'string') return url;
            if (url.startsWith('data:')) return normalizeDataUrl(url);
            const sourceRef = resolveSourceReferenceUrl(url);
            if (!force && !shouldSaveHistoryAssets) return sourceRef;
            try {
                const baseProxy = getItemProxyPreference(item);
                const useProxy = getProxyPreferenceForUrl(sourceRef, baseProxy);
                const { blob } = await fetchCacheSource(sourceRef, { useProxy, preferLocal: true });
                if (!blob) return sourceRef;
                const dataUrl = await blobToDataURL(blob);
                return normalizeDataUrl(dataUrl);
            } catch (e) {
                console.error('转换历史资源失败:', e);
                return sourceRef;
            }
        };
        const convertHistoryItemBlobUrls = async (item) => {
            const itemCopy = { ...item };
            if (itemCopy.url && typeof itemCopy.url === 'string') {
                const force = itemCopy.url.startsWith('blob:');
                itemCopy.url = await convertHistoryAssetUrl(itemCopy.url, itemCopy, force);
            }
            if (itemCopy.mjOriginalUrl && typeof itemCopy.mjOriginalUrl === 'string') {
                const force = itemCopy.mjOriginalUrl.startsWith('blob:');
                itemCopy.mjOriginalUrl = await convertHistoryAssetUrl(itemCopy.mjOriginalUrl, itemCopy, force);
            }
            if (itemCopy.originalUrl && typeof itemCopy.originalUrl === 'string') {
                const force = itemCopy.originalUrl.startsWith('blob:');
                itemCopy.originalUrl = await convertHistoryAssetUrl(itemCopy.originalUrl, itemCopy, force);
            }
            if (itemCopy.thumbnailUrl && typeof itemCopy.thumbnailUrl === 'string') {
                const force = itemCopy.thumbnailUrl.startsWith('blob:');
                itemCopy.thumbnailUrl = await convertHistoryAssetUrl(itemCopy.thumbnailUrl, itemCopy, force);
            }
            if (Array.isArray(itemCopy.mjImages)) {
                for (let i = 0; i < itemCopy.mjImages.length; i++) {
                    const imgUrl = itemCopy.mjImages[i];
                    if (imgUrl && typeof imgUrl === 'string') {
                        const force = imgUrl.startsWith('blob:');
                        itemCopy.mjImages[i] = await convertHistoryAssetUrl(imgUrl, itemCopy, force);
                    }
                }
            }
            if (Array.isArray(itemCopy.output_images)) {
                for (let i = 0; i < itemCopy.output_images.length; i++) {
                    const imgUrl = itemCopy.output_images[i];
                    if (imgUrl && typeof imgUrl === 'string') {
                        const force = imgUrl.startsWith('blob:');
                        itemCopy.output_images[i] = await convertHistoryAssetUrl(imgUrl, itemCopy, force);
                    }
                }
            }
            return itemCopy;
        };
        try {
            // 兼容性检查：优先使用 File System Access API
            if (!window.showSaveFilePicker) {
                // 降级到旧的 Blob 下载方式（仅适用于小文件）
                const shouldProceed = confirm('您的浏览器不支持流式保存大文件。\n\n如果项目包含大量图片/视频（>500MB），建议使用 Chrome 或 Edge 浏览器导出。\n\n是否继续使用传统方式保存？（可能导致内存溢出）');
                if (!shouldProceed) return;

                // 执行旧的保存逻辑（仅作为降级方案）
                const replacer = (key, value) => {
                    if (value === undefined) return null;
                    return value;
                };
                const nodesToSave = JSON.parse(JSON.stringify(nodes, replacer));
                const convertBlobUrlsToDataUrls = async (obj) => {
                    if (obj === null || obj === undefined) return obj;
                    if (typeof obj === 'string') {
                        if (obj.startsWith('blob:')) {
                            try {
                                const blob = await getBlobFromUrl(obj);
                                const dataUrl = await blobToDataURL(blob);
                                return dataUrl;
                            } catch (error) {
                                console.error('转换 Blob URL 失败:', error);
                                return resolveSourceReferenceUrl(obj);
                            }
                        }
                        return resolveSourceReferenceUrl(obj);
                    }
                    if (Array.isArray(obj)) {
                        return await Promise.all(obj.map(item => convertBlobUrlsToDataUrls(item)));
                    }
                    if (typeof obj === 'object') {
                        const converted = {};
                        for (const key in obj) {
                            if (obj.hasOwnProperty(key)) {
                                converted[key] = await convertBlobUrlsToDataUrls(obj[key]);
                            }
                        }
                        return converted;
                    }
                    return obj;
                };
                const nodesWithDataUrls = await convertBlobUrlsToDataUrls(nodesToSave);
                const characterLibraryToSave = JSON.parse(JSON.stringify(characterLibrary, replacer));
                const characterLibraryWithDataUrls = await convertBlobUrlsToDataUrls(characterLibraryToSave);
                const historyToSave = await Promise.all(historySnapshot.map(item => convertHistoryItemBlobUrls(item)));
                const projectData = {
                    version: '2.5.7',
                    projectName,
                    theme,
                    nodes: nodesWithDataUrls,
                    connections,
                    view,
                    history: historyToSave,
                    chatSessions,
                    characterLibrary: characterLibraryWithDataUrls,
                    modelLibrary,
                    timestamp: getCSTTimestamp()
                };
                const jsonStr = JSON.stringify(projectData, replacer, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = getCSTFilenameTimestamp();
                const filename = `${projectName || '未命名项目'}_${timestamp}.json`;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert(t('项目保存成功！'));
                return;
            }

            // 使用 File System Access API 流式写入
            const timestamp = getCSTFilenameTimestamp();
            const handle = await window.showSaveFilePicker({
                suggestedName: `${projectName || '未命名项目'}_${timestamp}.json`,
                types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }],
            });
            const writable = await handle.createWritable();

            // replacer 函数：将 undefined 转换为 null
            const replacer = (key, value) => {
                if (value === undefined) return null;
                return value;
            };
            // 辅助函数：转换单个节点的 Blob URL 字段
            const convertNodeBlobUrls = async (node) => {
                const nodeCopy = { ...node };

                // 转换 content
                if (nodeCopy.content && typeof nodeCopy.content === 'string') {
                    if (nodeCopy.content.startsWith('blob:')) {
                        try {
                            const b64 = await getBase64FromUrl(nodeCopy.content);
                            const mime = isVideoUrl(nodeCopy.content) ? 'video/mp4' : 'image/png';
                            nodeCopy.content = `data:${mime};base64,${b64}`;
                        } catch (e) {
                            console.error('转换节点 content 失败:', e);
                        }
                    } else {
                        nodeCopy.content = resolveSourceReferenceUrl(nodeCopy.content);
                    }
                }

                // 转换 maskContent
                if (nodeCopy.maskContent && typeof nodeCopy.maskContent === 'string') {
                    if (nodeCopy.maskContent.startsWith('blob:')) {
                        try {
                            const b64 = await getBase64FromUrl(nodeCopy.maskContent);
                            nodeCopy.maskContent = `data:image/png;base64,${b64}`;
                        } catch (e) {
                            console.error('转换节点 maskContent 失败:', e);
                        }
                    } else {
                        nodeCopy.maskContent = resolveSourceReferenceUrl(nodeCopy.maskContent);
                    }
                }

                // 转换 selectedKeyframes
                if (Array.isArray(nodeCopy.selectedKeyframes)) {
                    for (let i = 0; i < nodeCopy.selectedKeyframes.length; i++) {
                        const frame = nodeCopy.selectedKeyframes[i];
                        if (frame && frame.url && typeof frame.url === 'string' && frame.url.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(frame.url);
                                frame.url = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换关键帧失败:', e);
                            }
                        } else if (frame && frame.url && typeof frame.url === 'string') {
                            frame.url = resolveSourceReferenceUrl(frame.url);
                        }
                    }
                }

                // 转换 frames
                if (Array.isArray(nodeCopy.frames)) {
                    for (let i = 0; i < nodeCopy.frames.length; i++) {
                        const frame = nodeCopy.frames[i];
                        if (frame && frame.url && typeof frame.url === 'string' && frame.url.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(frame.url);
                                frame.url = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换帧失败:', e);
                            }
                        } else if (frame && frame.url && typeof frame.url === 'string') {
                            frame.url = resolveSourceReferenceUrl(frame.url);
                        }
                    }
                }

                // 转换 previewMjImages（预览图片数组）
                if (Array.isArray(nodeCopy.previewMjImages)) {
                    for (let i = 0; i < nodeCopy.previewMjImages.length; i++) {
                        const url = nodeCopy.previewMjImages[i];
                        if (url && typeof url === 'string' && url.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(url);
                                nodeCopy.previewMjImages[i] = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换 previewMjImages 失败:', e);
                            }
                        } else if (url && typeof url === 'string') {
                            nodeCopy.previewMjImages[i] = resolveSourceReferenceUrl(url);
                        }
                    }
                }

                return nodeCopy;
            };

            // 辅助函数：转换角色库项的 Blob URL
            const convertCharacterBlobUrls = async (character) => {
                const charCopy = { ...character };

                // 转换 avatar
                if (charCopy.avatar && typeof charCopy.avatar === 'string' && charCopy.avatar.startsWith('blob:')) {
                    try {
                        const b64 = await getBase64FromUrl(charCopy.avatar);
                        charCopy.avatar = `data:image/png;base64,${b64}`;
                    } catch (e) {
                        console.error('转换角色 avatar 失败:', e);
                    }
                } else if (charCopy.avatar && typeof charCopy.avatar === 'string') {
                    charCopy.avatar = resolveSourceReferenceUrl(charCopy.avatar);
                }

                // 转换 profile_picture_url
                if (charCopy.profile_picture_url && typeof charCopy.profile_picture_url === 'string' && charCopy.profile_picture_url.startsWith('blob:')) {
                    try {
                        const b64 = await getBase64FromUrl(charCopy.profile_picture_url);
                        charCopy.profile_picture_url = `data:image/png;base64,${b64}`;
                    } catch (e) {
                        console.error('转换角色 profile_picture_url 失败:', e);
                    }
                } else if (charCopy.profile_picture_url && typeof charCopy.profile_picture_url === 'string') {
                    charCopy.profile_picture_url = resolveSourceReferenceUrl(charCopy.profile_picture_url);
                }

                return charCopy;
            };

            // 1. 写入 JSON 头部
            await writable.write(`{
    \n  "version": "2.5.7", \n  "projectName": ${JSON.stringify(projectName || '')}, \n  "theme": ${JSON.stringify(theme || 'dark')}, \n  "nodes": [\n`);

            // 2. 流式写入节点（逐个处理，释放内存）
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                const nodeToSave = await convertNodeBlobUrls(node);

                // 使用 replacer 处理 undefined 值
                const nodeJson = JSON.stringify(nodeToSave, replacer, 2);
                // 为每个节点添加缩进（除了第一个）
                const indentedNodeJson = i === 0
                    ? nodeJson.split('\n').join('\n    ')
                    : '    ' + nodeJson.split('\n').join('\n    ');

                await writable.write(indentedNodeJson);
                if (i < nodes.length - 1) {
                    await writable.write(',\n');
                } else {
                    await writable.write('\n');
                }

                // 注意：每次循环迭代都会创建新的作用域，变量会自动被 GC 回收
            }

            // 3. 写入连接和视图
            await writable.write(`  ], \n  "connections": ${JSON.stringify(connections, replacer, 2)}, \n  "view": ${JSON.stringify(view, replacer, 2)}, \n  "history": [\n`);

            // 4. 流式写入历史记录（通常是最大的部分）
            for (let i = 0; i < historySnapshot.length; i++) {
                const item = historySnapshot[i];
                const itemToSave = await convertHistoryItemBlobUrls(item);

                const itemJson = JSON.stringify(itemToSave, replacer, 2);
                const indentedItemJson = i === 0
                    ? itemJson.split('\n').join('\n    ')
                    : '    ' + itemJson.split('\n').join('\n    ');

                await writable.write(indentedItemJson);
                if (i < historySnapshot.length - 1) {
                    await writable.write(',\n');
                } else {
                    await writable.write('\n');
                }

                // 注意：每次循环迭代都会创建新的作用域，变量会自动被 GC 回收
            }

            // 5. 写入角色库（流式处理）
            await writable.write(`  ], \n  "chatSessions": ${JSON.stringify(chatSessions, replacer, 2)}, \n  "characterLibrary": [\n`);

            for (let i = 0; i < characterLibrary.length; i++) {
                const character = characterLibrary[i];
                const charToSave = await convertCharacterBlobUrls(character);

                const charJson = JSON.stringify(charToSave, replacer, 2);
                const indentedCharJson = i === 0
                    ? charJson.split('\n').join('\n    ')
                    : '    ' + charJson.split('\n').join('\n    ');

                await writable.write(indentedCharJson);
                if (i < characterLibrary.length - 1) {
                    await writable.write(',\n');
                } else {
                    await writable.write('\n');
                }

                // 注意：每次循环迭代都会创建新的作用域，变量会自动被 GC 回收
            }

            // 6. 写入模型库
            await writable.write(`  ], \n  "modelLibrary": [\n`);
            for (let i = 0; i < modelLibrary.length; i++) {
                const entry = modelLibrary[i];
                const entryJson = JSON.stringify(entry, replacer, 2);
                const indentedEntryJson = i === 0
                    ? entryJson.split('\n').join('\n    ')
                    : '    ' + entryJson.split('\n').join('\n    ');
                await writable.write(indentedEntryJson);
                if (i < modelLibrary.length - 1) {
                    await writable.write(',\n');
                } else {
                    await writable.write('\n');
                }
            }

            // 7. 写入尾部
            await writable.write(`  ], \n  "timestamp": ${JSON.stringify(getCSTTimestamp())} \n
} `);

            // 关闭流
            await writable.close();
            alert(t('项目保存成功！'));
        } catch (error) {
            console.error('保存项目失败:', error);
            if (error.name === 'AbortError') {
                // 用户取消了保存
                return;
            }
            alert('保存失败: ' + (error.message || '未知错误'));
        }
    };

    const handleNewProject = useCallback(async () => {
        const hasContent = (nodes?.length || 0) > 0
            || (connections?.length || 0) > 0
            || (history?.length || 0) > 0
            || (chatSessions?.length || 0) > 1
            || (characterLibrary?.length || 0) > 0;
        if (hasContent) {
            const shouldSave = confirm('当前项目有内容，建议先保存。\n\n点击“确定”先保存再新建，点击“取消”直接新建。');
            if (shouldSave) {
                await handleSaveProject();
            }
        }
        await resetProjectState();
    }, [nodes, connections, history, chatSessions, characterLibrary, handleSaveProject, resetProjectState]);

    // 保存选中的工作流（框选节点后右键保存）
    const handleSaveSelectedWorkflow = async () => {
        try {
            setSelectionContextMenu({ visible: false, x: 0, y: 0 });

            const selectedIds = selectedNodeIds.size > 0 ? selectedNodeIds : (selectedNodeId ? new Set([selectedNodeId]) : new Set());
            if (selectedIds.size === 0) {
                alert(t('请先选择要保存的节点'));
                return;
            }

            const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
            const selectedConnections = connections.filter(conn => selectedIds.has(conn.from) && selectedIds.has(conn.to));

            if (!window.showSaveFilePicker) {
                const shouldProceed = confirm('您的浏览器不支持流式保存大文件。\n\n是否继续使用传统方式保存？');
                if (!shouldProceed) return;

                const replacer = (key, value) => value === undefined ? null : value;
                const nodesToSave = JSON.parse(JSON.stringify(selectedNodes, replacer));
                const convertBlobUrlsToDataUrls = async (obj) => {
                    if (obj === null || obj === undefined) return obj;
                    if (typeof obj === 'string') {
                        if (obj.startsWith('blob:')) {
                            try {
                                const blob = await getBlobFromUrl(obj);
                                const dataUrl = await blobToDataURL(blob);
                                return dataUrl;
                            } catch (error) {
                                console.error('转换 Blob URL 失败:', error);
                                return resolveSourceReferenceUrl(obj);
                            }
                        }
                        return resolveSourceReferenceUrl(obj);
                    }
                    if (Array.isArray(obj)) {
                        return await Promise.all(obj.map(item => convertBlobUrlsToDataUrls(item)));
                    }
                    if (typeof obj === 'object') {
                        const converted = {};
                        for (const key in obj) {
                            if (obj.hasOwnProperty(key)) {
                                converted[key] = await convertBlobUrlsToDataUrls(obj[key]);
                            }
                        }
                        return converted;
                    }
                    return obj;
                };

                const nodesWithDataUrls = await convertBlobUrlsToDataUrls(nodesToSave);
                const workflowData = {
                    version: '3.7.36c',
                    type: 'workflow',
                    nodes: nodesWithDataUrls,
                    connections: selectedConnections,
                    timestamp: getCSTTimestamp()
                };

                const jsonStr = JSON.stringify(workflowData, replacer, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = getCSTFilenameTimestamp();
                a.download = `工作流_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert(t('工作流保存成功！'));
                return;
            }

            const timestamp = getCSTFilenameTimestamp();
            const handle = await window.showSaveFilePicker({
                suggestedName: `工作流_${timestamp}.json`,
                types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }],
            });
            const writable = await handle.createWritable();

            const replacer = (key, value) => value === undefined ? null : value;

            const convertNodeBlobUrls = async (node) => {
                const nodeCopy = { ...node };

                if (nodeCopy.content && typeof nodeCopy.content === 'string') {
                    if (nodeCopy.content.startsWith('blob:')) {
                        try {
                            const b64 = await getBase64FromUrl(nodeCopy.content);
                            const mime = isVideoUrl(nodeCopy.content) ? 'video/mp4' : 'image/png';
                            nodeCopy.content = `data:${mime};base64,${b64}`;
                        } catch (e) {
                            console.error('转换节点 content 失败:', e);
                        }
                    } else {
                        nodeCopy.content = resolveSourceReferenceUrl(nodeCopy.content);
                    }
                }

                if (nodeCopy.maskContent && typeof nodeCopy.maskContent === 'string') {
                    if (nodeCopy.maskContent.startsWith('blob:')) {
                        try {
                            const b64 = await getBase64FromUrl(nodeCopy.maskContent);
                            nodeCopy.maskContent = `data:image/png;base64,${b64}`;
                        } catch (e) {
                            console.error('转换节点 maskContent 失败:', e);
                        }
                    } else {
                        nodeCopy.maskContent = resolveSourceReferenceUrl(nodeCopy.maskContent);
                    }
                }

                if (Array.isArray(nodeCopy.selectedKeyframes)) {
                    for (let i = 0; i < nodeCopy.selectedKeyframes.length; i++) {
                        const frame = nodeCopy.selectedKeyframes[i];
                        if (frame && frame.url && typeof frame.url === 'string' && frame.url.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(frame.url);
                                frame.url = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换关键帧失败:', e);
                            }
                        } else if (frame && frame.url && typeof frame.url === 'string') {
                            frame.url = resolveSourceReferenceUrl(frame.url);
                        }
                    }
                }

                if (Array.isArray(nodeCopy.frames)) {
                    for (let i = 0; i < nodeCopy.frames.length; i++) {
                        const frame = nodeCopy.frames[i];
                        if (frame && frame.url && typeof frame.url === 'string' && frame.url.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(frame.url);
                                frame.url = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换帧失败:', e);
                            }
                        } else if (frame && frame.url && typeof frame.url === 'string') {
                            frame.url = resolveSourceReferenceUrl(frame.url);
                        }
                    }
                }

                if (Array.isArray(nodeCopy.previewMjImages)) {
                    for (let i = 0; i < nodeCopy.previewMjImages.length; i++) {
                        const imgUrl = nodeCopy.previewMjImages[i];
                        if (imgUrl && typeof imgUrl === 'string' && imgUrl.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(imgUrl);
                                nodeCopy.previewMjImages[i] = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换预览图片失败:', e);
                            }
                        } else if (imgUrl && typeof imgUrl === 'string') {
                            nodeCopy.previewMjImages[i] = resolveSourceReferenceUrl(imgUrl);
                        }
                    }
                }

                return nodeCopy;
            };

            await writable.write(`{\n  "version": "3.7.36c",\n  "type": "workflow",\n  "nodes": [\n`);

            for (let i = 0; i < selectedNodes.length; i++) {
                const convertedNode = await convertNodeBlobUrls(selectedNodes[i]);
                const nodeJson = JSON.stringify(convertedNode, replacer, 4);
                const indentedJson = nodeJson.split('\n').map(line => '    ' + line).join('\n');
                await writable.write(indentedJson);
                if (i < selectedNodes.length - 1) {
                    await writable.write(',\n');
                } else {
                    await writable.write('\n');
                }
            }

            await writable.write(`  ],\n  "connections": ${JSON.stringify(selectedConnections, replacer, 2)},\n  "timestamp": ${JSON.stringify(getCSTTimestamp())}\n}`);
            await writable.close();
            alert(t('工作流保存成功！'));
        } catch (error) {
            console.error('保存工作流失败:', error);
            if (error.name === 'AbortError') return;
            alert('保存失败: ' + (error.message || '未知错误'));
        }
    };

    // 导入工作流（将工作流节点添加到当前画布）
    const handleImportWorkflow = async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (data.type !== 'workflow') {
                    alert('这不是一个有效的工作流文件。\n\n请使用"保存当前选取工作流"功能导出的文件。');
                    return;
                }
                if (!data.nodes || data.nodes.length === 0) {
                    alert(t('工作流文件中没有节点数据'));
                    return;
                }

                let localFiles = [];
                const baseUrl = (localServerUrl || 'http://127.0.0.1:9527').replace(/\/+$/, '');
                try {
                    if (baseUrl) {
                        const localFilesRes = await fetch(`${baseUrl}/list-files`);
                        if (localFilesRes.ok) {
                            const localFilesData = await localFilesRes.json();
                            if (localFilesData.success && localFilesData.files) {
                                localFiles = localFilesData.files;
                                console.log(`[导入工作流] 本地库已连接，找到 ${localFiles.length} 个文件`);
                            }
                        }
                    }
                } catch (err) {
                    console.log('[导入工作流] 本地服务器未连接');
                }

                const findLocalFileBySize = (dataUrl) => {
                    if (!localFiles.length || !dataUrl) return null;
                    try {
                        const base64 = dataUrl.split(',')[1];
                        if (!base64) return null;
                        const estimatedSize = Math.floor(base64.length * 0.75);
                        const tolerance = estimatedSize * 0.05;
                        const match = localFiles.find(f => Math.abs(f.size - estimatedSize) < tolerance);
                        if (match) {
                            return `${baseUrl}/file/${encodeURIComponent(match.rel_path)}`;
                        }
                    } catch (err) { }
                    return null;
                };

                const convertNodeUrls = async (node) => {
                    const stack = [node];
                    while (stack.length > 0) {
                        const current = stack.pop();
                        if (!current || typeof current !== 'object') continue;

                        for (const key in current) {
                            const val = current[key];
                            if (typeof val === 'string' && (val.startsWith('data:image/') || val.startsWith('data:video/'))) {
                                try {
                                    const localUrl = findLocalFileBySize(val);
                                    if (localUrl) {
                                        const testRes = await fetch(localUrl, { method: 'HEAD' });
                                        if (testRes.ok) {
                                            current[key] = localUrl;
                                            continue;
                                        }
                                    }
                                    const res = await fetch(val);
                                    const blob = await res.blob();
                                    current[key] = URL.createObjectURL(blob);
                                } catch (err) { }
                            } else if (typeof val === 'object' && val !== null) {
                                stack.push(val);
                            }
                        }
                    }
                    return node;
                };

                const idMap = new Map();
                data.nodes.forEach(node => {
                    idMap.set(node.id, `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`);
                });

                const canvasElement = canvasRef.current;
                let importX = 100, importY = 100;
                if (canvasElement) {
                    const rect = canvasElement.getBoundingClientRect();
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const worldPos = screenToWorld(centerX + rect.left, centerY + rect.top);
                    importX = worldPos.x;
                    importY = worldPos.y;
                }

                let minX = Infinity, minY = Infinity;
                data.nodes.forEach(node => {
                    if (node.x < minX) minX = node.x;
                    if (node.y < minY) minY = node.y;
                });

                const newNodes = [];
                for (const node of data.nodes) {
                    const convertedNode = await convertNodeUrls({ ...node });
                    convertedNode.id = idMap.get(node.id);
                    convertedNode.x = node.x - minX + importX;
                    convertedNode.y = node.y - minY + importY;
                    newNodes.push(convertedNode);
                }

                const newConnections = (data.connections || []).map(conn => ({
                    ...conn,
                    from: idMap.get(conn.from),
                    to: idMap.get(conn.to)
                })).filter(conn => conn.from && conn.to);

                setNodes(prev => [...prev, ...newNodes]);
                setConnections(prev => [...prev, ...newConnections]);
                setSelectedNodeIds(new Set(newNodes.map(n => n.id)));

                alert(`工作流导入成功！\n\n导入了 ${newNodes.length} 个节点和 ${newConnections.length} 个连接。`);
            } catch (error) {
                console.error('导入工作流失败:', error);
                alert('导入失败: ' + (error.message || '无效的JSON文件'));
            }
        };
        input.click();
    };

    // 功能5：从JSON文件加载项目（流式读取，支持超大文件，修复多行JSON解析问题，解决内存泄露）
    const applyLoadedProjectState = (tempState) => {
        if (!tempState || typeof tempState !== 'object') return;
        setProjectName(tempState.projectName || '未命名项目');
        setView(normalizeViewState(tempState.view));
        if (tempState.connections?.length > 0) setConnections(tempState.connections);
        if (tempState.chatSessions?.length > 0) setChatSessions(tempState.chatSessions);
        if (tempState.characterLibrary?.length > 0) setCharacterLibrary(tempState.characterLibrary);
        const shouldLoadModelLibrary = tempState.modelLibraryLoaded || (Array.isArray(tempState.modelLibrary) && tempState.modelLibrary.length > 0);
        if (shouldLoadModelLibrary) {
            const normalizedLibrary = (tempState.modelLibrary || [])
                .map((entry) => ({
                    id: entry.id,
                    displayName: entry.displayName || entry.modelName || entry.id,
                    modelName: entry.modelName || entry.displayName || entry.id,
                    type: entry.type || 'Chat',
                    apiType: entry.apiType || 'openai',
                    ratioLimits: Array.isArray(entry.ratioLimits) ? entry.ratioLimits : null,
                    ratioNotes: normalizeValueNotes(entry.ratioNotes),
                    ratioNotesEnabled: !!entry.ratioNotesEnabled,
                    resolutionLimits: Array.isArray(entry.resolutionLimits) ? entry.resolutionLimits : null,
                    resolutionNotes: normalizeResolutionNotes(entry.resolutionNotes),
                    resolutionNotesEnabled: !!entry.resolutionNotesEnabled,
                    durations: Array.isArray(entry.durations) ? entry.durations : null,
                    durationNotes: normalizeValueNotes(entry.durationNotes),
                    durationNotesEnabled: !!entry.durationNotesEnabled,
                    videoResolutions: Array.isArray(entry.videoResolutions) ? entry.videoResolutions : null,
                    videoResolutionNotes: normalizeValueNotes(entry.videoResolutionNotes),
                    videoResolutionNotesEnabled: !!entry.videoResolutionNotesEnabled,
                    supportsFirstLastFrame: !!entry.supportsFirstLastFrame,
                    supportsHD: !!entry.supportsHD,
                    omitRatioOnSubmit: !!entry.omitRatioOnSubmit,
                    omitResolutionOnSubmit: !!entry.omitResolutionOnSubmit,
                    customParams: normalizeCustomParams(entry.customParams),
                    asyncConfig: entry.asyncConfig && typeof entry.asyncConfig === 'object' ? entry.asyncConfig : null,
                    requestTemplate: normalizeRequestTemplate(entry.requestTemplate || getDefaultRequestTemplateForEntry(entry)),
                    requestOverrideEnabled: !!entry.requestOverrideEnabled,
                    requestOverridePatch: normalizeRequestOverridePatch(entry.requestOverridePatch),
                    previewOverrideEnabled: !!entry.previewOverrideEnabled,
                    previewOverridePatch: normalizePreviewOverridePatch(entry.previewOverridePatch)
                }))
                .filter((entry) => entry.id);
            setModelLibrary(normalizedLibrary);
        }
        if (['dark', 'light', 'solarized'].includes(tempState.theme)) {
            setTheme(tempState.theme);
        }
        if (tempState.nodes?.length > 0) setNodes(tempState.nodes);
        if (tempState.history?.length > 0) setHistory(tempState.history);
    };

    const importProjectBundle = async (file) => {
        setProgressState({ visible: true, progress: 0, status: 'READING BUNDLE...', type: 'import' });
        try {
            resetAssetBundleState({ keepStorage: true, keepActive: true });
            const zip = await JSZip.loadAsync(file);
            const projectFile = zip.file(/project\.json$/i)?.[0];
            if (!projectFile) throw new Error('未找到 project.json');
            const projectText = await projectFile.async('string');
            const projectData = JSON.parse(projectText || '{}');
            const assetFiles = zip.file(/^assets\//);
            const assetManifest = projectData.assetManifest || {};
            const pathToOriginal = new Map();
            Object.entries(assetManifest).forEach(([original, path]) => {
                if (path) pathToOriginal.set(path, original);
            });
            assetBundlePathToOriginalRef.current.clear();
            pathToOriginal.forEach((value, key) => assetBundlePathToOriginalRef.current.set(key, value));
            const assetUrlMap = new Map();
            for (const asset of assetFiles) {
                const blob = await asset.async('blob');
                const assetPath = asset.name;
                const originalUrl = pathToOriginal.get(assetPath) || '';
                const mimeFromPath = getMimeTypeFromPath(assetPath);
                const isImageAsset = (blob?.type && blob.type.startsWith('image/')) || mimeFromPath.startsWith('image/');
                const isVideoAsset = (blob?.type && blob.type.startsWith('video/')) || mimeFromPath.startsWith('video/');
                const typedBlob = blob && (!blob.type && mimeFromPath)
                    ? new Blob([blob], { type: mimeFromPath })
                    : blob;

                if (isImageAsset || isVideoAsset) {
                    try {
                        const assetId = await LocalImageManager.saveImage(typedBlob);
                        if (assetId) {
                            assetUrlMap.set(assetPath, assetId);
                            assetBundlePathToIdRef.current.set(assetPath, assetId);
                            if (originalUrl) assetBundleIdToOriginalRef.current.set(assetId, originalUrl);
                            continue;
                        }
                    } catch (e) { }
                }
                const url = URL.createObjectURL(typedBlob);
                assetUrlMap.set(assetPath, url);
                assetBundleBlobUrlsRef.current.add(url);
                if (originalUrl) assetBundleBlobToOriginalRef.current.set(url, originalUrl);
            }
            setAssetBundleActive(true);
            persistAssetBundleMeta();
            const applyAssetBundle = (obj) => {
                if (!obj) return obj;
                if (typeof obj === 'string') {
                    if (obj.startsWith('asset://')) {
                        const path = obj.replace('asset://', '');
                        const mapped = assetUrlMap.get(path);
                        if (mapped) return mapped;
                        const fallback = assetBundlePathToOriginalRef.current.get(path);
                        return fallback || obj;
                    }
                    const mappedPath = assetManifest[obj];
                    if (mappedPath) {
                        const mapped = assetUrlMap.get(mappedPath);
                        if (mapped) return mapped;
                        const fallback = assetBundlePathToOriginalRef.current.get(mappedPath);
                        if (fallback) return fallback;
                    }
                    return obj;
                }
                if (Array.isArray(obj)) return obj.map(applyAssetBundle);
                if (typeof obj === 'object') {
                    const next = {};
                    Object.entries(obj).forEach(([key, val]) => {
                        next[key] = applyAssetBundle(val);
                    });
                    return next;
                }
                return obj;
            };
            const hydratedProject = applyAssetBundle(projectData);
            setTimeout(() => {
                applyLoadedProjectState(hydratedProject);
                setProgressState(prev => ({ ...prev, visible: false }));
                alert(`加载成功！\n${hydratedProject.nodes?.length || 0} 个节点`);
                persistAutoSaveSnapshot({
                    nodes: hydratedProject.nodes || [],
                    connections: hydratedProject.connections || []
                }).catch((err) => {
                    console.warn('[AutoSave] 导入后立即保存失败:', err);
                });
                if (Array.isArray(hydratedProject.history)) {
                    persistHistorySnapshot(hydratedProject.history);
                }
            }, 100);
        } catch (error) {
            console.error('加载资产包失败:', error);
            setProgressState(prev => ({ ...prev, visible: false }));
            alert(`加载失败: ${error.message || error} `);
        }
    };

    const handleLoadProject = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,.zip';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // 初始化进度
            setProgressState({ visible: true, progress: 0, status: 'INITIALIZING...', type: 'import' });

            if (file.name && file.name.toLowerCase().endsWith('.zip')) {
                await importProjectBundle(file);
                return;
            }

            // --- 尝试获取本地库文件列表（用于优先使用本地文件）---
            let localFiles = [];
            const localBaseUrl = (localServerUrl || 'http://127.0.0.1:9527').replace(/\/+$/, '');
            try {
                if (localBaseUrl) {
                    const localFilesRes = await fetch(`${localBaseUrl}/list-files`);
                    if (localFilesRes.ok) {
                        const localFilesData = await localFilesRes.json();
                        if (localFilesData.success && localFilesData.files) {
                            localFiles = localFilesData.files;
                            console.log(`[导入] 本地库已连接，找到 ${localFiles.length} 个文件`);
                        }
                    }
                }
            } catch (e) {
                console.log('[导入] 本地服务器未连接，将使用原始数据');
            }

            const findLocalFileBySize = (dataUrl) => {
                if (!localFiles.length || !dataUrl) return null;
                try {
                    const base64 = dataUrl.split(',')[1];
                    if (!base64) return null;
                    const estimatedSize = Math.floor(base64.length * 0.75);
                    const tolerance = estimatedSize * 0.05;
                    const match = localFiles.find(f => Math.abs(f.size - estimatedSize) < tolerance);
                    if (match) {
                        return `${localBaseUrl}/file/${encodeURIComponent(match.rel_path)}`;
                    }
                } catch (e) { }
                return null;
            };

            const tempState = {
                nodes: [], history: [], connections: [],
                chatSessions: [], characterLibrary: [],
                projectName: '', view: null, theme: '', modelLibrary: [],
                modelLibraryLoaded: false
            };

            let currentSection = null;
            let buffer = '';
            let objectBuffer = '';
            let braceCount = 0;
            let inObject = false;
            let bytesRead = 0;
            const totalBytes = file.size;

            // --- 关键辅助函数：原地转换对象中的 Base64 为 Blob URL ---
            // 这一步必须非常快且不占用额外内存
            const convertItemImmediately = async (item) => {
                // 递归遍历对象，找到所有 data:image/data:video 开头的字符串并转换
                const stack = [item];
                while (stack.length > 0) {
                    const current = stack.pop();
                    if (!current || typeof current !== 'object') continue;

                    for (const key in current) {
                        const val = current[key];
                        if (typeof val === 'string' && (val.startsWith('data:image/') || val.startsWith('data:video/'))) {
                            try {
                                const localUrl = findLocalFileBySize(val);
                                if (localUrl) {
                                    const testRes = await fetch(localUrl, { method: 'HEAD' });
                                    if (testRes.ok) {
                                        current[key] = localUrl;
                                        continue;
                                    }
                                }
                                // 立即转换为 Blob URL，释放原字符串内存
                                const res = await fetch(val);
                                const blob = await res.blob();
                                current[key] = URL.createObjectURL(blob);
                            } catch (err) {
                                // 转换失败则保持原样，防止丢失数据
                            }
                        } else if (typeof val === 'object' && val !== null) {
                            stack.push(val);
                        }
                    }
                }
                return item;
            };

            try {
                const stream = file.stream().pipeThrough(new TextDecoderStream());
                const reader = stream.getReader();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    // 更新进度条 (每读取 5MB 更新一次 UI，避免频繁渲染卡顿)
                    bytesRead += value.length;
                    if (Math.random() > 0.95) {
                        const percent = Math.min(99, (bytesRead / totalBytes) * 100);
                        setProgressState(prev => ({
                            ...prev,
                            progress: percent,
                            status: `PROCESSING ${(bytesRead / 1024 / 1024).toFixed(0)} MB`
                        }));
                    }

                    buffer += value;

                    // 逐行解析
                    while (true) {
                        const newlineIndex = buffer.indexOf('\n');
                        if (newlineIndex === -1) break;

                        const line = buffer.substring(0, newlineIndex);
                        buffer = buffer.substring(newlineIndex + 1);
                        const trimmedLine = line.trim();
                        if (!trimmedLine) continue;

                        // 状态机检测
                        if (trimmedLine.includes('"nodes": [')) { currentSection = 'nodes'; continue; }
                        if (trimmedLine.includes('"history": [')) { currentSection = 'history'; continue; }
                        if (trimmedLine.includes('"connections": [')) { currentSection = 'connections'; continue; }
                        if (trimmedLine.includes('"chatSessions": [')) { currentSection = 'chatSessions'; continue; }
                        if (trimmedLine.includes('"characterLibrary": [')) { currentSection = 'characterLibrary'; continue; }
                        if (trimmedLine.includes('"modelLibrary": [')) { currentSection = 'modelLibrary'; tempState.modelLibraryLoaded = true; continue; }

                        // 结束符检测
                        if ((trimmedLine === '],' || trimmedLine === ']') && braceCount === 0) {
                            currentSection = null;
                            objectBuffer = '';
                            inObject = false;
                            continue;
                        }

                        // 简单字段解析
                        if (!currentSection) {
                            if (trimmedLine.startsWith('"projectName":')) {
                                try { const m = trimmedLine.match(/"projectName":\s*(.+)/); if (m) tempState.projectName = JSON.parse(m[1].replace(/,$/, '')); } catch (e) { }
                            }
                            if (trimmedLine.startsWith('"theme":')) {
                                try { const m = trimmedLine.match(/"theme":\s*(.+)/); if (m) tempState.theme = JSON.parse(m[1].replace(/,$/, '')); } catch (e) { }
                            }
                            if (trimmedLine.startsWith('"view":')) {
                                // view 通常很短，这里做个简单处理，实际可能需要多行逻辑，但为了性能暂略
                                try { const m = trimmedLine.match(/"view":\s*(.+)/); if (m && m[1].endsWith('}')) tempState.view = JSON.parse(m[1].replace(/,$/, '')); } catch (e) { }
                            }
                            continue;
                        }

                        // 对象累积
                        if (currentSection) {
                            for (let char of line) {
                                if (char === '{') { braceCount++; inObject = true; }
                                if (char === '}') { braceCount--; }
                            }
                            objectBuffer += line + '\n';

                            if (inObject && braceCount === 0) {
                                let jsonStr = objectBuffer.trim();
                                if (jsonStr.endsWith(',')) jsonStr = jsonStr.slice(0, -1);

                                try {
                                    const item = JSON.parse(jsonStr);

                                    // === 核心优化点 ===
                                    // 立即转换，防止 Base64 堆积在内存中
                                    if (currentSection === 'nodes' || currentSection === 'history' || currentSection === 'characterLibrary') {
                                        await convertItemImmediately(item);
                                    }

                                    // 转换后再存入数组
                                    if (currentSection === 'nodes' && item.id) {
                                        if (!item.settings) item.settings = {};
                                        tempState.nodes.push(item);
                                    } else if (currentSection === 'history') {
                                        tempState.history.push(item);
                                    } else if (currentSection === 'connections') {
                                        tempState.connections.push(item);
                                    } else if (currentSection === 'chatSessions') {
                                        tempState.chatSessions.push(item);
                                    } else if (currentSection === 'characterLibrary') {
                                        tempState.characterLibrary.push(item);
                                    } else if (currentSection === 'modelLibrary') {
                                        tempState.modelLibrary.push(item);
                                    }
                                } catch (parseErr) {
                                    // 忽略解析错误，继续处理下一个
                                }
                                objectBuffer = '';
                                inObject = false;
                            }
                        }
                    }
                }

                // 完成
                setProgressState(prev => ({ ...prev, progress: 100, status: 'FINALIZING...' }));

                // 批量更新 State
                setTimeout(() => {
                    applyLoadedProjectState(tempState);
                    setProgressState(prev => ({ ...prev, visible: false }));
                    alert(`加载成功！\n${tempState.nodes.length} 个节点`);
                    persistAutoSaveSnapshot({
                        nodes: tempState.nodes,
                        connections: tempState.connections
                    }).catch((err) => {
                        console.warn('[AutoSave] 导入后立即保存失败:', err);
                    });
                    if (Array.isArray(tempState.history)) {
                        persistHistorySnapshot(tempState.history);
                    }
                }, 200);

            } catch (error) {
                console.error('加载失败:', error);
                setProgressState(prev => ({ ...prev, visible: false }));
                alert(`加载失败: ${error.message} `);
            }
        };
        input.click();
    };

    // --- 节点操作 ---
    const addNode = (type, worldX, worldY, sourceId, initialContent = undefined, initialDimensions = undefined, targetId = undefined, inputType = undefined) => {
        saveToUndoStack(); // V3.4.6: 保存到撤销栈
        const defaultSize = type === 'gen-video'
            ? { w: 400, h: 500 }
            : type === 'gen-image'
                ? { w: 440, h: 420 }
                : type === 'video-input'
                    ? { w: 580, h: 460 }
                    : type === 'video-analyze'
                        ? { w: 480, h: 500 }
                        : type === 'storyboard-node'
                            ? { w: 720, h: 500 }
                            : type === 'image-compare'
                                ? { w: 400, h: 300 }
                                : type === 'preview'
                                    ? { w: 320, h: 260 }
                                    : type === 'text-node'
                                        ? { w: 280, h: 200 }
                                        : type === 'novel-input'
                                            ? { w: 400, h: 500 }
                                            : type === 'extract-characters-scenes'
                                                ? { w: 400, h: 500 }
                                                : type === 'character-description' || type === 'scene-description'
                                                    ? { w: 400, h: 400 }
                                                    : type === 'create-character' || type === 'create-scene'
                                                        ? { w: 350, h: 300 }
                                                        : type === 'generate-character-video' || type === 'generate-scene-video'
                                                            ? { w: 400, h: 450 }
                                                            : (type === 'generate-character-image' || type === 'generate-scene-image')
                                                                ? { w: 400, h: 450 }
                                                                : type === 'local-save'
                                                                    ? { w: 320, h: 380 }
                                        : { w: 260, h: 260 };
        const newNode = {
            id: `node - ${Date.now()} `,
            type,
            x: worldX - defaultSize.w / 2,
            y: worldY - defaultSize.h / 2,
            width: defaultSize.w,
            height: defaultSize.h,
            content: initialContent,
            ...(initialDimensions ? { dimensions: initialDimensions } : {}),
            // V3.4.8: 使用上次使用的模型
            settings: type === 'gen-image'
                ? { model: resolveModelKey(lastUsedImageModel), ratio: lastUsedRatio, resolution: lastUsedImageResolution, prompt: '' }
                : type === 'gen-video'
                    ? { model: resolveModelKey(lastUsedVideoModel), duration: '5s', ratio: lastUsedRatio, resolution: lastUsedVideoResolution, videoPrompt: '' }
                    : type === 'video-analyze'
                        ? { model: resolveModelKey(lastUsedAnalyzeModel), segmentDuration: parseInt(lastUsedSegmentDuration), analysisMode: 'manual', voiceoverResults: [], analysisResults: [] }
                        : type === 'storyboard-node'
                            ? { projectTitle: t('未命名分镜'), shots: [] }
                                    : type === 'text-node'
                                        ? { text: initialContent || '' }
                                        : type === 'novel-input'
                                        ? { content: '' }
                                        : type === 'extract-characters-scenes'
                                            ? {
                                                model: resolveModelKey(lastUsedExtractModel || ''),
                                                analysisResults: null,
                                                lastAnalyzed: null,
                                                isAnalyzing: false,
                                                progress: 0,
                                                errorMsg: null
                                            }
                                            : type === 'character-description' || type === 'scene-description'
                                                ? {
                                                    characterId: '',
                                                    characterName: '',
                                                    role: '',
                                                    age: '',
                                                    gender: '',
                                                    sceneId: '',
                                                    sceneName: '',
                                                    description: '',
                                                    prompt: '',
                                                    mode: 'video',
                                                    style: 'none',
                                                    imageModel: resolveModelKey(lastUsedImageModel),
                                                    imageRatio: lastUsedRatio || '16:9',
                                                    imageResolution: lastUsedImageResolution,
                                                    referenceImages: [],
                                                    chatModel: resolveModelKey(lastUsedExtractModel || ''),
                                                    isEnhancing: false
                                                }
                                                : type === 'create-character' || type === 'create-scene'
                                                    ? { name: '', startSecond: 1, endSecond: 3, isCreating: false, createProgress: 0, createError: null }
                                                    : type === 'generate-character-video' || type === 'generate-scene-video'
                                                    ? { model: resolveModelKey(lastUsedVideoModel), duration: '15s', ratio: lastUsedRatio || '16:9', resolution: lastUsedVideoResolution, videoPrompt: '', referenceImages: [], sourceType: '', sourceId: '', isGenerating: false, progress: 0, error: null }
                                                    : (type === 'generate-character-image' || type === 'generate-scene-image')
                                                            ? { model: resolveModelKey(lastUsedImageModel), ratio: lastUsedRatio || '16:9', resolution: lastUsedImageResolution, prompt: '', referenceImages: [], chatModel: resolveModelKey(lastUsedExtractModel || ''), imageUrls: [], selectedImageIndex: null, isGenerating: false, progress: 0, error: null }
                                                            : type === 'local-save'
                                                                ? { serverUrl: localServerUrl, savePath: '', subfolder: '', autoSave: false, serverStatus: localCacheServerConnected ? 'connected' : 'disconnected', lastSaved: null, savedFiles: [], lastSavedUrls: [] }
                                : {},
        };
        setNodes(prev => [...prev, newNode]);
        // 从输出端口连接到新节点（原有逻辑）
        if (sourceId) {
            setConnections(prev => [...prev, { id: `conn - ${Date.now()} `, from: sourceId, to: newNode.id }]);
        }
        // 从输入端口连接到新节点（反向连接）
        if (targetId) {
            setConnections(prev => {
                // 如果连接到特定输入点，先删除该输入点的旧连接
                if (inputType && inputType !== 'default') {
                    const filtered = prev.filter((c) =>
                        !(c.to === targetId && (c.inputType || 'default') === inputType)
                    );
                    return [...filtered, {
                        id: `conn - ${Date.now()} `,
                        from: newNode.id,
                        to: targetId,
                        inputType: inputType !== 'default' ? inputType : undefined
                    }];
                }
                return [...prev, {
                    id: `conn - ${Date.now()} `,
                    from: newNode.id,
                    to: targetId
                }];
            });
        }
        setContextMenu(prev => ({ ...prev, visible: false }));
        setContextMenuExpanded(false);
        setConnectingSource(null);
        setConnectingTarget(null);
        setConnectingInputType(null);
        return newNode;
    };

    // V2.6.1: 角色/场景提示词生成与自动流程
    const normalizeCharacterAge = (ageValue) => {
        if (!ageValue) return '';
        if (typeof ageValue === 'number') return `${ageValue}岁左右`;
        const text = String(ageValue).trim();
        if (!text) return '';
        if (text.includes('岁') || text.includes('年')) return text;
        return `${text}岁左右`;
    };

    const DESCRIPTION_STYLE_OPTIONS = [
        { value: 'none', label: '无' },
        { value: '2d-anime', label: t('2D动漫') },
        { value: '3d-anime', label: t('3D动漫') },
        { value: 'realistic', label: t('写实') },
        { value: 'selfie', label: t('自拍') },
        { value: 'news', label: t('新闻') },
        { value: 'manga', label: t('漫画') }
    ];

    const getDescriptionStylePrefix = useCallback((style) => {
        switch (style) {
            case '2d-anime':
                return '2D动漫风格';
            case '3d-anime':
                return '3D动漫风格';
            case 'realistic':
                return '写实风格';
            case 'selfie':
                return '自拍风格';
            case 'news':
                return '新闻风格';
            case 'manga':
                return '漫画风格';
            default:
                return '动漫风格';
        }
    }, []);

    const stripCharacterVideoSuffix = (text) => {
        if (!text) return '';
        let cleaned = text.replace(/，然后缓慢转一圈360度全方位展示身体/g, '');
        const markers = [
            '，正在用中文普通话面向镜头做自我介绍，说着：我是',
            '，正在用中文普通话面向镜头做自我介绍'
        ];
        markers.forEach((marker) => {
            const idx = cleaned.indexOf(marker);
            if (idx !== -1) cleaned = cleaned.slice(0, idx);
        });
        return cleaned;
    };

    const ensureCharacterVideoSuffix = (text) => {
        if (!text) return text;
        return text.includes('360度全方位展示身体') ? text : `${text}，然后缓慢转一圈360度全方位展示身体`;
    };

    const generateCharacterPrompt = useCallback((character, mode = 'video') => {
        const name = character?.name || character?.characterName || '角色';
        const role = (character?.role || character?.identity || character?.profession || '').trim();
        const description = (character?.description || character?.appearance || '').trim();
        const ageText = normalizeCharacterAge(character?.age);
        const genderText = character?.gender ? String(character.gender).trim() : '';
        const subjectText = `${ageText}${genderText}`.trim() || '角色';

        const detailText = [role, description].filter(Boolean).join('，');
        const detailPart = detailText ? `，${detailText}` : '';
        const introRole = role || description ? `，${role || description}` : '';

        const basePrompt = `动漫风格，全身视角，名叫${name}的${subjectText}站在白色背景前${detailPart}`;
        const speechPrompt = `${basePrompt}，正在用中文普通话面向镜头做自我介绍，说着：我是${name}${introRole}`;
        if (mode === 'video') {
            return `${speechPrompt}，然后缓慢转一圈360度全方位展示身体`;
        }
        return basePrompt;
    }, []);

    const generateScenePrompt = useCallback((scene) => {
        const location = scene?.location || scene?.name || scene?.sceneName || '';
        const description = scene?.description || '极度奢华的星际战舰舰桥内部，空间广阔如同一座宫殿，四壁装饰着繁复的黄金浮雕与象牙立柱，地面铺着深红色的天鹅绒地毯，巨大的落地舷窗外是深邃星空，中央悬挂着水晶吊灯，操作台被伪装成古典家具的样子，整体色调金碧辉煌，氛围庄严却透着一种不切实际的荒谬感';
        return location ? `${location}，${description}` : description;
    }, []);

    const runDescriptionPromptAction = async (nodeId, action) => {
        const node = nodesMap.get(nodeId);
        if (!node || (node.type !== 'character-description' && node.type !== 'scene-description')) return;

        const modelId = resolveModelKey(node.settings?.chatModel || lastUsedExtractModel || '');
        if (!modelId) {
            showToast('请先选择大模型', 'warning', 3000);
            setActiveDropdown({ nodeId, type: 'desc-model' });
            return;
        }

        const credentials = getApiCredentials(modelId);
        if (!credentials.key) {
            showToast('请先在设置中配置 API Key', 'error', 4000);
            setSettingsOpen(true);
            return;
        }

        const promptText = (node.settings?.prompt || '').trim();
        if (!promptText) {
            showToast('请先输入提示词', 'warning', 3000);
            return;
        }

        const config = getApiConfigByKey(modelId);
        const baseUrl = (credentials.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
        const modelName = config?.modelName || modelId;
        const isCharacter = node.type === 'character-description';
        const characterFilterPrompt = '你是一个提示词优化专家。请分析以下提示词，只保留关于人物外貌、服装、姿态等角色特征的描述，去除所有剧情、动作、对话和背景信息。输出应简洁，只包含角色特征描述，格式为"全身视角，[人物特征描述]，站在纯白色背景前"。必须确保背景始终是纯白色，不能有任何场景描述。';
        const sceneEnhancePrompt = '你是一个场景描述优化专家。请分析以下提示词，只保留关于场景、环境、建筑、背景等场景特征的描述，去除所有人物、角色、字符、对话和动作描述。输出应简洁，只包含场景特征描述，不能包含任何人物或角色。';

        let systemPrompt = '';
        let userPrompt = promptText;
        let temperature = 0.7;

        if (isCharacter && action === 'filter') {
            systemPrompt = characterFilterPrompt;
            temperature = 0.3;
        } else if (!isCharacter && action === 'enhance') {
            systemPrompt = sceneEnhancePrompt;
            temperature = 0.3;
        } else {
            systemPrompt = action === 'enhance'
                ? '你是影视分镜提示词优化专家。请在保持原意的基础上扩展细节、镜头语言与氛围质感，输出一段中文提示词。不要输出解释或JSON。'
                : '你是提示词清洗助手。请移除无效/冲突/敏感词，保留核心语义并更精炼，输出一段中文提示词。不要输出解释或JSON。';
        }

        updateNodeSettings(nodeId, { isEnhancing: true });
        try {
            const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${credentials.key}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: modelName,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userPrompt }
                    ],
                    temperature
                })
            });

            if (!response.ok) {
                let detail = '';
                try {
                    const err = await response.json();
                    detail = err?.error?.message || err?.message || '';
                } catch { }
                throw new Error(`API Error: ${response.status}${detail ? ` - ${detail}` : ''}`);
            }

            const data = await response.json();
            const content = data.choices?.[0]?.message?.content || data.content || '';
            const cleaned = content.replace(/```[\s\S]*?```/g, '').trim();
            if (cleaned) {
                updateNodeSettings(nodeId, { prompt: cleaned });
                showToast(action === 'enhance' ? '已增强提示词' : '已过滤提示词', 'success', 2000);
            } else {
                showToast('返回内容为空，请重试', 'warning', 3000);
            }
        } catch (err) {
            console.error('[描述提示词处理失败]', err);
            showToast(`处理失败: ${err.message || '未知错误'}`, 'error', 4000);
        } finally {
            updateNodeSettings(nodeId, { isEnhancing: false });
        }
    };

    const generateFullWorkflow = useCallback((extractNodeId, analysisResults) => {
        const extractNode = nodesMap.get(extractNodeId);
        if (!extractNode) return;

        const characters = Array.isArray(analysisResults?.characters) ? analysisResults.characters : [];
        const scenes = Array.isArray(analysisResults?.scenes) ? analysisResults.scenes : [];
        if (characters.length === 0 && scenes.length === 0) return;

        saveToUndoStack();

        const baseX = extractNode.x + extractNode.width + 100;
        const baseY = extractNode.y;
        const rowGap = 450;
        const timestamp = Date.now();

        const defaultVideoModel = resolveModelKey(lastUsedVideoModel)
            || resolveModelKey(apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'))?.id)
            || resolveModelKey(apiConfigs.find(c => c.type === 'Video')?.id)
            || '';
        const defaultImageModel = resolveModelKey(lastUsedImageModel) || resolveModelKey(apiConfigs.find(c => isImageModelType(c.type))?.id) || '';
        const defaultChatModel = resolveModelKey(lastUsedExtractModel) || resolveModelKey(apiConfigs.find(c => isChatModelType(c.type))?.id) || '';
        const defaultRatio = lastUsedRatio || '16:9';
        const defaultVideoResolution = lastUsedVideoResolution || '720p';
        const defaultImageResolution = lastUsedImageResolution || '2K';

        const newNodes = [];
        const newConnections = [];

        if (characters.length > 0) {
            characters.forEach((character, idx) => {
                const descId = `node - char-desc - ${timestamp} - ${idx}`;
                const videoId = `node - char-video - ${timestamp} - ${idx}`;
                const createId = `node - char-create - ${timestamp} - ${idx}`;
                const prompt = generateCharacterPrompt(character, 'video');

                newNodes.push({
                    id: descId,
                    type: 'character-description',
                    x: baseX,
                    y: baseY + (idx * rowGap),
                    width: 400,
                    height: 400,
                    settings: {
                        characterId: character?.id || '',
                        characterName: character?.name || '',
                        role: character?.role || '',
                        age: character?.age || '',
                        gender: character?.gender || '',
                        description: character?.description || '',
                        prompt,
                        mode: 'video',
                        imageModel: defaultImageModel,
                        imageRatio: defaultRatio,
                        imageResolution: defaultImageResolution,
                        referenceImages: [],
                        chatModel: defaultChatModel
                    }
                });

                newNodes.push({
                    id: videoId,
                    type: 'generate-character-video',
                    x: baseX + 420,
                    y: baseY + (idx * rowGap),
                    width: 400,
                    height: 450,
                    settings: {
                        model: defaultVideoModel,
                        duration: '15s',
                        ratio: defaultRatio,
                        resolution: defaultVideoResolution,
                        videoPrompt: prompt,
                        referenceImages: [],
                        sourceType: 'character-description',
                        sourceId: descId
                    }
                });

                newNodes.push({
                    id: createId,
                    type: 'create-character',
                    x: baseX + 840,
                    y: baseY + (idx * rowGap),
                    width: 350,
                    height: 300,
                    settings: {
                        name: character?.name || '',
                        startSecond: 1,
                        endSecond: 3
                    }
                });

                newConnections.push(
                    { id: `conn - char-desc - ${timestamp} - ${idx}`, from: extractNodeId, to: descId },
                    { id: `conn - char-video - ${timestamp} - ${idx}`, from: descId, to: videoId },
                    { id: `conn - char-create - ${timestamp} - ${idx}`, from: videoId, to: createId }
                );
            });
        }

        if (scenes.length > 0) {
            const characterCount = characters.length;
            scenes.forEach((scene, idx) => {
                const sceneIndex = characterCount + idx;
                const descId = `node - scene-desc - ${timestamp} - ${idx}`;
                const videoId = `node - scene-video - ${timestamp} - ${idx}`;
                const createId = `node - scene-create - ${timestamp} - ${idx}`;
                const prompt = generateScenePrompt(scene);
                const sceneName = scene?.location || scene?.name || scene?.sceneName || '';

                newNodes.push({
                    id: descId,
                    type: 'scene-description',
                    x: baseX,
                    y: baseY + (sceneIndex * rowGap),
                    width: 400,
                    height: 400,
                    settings: {
                        sceneId: scene?.id || '',
                        sceneName,
                        description: scene?.description || '',
                        prompt,
                        mode: 'video',
                        style: scene?.style || '',
                        imageModel: defaultImageModel,
                        imageRatio: defaultRatio,
                        imageResolution: defaultImageResolution,
                        referenceImages: [],
                        chatModel: defaultChatModel
                    }
                });

                newNodes.push({
                    id: videoId,
                    type: 'generate-scene-video',
                    x: baseX + 420,
                    y: baseY + (sceneIndex * rowGap),
                    width: 400,
                    height: 450,
                    settings: {
                        model: defaultVideoModel,
                        duration: '15s',
                        ratio: defaultRatio,
                        resolution: defaultVideoResolution,
                        videoPrompt: prompt,
                        referenceImages: [],
                        sourceType: 'scene-description',
                        sourceId: descId
                    }
                });

                newNodes.push({
                    id: createId,
                    type: 'create-scene',
                    x: baseX + 840,
                    y: baseY + (sceneIndex * rowGap),
                    width: 350,
                    height: 300,
                    settings: {
                        name: sceneName,
                        startSecond: 1,
                        endSecond: 3
                    }
                });

                newConnections.push(
                    { id: `conn - scene-desc - ${timestamp} - ${idx}`, from: extractNodeId, to: descId },
                    { id: `conn - scene-video - ${timestamp} - ${idx}`, from: descId, to: videoId },
                    { id: `conn - scene-create - ${timestamp} - ${idx}`, from: videoId, to: createId }
                );
            });
        }

        if (newNodes.length > 0) {
            setNodes(prev => [...prev, ...newNodes]);
        }
        if (newConnections.length > 0) {
            setConnections(prev => [...prev, ...newConnections]);
        }
    }, [nodesMap, apiConfigs, lastUsedVideoModel, lastUsedImageModel, lastUsedExtractModel, lastUsedRatio, lastUsedVideoResolution, lastUsedImageResolution, generateCharacterPrompt, generateScenePrompt]);

    const ensureImageNodeForDescription = (descNodeId) => {
        const descNode = nodesMap.get(descNodeId);
        if (!descNode) return;
        const isCharacter = descNode.type === 'character-description';
        const targetType = isCharacter ? 'generate-character-image' : 'generate-scene-image';

        const existing = connections.find(conn => conn.from === descNodeId && nodesMap.get(conn.to)?.type === targetType);
        if (existing) return;

                const baseCharacter = {
                    name: descNode.settings?.characterName || descNode.settings?.name || '角色',
                    role: descNode.settings?.role || '',
                    description: descNode.settings?.description || '',
                    age: descNode.settings?.age || '',
                    gender: descNode.settings?.gender || ''
                };
        const baseScene = {
            name: descNode.settings?.sceneName || descNode.settings?.location || '场景',
            location: descNode.settings?.sceneName || descNode.settings?.location || '',
            description: descNode.settings?.description || ''
        };
        const defaultPrompt = isCharacter
            ? generateCharacterPrompt(baseCharacter, 'image')
            : generateScenePrompt(baseScene);

        const worldX = descNode.x + descNode.width + 200;
        const worldY = descNode.y + descNode.height / 2;
        const created = addNode(targetType, worldX, worldY, descNodeId);
        if (!created?.id) return;

        const defaultImageModel = resolveModelKey(descNode.settings?.imageModel || lastUsedImageModel || apiConfigs.find(c => isImageModelType(c.type))?.id || '');
        const defaultRatio = descNode.settings?.imageRatio || lastUsedRatio || '16:9';
        const defaultResolution = descNode.settings?.imageResolution || lastUsedImageResolution || '2K';
        const defaultChatModel = resolveModelKey(descNode.settings?.chatModel || lastUsedExtractModel || '');

        const rawPrompt = descNode.settings?.prompt || defaultPrompt;
        const imagePrompt = isCharacter ? stripCharacterVideoSuffix(rawPrompt) : rawPrompt;

        updateNodeSettings(created.id, {
            model: defaultImageModel,
            ratio: defaultRatio,
            resolution: defaultResolution,
            prompt: imagePrompt,
            referenceImages: descNode.settings?.referenceImages || [],
            chatModel: defaultChatModel,
            sourceType: descNode.type,
            sourceId: descNode.id
        });
    };

    const ensureVideoNodeForDescription = (descNodeId) => {
        const descNode = nodesMap.get(descNodeId);
        if (!descNode) return;
        const isCharacter = descNode.type === 'character-description';
        const targetType = isCharacter ? 'generate-character-video' : 'generate-scene-video';

        const existing = connections.find(conn => conn.from === descNodeId && nodesMap.get(conn.to)?.type === targetType);
        if (existing) return;

        const baseCharacter = {
            name: descNode.settings?.characterName || descNode.settings?.name || '角色',
            role: descNode.settings?.role || '',
            description: descNode.settings?.description || '',
            age: descNode.settings?.age || '',
            gender: descNode.settings?.gender || ''
        };
        const baseScene = {
            name: descNode.settings?.sceneName || descNode.settings?.location || '场景',
            location: descNode.settings?.sceneName || descNode.settings?.location || '',
            description: descNode.settings?.description || ''
        };
        const defaultPrompt = isCharacter
            ? generateCharacterPrompt(baseCharacter, 'video')
            : generateScenePrompt(baseScene);
        const rawPrompt = descNode.settings?.prompt || defaultPrompt;
        const videoPrompt = isCharacter ? ensureCharacterVideoSuffix(rawPrompt) : rawPrompt;

        const worldX = descNode.x + descNode.width + 200;
        const worldY = descNode.y + descNode.height / 2;
        const created = addNode(targetType, worldX, worldY, descNodeId);
        if (!created?.id) return;

        const defaultVideoModel = resolveModelKey(lastUsedVideoModel)
            || resolveModelKey(apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'))?.id)
            || resolveModelKey(apiConfigs.find(c => c.type === 'Video')?.id)
            || '';
        const defaultRatio = descNode.settings?.imageRatio || lastUsedRatio || '16:9';
        const defaultResolution = lastUsedVideoResolution || '720p';

        updateNodeSettings(created.id, {
            model: defaultVideoModel,
            duration: '15s',
            ratio: defaultRatio,
            resolution: defaultResolution,
            videoPrompt,
            referenceImages: descNode.settings?.referenceImages || [],
            sourceType: descNode.type,
            sourceId: descNode.id
        });
    };



    // 获取连接的 gen-image 或 gen-video 节点（用于 storyboard-node 节点）
    const getConnectedGenNodes = useCallback((sourceNodeId) => {
        const genNodes = [];
        for (const conn of connections) {
            if (conn.from === sourceNodeId) {
                const targetNode = nodesMap.get(conn.to);
                if (targetNode && (targetNode.type === 'gen-image' || targetNode.type === 'gen-video')) {
                    genNodes.push(targetNode);
                }
            }
        }
        return genNodes;
    }, [connections, nodesMap]);

    // 获取模型的默认时长
    const getDefaultDurationForModel = (modelId) => {
        if (!modelId) return '5s';
        const config = getApiConfigByKey(modelId);
        if (Array.isArray(config?.durations) && config.durations.length > 0) {
            return config.durations[0];
        }
        const resolvedId = config?.id || modelId;
        if (resolvedId === 'sora-2-pro') return '15s';
        if (resolvedId.includes('sora-2') || resolvedId === 'sora-2') return '15s';
        if (resolvedId.includes('veo') || resolvedId === 'google-veo3') return '8s';
        if (resolvedId.includes('grok') || resolvedId === 'grok-3') return '8s';
        if (resolvedId.includes('jimeng-video-sora2') || resolvedId.includes('jimeng-sora2')) return '4s';
        return '5s';
    };

    // 获取模型可用的时长选项
    const getDefaultDurationsForModel = (modelId) => {
        if (!modelId) return ['5s', '10s'];
        const config = getApiConfigByKey(modelId);
        if (Array.isArray(config?.durations) && config.durations.length > 0) {
            return config.durations;
        }
        const resolvedId = config?.id || modelId;
        if (resolvedId === 'sora-2-pro') return ['15s', '25s'];
        if (resolvedId.includes('sora-2') || resolvedId === 'sora-2') return ['5s', '10s', '15s'];
        if (resolvedId.includes('veo') || resolvedId === 'google-veo3') return ['8s'];
        if (resolvedId.includes('grok') || resolvedId === 'grok-3') return ['8s', '5s'];
        if (resolvedId.includes('jimeng-video-sora2') || resolvedId.includes('jimeng-sora2')) return ['4s', '8s', '12s'];
        if (resolvedId.includes('jimeng')) return ['5s', '10s'];  // Jimeng 只支持 5s 和 10s
        return ['5s', '10s'];
    };

    // 分镜表节点功能函数
    const addEmptyShot = (nodeId) => {
        const node = nodesMap.get(nodeId);
        if (!node || node.type !== 'storyboard-node') return;

        // V3.7.18: 根据当前模式选择正确的模型
        const mode = node.settings?.mode || 'video';
        let defaultModel;
        let defaultRatio;
        let defaultDuration;

        if (mode === 'image') {
            // 图片模式: 使用图片模型
            defaultModel = resolveModelKey(localStorage.getItem('tapnow_last_image_model') || apiConfigs.find(c => isImageModelType(c.type))?.id || '');
            defaultRatio = '1:1';  // 图片默认1:1
            defaultDuration = undefined;  // 图片没有秒数
        } else {
            // 视频模式: 使用视频模型
            defaultModel = resolveModelKey(lastUsedVideoModel || localStorage.getItem('tapnow_last_video_model') || apiConfigs.find(c => c.type === 'Video')?.id || '');
            defaultRatio = '16:9';  // 视频默认16:9
            defaultDuration = getDefaultDurationForModel(defaultModel);
        }

        const newShot = {
            id: `shot-${Date.now()}`,
            scene_index: (node.settings?.shots?.length || 0) + 1,
            time_range: '',
            image_url: '',
            description: '',
            prompt: '',
            camera: '',
            tags: [],
            status: 'draft',
            model: defaultModel,
            ratio: defaultRatio,
            duration: defaultDuration,
            outputEnabled: false,  // V3.7.26: 默认不启用输出（需要用户确认）
            selectedImageIndex: -1  // V3.7.26: 默认不选中
        };
        updateNodeSettings(nodeId, {
            shots: [...(node.settings?.shots || []), newShot]
        });
    };

    const deleteShot = (nodeId, shotId) => {
        const node = nodesMap.get(nodeId);
        if (!node || node.type !== 'storyboard-node') return;
        const updatedShots = (node.settings?.shots || []).filter(s => s.id !== shotId);
        // 重新编号
        updatedShots.forEach((shot, idx) => {
            shot.scene_index = idx + 1;
        });
        updateNodeSettings(nodeId, { shots: updatedShots });
    };

    // V3.7.29: 修复并发预览覆盖 - 使用函数式更新避免陈旧闭包问题
    // V3.7.29 fix3: 使用 setTimeout(0) 代替 queueMicrotask，更可靠
    // V3.7.29: 修复并发预览覆盖 - 使用函数式更新避免陈旧闭包问题
    // V3.7.29 fix3: 使用 setTimeout(0) 代替 queueMicrotask，更可靠
    // V3.7.29 fix4: 添加 options 参数支持条件更新（如 onlyIfStatus）
    // V3.7.30 fix: 移除 setTimeout 包装，直接调用确保状态更新不丢失
    const updateShot = (nodeId, shotId, updates, options = {}) => {
        let didUpdate = false;
        let statusForTimer = updates.status;

        setNodes(prevNodes => {
            const node = prevNodes.find(n => n.id === nodeId);
            if (!node || node.type !== 'storyboard-node') {
                console.warn(`[updateShot] 节点未找到或类型不匹配:`, { nodeId, found: !!node, type: node?.type });
                return prevNodes;
            }

            // 检查条件更新
            if (options.onlyIfStatus) {
                const currentShot = (node.settings?.shots || []).find(s => isSameShotId(s.id, shotId));
                if (currentShot && currentShot.status !== options.onlyIfStatus) {
                    console.warn(`[updateShot] 跳过更新: ${shotId}, 当前状态 ${currentShot.status} !== 期望状态 ${options.onlyIfStatus}`);
                    return prevNodes;
                }
            }

            const currentShot = (node.settings?.shots || []).find(s => isSameShotId(s.id, shotId));
            const finalUpdates = { ...updates };
            const hasDurationCost = Object.prototype.hasOwnProperty.call(finalUpdates, 'durationCost');
            const finishingStatuses = new Set(['done', 'completed', 'failed', 'error']);

            if (finalUpdates.status === 'generating' && !hasDurationCost) {
                finalUpdates.durationCost = 0;
            }

            if (finalUpdates.status && finishingStatuses.has(finalUpdates.status) && !hasDurationCost) {
                if (currentShot?.generationStartTime) {
                    const elapsedSeconds = (Date.now() - currentShot.generationStartTime) / 1000;
                    finalUpdates.durationCost = Number(elapsedSeconds.toFixed(1));
                }
            }

            didUpdate = true;
            statusForTimer = finalUpdates.status;

            const updatedShots = (node.settings?.shots || []).map(shot =>
                shot.id === shotId ? { ...shot, ...finalUpdates } : shot
            );

            // [Cleaned Log] updateShot info removed


            // 返回更新后的节点数组
            return prevNodes.map(n =>
                n.id === nodeId
                    ? { ...n, settings: { ...n.settings, shots: updatedShots } }
                    : n
            );
        });

        if (didUpdate && statusForTimer) {
            const key = `${nodeId}-${shotId}`;
            if (statusForTimer === 'generating') {
                setShotTimers(prev => ({ ...prev, [key]: '0.0s' }));
            } else {
                setShotTimers(prev => {
                    if (!prev[key]) return prev;
                    const next = { ...prev };
                    delete next[key];
                    return next;
                });
            }
        }

        // V3.7.5: 如果更新了图片或视频，且有连接的预览窗口，自动更新预览
        // 注意：这里的 updates 是传入的参数，不受闭包影响
        if (updates.video_url || updates.output_url || updates.output_images || updates.image_url || updates.lastFrame) {
            const finalUrl = updates.video_url || updates.output_url || (updates.output_images && updates.output_images[0]) || updates.image_url || updates.lastFrame;
            const type = updates.video_url ? 'video' : 'image';
            const filename = updates.image_filename || '';

            setTimeout(() => {
                updatePreviewFromTask(`temp-${Date.now()}`, finalUrl, type, nodeId, null, filename);
            }, 50);
        }
    };

    // 从 video-analyze 节点导入分析结果
    const importShotsFromAnalysis = (nodeId) => {
        const storyboardNode = nodesMap.get(nodeId);
        if (!storyboardNode || storyboardNode.type !== 'storyboard-node') return;

        const analyzeNode = getConnectedVideoAnalyzeNode(nodeId);
        if (!analyzeNode) {
            alert(t('请先连接一个视频拆解节点'));
            return;
        }

        // 获取分析结果（优先使用 settings.analysisResults，其次使用 analysisResults）
        const analysisResults = analyzeNode.settings?.analysisResults || analyzeNode.analysisResults || [];
        if (analysisResults.length === 0) {
            alert(t('视频拆解节点没有分析结果，请先执行分析'));
            return;
        }

        // 转换为 shots 格式
        const newShots = analysisResults.map((result, idx) => {
            const keyframe = result.keyframes?.find(k => k.type === 'current') || result.keyframes?.[0];
            const mjPrompt = keyframe?.mj_prompt || '';
            const jimengPrompt = keyframe?.jimeng_prompt || '';
            const description = keyframe?.description || result.keyframes?.[0]?.description || '';

            // 提取标签
            const tags = [];
            if (result.global_tags?.style?.[0]) tags.push(result.global_tags.style[0]);
            if (keyframe?.description) {
                // 简单提取运镜信息
                const cameraKeywords = ['推', '拉', '摇', '移', '跟', '升', '降', 'Dolly', 'Pan', 'Tilt', 'Zoom'];
                cameraKeywords.forEach(keyword => {
                    if (description.includes(keyword)) {
                        tags.push(keyword);
                    }
                });
            }

            return {
                id: `shot - ${Date.now()} -${idx} `,
                scene_index: idx + 1,
                time_range: result.time_range || '',
                image_url: '',
                description: description,
                prompt: mjPrompt || jimengPrompt,
                camera: tags.find(t => ['推', '拉', '摇', '移', '跟', 'Dolly', 'Pan', 'Tilt', 'Zoom'].some(k => t.includes(k))) || '',
                tags: tags,
                status: 'draft'
            };
        });

        updateNodeSettings(nodeId, { shots: newShots });
    };

    // 自动从分析结果创建分镜表节点
    const createStoryboardFromAnalysisResult = (analyzeNodeId, analysisResults) => {
        const analyzeNode = nodesMap.get(analyzeNodeId);
        if (!analyzeNode || !analysisResults || analysisResults.length === 0) {
            console.warn('[自动生成分镜表] 分析节点不存在或分析结果为空');
            return;
        }

        // 1. 数据转换 (复用现有逻辑)
        const newShots = analysisResults.map((result, idx) => {
            const keyframe = result.keyframes?.find(k => k.type === 'current') || result.keyframes?.[0];
            const mjPrompt = keyframe?.mj_prompt || '';
            const jimengPrompt = keyframe?.jimeng_prompt || '';
            const description = keyframe?.description || result.keyframes?.[0]?.description || '';

            // 提取标签
            const tags = [];
            if (result.global_tags?.style?.[0]) tags.push(result.global_tags.style[0]);
            if (result.global_tags?.camera?.[0]) tags.push(result.global_tags.camera[0]);
            if (keyframe?.description) {
                // 简单提取运镜信息
                const cameraKeywords = ['推', '拉', '摇', '移', '跟', '升', '降', 'Dolly', 'Pan', 'Tilt', 'Zoom'];
                cameraKeywords.forEach(keyword => {
                    if (description.includes(keyword)) {
                        tags.push(keyword);
                    }
                });
            }

            // 提取运镜信息
            const camera = result.global_tags?.camera?.[0] ||
                tags.find(t => ['推', '拉', '摇', '移', '跟', 'Dolly', 'Pan', 'Tilt', 'Zoom'].some(k => t.includes(k))) ||
                '';

            return {
                id: `shot - ${Date.now()} -${idx} `,
                scene_index: idx + 1,
                time_range: result.time_range || '',
                image_url: '',
                description: description,
                prompt: mjPrompt || jimengPrompt,
                camera: camera,
                tags: tags,
                status: 'draft'
            };
        });

        // 2. 计算新节点位置（放在源节点右侧）
        const newX = analyzeNode.x + analyzeNode.width + 100;
        const newY = analyzeNode.y;
        const storyboardId = `node - storyboard - ${Date.now()} `;

        // 3. 创建节点
        const newNode = {
            id: storyboardId,
            type: 'storyboard-node',
            x: newX,
            y: newY,
            width: 600,
            height: 500,
            settings: {
                projectTitle: t('AI 拆解结果'),
                shots: newShots
            }
        };

        // 4. 更新状态
        setNodes(prev => [...prev, newNode]);
        setConnections(prev => [...prev, {
            id: `conn - ${Date.now()} `,
            from: analyzeNodeId,
            to: storyboardId
        }]);

    };

    // 分镜表任务映射：用于追踪从分镜表触发的生成任务
    const storyboardTaskMapRef = useRef(new Map()); // taskId -> { storyboardNodeId, shotId }
    const storyboardHistoryMapRef = useRef(new Map()); // historyId -> { nodeId, shotId, isImageMode }
    const storyboardHistorySyncRef = useRef(new Set()); // historyId -> synced

    useEffect(() => {
        if (!Array.isArray(history) || history.length === 0) return;
        const synced = storyboardHistorySyncRef.current;
        const nodesSnapshot = nodesRef.current || [];
        const debugStoryboard = isStoryboardDebugEnabled();
        history.forEach((item) => {
            if (!item || synced.has(item.id)) return;
            const status = String(item.status || '').toLowerCase();
            if (status !== 'completed' && status !== 'done') return;
            if (item.type && item.type !== 'image') return;
            const mappedInfo = storyboardHistoryMapRef.current.get(item.id);
            const storyboardInfo = mappedInfo || parseStoryboardSourceNodeId(item.sourceNodeId);
            if (!storyboardInfo || !storyboardInfo.isImageMode) {
                if (debugStoryboard) {
                    console.warn('[Storyboard Sync] sourceNodeId 解析失败', { historyId: item.id, sourceNodeId: item.sourceNodeId });
                }
                synced.add(item.id);
                return;
            }
            const node = findStoryboardNodeById(nodesSnapshot, storyboardInfo.nodeId);
            if (!node) {
                if (debugStoryboard) {
                    console.warn('[Storyboard Sync] 未找到分镜节点', { historyId: item.id, nodeId: storyboardInfo.nodeId });
                }
                synced.add(item.id);
                return;
            }
            const resolved = resolveStoryboardShotCandidate(node, storyboardInfo.shotId, item);
            if (!resolved || !resolved.shot) {
                if (debugStoryboard) {
                    console.warn('[Storyboard Sync] 未找到镜头', { historyId: item.id, nodeId: storyboardInfo.nodeId, shotId: storyboardInfo.shotId });
                }
                synced.add(item.id);
                return;
            }
            const shot = resolved.shot;
            if (Array.isArray(shot.output_images) && shot.output_images.length > 0) {
                synced.add(item.id);
                return;
            }
            const fallbackImages = Array.isArray(item.output_images) && item.output_images.length > 0
                ? item.output_images
                : (Array.isArray(item.mjImages) && item.mjImages.length > 0 ? item.mjImages : (item.url ? [item.url] : []));
            if (fallbackImages.length === 0) {
                if (debugStoryboard) {
                    console.warn('[Storyboard Sync] history 无可用图片', { historyId: item.id, nodeId: storyboardInfo.nodeId, shotId: storyboardInfo.shotId });
                }
                return;
            }
            if (resolved.reason === 'fallback' && !isSameShotId(shot.id, storyboardInfo.shotId)) {
                if (debugStoryboard) {
                    console.warn('[Storyboard Sync] 使用兜底镜头匹配', {
                        historyId: item.id,
                        nodeId: storyboardInfo.nodeId,
                        originalShotId: storyboardInfo.shotId,
                        matchedShotId: shot.id
                    });
                }
            }
            updateShot(storyboardInfo.nodeId, shot.id, {
                output_images: fallbackImages,
                output_url: fallbackImages[0],
                selectedImageIndex: 0,
                outputEnabled: false,
                status: 'done'
            });
            synced.add(item.id);
            console.log('[Storyboard Sync] 回填分镜输出', {
                historyId: item.id,
                nodeId: storyboardInfo.nodeId,
                shotId: storyboardInfo.shotId,
                count: fallbackImages.length
            });
        });
    }, [history]);

    // 跟踪当前聚焦的提示词文本框
    const focusedPromptTextareaRef = useRef(null);

    // 生成单个镜头
    // 重构后的生成单个镜头函数：原地生成，不依赖外部节点
    // 创建角色
    const createCharacter = async (videoUrl, startSecond, endSecond, fromTaskId = null, customEndpoint = null) => {
        try {
            // 1. 获取配置
            const soraConfig = apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'));
            if (!soraConfig) {
                alert(t('未找到 Sora 2 模型配置，请先在设置中配置 Sora 2 或 Sora 2 Pro'));
                setCreateCharacterSubmitting(false);
                return;
            }

            // V3.4.19: 使用 getApiCredentials 获取凭据
            const credentials = getApiCredentials(soraConfig.id);
            const apiKey = credentials.key;

            if (!apiKey) {
                alert(t('请先配置 API Key'));
                setCreateCharacterSubmitting(false);
                return;
            }

            // 验证时间范围
            if (endSecond - startSecond < 1 || endSecond - startSecond > 3) {
                alert(t('时间范围必须在 1-3 秒之间'));
                setCreateCharacterSubmitting(false);
                return;
            }

            // 2. 使用用户提供的 endpoint 或自动构造
            const timestamps = `${startSecond},${endSecond} `;
            let endpoint;
            if (customEndpoint && customEndpoint.trim()) {
                endpoint = customEndpoint.trim();
            } else {
                // 如果没有提供，使用默认路径
                const baseUrl = (soraConfig.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                endpoint = `${baseUrl}/sora/v1/characters`;
            }

            // 3. 构造 Body
            const payload = fromTaskId
                ? { from_task: fromTaskId, timestamps }
                : { url: videoUrl, timestamps };

            // 4. 详细调试日志
            console.log('[Create Character] Request Details:', {
                endpoint,
                apiKey: apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 4)} ` : 'EMPTY',
                payload,
                fromTaskId,
                videoUrl: fromTaskId ? 'N/A (using from_task)' : videoUrl,
                customEndpoint: customEndpoint || 'N/A (using default)'
            });

            // 5. 发送请求
            const resp = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            // 6. 错误处理
            if (!resp.ok) {
                const errText = await resp.text();
                console.error('[Create Character] API Error:', {
                    status: resp.status,
                    statusText: resp.statusText,
                    errorText: errText,
                    endpoint
                });

                // 尝试解析错误响应
                let errorData = null;
                try {
                    errorData = JSON.parse(errText);
                } catch (e) {
                    // 如果不是 JSON，使用原始文本
                }

                // 特殊处理 500 错误和 get_origin_task_failed
                if (resp.status === 500 || (errorData && (errorData.code === 'get_origin_task_failed' || errorData.message?.includes('get_origin_task_failed')))) {
                    throw new Error('TASK_NOT_FOUND');
                }

                throw new Error(`API错误(${resp.status}): ${errText || resp.statusText} `);
            }

            const data = await resp.json();

            // 7. 保存到角色库
            if (data.id && data.username) {
                const newCharacter = {
                    id: data.id,
                    username: data.username,
                    profile_picture_url: data.profile_picture_url || '',
                    permalink: data.permalink || ''
                };

                const updated = [...characterLibrary, newCharacter];
                setCharacterLibrary(updated);
                alert(`角色 "${data.username}" 创建成功！`);
                setCreateCharacterOpen(false);
                // 重置表单
                setCreateCharacterVideoSourceType('url');
                setCreateCharacterVideoUrl('');
                setCreateCharacterSelectedTaskId('');
                setCreateCharacterStartSecond(1);
                setCreateCharacterEndSecond(3);
                setCreateCharacterEndpoint('');
            } else {
                throw new Error('返回数据缺少 id 或 username');
            }
        } catch (err) {
            console.error('[Create Character] Failed:', err);
            let msg = err.message;

            // 特殊处理：原任务已过期或无法访问
            if (msg === 'TASK_NOT_FOUND') {
                alert('创建失败：原任务已过期或无法访问。\n\n请尝试获取该视频的下载链接，使用"输入视频 URL"方式重新创建。');
                return;
            }

            // 处理网络错误
            if (msg.includes('Failed to fetch') || err.name === 'TypeError' || err.message.includes('NetworkError')) {
                msg = '连接失败。可能原因：\n\n1. API 地址填写错误\n   - 请检查 API 接口地址是否多余了 "/sora" 前缀\n   - 有些服务商的路径可能不同，请询问服务商 Sora 角色创建接口的准确路径\n\n2. 跨域限制 (CORS)\n   - 请尝试安装 Allow CORS 浏览器插件\n\n3. 网络问题\n   - 请检查网络连接';
            }

            alert(`创建角色失败: ${msg} `);
        } finally {
            setCreateCharacterSubmitting(false);
        }
    };

    const scheduleStoryboardTimeout = (nodeId, shotId, startAt, mode) => {
        const timeoutMs = mode === 'image' ? IMAGE_TASK_TIMEOUT_MS : VIDEO_TASK_TIMEOUT_MS;
        const timeoutSeconds = Math.round(timeoutMs / 1000);
        setTimeout(() => {
            const currentNodes = nodesRef.current || [];
            const node = currentNodes.find(n => n.id === nodeId);
            const currentShot = node?.settings?.shots?.find(s => isSameShotId(s.id, shotId));
            if (!currentShot) return;
            if (currentShot.status !== 'generating') return;
            if (currentShot.generationStartTime !== startAt) return;
            updateShot(nodeId, shotId, { status: 'failed', errorMsg: `任务超时（${timeoutSeconds}s）` }, { onlyIfStatus: 'generating' });
        }, timeoutMs);
    };

    const generateSingleShot = (nodeId, shot) => {
        // 1. 构建更加丰富的 Prompt
        // 优先级：提示词 > 画面描述 > 风格标签 > 运镜
        let finalPrompt = shot.prompt || "";

        // 如果提示词为空，尝试使用描述自动构建
        if (!finalPrompt && shot.description) {
            finalPrompt = shot.description;
        }

        // 拼接风格标签 (Style Tags)
        if (shot.tags && shot.tags.length > 0) {
            const styleText = shot.tags.join(", ");
            finalPrompt += `, ${styleText} `;
        }

        // 拼接运镜 (Camera)
        if (shot.camera) {
            finalPrompt += `, ${shot.camera} camera movement`;
        }

        if (!finalPrompt) {
            alert(t('请至少填写画面描述或提示词'));
            return;
        }

        // 2. 获取选中的视频模型（必须选择视频模型）
        const selectedModel = resolveModelKey(shot.model || (apiConfigs.find(c => c.type === 'Video' && c.id === 'sora-2')?.id || apiConfigs.find(c => c.type === 'Video')?.id || ''));
        const modelConfig = getApiConfigByKey(selectedModel);

        if (!modelConfig || modelConfig.type !== 'Video') {
            alert(t('请先选择一个视频模型'));
            return;
        }

        // 3. 准备参考图 (Image Input)
        // 如果分镜格子里已经有图（比如用户拖入的参考图），则将其作为 img2img/img2vid 的输入
        const sourceImages = [];
        if (shot.image_url) {
            sourceImages.push(shot.image_url);
        }
        // V3.7.5: Support lastFrame (Video End Frame)
        if (shot.useFirstLastFrame && shot.lastFrame) {
            sourceImages.push(shot.lastFrame);
        }

        // 4. 更新 shot 状态为生成中
        const startAt = Date.now();
        updateShot(nodeId, shot.id, { status: 'generating', generationStartTime: startAt });
        scheduleStoryboardTimeout(nodeId, shot.id, startAt, 'video');

        // 5. 构建覆盖选项 - 确保 duration 格式正确
        let durationValue = shot.duration || getDefaultDurationForModel(selectedModel);
        // V3.5.5: 验证 duration 是否在模型支持的范围内
        const validDurations = getDefaultDurationsForModel(selectedModel);
        if (!validDurations.includes(durationValue)) {
            console.warn(`[V3.5.5] Duration "${durationValue}" not valid for model "${selectedModel}", using "${validDurations[0]}"`);
            durationValue = validDurations[0]; // 使用第一个有效值作为默认
        }
        // 确保 duration 是字符串且带 's' 后缀
        const normalizedDuration = String(durationValue).endsWith('s') ? durationValue : `${durationValue}s`;

        const overrideOptions = {
            model: selectedModel,
            ratio: shot.ratio || '16:9',
            duration: normalizedDuration,
            resolution: normalizeVideoResolutionLower(shot.resolution || '720p'),
            isHD: !!shot.isHD,
            customParams: shot.customParams || null
        };


        // 6. 创建一个特殊的节点ID用于标识这是分镜表的任务
        // V3.5.8: 修复格式，移除多余空格
        // 格式：storyboard-${nodeId}-shot-${shotId}
        const virtualNodeId = `storyboard-${nodeId}-shot-${shot.id}`;

        // 7. 预先记录任务映射（在 startGeneration 创建 taskId 之前）
        // 由于 startGeneration 内部会使用 Date.now().toString() 作为 taskId
        // 我们需要在 startGeneration 内部检查 sourceNodeId 模式并自动记录
        // 这里我们先调用 startGeneration，任务映射会在 startGeneration 内部完成

        // 调用核心生成函数
        startGeneration(finalPrompt, 'video', sourceImages, virtualNodeId, overrideOptions).catch((err) => {
            const msg = err?.message || '视频生成失败';
            updateShot(nodeId, shot.id, { status: 'failed', errorMsg: msg }, { onlyIfStatus: 'generating' });
        });
    };

    // V3.6.1: 智能分镜图片生成函数
    const generateSingleImage = (nodeId, shot) => {
        // 1. 构建 Prompt
        let finalPrompt = shot.prompt || "";

        // 如果提示词为空，尝试使用描述自动构建
        if (!finalPrompt && shot.description) {
            finalPrompt = shot.description;
        }

        // 拼接风格标签 (Style Tags)
        if (shot.tags && shot.tags.length > 0) {
            const styleText = shot.tags.join(", ");
            finalPrompt += `, ${styleText} `;
        }

        if (!finalPrompt) {
            alert(t('请至少填写画面描述或提示词'));
            return;
        }

        // 2. 获取选中的图片模型
        const selectedModel = resolveModelKey(shot.model || localStorage.getItem('tapnow_last_image_model') || (apiConfigs.find(c => isImageModelType(c.type))?.id || ''));
        const modelConfig = getApiConfigByKey(selectedModel);

        if (!modelConfig || !isImageModelType(modelConfig.type)) {
            alert(t('请先选择一个图片模型'));
            return;
        }

        // V3.7.27: 提前验证 API 凭据，避免设置 generating 后卡住
        const credentials = getApiCredentials(selectedModel);
        if (!credentials.key) {
            alert(`模型 "${selectedModel}" 的 API Key 未配置，请先在设置中配置`);
            updateShot(nodeId, shot.id, { status: 'failed', errorMsg: 'API Key 未配置' });
            setSettingsOpen(true);
            return;
        }

        // 3. 准备参考图 (Image Input)
        const sourceImages = [];
        if (shot.image_url) {
            sourceImages.push(shot.image_url);
        }
        // V3.6.1: 多图片参考支持
        if (shot.referenceImages && shot.referenceImages.length > 0) {
            sourceImages.push(...shot.referenceImages);
        }

        // 4. 更新 shot 状态为生成中（已验证 API 配置有效）
        const startAt = Date.now();
        updateShot(nodeId, shot.id, { status: 'generating', generationStartTime: startAt });
        scheduleStoryboardTimeout(nodeId, shot.id, startAt, 'image');

        // 5. 构建覆盖选项
        const overrideOptions = {
            model: selectedModel,
            ratio: shot.ratio || '1:1',
            resolution: normalizeImageResolution(shot.resolution || '2K'),
            customParams: shot.customParams || null
        };


        // 6. 创建一个特殊的节点ID用于标识这是分镜表的图片任务
        const virtualNodeId = `storyboard-img-${nodeId}-shot-${shot.id}`;

        // 7. 调用核心生成函数
        startGeneration(finalPrompt, 'image', sourceImages, virtualNodeId, overrideOptions).catch((err) => {
            const msg = err?.message || '图片生成失败';
            updateShot(nodeId, shot.id, { status: 'failed', errorMsg: msg }, { onlyIfStatus: 'generating' });
        });
    };

    // 拓展图片 Zoom Out 功能
    const handleExpandImageZoom = async (nodeId, zoomLevel) => {
        const node = nodesMap.get(nodeId);
        if (!node || !node.content) {
            console.warn('拓展图片: 节点不存在或没有图片内容');
            return;
        }

        // 查找 Midjourney 配置（优先使用节点设置中选择的模型）
        const selectedMjModelId = node.settings?.mjModel || 'mj-v7';
        let mjConfig = apiConfigs.find(c => c.id === selectedMjModelId);

        // 如果找不到，尝试查找任何 Midjourney 配置
        if (!mjConfig) {
            mjConfig = apiConfigs.find(c => c.id.includes('mj') || c.provider.toLowerCase().includes('midjourney'));
        }

        if (!mjConfig) {
            alert(t('请先配置 Midjourney API'));
            setSettingsOpen(true);
            return;
        }

        // V3.4.19: 使用 getApiCredentials 获取凭据
        const credentials = getApiCredentials(mjConfig.id);
        const apiKey = credentials.key;
        const baseUrl = credentials.url;
        if (!apiKey) {
            alert(t('请先配置 Midjourney API Key'));
            setSettingsOpen(true);
            return;
        }

        try {
            // 1. 上传图片获取 HTTP URL（如果是 data URL）
            let imageUrl = node.content;
            if (imageUrl.startsWith('data:')) {
                const httpUrl = await uploadImageToGetHttpUrl(imageUrl, baseUrl, apiKey);
                if (!httpUrl) {
                    console.error('拓展图片: 图片上传失败，所有方法都失败');
                    alert(t('图片上传失败，无法进行拓展。请检查网络连接和API配置。'));
                    return;
                }
                imageUrl = httpUrl;
            } else if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
            } else {
                console.warn('拓展图片: 图片URL格式未知:', imageUrl.substring(0, 50));
            }

            // 2. 先提交图片到 Midjourney 获取原始任务ID
            const taskId = Date.now().toString();
            const now = Date.now();

            setHistory((prev) => [{
                id: taskId,
                type: 'image',
                url: '',
                prompt: `Zoom Out ${zoomLevel} x`,
                time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                status: 'generating',
                progress: 5,
                modelName: 'Midjourney Zoom',
                width: 0,
                height: 0,
                remoteTaskId: null,
                apiConfig: { modelId: 'mj-zoom', baseUrl, apiKey, provider: mjConfig?.provider, useProxy: !!credentials.useProxy },
                provider: mjConfig?.provider,
                useProxy: !!credentials.useProxy,
                sourceNodeId: nodeId,
                startTime: now,
                durationMs: null
            }, ...prev]);
            setHistoryOpen(true);

            // 3. 提交图片到 Midjourney（使用 imagine 接口，不包含 zoom 参数）
            const mjMode = 'fast';
            const imagineEndpoint = `${baseUrl}/${mjMode}/mj/submit/imagine`;
            const imaginePayload = {
                prompt: imageUrl,
                notifyHook: '',
                state: ''
            };

            const imagineResp = await fetch(imagineEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(imaginePayload)
            });

            const imagineText = await imagineResp.text();
            if (!imagineResp.ok) {
                throw new Error(imagineText || `Imagine API error: ${imagineResp.status} `);
            }

            const imagineData = JSON.parse(imagineText);
            if (imagineData.code !== 1 && imagineData.code !== 22) {
                throw new Error(imagineData.description || `Midjourney提交失败: code ${imagineData.code} `);
            }

            const originalTaskId = imagineData.result;
            if (!originalTaskId) throw new Error('未获取到任务ID');


            // 4. 等待原始任务完成（ZOOM操作需要原始任务完成）
            let originalTaskCompleted = false;
            let pollCount = 0;
            const maxPolls = 120; // 最多轮询120次（约10分钟）

            while (!originalTaskCompleted && pollCount < maxPolls) {
                await new Promise(resolve => setTimeout(resolve, 5000)); // 每5秒检查一次
                pollCount++;

                try {
                    const statusResp = await fetch(`${baseUrl}/${mjMode}/mj/task/${originalTaskId}/fetch`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    const statusText = await statusResp.text();
                    const statusData = JSON.parse(statusText);
                    const status = statusData?.status || '';


                    if (status === 'SUCCESS' || status === 'FINISHED') {
                        originalTaskCompleted = true;
                    } else if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                        throw new Error(`原始任务失败: ${status}`);
                    }
                } catch (error) {
                    if (pollCount >= maxPolls) {
                        throw new Error('原始任务状态检查超时');
                    }
                    console.warn('拓展图片: 状态检查出错，继续重试', error);
                }
            }

            if (!originalTaskCompleted) {
                throw new Error('原始任务超时，无法执行ZOOM操作');
            }

            // 5. 使用 modal 接口提交 ZOOM 操作
            const modalEndpoint = `${baseUrl}/mj/submit/modal`;
            // ZOOM操作的prompt格式：根据Midjourney文档，使用 --zoomout 参数
            const zoomPrompt = `--zoomout ${zoomLevel}`;
            const modalPayload = {
                taskId: originalTaskId,
                prompt: zoomPrompt
                // maskBase64 可选，ZOOM 不需要蒙版
            };


            const modalResp = await fetch(modalEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(modalPayload)
            });

            const modalText = await modalResp.text();
            if (!modalResp.ok) {
                throw new Error(modalText || `Modal API error: ${modalResp.status}`);
            }

            const modalData = JSON.parse(modalText);
            if (modalData.code !== 1 && modalData.code !== 22) {
                throw new Error(modalData.description || `ZOOM提交失败: code ${modalData.code}`);
            }

            const zoomTaskId = modalData.result;
            if (!zoomTaskId) throw new Error('未获取到ZOOM任务ID');


            // 6. 更新历史记录，保存ZOOM任务ID
            setHistory((prev) => prev.map((hItem) =>
                hItem.id === taskId
                    ? { ...hItem, remoteTaskId: zoomTaskId, status: 'generating', progress: 20 }
                    : hItem
            ));

            // 7. 开始轮询ZOOM任务状态
            pollMidjourneyJob(zoomTaskId, taskId, baseUrl, apiKey, mjMode, 0, 0);
        } catch (error) {
            console.error('拓展图片: 处理失败', error);
            const taskId = Date.now().toString();
            setHistory((prev) => {
                const existing = prev.find(h => h.sourceNodeId === nodeId && h.prompt === `Zoom Out ${zoomLevel}x`);
                if (existing) {
                    return prev.map((hItem) =>
                        hItem.id === existing.id
                            ? { ...hItem, status: 'failed', errorMsg: error.message || '拓展失败' }
                            : hItem
                    );
                }
                return prev;
            });
        }
    };


    // V2.6.1: 角色场景提取逻辑
    const handleExtractAnalysis = async (nodeId, options = {}) => {
        const node = nodesMap.get(nodeId);
        const inputOverride = options.inputText || '';
        const modelOverride = options.modelId || '';

        // 1. 获取输入文本
        let inputText = inputOverride || node?.settings?.content || ''; // 优先使用自身内容（如果有）

        // 如果自身为空，查找连接的输入
        if (!inputText) {
            const incomingConn = connections.find(c => c.to === nodeId);
            if (incomingConn) {
                const sourceNode = nodesMap.get(incomingConn.from);
                if (sourceNode && (sourceNode.type === 'novel-input' || sourceNode.type === 'text-node')) {
                    inputText = sourceNode.settings?.content || sourceNode.content || '';
                }
            }
        }

        if (!inputText || inputText.trim().length === 0) {
            showToast('请先输入小说内容或连接小说输入节点', 'error');
            return;
        }

        // 2. 获取模型配置
        const modelId = resolveModelKey(modelOverride || node?.settings?.model || '');
        if (!modelId) {
            showToast('请先选择分析模型', 'error');
            return;
        }

        const config = getApiConfigByKey(modelId);
        if (!config) {
            showToast('模型配置无效', 'error');
            return;
        }

        // V3.4.19: 使用 getApiCredentials 获取凭据
        const credentials = getApiCredentials(modelId);
        const apiKey = credentials.key;
        if (!apiKey) {
            showToast('请先在设置中配置 API Key', 'error');
            setSettingsOpen(true);
            return;
        }

        if (node?.settings?.model !== modelId) {
            updateNodeSettings(nodeId, { model: modelId });
        }
        setLastUsedExtractModel(modelId);
        try { localStorage.setItem('tapnow_last_extract_model', modelId); } catch { }

        // 3. 更新状态
        updateNodeSettings(nodeId, { isAnalyzing: true, progress: 5, errorMsg: null, analysisResults: null });
        let progressTimer = setInterval(() => {
            setNodes(prev => prev.map(n => {
                if (n.id !== nodeId) return n;
                const current = n.settings?.progress || 0;
                const next = Math.min(current + 7, 92);
                return { ...n, settings: { ...n.settings, progress: next } };
            }));
        }, 500);

        // 4. 构建提示词
        const prompt = `请分析以下小说内容，提取出所有主要角色和关键场景。

小说内容：
${inputText.substring(0, 15000)} ... (截断)

请按以下 JSON 格式返回：
{
    "characters": [
        { "name": "角色名", "role": "身份/职业/设定", "age": "年龄段或岁数", "gender": "性别", "description": "角色外貌和性格描述", "appearance": "外貌特征关键词" }
    ],
    "scenes": [
        { "location": "场景名", "description": "环境描述", "mood": "氛围关键词", "style": "风格关键词" }
    ]
}
只返回 JSON，不要包含 markdown 代码块标记。`;

        try {
            const baseUrl = (credentials.url || DEFAULT_BASE_URL).replace(/\/+$/, '');

            const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: config.modelName || config.id || 'gemini-1.5-pro-latest',
                    messages: [
                        { role: 'system', content: 'You are a helpful assistant that analyzes novels.' },
                        { role: 'user', content: prompt }
                    ],
                    temperature: 0.7
                })
            });

            if (!response.ok) {
                let detail = '';
                try {
                    const err = await response.json();
                    detail = err?.error?.message || err?.message || '';
                } catch { }
                if (response.status === 401) {
                    showToast('API Key 无效或未授权（401），请检查配置', 'error', 5000);
                    setSettingsOpen(true);
                }
                throw new Error(`API Error: ${response.status}${detail ? ` - ${detail}` : ''}`);
            }

            const data = await response.json();
            const content = data.choices?.[0]?.message?.content || data.content || '';

            // 5. 解析结果并写入节点
            let result = null;
            try {
                const cleanJson = content.replace(/```json/g, '').replace(/```/g, '').trim();
                result = JSON.parse(cleanJson);
            } catch (e) {
                console.warn('JSON Parse Error', e);
            }

            const characters = Array.isArray(result?.characters) ? result.characters : [];
            const scenes = Array.isArray(result?.scenes) ? result.scenes : [];

            if (result && (characters.length > 0 || scenes.length > 0)) {
                updateNodeSettings(nodeId, {
                    analysisResults: { characters, scenes },
                    lastAnalyzed: Date.now(),
                    errorMsg: null
                });
                setTimeout(() => {
                    generateFullWorkflow(nodeId, { characters, scenes });
                }, 200);
            } else {
                updateNodeSettings(nodeId, { analysisResults: null, lastAnalyzed: Date.now(), errorMsg: '解析失败或无有效结果' });
                showToast('解析失败：未获得可用的角色/场景数据', 'warning');
            }

        } catch (error) {
            console.error('Extraction Failed', error);
            let msg = error?.message || '提取失败';
            if (error?.name === 'TypeError' || /Failed to fetch|NetworkError/i.test(msg)) {
                msg = '网络或跨域请求失败（CORS）。请检查 API 地址、协议（http/https）或开启浏览器 CORS 插件。';
            }
            updateNodeSettings(nodeId, { errorMsg: msg });
            showToast(`提取失败: ${msg}`, 'error', 5000);
        } finally {
            if (progressTimer) clearInterval(progressTimer);
            setNodes(prev => prev.map(n => n.id === nodeId ? {
                ...n,
                settings: { ...n.settings, isAnalyzing: false, progress: 100 }
            } : n));
            setTimeout(() => updateNodeSettings(nodeId, { progress: 0 }), 800);
        }
    };

    const handleNovelExtract = (nodeId) => {
        const node = nodesMap.get(nodeId);
        if (!node) return;

        const inputText = node.settings?.content || '';
        if (!inputText || inputText.trim().length === 0) {
            showToast('请先输入小说内容', 'error');
            return;
        }

        const existing = connections.find(c => c.from === nodeId && nodesMap.get(c.to)?.type === 'extract-characters-scenes');
        let targetId = existing?.to;
        let targetNode = targetId ? nodesMap.get(targetId) : null;
        if (!targetId) {
            const extractWidth = 400;
            const extractHeight = 500;
            const worldX = node.x + node.width + 50 + extractWidth / 2;
            const worldY = node.y + node.height / 2;
            const created = addNode('extract-characters-scenes', worldX, worldY, nodeId);
            targetId = created?.id;
            targetNode = created || null;
        }

        if (!targetId) return;

        const modelId = resolveModelKey(
            targetNode?.settings?.model
            || nodesMap.get(targetId)?.settings?.model
            || lastUsedExtractModel
            || ''
        );
        if (!modelId) {
            showToast('请在“提取角色和场景”节点选择分析模型', 'warning', 4000);
            setActiveDropdown({ nodeId: targetId, type: 'extract-model' });
            return;
        }

        const credentials = getApiCredentials(modelId);
        if (!credentials.key) {
            showToast('请先在设置中配置 API Key', 'error');
            setSettingsOpen(true);
            return;
        }

        updateNodeSettings(targetId, { model: modelId });
        requestAnimationFrame(() => {
            handleExtractAnalysis(targetId, { inputText, modelId });
        });
    };

    const handleFileUpload = (nodeId, e) => {
        const file = e.target.files?.[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                const content = ev.target.result;
                let dimensions = { w: 0, h: 0 };
                try { dimensions = await getImageDimensions(content); } catch (e) { }
                // V3.4.7: 保存撤销状态（图片更换是可撤销的操作）
                saveToUndoStack();
                setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, content: content, dimensions } : n));
            };
            reader.readAsDataURL(file);
        }
    };

    // 按时间段分组关键帧
    const groupKeyframesByTime = (keyframes, segmentDuration) => {
        if (!keyframes || keyframes.length === 0) return [];
        const sorted = [...keyframes].sort((a, b) => a.time - b.time);
        const groups = [];
        let currentGroup = [];
        let currentGroupStart = sorted[0].time;

        sorted.forEach((frame, idx) => {
            if (frame.time - currentGroupStart >= segmentDuration && currentGroup.length > 0) {
                groups.push([...currentGroup]);
                currentGroup = [frame];
                currentGroupStart = frame.time;
            } else {
                currentGroup.push(frame);
            }
        });

        if (currentGroup.length > 0) {
            groups.push(currentGroup);
        }

        return groups;
    };

    // 为选中关键帧生成提示词
    const handleGeneratePrompts = async (nodeId) => {
        const node = nodesMap.get(nodeId);
        if (!node || node.type !== 'video-analyze') return;

        const videoInputNode = getConnectedVideoInputNode(nodeId);
        if (!videoInputNode) {
            alert(t('请先连接一个视频输入节点'));
            return;
        }

        const selectedKeyframes = videoInputNode.selectedKeyframes || [];
        if (selectedKeyframes.length === 0) {
            alert(t('请先在视频输入节点中选择关键帧'));
            return;
        }

        const modelId = resolveModelKey(node.settings?.model || 'gemini-3-pro');
        // V3.4.8: 使用 getApiCredentials 获取 Provider 配置
        const { key: apiKey, url: baseUrl } = getApiCredentials(modelId);
        // V3.4.13: 获取完整config用于历史记录显示
        const config = getApiConfigByKey(modelId);

        if (!apiKey) {
            alert(t('请先在 API 设置中配置 Key'));
            setSettingsOpen(true);
            return;
        }

        const segmentDuration = node.settings?.segmentDuration || 3;
        const groups = groupKeyframesByTime(selectedKeyframes, segmentDuration);

        if (groups.length === 0) {
            alert(t('无法分组关键帧'));
            return;
        }

        setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isGenerating: true, analysisResults: [] } : n));

        const allResults = [];
        const videoFileName = videoInputNode.videoFileName || 'video.mp4';
        const videoDuration = videoInputNode.videoMeta?.duration || 0;
        // 保存分析模式，用于判断是否添加到历史记录
        const analysisMode = node.settings?.analysisMode || 'manual';

        try {
            for (let sceneIndex = 0; sceneIndex < groups.length; sceneIndex++) {
                const group = groups[sceneIndex];
                const timeRange = `${group[0].time.toFixed(1)}s-${group[group.length - 1].time.toFixed(1)}s`;

                // 构建多模态消息
                const systemPrompt = `你是一个专业的视频拆解和提示词生成助手。请分析提供的视频关键帧，动态拆解视频内容，并根据用户选中的关键帧生成高质量的AI绘图提示词。

请返回严格的 JSON 格式，结构如下：
{
  "video_id": "${videoFileName}",
  "scene_index": ${sceneIndex + 1},
  "time_range": "${timeRange}",
  "keyframes": [
    {
      "type": "prev",
      "time": 5.2,
      "description": "上一画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    },
    {
      "type": "current",
      "time": 6.8,
      "description": "当前画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    },
    {
      "type": "next",
      "time": 8.7,
      "description": "下一画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    }
  ],
  "global_tags": {
    "style": ["赛博朋克", "末日科幻"],
    "camera": ["低机位", "广角"],
    "color": ["冷暖对比"]
  }
}

要求：
1. 为每个关键帧生成 prev/current/next 三种类型的描述和提示词
2. mj_prompt 使用英文，适合 Midjourney
3. jimeng_prompt 使用中文，适合即梦AI
4. global_tags 提取整个场景的风格、镜头、色彩特征`;

                const userContent = [
                    { type: "text", text: `请分析以下视频关键帧（场景 ${sceneIndex + 1}，时间段：${timeRange}），生成详细的提示词：` }
                ];

                // 添加关键帧图片（限制最多15张，因为API限制是16张，需要留一些余量）
                const maxFrames = 15;
                const framesToSend = group.length > maxFrames ? group.slice(0, maxFrames) : group;
                framesToSend.forEach((frame, idx) => {
                    userContent.push({
                        type: "image_url",
                        image_url: { url: frame.url }
                    });
                    if (idx < framesToSend.length - 1) {
                        userContent.push({ type: "text", text: `关键帧 ${idx + 1}（时间：${frame.time.toFixed(2)}s）` });
                    }
                });
                if (group.length > maxFrames) {
                    userContent.push({ type: "text", text: `注意：该场景共有 ${group.length} 个关键帧，但为了符合API限制，仅发送了前 ${maxFrames} 个关键帧进行分析。` });
                }

                const apiMessages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userContent }
                ];

                // 添加超时控制（60秒）
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                let response;
                try {
                    response = await fetch(`${baseUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: config?.id || 'gemini-3-pro', // V3.7.24: 使用 config.id
                            messages: apiMessages,
                            stream: false
                        }),
                        signal: controller.signal
                    });
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    // 处理网络错误
                    if (fetchError.name === 'AbortError') {
                        throw new Error('请求超时，请检查网络连接或稍后重试');
                    } else if (fetchError.message && fetchError.message.includes('Failed to fetch')) {
                        throw new Error(`无法连接到 API 服务器 (${baseUrl})。请检查：\n1. API 地址是否正确\n2. 网络连接是否正常\n3. API 服务是否可用`);
                    } else {
                        throw new Error(`网络请求失败: ${fetchError.message}`);
                    }
                } finally {
                    clearTimeout(timeoutId);
                }

                if (!response.ok) {
                    let errText = '';
                    try {
                        errText = await response.text();
                    } catch (e) {
                        errText = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    throw new Error(errText || `API Error: ${response.status}`);
                }

                const data = await response.json();
                console.log('[视频拆解] API 响应数据:', {
                    hasData: !!data,
                    hasChoices: !!data.choices,
                    choicesLength: data.choices?.length,
                    dataKeys: Object.keys(data || {}),
                    model: config?.modelName || config?.id
                });

                // 支持多种响应格式
                let aiContent = null;
                if (data.choices && data.choices.length > 0) {
                    // OpenAI 格式: data.choices[0].message.content
                    aiContent = data.choices[0]?.message?.content;
                } else if (data.data?.choices && data.data.choices.length > 0) {
                    // 嵌套 data.choices 格式
                    aiContent = data.data.choices[0]?.message?.content;
                } else if (data.content) {
                    // 直接 content 字段
                    aiContent = data.content;
                } else if (data.data?.content) {
                    // 嵌套 data.content 格式
                    aiContent = data.data.content;
                } else if (data.text) {
                    // text 字段
                    aiContent = data.text;
                } else if (data.data?.text) {
                    // 嵌套 data.text 格式
                    aiContent = data.data.text;
                } else if (data.message) {
                    // message 字段
                    aiContent = typeof data.message === 'string' ? data.message : data.message.content;
                } else if (data.data?.message) {
                    // 嵌套 data.message 格式
                    aiContent = typeof data.data.message === 'string' ? data.data.message : data.data.message.content;
                } else if (data.result) {
                    // result 字段
                    aiContent = typeof data.result === 'string' ? data.result : data.result.content;
                } else if (data.data?.result) {
                    // 嵌套 data.result 格式
                    aiContent = typeof data.data.result === 'string' ? data.data.result : data.data.result.content;
                }

                if (!aiContent || aiContent.trim() === '' || aiContent === '{}') {
                    console.error('[视频拆解] API 响应内容为空:', data);
                    throw new Error(`API 返回内容为空。响应数据: ${JSON.stringify(data).substring(0, 200)}`);
                }


                // 尝试解析 JSON（可能包含 markdown 代码块）
                let jsonStr = aiContent.trim();
                if (jsonStr.startsWith('```')) {
                    jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
                }

                let result;
                try {
                    result = JSON.parse(jsonStr);
                } catch (e) {
                    console.error('[视频拆解] 解析 JSON 失败:', e, '内容前500字符:', jsonStr.substring(0, 500));
                    // 尝试修复常见的JSON格式问题
                    try {
                        // 移除可能的注释
                        jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                        // 尝试修复尾随逗号
                        jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                        result = JSON.parse(jsonStr);
                    } catch (e2) {
                        console.error('[视频拆解] JSON修复后仍解析失败:', e2, '原始内容:', jsonStr);
                        // 如果还是失败，创建一个默认结构
                        result = {
                            video_id: videoFileName,
                            scene_index: sceneIndex + 1,
                            time_range: timeRange,
                            keyframes: group.map((frame, fIdx) => ({
                                type: fIdx === 0 ? 'prev' : fIdx === 1 ? 'current' : 'next',
                                time: frame.time,
                                description: `视频帧 ${frame.time.toFixed(1)}s`,
                                mj_prompt: 'A detailed scene from the video',
                                jimeng_prompt: '视频场景描述'
                            })),
                            global_tags: { style: [], camera: [], color: [] }
                        };
                        console.warn('[视频拆解] 使用默认结构，原始内容:', jsonStr.substring(0, 200));
                    }
                }

                allResults.push(result);

                // 更新节点状态
                setNodes((prev) => prev.map((n) => {
                    if (n.id === nodeId) {
                        const currentResults = n.analysisResults || [];
                        const updatedResults = [...currentResults, result];
                        return { ...n, analysisResults: updatedResults };
                    }
                    return n;
                }));

                // 只有自动模式（AI 导演拆解）才添加到历史记录，手动选帧拆解不添加到历史记录
                const isManualMode = analysisMode === 'manual';
                if (!isManualMode) {
                    // 添加到历史记录
                    const taskId = `analyze-${nodeId}-${sceneIndex}-${Date.now()}`;
                    const historyItem = {
                        id: taskId,
                        type: 'analyze',
                        prompt: `视频拆解 - 场景 ${sceneIndex + 1}`,
                        url: group[0]?.url || '',
                        status: 'completed',
                        progress: 100,
                        modelName: config?.provider || 'Gemini 3 Pro',
                        time: new Date().toLocaleString('zh-CN'),
                        sourceNodeId: nodeId,
                        analysisResult: result,
                        videoFileName,
                        sceneIndex: sceneIndex + 1,
                        timeRange
                    };

                    setHistory((prev) => [historyItem, ...prev]);
                }
            }

            // 确保所有结果都已更新到节点
            setNodes((prev) => prev.map((n) => {
                if (n.id === nodeId) {
                    // 确保使用最新的 allResults
                    const finalResults = allResults.length > 0 ? allResults : (n.analysisResults || []);
                    return { ...n, isGenerating: false, analysisResults: finalResults };
                }
                return n;
            }));

        } catch (error) {
            console.error('生成提示词失败:', error);
            const errorMsg = error.message || '未知错误';
            setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isGenerating: false, errorMsg: errorMsg } : n));
            // 不显示 alert，错误信息已经在节点上显示
            // alert(`生成提示词失败: ${errorMsg}`);
        }
    };

    // AI 视频全自动分析
    const handleAutoVideoAnalysis = async (nodeId) => {
        const node = nodesMap.get(nodeId);
        if (!node || node.type !== 'video-analyze') return;

        const videoInputNode = getConnectedVideoInputNode(nodeId);
        if (!videoInputNode || !videoInputNode.content) {
            alert(t('请先连接一个包含视频的视频输入节点'));
            return;
        }

        // 预处理视频内容：如果是 blob: URL，需要转换为 base64 以便远程可访问
        let videoDataUrl = videoInputNode.content;
        if (videoDataUrl.startsWith('blob:')) {
            try {
                const blob = await fetch(videoDataUrl).then(r => r.blob());
                videoDataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onerror = () => reject(new Error('FileReader failed'));
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
            } catch (e) {
                console.error('Blob conversion failed', e);
                alert(t('视频转换失败，无法发送给 AI'));
                return;
            }
        }

        // 强制使用 gemini-3-pro 模型（支持视频输入）
        let config = apiConfigs.find((c) => c.id === 'gemini-3-pro' && isChatModelType(c.type));

        // 如果没有找到 gemini-3-pro，尝试其他 gemini 模型
        if (!config) {
            config = apiConfigs.find((c) => {
                const modelId = c.id?.toLowerCase() || '';
                return modelId.includes('gemini') && isChatModelType(c.type);
            });
        }

        // 如果还是没有，使用默认配置
        if (!config) {
            config = apiConfigs.find((c) => isChatModelType(c.type));
        }

        // V3.4.8: 使用 getApiCredentials 获取 Provider 配置
        const { key: apiKey, url: baseUrl } = getApiCredentials(config?.id || 'gemini-3-pro');

        if (!apiKey) {
            alert(t('请先在 API 设置中配置 Key'));
            setSettingsOpen(true);
            return;
        }

        setNodes((prev) => prev.map((n) =>
            n.id === nodeId
                ? { ...n, isGenerating: true, settings: { ...n.settings, voiceoverResults: [], analysisResults: [] } }
                : n
        ));

        try {
            const systemPrompt = `你是一位世界级的**游戏买量视频拆解专家**和**AI视觉导演**。你需要同时完成两项任务：

1. **视觉拆解**：分析视频的每一个分镜，推测其运镜手法（推拉摇移）、画面动态、人物关系。

2. **听觉提取**：提取视频中的口播文案（Voiceover）。

请按时间顺序，将视频拆解为多个关键场景，并返回如下 **JSON 格式**（不要包含Markdown代码块标记）：

{
  "voiceover_script": [
    { "time_range": "0s-3s", "text": "提取的口播文案..." }
  ],
  "scenes": [
    {
      "scene_id": 1,
      "time_range": "0s-2.5s",
      "visual_analysis": {
        "camera_movement": "详细描述运镜，例如：镜头瞬间快速拉远(Dolly Zoom Out)，或 环绕拍摄(Orbit)",
        "subject_dynamics": "描述主体动作，例如：角色从王座上猛然站起，披风飞扬",
        "atmosphere": "赛博朋克，冷峻，高科技感"
      },
      "prompts": {
        "jimeng_prompt": "即梦提示词：一定要包含运镜描述。格式：(运镜描述)+画面主体+环境+风格。例如：(镜头急速拉远)，一名黑发年轻男子坐在虚拟王座上，身穿黑色长风衣...",
        "mj_prompt": "Midjourney Prompt: English description, include camera directives like 'dynamic angle', 'fast zoom out', 'cinematic lighting'..."
      }
    }
  ]
}

**重要要求：**
- **运镜分析**要非常精准。
- **即梦提示词**必须将"运镜描述"放在最前面，用括号括起来。
- **口播提取**要依靠视频中的音频内容，如果视频没有声音则留空。`;

            // 直接使用视频 URL（gemini-3-pro 支持视频输入）
            const userContent = [
                { type: "text", text: t('请分析这段视频。请严格按JSON格式输出拆解报告。') },
                { type: "image_url", image_url: { url: videoDataUrl } }
            ];

            const apiMessages = [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userContent }
            ];

            // 添加超时控制（120秒，因为视频分析需要更长时间）
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 120000);

            let response;
            try {
                response = await fetch(`${baseUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: config?.id || 'gemini-3-pro', // V3.7.24: 使用 config.id 而非 modelName
                        messages: apiMessages,
                        stream: false
                    }),
                    signal: controller.signal
                });
            } catch (fetchError) {
                clearTimeout(timeoutId);
                // 处理网络错误
                if (fetchError.name === 'AbortError') {
                    throw new Error('请求超时（120秒），视频分析可能需要更长时间，请稍后重试');
                } else if (fetchError.message && fetchError.message.includes('Failed to fetch')) {
                    throw new Error(`无法连接到 API 服务器 (${baseUrl})。请检查：\n1. API 地址是否正确\n2. 网络连接是否正常\n3. API 服务是否可用\n4. 是否配置了正确的 API Key`);
                } else {
                    throw new Error(`网络请求失败: ${fetchError.message}`);
                }
            } finally {
                clearTimeout(timeoutId);
            }

            if (!response.ok) {
                let errText = '';
                try {
                    errText = await response.text();
                } catch (e) {
                    errText = `HTTP ${response.status}: ${response.statusText}`;
                }
                throw new Error(errText || `API Error: ${response.status}`);
            }

            const data = await response.json();
            console.log('[AI导演拆解] API 响应数据:', {
                hasData: !!data,
                hasChoices: !!data.choices,
                choicesLength: data.choices?.length,
                dataKeys: Object.keys(data || {}),
                model: config?.modelName || config?.id
            });

            // 支持多种响应格式
            let aiContent = null;
            if (data.choices && data.choices.length > 0) {
                // OpenAI 格式: data.choices[0].message.content
                aiContent = data.choices[0]?.message?.content;
            } else if (data.data?.choices && data.data.choices.length > 0) {
                // 嵌套 data.choices 格式
                aiContent = data.data.choices[0]?.message?.content;
            } else if (data.content) {
                // 直接 content 字段
                aiContent = data.content;
            } else if (data.data?.content) {
                // 嵌套 data.content 格式
                aiContent = data.data.content;
            } else if (data.text) {
                // text 字段
                aiContent = data.text;
            } else if (data.data?.text) {
                // 嵌套 data.text 格式
                aiContent = data.data.text;
            } else if (data.message) {
                // message 字段
                aiContent = typeof data.message === 'string' ? data.message : data.message.content;
            } else if (data.data?.message) {
                // 嵌套 data.message 格式
                aiContent = typeof data.data.message === 'string' ? data.data.message : data.data.message.content;
            } else if (data.result) {
                // result 字段
                aiContent = typeof data.result === 'string' ? data.result : data.result.content;
            } else if (data.data?.result) {
                // 嵌套 data.result 格式
                aiContent = typeof data.data.result === 'string' ? data.data.result : data.data.result.content;
            }

            if (!aiContent || aiContent.trim() === '' || aiContent === '{}') {
                console.error('[AI导演拆解] API 响应内容为空:', data);
                throw new Error(`API 返回内容为空。响应数据: ${JSON.stringify(data).substring(0, 200)}`);
            }


            // 解析 JSON
            let jsonStr = aiContent.trim();
            if (jsonStr.startsWith('```')) {
                jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
            }

            let result;
            try {
                result = JSON.parse(jsonStr);
            } catch (e) {
                console.error('[AI导演拆解] 解析 JSON 失败:', e, '内容前500字符:', jsonStr.substring(0, 500));
                // 尝试修复
                try {
                    jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                    jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                    result = JSON.parse(jsonStr);
                } catch (e2) {
                    console.error('[AI导演拆解] JSON修复后仍解析失败:', e2, '原始内容:', jsonStr.substring(0, 500));
                    throw new Error(`模型返回的不是有效的 JSON 格式。原始内容: ${jsonStr.substring(0, 200)}`);
                }
            }

            // 处理 voiceover_script，转换为 voiceoverResults 格式
            const voiceoverResults = (result.voiceover_script || []).map((v, idx) => ({
                time: idx,
                text: v.text || ''
            }));

            // 处理 scenes，转换为 analysisResults 格式
            const analysisResults = (result.scenes || []).map((scene, idx) => ({
                scene_index: scene.scene_id || idx + 1,
                time_range: scene.time_range || '',
                keyframes: [{
                    type: 'current',
                    time: 0,
                    description: `${scene.visual_analysis?.camera_movement || ''} ${scene.visual_analysis?.subject_dynamics || ''}`.trim(),
                    mj_prompt: scene.prompts?.mj_prompt || '',
                    jimeng_prompt: scene.prompts?.jimeng_prompt || ''
                }],
                global_tags: {
                    style: scene.visual_analysis?.atmosphere ? [scene.visual_analysis.atmosphere] : [],
                    camera: scene.visual_analysis?.camera_movement ? [scene.visual_analysis.camera_movement] : [],
                    color: []
                }
            }));

            // 更新节点状态
            setNodes((prev) => prev.map((n) => {
                if (n.id === nodeId) {
                    return {
                        ...n,
                        isGenerating: false,
                        settings: {
                            ...n.settings,
                            voiceoverResults,
                            analysisResults
                        }
                    };
                }
                return n;
            }));

            // 自动创建分镜表节点
            if (analysisResults.length > 0) {
                setTimeout(() => {
                    createStoryboardFromAnalysisResult(nodeId, analysisResults);
                }, 100); // 延迟100ms确保节点状态已更新
            }

        } catch (error) {
            console.error('AI视频分析失败:', error);
            const errorMsg = error.message || 'AI视频分析失败';
            setNodes((prev) => prev.map((n) =>
                n.id === nodeId
                    ? { ...n, isGenerating: false, errorMsg: errorMsg }
                    : n
            ));
            // 不显示 alert，错误信息已经在节点上显示
            // alert(`AI视频分析失败: ${errorMsg}`);
        }
    };

    const addPromptLibraryItem = () => {
        const name = promptLibraryForm.name.trim();
        const prompt = promptLibraryForm.prompt.trim();
        if (!name || !prompt) {
            alert(t('请输入名称和提示词内容'));
            return;
        }
        setPromptLibrary((prev) => [
            { id: `custom-${Date.now()}`, name, prompt },
            ...prev
        ]);
        setPromptLibraryForm({ name: '', prompt: '' });
    };
    const removePromptLibraryItem = (id) => {
        setPromptLibrary((prev) => prev.filter((p) => p.id !== id));
    };
    const applyLibraryPrompt = (nodeId, promptText) => {
        if (!nodeId || !promptText) return;
        updateNodeSettings(nodeId, { prompt: promptText });
    };

    // 生成九宫格分镜脚本提示词
    const generateGridPrompt = () => {
        const currentSelectedId = selectedNodeIdRef.current;
        if (!currentSelectedId) {
            alert(t('请先选中一个AI绘图节点'));
            return;
        }

        const targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
        if (!targetNode || targetNode.type !== 'gen-image') {
            alert(t('请选中一个AI绘图节点（gen-image）'));
            return;
        }

        // 获取连接的参考图
        const connectedImages = getConnectedInputImages(targetNode.id, 'default');
        const hasReferenceImage = connectedImages.length > 0;

        // 生成提示词
        const gridPrompt = hasReferenceImage
            ? GRID_PROMPT_TEXT
            : `生成一张九宫格（3x3 grid）布局的分镜脚本。在9个格子中展示同一个角色不同的动作、表情和拍摄角度（如正面、侧面、背面、特写等）。要求风格高度统一，形成一张完整的角色动态表（Character Sheet）。`;

        // 更新节点的提示词，保持模型、分辨率、比例不变
        updateNodeSettings(targetNode.id, { prompt: gridPrompt });

        // 提示用户
        alert(t('已生成九宫格分镜脚本提示词！'));
    };

    // 智能拆分放大：直接生成提示词
    const handleUpscale = () => {
        const currentSelectedId = selectedNodeIdRef.current;
        if (!currentSelectedId) {
            alert(t('请选择图片生成节点进行放大。'));
            return;
        }

        const targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
        if (!targetNode || targetNode.type !== 'gen-image') {
            alert(t('请选择图片生成节点进行放大。'));
            return;
        }

        const upscalePrompt = UPSCALE_PROMPT_TEXT;

        // 更新节点的提示词
        updateNodeSettings(targetNode.id, { prompt: upscalePrompt });

        // 提示用户
        alert(t('已生成高清放大提示词！'));
    };

    // 切割九宫格图片（3x3网格）
    const splitGridImage = async (imageUrl) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';

            const timeout = setTimeout(() => {
                reject(new Error('图片加载超时'));
            }, 30000);

            img.onload = () => {
                clearTimeout(timeout);
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // 九宫格是3x3网格，每张图是原图的1/3
                    const singleWidth = Math.floor(img.width / 3);
                    const singleHeight = Math.floor(img.height / 3);

                    const images = [];

                    // 切割9张图：按从上到下、从左到右的顺序（1-9）
                    const cropPromises = [];

                    for (let row = 0; row < 3; row++) {
                        for (let col = 0; col < 3; col++) {
                            const cropX = Math.max(0, Math.min(col * singleWidth, img.width - singleWidth));
                            const cropY = Math.max(0, Math.min(row * singleHeight, img.height - singleHeight));
                            const cropW = Math.min(singleWidth, img.width - cropX);
                            const cropH = Math.min(singleHeight, img.height - cropY);

                            const cropCanvas = document.createElement('canvas');
                            cropCanvas.width = cropW;
                            cropCanvas.height = cropH;
                            const cropCtx = cropCanvas.getContext('2d');

                            cropCtx.fillStyle = '#ffffff';
                            cropCtx.fillRect(0, 0, cropW, cropH);

                            cropCtx.drawImage(
                                img,
                                cropX, cropY, cropW, cropH,
                                0, 0, cropW, cropH
                            );

                            // 使用 toDataURL 替代 toBlob，避免 Blob URL 持久化问题
                            try {
                                const dataUrl = cropCanvas.toDataURL('image/png');
                                cropPromises.push(Promise.resolve({
                                    url: dataUrl,
                                    width: cropW,
                                    height: cropH
                                }));
                            } catch (e) {
                                console.error('Canvas toDataURL 失败:', e);
                            }
                        }
                    }

                    // 等待所有切割完成
                    Promise.all(cropPromises).then((results) => {
                        resolve(results);
                    }).catch((error) => {
                        reject(error);
                    });
                } catch (error) {
                    reject(error);
                }
            };

            img.onerror = () => {
                clearTimeout(timeout);
                reject(new Error('图片加载失败'));
            };

            img.src = imageUrl;
        });
    };

    // 裁切九宫格图片并创建节点
    const handleSplitGridImage = async () => {
        const currentSelectedId = selectedNodeIdRef.current;
        if (!currentSelectedId) {
            alert(t('请先选中一个图片节点'));
            return;
        }

        const targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
        if (!targetNode) {
            alert(t('未找到选中的节点'));
            return;
        }

        const imageUrl = targetNode.content;
        if (!imageUrl) {
            alert(t('选中的节点没有图片内容'));
            return;
        }

        try {
            // 切割图片
            const croppedImages = await splitGridImage(imageUrl);

            if (croppedImages.length !== 9) {
                alert(t('切割失败：未能生成9张图片'));
                return;
            }

            // 获取原节点的位置和尺寸
            const sourceX = targetNode.x;
            const sourceY = targetNode.y;
            const sourceWidth = targetNode.width || 260;
            const nodeWidth = 260;
            const nodeHeight = 260;
            const spacing = 20;

            const cols = 3;
            const rows = 3;

            // 计算起始位置：位于原图的右侧开始排列
            const startX = sourceX + sourceWidth + spacing;
            const startY = sourceY;

            // 创建9个新节点
            const newNodes = [];
            for (let i = 0; i < croppedImages.length; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = startX + col * (nodeWidth + spacing);
                const y = startY + row * (nodeHeight + spacing);

                const newNode = {
                    id: `node-${Date.now()}-${i}`,
                    type: 'input-image',
                    x: x,
                    y: y,
                    width: nodeWidth,
                    height: nodeHeight,
                    content: croppedImages[i].url,
                    dimensions: { w: croppedImages[i].width, h: croppedImages[i].height }
                };
                newNodes.push(newNode);
            }

            setNodes(prev => [...prev, ...newNodes]);
            // 静默创建，不显示成功提示
        } catch (error) {
            alert('切割失败: ' + error.message);
        }
    };

    const handleSplitGridFromUrl = async (imageUrl, options = {}) => {
        if (!imageUrl) return;
        const {
            originX,
            originY,
            cols = 3,
            spacing = 20,
            nodeWidth = 260,
            nodeHeight = 260,
            replaceSelected = false, // 是否替换已选中的节点
        } = options;

        try {
            const croppedImages = await splitGridImage(imageUrl);
            if (croppedImages.length !== 9) {
                alert(t('切割失败：未能生成9张图片'));
                return;
            }

            // 检查是否有框选的节点需要替换
            const currentSelectedIds = selectedNodeIdsRef.current;
            if (replaceSelected && currentSelectedIds && currentSelectedIds.size === 9) {
                // 替换模式：更新已选中的9个节点
                const selectedIdsArray = Array.from(currentSelectedIds);
                setNodes(prev => prev.map(node => {
                    const index = selectedIdsArray.indexOf(node.id);
                    if (index !== -1 && index < croppedImages.length) {
                        // 替换节点内容，保持位置和大小
                        return {
                            ...node,
                            content: croppedImages[index].url,
                            dimensions: {
                                w: croppedImages[index].width,
                                h: croppedImages[index].height
                            }
                        };
                    }
                    return node;
                }));
                // 静默替换，不显示提示
                return;
            }

            // 创建新节点模式（原有逻辑）
            const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
            const startX = originX !== undefined ? originX : world.x;
            const startY = originY !== undefined ? originY : world.y;
            const newNodes = [];
            for (let i = 0; i < croppedImages.length; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = startX + col * (nodeWidth + spacing);
                const y = startY + row * (nodeHeight + spacing);
                newNodes.push({
                    id: `node-${Date.now()}-${i}`,
                    type: 'input-image',
                    x,
                    y,
                    width: nodeWidth,
                    height: nodeHeight,
                    content: croppedImages[i].url,
                    dimensions: { w: croppedImages[i].width, h: croppedImages[i].height }
                });
            }
            setNodes(prev => [...prev, ...newNodes]);
            // 静默创建，不显示成功提示
        } catch (e) {
            alert('切割失败: ' + e.message);
        }
    };

    // 智能整理节点：DAG 层级布局 + 交叉最小化 (Barycenter Heuristic)
    const autoArrangeNodes = () => {
        // 1. 获取选中的节点
        const currentSelectedId = selectedNodeIdRef.current;
        const currentSelectedIds = selectedNodeIdsRef.current;

        let nodesToArrange = [];

        if (currentSelectedId) {
            const node = nodesRef.current.find(n => n.id === currentSelectedId);
            if (node) nodesToArrange = [node];
        } else if (currentSelectedIds && currentSelectedIds.size > 0) {
            nodesToArrange = nodesRef.current.filter(n => currentSelectedIds.has(n.id));
        }

        if (nodesToArrange.length < 2) {
            alert(t('请至少选中两个节点进行智能整理'));
            return;
        }

        const targetNodeIds = new Set(nodesToArrange.map(n => n.id));

        // 2. 构建图结构
        // map: id -> graphNode
        const graph = {};
        nodesToArrange.forEach(n => {
            graph[n.id] = {
                id: n.id,
                node: n,
                parents: [],
                children: [],
                level: 0,
                rank: 0 // 用于层内排序
            };
        });

        connectionsRef.current.forEach(conn => {
            if (targetNodeIds.has(conn.from) && targetNodeIds.has(conn.to)) {
                graph[conn.from].children.push(conn.to);
                graph[conn.to].parents.push(conn.from);
            }
        });

        // 3. 计算层级 (Assign Layers) - Longest Path Layering
        // 找出入度为0的节点
        let roots = Object.values(graph).filter(n => n.parents.length === 0);

        // 处理环路或纯独立节点：如果没有根，取第一个
        if (roots.length === 0 && nodesToArrange.length > 0) {
            roots = [Object.values(graph)[0]];
        }

        // 计算每个节点的深度 level
        const calcLevels = () => {
            const queue = roots.map(r => ({ node: r, lvl: 0 }));
            const visited = new Set();

            while (queue.length > 0) {
                const { node, lvl } = queue.shift();
                // 只有当该节点未访问，或者发现了更长的路径时更新
                if (lvl >= node.level) {
                    node.level = lvl;
                    // 只有当该节点的所有父节点都处理过，或者它是根节点时，才继续往下（简化版拓扑排序）
                    // 这里为了简单，直接遍历子节点
                    node.children.forEach(childId => {
                        const childNode = graph[childId];
                        if (childNode) {
                            // 避免环路无限循环：限制最大深度
                            if (lvl < 20) {
                                queue.push({ node: childNode, lvl: lvl + 1 });
                            }
                        }
                    });
                }
            }
        };
        calcLevels();

        // 4. 构建层级数组
        // layers: [ [node, node], [node], ... ]
        const maxLevel = Math.max(...Object.values(graph).map(n => n.level));
        const layers = Array.from({ length: maxLevel + 1 }, () => []);

        Object.values(graph).forEach(n => {
            layers[n.level].push(n);
        });

        // 5. 交叉最小化 (Crossing Minimization) - Iterative Barycenter Method
        // 初始排序：保持目前的相对顺序或ID顺序
        layers.forEach(layer => {
            layer.sort((a, b) => a.node.y - b.node.y);
        });

        // 迭代次数，比如做 3 次往返扫描
        const iterations = 3;

        for (let i = 0; i < iterations; i++) {
            // Forward Sweep (从左往右): 子节点跟随父节点的重心
            for (let l = 1; l < layers.length; l++) {
                const layer = layers[l];
                layer.forEach(n => {
                    if (n.parents.length > 0) {
                        let sumRank = 0;
                        n.parents.forEach(pid => {
                            // 找到父节点在上一层中的索引位置(rank)
                            const parentNode = graph[pid];
                            const parentLayerIndex = layers[l - 1].indexOf(parentNode);
                            if (parentLayerIndex !== -1) sumRank += parentLayerIndex;
                        });
                        n.barycenter = sumRank / n.parents.length;
                    } else {
                        n.barycenter = layers[l].indexOf(n); // 保持原位
                    }
                });
                // 根据重心排序
                layer.sort((a, b) => (a.barycenter || 0) - (b.barycenter || 0));
            }

            // Backward Sweep (从右往左): 父节点跟随子节点的重心
            // 这一步对于解决图中的那种"输入节点乱序导致连线交叉"非常关键
            for (let l = layers.length - 2; l >= 0; l--) {
                const layer = layers[l];
                layer.forEach(n => {
                    if (n.children.length > 0) {
                        let sumRank = 0;
                        n.children.forEach(cid => {
                            const childNode = graph[cid];
                            const childLayerIndex = layers[l + 1].indexOf(childNode);
                            if (childLayerIndex !== -1) sumRank += childLayerIndex;
                        });
                        n.barycenter = sumRank / n.children.length;
                    } else {
                        n.barycenter = layers[l].indexOf(n);
                    }
                });
                layer.sort((a, b) => (a.barycenter || 0) - (b.barycenter || 0));
            }
        }

        // 6. 计算最终坐标 (Coordinate Assignment)
        const startX = Math.min(...nodesToArrange.map(n => n.x));
        const startY = Math.min(...nodesToArrange.map(n => n.y));
        const H_SPACING = 150; // 加宽一点水平间距，给连线留空间
        const V_SPACING = 40;  // 垂直间距

        let currentX = startX;
        const updatedNodesMap = new Map();

        layers.forEach((layer, lIndex) => {
            if (layer.length === 0) return;

            // 计算该层最宽的节点，用于推算下一层的X
            const maxW = Math.max(...layer.map(n => n.node.width || 260));

            // 计算该层总高度，用于垂直居中对齐整个层
            const totalH = layer.reduce((sum, n) => sum + (n.node.height || 200), 0) + (layer.length - 1) * V_SPACING;

            // 简单的垂直排列，从 startY 开始
            // 进阶优化：可以让层与层之间垂直中心对齐，但这里简单排列通常就够了
            let currentY = startY;

            layer.forEach(graphNode => {
                updatedNodesMap.set(graphNode.id, {
                    ...graphNode.node,
                    x: currentX,
                    y: currentY
                });
                currentY += (graphNode.node.height || 200) + V_SPACING;
            });

            currentX += maxW + H_SPACING;
        });

        // 7. 应用更新
        setNodes(prev => prev.map(node => {
            if (updatedNodesMap.has(node.id)) {
                return updatedNodesMap.get(node.id);
            }
            return node;
        }));
    };



    const insertKeyframesFromUrls = useCallback((nodeId, urls, insertIdx = null) => {
        const existingNode = nodesMap.get(nodeId);
        if (!existingNode) return;
        const existingFrames = existingNode?.frames || [];
        const existingKeyframes = existingNode?.selectedKeyframes || [];
        const validUrls = (urls || []).filter(Boolean);
        if (validUrls.length === 0) return;

        const newKeyframes = validUrls.map((url, idx) => ({
            time: Date.now() + idx,
            url,
            filename: ''
        }));

        const targetIndex = insertIdx !== null ? insertIdx : existingFrames.length;
        const updatedFrames = [
            ...existingFrames.slice(0, targetIndex),
            ...newKeyframes,
            ...existingFrames.slice(targetIndex)
        ];
        const framesToSelect = new Set([...existingKeyframes, ...newKeyframes]);
        const normalizedFrames = updatedFrames.map((f, i) => ({ ...f, time: i }));
        const newSelectedKeyframes = normalizedFrames.filter((_, i) => framesToSelect.has(updatedFrames[i]));

        setNodes(prev => prev.map(n =>
            n.id === nodeId
                ? { ...n, frames: normalizedFrames, selectedKeyframes: newSelectedKeyframes }
                : n
        ));
    }, [nodesMap, setNodes]);

    const handleVideoDrop = async (nodeId, e) => {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.remove('drag-over');

        const payload = getHistoryDragPayload(e);
        if (payload) {
            const dragUrl = resolveDroppedUrlCandidate(resolveHistoryPayloadUrl(payload), payload.type);
            if (dragUrl) {
                const isVideo = payload.type === 'video' || isVideoUrl(dragUrl);
                if (isVideo) {
                    let videoMeta = { duration: 0, w: 0, h: 0 };
                    try {
                        const metaUrl = await resolveUrlForMediaMeta(dragUrl);
                        videoMeta = await getVideoMetadata(metaUrl);
                    } catch { }
                    saveToUndoStack();
                    setNodes(prev => prev.map(n =>
                        n.id === nodeId
                            ? { ...n, content: dragUrl, videoMeta, frames: [], selectedKeyframes: [], extractingFrames: false, videoFileName: '' }
                            : n
                    ));
                } else {
                    insertKeyframesFromUrls(nodeId, [dragUrl]);
                }
                return;
            }
        }

        const dragUrlCandidate = resolveDroppedUrlCandidate(getDragUrlCandidate(e));
        if (dragUrlCandidate) {
            if (isVideoUrl(dragUrlCandidate)) {
                let videoMeta = { duration: 0, w: 0, h: 0 };
                try {
                    const metaUrl = await resolveUrlForMediaMeta(dragUrlCandidate);
                    videoMeta = await getVideoMetadata(metaUrl);
                } catch { }
                saveToUndoStack();
                setNodes(prev => prev.map(n =>
                    n.id === nodeId
                        ? { ...n, content: dragUrlCandidate, videoMeta, frames: [], selectedKeyframes: [], extractingFrames: false, videoFileName: '' }
                        : n
                ));
            } else {
                insertKeyframesFromUrls(nodeId, [dragUrlCandidate]);
            }
            return;
        }

        const files = Array.from(e.dataTransfer.files);

        // V3.5.17: Handle video files
        const videoFile = files.find(file => file.type.startsWith('video/'));
        if (videoFile) {
            handleVideoFileUpload(nodeId, videoFile);
            return;
        }

        // V3.5.17: Handle image files - add as keyframes for keyframe organizer
        const imageFiles = files.filter(file => file.type.startsWith('image/'));
        // V3.5.19: Sort by filename naturally (1, 2, 10)
        imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

        if (imageFiles.length > 0) {
            // Get existing data from node
            const existingNode = nodesMap.get(nodeId);
            const existingFrames = existingNode?.frames || [];
            const existingKeyframes = existingNode?.selectedKeyframes || [];

            // Read all images and save to IndexedDB to avoid localStorage quota
            let loadedCount = 0;
            const newKeyframes = [];

            imageFiles.forEach((file, idx) => {
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    const base64Data = ev.target.result;

                    // Save to IndexedDB and get img_id
                    const imgId = await LocalImageManager.saveImage(base64Data);

                    newKeyframes[idx] = {
                        time: existingFrames.length + idx,  // Use frames count for time
                        url: imgId,  // Store img_id instead of base64
                        filename: file.name
                    };
                    loadedCount++;

                    // When all images loaded, update node once
                    if (loadedCount === imageFiles.length) {
                        const validKeyframes = newKeyframes.filter(Boolean);
                        setNodes(prev => prev.map(n =>
                            n.id === nodeId
                                ? {
                                    ...n,
                                    frames: [...existingFrames, ...validKeyframes],  // Add to frames for display
                                    selectedKeyframes: [...existingKeyframes, ...validKeyframes]  // Also pre-select
                                }
                                : n
                        ));
                    }
                };
                reader.readAsDataURL(file);
            });
        }
    };

    // V3.5.20: Drag & Drop Insert Logic Handlers
    const handleKeyframeItemDragOver = (e, nodeId, idx) => {
        e.preventDefault(); e.stopPropagation();
        const rect = e.currentTarget.getBoundingClientRect();
        // Determine insertion point: left half = before, right half = after
        const isRightHalf = (e.clientX - rect.left) > (rect.width / 2);
        const insertIdx = isRightHalf ? idx + 1 : idx;

        if (dragInsertIndex !== insertIdx || dragInsertNodeId !== nodeId) {
            setDragInsertIndex(insertIdx);
            setDragInsertNodeId(nodeId);
        }
    };

    const handleKeyframeContainerDragOver = (e, nodeId, length) => {
        e.preventDefault(); e.stopPropagation();
        // If hovering directly over empty space in container, default to append
        if (e.target === e.currentTarget) {
            if (dragInsertIndex !== length || dragInsertNodeId !== nodeId) {
                setDragInsertIndex(length);
                setDragInsertNodeId(nodeId);
            }
        }
    };

    const handleKeyframeListDrop = (nodeId, e) => {
        e.preventDefault();
        e.stopPropagation();

        // Calculate insertion index
        let insertIdx = (dragInsertNodeId === nodeId && dragInsertIndex !== null)
            ? dragInsertIndex
            : (nodesMap.get(nodeId)?.frames || []).length;

        // Reset drag state
        setDragInsertNodeId(null);
        setDragInsertIndex(null);

        const payload = getHistoryDragPayload(e);
        if (payload) {
            const dragUrl = resolveDroppedUrlCandidate(resolveHistoryPayloadUrl(payload), payload.type);
            if (dragUrl && !(payload.type === 'video' || isVideoUrl(dragUrl))) {
                insertKeyframesFromUrls(nodeId, [dragUrl], insertIdx);
            }
            return;
        }

        const dragUrlCandidate = resolveDroppedUrlCandidate(getDragUrlCandidate(e));
        if (dragUrlCandidate && !isVideoUrl(dragUrlCandidate)) {
            insertKeyframesFromUrls(nodeId, [dragUrlCandidate], insertIdx);
            return;
        }

        const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
        if (files.length === 0) return;

        // Sort files by name
        files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

        const existingNode = nodesMap.get(nodeId);
        const existingFrames = existingNode?.frames || [];
        const existingKeyframes = existingNode?.selectedKeyframes || [];

        let loadedCount = 0;
        const newKeyframes = [];

        files.forEach((file, idx) => {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                const base64Data = ev.target.result;
                const imgId = await LocalImageManager.saveImage(base64Data);

                // V3.7.6: Create blob URL immediately so it can be displayed
                let displayUrl = base64Data; // Fallback to base64
                try {
                    const blob = await LocalImageManager.getImage(imgId);
                    if (blob) displayUrl = URL.createObjectURL(blob);
                } catch (e) {
                    console.warn('[KeyframeOrganizer] Failed to create blob URL, using base64:', e);
                }

                newKeyframes[idx] = {
                    time: Date.now() + idx,
                    url: displayUrl,
                    imgId: imgId, // Keep ID for persistence
                    filename: file.name
                };
                loadedCount++;

                if (loadedCount === files.length) {
                    const validNewFrames = newKeyframes.filter(Boolean);

                    // Insert into frames array
                    const updatedFrames = [
                        ...existingFrames.slice(0, insertIdx),
                        ...validNewFrames,
                        ...existingFrames.slice(insertIdx)
                    ];

                    // 识别哪些关键帧应该被选中（现有选中的 + 新添加的）
                    const framesToSelect = new Set([...existingKeyframes, ...validNewFrames]);

                    // 根据索引重新计算时间（标准化） - 这一步会创建带有新时间的新对象
                    const normalizedFrames = updatedFrames.map((f, i) => ({ ...f, time: i }));

                    // 从 normalizedFrames 重新构建 selectedKeyframes，确保它们匹配新的对象/时间
                    // 我们利用 updatedFrames（源引用）和 normalizedFrames 之间的索引对齐
                    // 逻辑：如果 updatedFrames[i]（原始对象）在 framesToSelect 集合中，则选中对应的 normalizedFrames[i]（新对象）
                    const newSelectedKeyframes = normalizedFrames.filter((_, i) => framesToSelect.has(updatedFrames[i]));

                    setNodes(prev => prev.map(n =>
                        n.id === nodeId
                            ? {
                                ...n,
                                frames: normalizedFrames,
                                selectedKeyframes: newSelectedKeyframes
                            }
                            : n
                    ));
                }
            };
            reader.readAsDataURL(file);
        });
    };

    // 智能抽帧：场景检测算法
    const detectScenesAndCapture = async (videoUrl, threshold = 30) => {
        return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            video.crossOrigin = "anonymous";
            video.src = videoUrl;
            video.muted = true;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            const keyframes = [];
            let prevData = null;

            video.onloadeddata = async () => {
                canvas.width = 320;
                canvas.height = Math.floor(320 * (video.videoHeight / video.videoWidth));

                const duration = video.duration;
                const sampleRate = 2;

                video.currentTime = 0;

                const scan = async () => {
                    // 检查是否已经扫描完成
                    const currentTime = video.currentTime;
                    if (currentTime >= duration || Math.abs(currentTime - duration) < 0.01) {
                        // 确保最后一帧也被包含
                        if (keyframes.length === 0 || parseFloat(keyframes[keyframes.length - 1].time) < duration - 0.5) {
                            const hdCanvas = document.createElement('canvas');
                            hdCanvas.width = video.videoWidth;
                            hdCanvas.height = video.videoHeight;
                            const hdCtx = hdCanvas.getContext('2d');
                            video.currentTime = Math.max(0, duration - 0.1);
                            await new Promise(r => {
                                const timeout = setTimeout(() => r(), 200);
                                video.onseeked = () => {
                                    clearTimeout(timeout);
                                    hdCtx.drawImage(video, 0, 0);
                                    const lastTime = Math.max(0, duration - 0.1);
                                    keyframes.push({
                                        time: lastTime.toFixed(2),
                                        image: hdCanvas.toDataURL('image/jpeg', 0.8)
                                    });
                                    r();
                                };
                            });
                        }
                        resolve(keyframes.map(kf => ({ time: parseFloat(kf.time), url: kf.image })));
                        return;
                    }

                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const frameData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

                    if (prevData) {
                        let diff = 0;
                        for (let i = 0; i < frameData.length; i += 4) {
                            diff += Math.abs(frameData[i] - prevData[i]) +
                                Math.abs(frameData[i + 1] - prevData[i + 1]) +
                                Math.abs(frameData[i + 2] - prevData[i + 2]);
                        }
                        const avgDiff = diff / (frameData.length / 4 * 3);

                        if (avgDiff > threshold) {
                            const hdCanvas = document.createElement('canvas');
                            hdCanvas.width = video.videoWidth;
                            hdCanvas.height = video.videoHeight;
                            hdCanvas.getContext('2d').drawImage(video, 0, 0);
                            const dataUrl = hdCanvas.toDataURL('image/jpeg', 0.8);

                            // 确保使用实际的currentTime，而不是字符串
                            const captureTime = video.currentTime;
                            keyframes.push({
                                time: captureTime.toFixed(2),
                                image: dataUrl
                            });
                            prevData = null;
                        } else {
                            prevData = frameData;
                        }
                    } else {
                        // 第一帧，记录当前时间（确保使用实际的currentTime）
                        prevData = frameData;
                        const currentTime = video.currentTime;
                        const hdCanvas = document.createElement('canvas');
                        hdCanvas.width = video.videoWidth;
                        hdCanvas.height = video.videoHeight;
                        hdCanvas.getContext('2d').drawImage(video, 0, 0);
                        keyframes.push({
                            time: currentTime.toFixed(2),
                            image: hdCanvas.toDataURL('image/jpeg', 0.8)
                        });
                    }

                    // 更新到下一个采样点
                    const nextTime = video.currentTime + (1 / sampleRate);
                    if (nextTime >= duration) {
                        // 确保最后一帧也被包含
                        if (keyframes.length === 0 || parseFloat(keyframes[keyframes.length - 1].time) < duration - 0.5) {
                            const hdCanvas = document.createElement('canvas');
                            hdCanvas.width = video.videoWidth;
                            hdCanvas.height = video.videoHeight;
                            const hdCtx = hdCanvas.getContext('2d');
                            video.currentTime = Math.max(0, duration - 0.1);
                            await new Promise(r => {
                                const timeout = setTimeout(() => r(), 200);
                                video.onseeked = () => {
                                    clearTimeout(timeout);
                                    hdCtx.drawImage(video, 0, 0);
                                    const lastTime = Math.max(0, duration - 0.1);
                                    keyframes.push({
                                        time: lastTime.toFixed(2),
                                        image: hdCanvas.toDataURL('image/jpeg', 0.8)
                                    });
                                    r();
                                };
                            });
                        }
                        resolve(keyframes.map(kf => ({ time: parseFloat(kf.time), url: kf.image })));
                        return;
                    }
                    video.currentTime = nextTime;
                    await new Promise(r => {
                        const timeout = setTimeout(() => r(), 200); // 超时保护
                        video.onseeked = () => {
                            clearTimeout(timeout);
                            r();
                        };
                    });
                    scan();
                };

                scan();
            };

            video.onerror = (e) => reject(new Error("视频加载失败，请检查格式或跨域设置"));
        });
    };

    const handleAutoExtractKeyframes = async (nodeId, fps = 2) => {
        const node = nodesMap.get(nodeId);
        if (!node?.content) return;
        setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: true } : n));
        try {
            const frames = await extractKeyFrames(node.content, { fps });
            setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, frames, selectedKeyframes: [], extractingFrames: false } : n));
        } catch (error) {
            console.error('视频抽帧失败', error);
            setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: false } : n));
        }
    };

    const handleSmartExtractKeyframes = async (nodeId, threshold = 30) => {
        const node = nodesMap.get(nodeId);
        if (!node?.content) return;
        setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: true } : n));
        try {
            const frames = await detectScenesAndCapture(node.content, threshold);
            setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, frames, selectedKeyframes: [], extractingFrames: false } : n));
        } catch (error) {
            console.error('智能抽帧失败', error);
            alert(`智能抽帧失败: ${error.message}`);
            setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: false } : n));
        }
    };

    // 提取口播文案
    const handleExtractVoiceover = async (nodeId) => {
        const node = nodesMap.get(nodeId);
        if (!node || node.type !== 'video-analyze') return;

        const videoInputNode = getConnectedVideoInputNode(nodeId);
        if (!videoInputNode || !videoInputNode.content) {
            alert(t('请先连接一个包含视频的视频输入节点'));
            return;
        }

        const modelId = node.settings?.model || 'gemini-3-pro';
        // V3.4.8: 使用 getApiCredentials 获取 Provider 配置
        const { key: apiKey, url: baseUrl } = getApiCredentials(modelId);

        if (!apiKey) {
            alert(t('请先在 API 设置中配置 Key'));
            setSettingsOpen(true);
            return;
        }

        setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isExtractingVoiceover: true, voiceoverResults: [] } : n));

        const videoFileName = videoInputNode.videoFileName || 'video.mp4';
        const videoDuration = videoInputNode.videoMeta?.duration || 0;

        try {
            // 构建多模态消息，请求提取口播文案
            const systemPrompt = `你是一个专业的视频口播文案提取助手。请分析提供的视频，提取每一秒的口播内容。

请返回严格的 JSON 格式，结构如下：
{
  "video_id": "${videoFileName}",
  "duration": ${videoDuration},
  "voiceover": [
    {
      "time": 0,
      "text": "第一秒的口播内容"
    },
    {
      "time": 1,
      "text": "第二秒的口播内容"
    },
    {
      "time": 2,
      "text": "第三秒的口播内容"
    }
  ]
}

要求：
1. 按秒为单位提取口播内容
2. 如果某一秒没有口播，text 字段为空字符串
3. 准确记录每一秒的说话内容
4. 只提取口播文案，不要添加其他描述`;

            // 从视频中提取关键帧用于分析（每5秒一帧，避免太多）
            const sampleFrames = [];
            const video = document.createElement('video');
            video.crossOrigin = 'anonymous';
            video.src = videoInputNode.content;
            video.muted = true;

            await new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');

                    let currentTime = 0;
                    const extractFrame = async () => {
                        if (currentTime >= videoDuration) {
                            resolve();
                            return;
                        }

                        video.currentTime = currentTime;
                        await new Promise((r) => {
                            video.onseeked = () => {
                                ctx.drawImage(video, 0, 0);
                                const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                                sampleFrames.push({
                                    time: currentTime,
                                    url: dataUrl
                                });
                                currentTime += 5; // 每5秒一帧
                                setTimeout(r, 50);
                            };
                        });
                        extractFrame();
                    };
                    extractFrame();
                };
            });

            // 构建用户消息，包含视频帧
            const userContent = [
                { type: "text", text: `请分析以下视频，提取每一秒的口播文案。视频总时长：${videoDuration.toFixed(1)}秒。` }
            ];

            // 添加关键帧（每5秒一帧，避免太多）
            sampleFrames.forEach((frame) => {
                userContent.push({
                    type: "image_url",
                    image_url: { url: frame.url }
                });
                userContent.push({
                    type: "text",
                    text: `时间点：${frame.time.toFixed(1)}秒`
                });
            });

            const apiMessages = [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userContent }
            ];

            const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: config?.id || 'gemini-3-pro', // V3.7.24: 使用 config.id
                    messages: apiMessages,
                    stream: false
                })
            });

            if (!response.ok) {
                const errText = await response.text();
                throw new Error(errText || `API Error: ${response.status}`);
            }

            const data = await response.json();
            const aiContent = data.choices?.[0]?.message?.content || "{}";

            // 解析 JSON
            let jsonStr = aiContent.trim();
            if (jsonStr.startsWith('```')) {
                jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
            }

            let result;
            try {
                result = JSON.parse(jsonStr);
            } catch (e) {
                console.error('解析 JSON 失败:', e, jsonStr);
                // 尝试修复
                try {
                    jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                    jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                    result = JSON.parse(jsonStr);
                } catch (e2) {
                    throw new Error('模型返回的不是有效的 JSON 格式');
                }
            }

            // 更新节点状态
            setNodes((prev) => prev.map((n) =>
                n.id === nodeId
                    ? { ...n, isExtractingVoiceover: false, voiceoverResults: result.voiceover || [] }
                    : n
            ));

        } catch (error) {
            console.error('提取口播文案失败', error);
            setNodes((prev) => prev.map((n) =>
                n.id === nodeId
                    ? { ...n, isExtractingVoiceover: false, errorMsg: error.message || '提取口播文案失败' }
                    : n
            ));
        }
    };

    const handleToggleKeyframe = (nodeId, frame, index = 0, event = null) => {
        const shiftKey = !!event?.shiftKey;
        setNodes(prev => prev.map(n => {
            if (n.id !== nodeId) return n;
            const frames = n.frames || [];
            const keyOf = (f) => `${f.time}-${f.url}`;
            const frameMap = new Map(frames.map(f => [keyOf(f), f]));
            const currentSelected = n.selectedKeyframes || [];
            let nextSelected = [...currentSelected];

            if (shiftKey && frameSelectionRef.current[nodeId] !== undefined && frameSelectionRef.current[nodeId] !== null && frames.length > 0) {
                const lastIndex = frameSelectionRef.current[nodeId];
                const start = Math.min(lastIndex, index);
                const end = Math.max(lastIndex, index);
                const rangeFrames = frames.slice(start, end + 1);
                const selectedKeys = new Set(nextSelected.map(keyOf));
                rangeFrames.forEach(f => selectedKeys.add(keyOf(f)));
                nextSelected = Array.from(selectedKeys).map(k => frameMap.get(k)).filter(Boolean);
            } else {
                const exists = nextSelected.some(f => keyOf(f) === keyOf(frame));
                nextSelected = exists
                    ? nextSelected.filter(f => keyOf(f) !== keyOf(frame))
                    : [...nextSelected, frame];
            }

            frameSelectionRef.current[nodeId] = index;
            return { ...n, selectedKeyframes: nextSelected };
        }));
    };

    const openFrameContextMenu = (e, nodeId, frame) => {
        e.preventDefault();
        e.stopPropagation();
        setFrameContextMenu({ visible: true, x: e.clientX, y: e.clientY, nodeId, frame });
    };

    const closeFrameContextMenu = () => {
        setFrameContextMenu({ visible: false, x: 0, y: 0, nodeId: null, frame: null });
    };

    const sendFrameToChat = () => {
        const { frame } = frameContextMenu;
        if (!frame?.url) return;
        const newFile = {
            name: `Frame-${(frame.time ?? 0).toFixed(2)}s.png`,
            type: 'image/png',
            content: frame.url,
            isImage: true,
            isVideo: false,
            isAudio: false,
            fromHistory: true,
            fileExt: 'png'
        };
        setChatFiles(prev => [...prev, newFile]);
        setIsChatOpen(true);
        closeFrameContextMenu();
    };

    const sendFrameToCanvas = async () => {
        const { frame } = frameContextMenu;
        if (!frame?.url) return;

        let imageUrl = frame.url;

        // 如果是 Blob URL，转换为 data URL（避免项目保存后失效）
        if (imageUrl.startsWith('blob:')) {
            try {
                const base64 = await getBase64FromUrl(imageUrl);
                imageUrl = `data:image/png;base64,${base64}`;
            } catch (e) {
                console.error('⚠️ Blob URL 转换失败，使用原始 URL:', e);
            }
        }

        let dims;
        try {
            const real = await getImageDimensions(imageUrl);
            if (real?.w && real?.h) dims = { w: real.w, h: real.h };
        } catch (e) { }

        // V3.4.12: 修复层叠逻辑 - 找最后一个 input-image 节点位置作为基准
        const inputImageNodes = nodes.filter(n => n.type === 'input-image');
        let baseX, baseY;

        if (inputImageNodes.length > 0) {
            // 使用最后一个 input-image 节点的位置
            const lastNode = inputImageNodes[inputImageNodes.length - 1];
            baseX = lastNode.x - 40;  // 向左偏移
            baseY = lastNode.y + 35;  // 向下偏移
        } else {
            // 没有 input-image 节点时使用屏幕中心
            const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
            baseX = world.x + 50;
            baseY = world.y + 50;
        }

        // 检查目标位置是否有重叠，继续偏移
        let targetX = baseX;
        let targetY = baseY;
        const checkOverlap = (x, y) => nodes.some(n =>
            Math.abs(n.x - x) < 80 && Math.abs(n.y - y) < 80
        );
        let attempts = 0;
        while (checkOverlap(targetX, targetY) && attempts < 50) {
            targetX -= 40;
            targetY += 35;
            attempts++;
        }

        addNode('input-image', targetX, targetY, null, imageUrl, dims);
        closeFrameContextMenu();
    };

    const sendFrameToPreview = () => {
        const { frame } = frameContextMenu;
        if (!frame?.url) return;
        setNodes(prev => {
            // 优先使用当前选中的预览节点
            const selectedId = selectedNodeIdRef.current;
            const selectedIds = selectedNodeIdsRef.current;
            const previews = prev.filter(n => n.type === 'preview');
            if (!previews.length) return prev;

            // 先查找选中的预览节点
            let targetId = null;
            if (selectedId) {
                const selectedPreview = previews.find(p => p.id === selectedId);
                if (selectedPreview) targetId = selectedPreview.id;
            }
            if (!targetId && selectedIds && selectedIds.size > 0) {
                const selectedPreview = previews.find(p => selectedIds.has(p.id));
                if (selectedPreview) targetId = selectedPreview.id;
            }
            // 如果没有选中预览节点，则默认使用最后一个预览窗口
            if (!targetId) {
                targetId = previews[previews.length - 1].id;
            }

            return prev.map(n =>
                n.id === targetId
                    ? { ...n, content: frame.url, previewType: 'image' }
                    : n
            );
        });
        closeFrameContextMenu();
    };

    const applyFrameToSelectedNode = () => {
        const { frame } = frameContextMenu;
        if (!frame?.url) return;
        const targetId = selectedNodeId;
        const targetNode = nodesMap.get(targetId);
        if (targetNode && targetNode.type === 'input-image') {
            setNodes(prev => prev.map(n => n.id === targetId ? { ...n, content: frame.url } : n));
        } else {
            alert(t('请先选择一个"图片输入"节点'));
        }
        closeFrameContextMenu();
    };

    const handleHistoryRightClick = (e, item, imageUrl = null, imageIndex = null) => {
        e.preventDefault();
        e.stopPropagation();
        // 如果提供了 imageUrl 和 imageIndex，说明是点击了多图中的某一张
        // 否则使用 item.url（单图情况）
        const selectedUrl = imageUrl ? resolveHistoryUrl(item, imageUrl) : resolveHistoryUrl(item);
        const selectedIndex = imageIndex !== null ? imageIndex : (item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : null);

        // 创建一个修改后的item，使用选中的图片URL
        const menuItem = {
            ...item,
            url: selectedUrl,
            selectedMjImageIndex: selectedIndex
        };

        const world = screenToWorld(e.clientX, e.clientY);
        setHistoryContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, item: menuItem });
        setHistorySendMenuOpen(false);
    };

    const applyHistoryToSelectedNode = () => {
        const item = historyContextMenu.item;
        const targetId = selectedNodeId;
        const targetNode = nodesMap.get(targetId);
        const resolvedUrl = resolveHistoryUrl(item);

        if (targetNode && targetNode.type === 'input-image' && resolvedUrl) {
            setNodes(prev => prev.map(n => n.id === targetId ? { ...n, content: resolvedUrl } : n));
        } else {
            alert(t('请先选择一个"图片输入"节点'));
        }
        setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
    };

    const applyHistoryToActiveShot = (item) => {
        if (!activeShot.nodeId || !activeShot.shotId) return false;
        const imageUrl = resolveHistoryUrl(item);
        if (!imageUrl) return false;
        if (item.type === 'video' || isVideoUrl(imageUrl)) {
            showToast('当前分镜仅支持图片参考', 'warning');
            return false;
        }
        updateShot(activeShot.nodeId, activeShot.shotId, { image_url: imageUrl, image_filename: '' });
        return true;
    };

    const getDefaultNodeSize = useCallback((type) => {
        if (type === 'video-input') return { w: 580, h: 460 };
        if (type === 'input-image') return { w: 260, h: 260 };
        return { w: 260, h: 260 };
    }, []);

    const createLinkedInputNode = useCallback(async (targetNode, url, isVideo) => {
        if (!targetNode || !url) return false;
        const nodeType = isVideo ? 'video-input' : 'input-image';
        const size = getDefaultNodeSize(nodeType);
        const gap = 40;
        const worldX = targetNode.x - gap - size.w / 2;
        const worldY = targetNode.y + (targetNode.height / 2);

        let dims = undefined;
        if (!isVideo) {
            try {
                const metaUrl = await resolveUrlForMediaMeta(url);
                dims = await getImageDimensions(metaUrl);
            } catch { }
        }

        const newNode = addNode(nodeType, worldX, worldY, null, url, dims, targetNode.id);

        if (isVideo && newNode?.id) {
            try {
                const metaUrl = await resolveUrlForMediaMeta(url);
                const videoMeta = await getVideoMetadata(metaUrl);
                setNodes(prev => prev.map(n =>
                    n.id === newNode.id
                        ? { ...n, content: url, videoMeta, frames: [], selectedKeyframes: [], extractingFrames: false, videoFileName: '' }
                        : n
                ));
            } catch { }
        }

        return true;
    }, [addNode, getDefaultNodeSize, resolveUrlForMediaMeta, setNodes]);

    const applyHistoryToNode = async (targetNode, item) => {
        if (!targetNode) return false;
        const resolvedUrl = normalizeHistoryVideoUrl(resolveHistoryUrl(item), item.type);
        if (!resolvedUrl) return false;

        if (targetNode.type === 'preview') {
            const previewImages = getHistoryMultiImages(item);
            const selectedIndex = item.selectedMjImageIndex ?? 0;
            const previewUrl = previewImages ? (previewImages[selectedIndex] || previewImages[0]) : resolvedUrl;
            setNodes(prev => prev.map(n =>
                n.id === targetNode.id
                    ? { ...n, content: previewUrl, previewType: item.type === 'video' || isVideoUrl(previewUrl) ? 'video' : 'image', previewMjImages: previewImages }
                    : n
            ));
            return true;
        }

        if (targetNode.type === 'input-image') {
            let dimensions = null;
            if (!isVideoUrl(resolvedUrl)) {
                try {
                    const metaUrl = await resolveUrlForMediaMeta(resolvedUrl);
                    dimensions = await getImageDimensions(metaUrl);
                } catch { }
            }
            setNodes(prev => prev.map(n =>
                n.id === targetNode.id
                    ? { ...n, content: resolvedUrl, dimensions: isVideoUrl(resolvedUrl) ? null : dimensions }
                    : n
            ));
            return true;
        }

        if (targetNode.type === 'video-input') {
            if (item.type === 'video' || isVideoUrl(resolvedUrl)) {
                let videoMeta = { duration: 0, w: 0, h: 0 };
                try {
                    const metaUrl = await resolveUrlForMediaMeta(resolvedUrl);
                    videoMeta = await getVideoMetadata(metaUrl);
                } catch { }
                setNodes(prev => prev.map(n =>
                    n.id === targetNode.id
                        ? { ...n, content: resolvedUrl, videoMeta, frames: [], selectedKeyframes: [], extractingFrames: false, videoFileName: '' }
                        : n
                ));
                return true;
            }
            insertKeyframesFromUrls(targetNode.id, [resolvedUrl]);
            return true;
        }

        if (targetNode.type === 'video-analyze') {
            const isVideo = item.type === 'video' || isVideoUrl(resolvedUrl);
            return await createLinkedInputNode(targetNode, resolvedUrl, isVideo);
        }

        if (targetNode.type === 'gen-image' || targetNode.type === 'gen-video' || targetNode.type === 'image-compare') {
            const isVideo = item.type === 'video' || isVideoUrl(resolvedUrl);
            if (isVideo && targetNode.type === 'gen-image') {
                showToast('AI 绘图仅支持图片输入', 'warning');
                return false;
            }
            if (isVideo && targetNode.type === 'image-compare') {
                showToast('图像对比仅支持图片输入', 'warning');
                return false;
            }
            return await createLinkedInputNode(targetNode, resolvedUrl, isVideo);
        }

        return false;
    };

    const handleVideoAnalyzeDrop = async (nodeId, e) => {
        e.preventDefault();
        e.stopPropagation();
        const targetNode = nodesMap.get(nodeId);
        if (!targetNode) return;

        const payload = getHistoryDragPayload(e);
        if (payload) {
            const dragUrl = resolveDroppedUrlCandidate(resolveHistoryPayloadUrl(payload), payload.type);
            if (dragUrl) {
                const isVideo = payload.type === 'video' || isVideoUrl(dragUrl);
                await createLinkedInputNode(targetNode, dragUrl, isVideo);
            }
            return;
        }

        const candidate = resolveDroppedUrlCandidate(getDragUrlCandidate(e));
        if (candidate) {
            await createLinkedInputNode(targetNode, candidate, isVideoUrl(candidate));
            return;
        }

        const files = Array.from(e.dataTransfer.files || []);
        const videoFile = files.find(file => file.type.startsWith('video/'));
        if (videoFile) {
            const size = getDefaultNodeSize('video-input');
            const gap = 40;
            const worldX = targetNode.x - gap - size.w / 2;
            const worldY = targetNode.y + (targetNode.height / 2);
            const newNode = addNode('video-input', worldX, worldY, null, undefined, undefined, targetNode.id);
            if (newNode?.id) {
                handleVideoFileUpload(newNode.id, videoFile);
            }
            return;
        }

        const imageFile = files.find(file => file.type.startsWith('image/'));
        if (imageFile) {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                const content = ev.target.result;
                if (content) {
                    await createLinkedInputNode(targetNode, content, false);
                }
            };
            reader.readAsDataURL(imageFile);
        }
    };

    const handleGenNodeDrop = async (nodeId, e) => {
        e.preventDefault();
        e.stopPropagation();
        const targetNode = nodesMap.get(nodeId);
        if (!targetNode) return;

        const payload = getHistoryDragPayload(e);
        if (payload) {
            const dragUrl = resolveDroppedUrlCandidate(resolveHistoryPayloadUrl(payload), payload.type);
            if (dragUrl) {
                const isVideo = payload.type === 'video' || isVideoUrl(dragUrl);
                if (isVideo && (targetNode.type === 'gen-image' || targetNode.type === 'image-compare' || targetNode.type === 'gen-video')) {
                    showToast('当前节点仅支持图片参考', 'warning');
                    return;
                }
                await createLinkedInputNode(targetNode, dragUrl, false);
            }
            return;
        }

        const candidate = resolveDroppedUrlCandidate(getDragUrlCandidate(e));
        if (candidate) {
            const isVideo = isVideoUrl(candidate);
            if (isVideo && (targetNode.type === 'gen-image' || targetNode.type === 'image-compare' || targetNode.type === 'gen-video')) {
                showToast('当前节点仅支持图片参考', 'warning');
                return;
            }
            await createLinkedInputNode(targetNode, candidate, false);
            return;
        }

        const files = Array.from(e.dataTransfer.files || []);
        const imageFile = files.find(file => file.type.startsWith('image/'));
        if (imageFile) {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                const content = ev.target.result;
                if (content) {
                    await createLinkedInputNode(targetNode, content, false);
                }
            };
            reader.readAsDataURL(imageFile);
            return;
        }

        const videoFile = files.find(file => file.type.startsWith('video/'));
        if (videoFile) {
            showToast('当前节点仅支持图片参考', 'warning');
        }
    };

    const sendHistoryToCanvas = async () => {
        const item = historyContextMenu.item;
        const resolvedUrl = resolveHistoryUrl(item, item?.url || item?.originalUrl || item?.mjOriginalUrl || null);
        if (!resolvedUrl) return;

        // Fix: Mark video content so input-image node knows to display it properly
        let content = resolvedUrl;
        if (item.type === 'video' && !isVideoUrl(content)) {
            // Append helper param so isVideoUrl returns true
            content += (content.includes('?') ? '&' : '?') + 'force_video_display=true';
        }

        let dims;
        if (item.type === 'image') {
            try {
                const real = await getImageDimensions(content);
                if (real?.w && real?.h) {
                    dims = { w: real.w, h: real.h };
                }
            } catch (e) {
                console.error('SendHistoryToCanvas getImageDimensions error', e);
            }
        }

        // V3.4.12: 修复层叠逻辑 - 找最后一个 input-image 节点位置作为基准
        const inputImageNodes = nodes.filter(n => n.type === 'input-image');
        let baseX, baseY;

        if (inputImageNodes.length > 0) {
            const lastNode = inputImageNodes[inputImageNodes.length - 1];
            baseX = lastNode.x - 40;
            baseY = lastNode.y + 35;
        } else {
            const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
            baseX = world.x + 50;
            baseY = world.y + 50;
        }

        let targetX = baseX;
        let targetY = baseY;
        const checkOverlap = (x, y) => nodes.some(n =>
            Math.abs(n.x - x) < 80 && Math.abs(n.y - y) < 80
        );
        let attempts = 0;
        while (checkOverlap(targetX, targetY) && attempts < 50) {
            targetX -= 40;
            targetY += 35;
            attempts++;
        }

        addNode('input-image', targetX, targetY, null, content, dims);
        setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
        setHistorySendMenuOpen(false);
    };

    const sendHistoryToChat = () => {
        const item = historyContextMenu.item;
        const resolvedUrl = resolveHistoryUrl(item, item?.url || item?.originalUrl || item?.mjOriginalUrl || null);
        if (!item || !resolvedUrl) return;

        // 确保正确识别图片和视频类型
        const isImage = item.type === 'image';
        const isVideo = item.type === 'video';
        const fileExt = isImage ? 'png' : (isVideo ? 'mp4' : 'file');
        const mimeType = isImage ? 'image/png' : (isVideo ? 'video/mp4' : 'application/octet-stream');

        const newFile = {
            name: `Generated-${item.id}.${fileExt}`,
            type: mimeType,
            content: resolvedUrl,
            isImage,
            isVideo,
            isAudio: false,
            fromHistory: true,
            fileExt
        };

        setChatFiles(prev => [...prev, newFile]);
        setIsChatOpen(true);
        setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
        setHistorySendMenuOpen(false);
    };

    const sendHistoryToPreview = () => {
        const item = historyContextMenu.item;
        const resolvedUrl = resolveHistoryUrl(item, item?.url || item?.originalUrl || item?.mjOriginalUrl || null);
        if (!resolvedUrl) return;
        const previewImages = item?.mjImages && item.mjImages.length > 1 ? item.mjImages : null;
        const selectedIndex = item?.selectedMjImageIndex ?? 0;
        const previewUrl = previewImages ? (previewImages[selectedIndex] || previewImages[0] || resolvedUrl) : resolvedUrl;
        setNodes(prev => {
            const previews = prev.filter(n => n.type === 'preview');
            if (!previews.length) return prev;
            const selectedId = selectedNodeIdRef.current;
            const selectedIds = selectedNodeIdsRef.current;
            let targetId = null;
            if (selectedId) {
                const selectedPreview = previews.find(p => p.id === selectedId);
                if (selectedPreview) targetId = selectedPreview.id;
            }
            if (!targetId && selectedIds && selectedIds.size > 0) {
                const selectedPreview = previews.find(p => selectedIds.has(p.id));
                if (selectedPreview) targetId = selectedPreview.id;
            }
            if (!targetId) targetId = previews[previews.length - 1].id;

            return prev.map(n =>
                n.id === targetId
                    ? {
                        ...n,
                        content: previewUrl,
                        previewType: item.type === 'video' || isVideoUrl(previewUrl) ? 'video' : 'image',
                        previewMjImages: previewImages
                    }
                    : n
            );
        });
        setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
        setHistorySendMenuOpen(false);
    };

    const sendHistorySmart = async () => {
        const item = historyContextMenu.item;
        if (!item) return;

        const chatRecent = lastInteractionRef.current.target === 'chat' && (Date.now() - lastInteractionRef.current.at) < 3000;
        if (isChatInputFocused || isChatHovered || chatRecent) {
            sendHistoryToChat();
            return;
        }

        const targetId = selectedNodeIdRef.current || (selectedNodeIdsRef.current && [...selectedNodeIdsRef.current][0]);
        if (targetId) {
            const targetNode = nodesMap.get(targetId);
            if (targetNode) {
                if (targetNode.type === 'storyboard-node') {
                    if (activeShot.nodeId && activeShot.shotId) {
                        const handled = applyHistoryToActiveShot(item);
                        if (handled) {
                            setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
                            setHistorySendMenuOpen(false);
                            return;
                        }
                    }
                    showToast('请先选中分镜中的镜头', 'warning');
                    return;
                }

                const handled = await applyHistoryToNode(targetNode, item);
                if (handled) {
                    setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
                    setHistorySendMenuOpen(false);
                    return;
                }
            }
        }

        if (activeShot.nodeId && activeShot.shotId) {
            const handled = applyHistoryToActiveShot(item);
            if (handled) {
                setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
                setHistorySendMenuOpen(false);
                return;
            }
        }

        sendHistoryToCanvas();
    };

    // V3.5.0: 批量下载 (ZIP打包 / 单文件直接下载)
    const handleHistoryBatchDownload = async (items) => {
        if (!items || items.length === 0) {
            console.warn('[V3.5.1 Debug] No items to download');
            return;
        }
        const resolveHistoryUrl = (target) => target?.localCacheUrl || target?.url || target?.originalUrl || target?.mjOriginalUrl;

        // 如果只有一项且是单图/视频，保持原有直接下载体验
        if (items.length === 1) {
            const firstItem = items[0];
            const resolvedFirstUrl = resolveHistoryUrl(firstItem);
            const isSingleSimpleItem = !firstItem?.mjImages && resolvedFirstUrl;
            if (isSingleSimpleItem) {
                // V3.5.15: Add progress for single download too
                setDownloadProgress({ active: true, current: 0, total: 1 });
                try {
                    const url = resolvedFirstUrl;
                    // V3.5.6: 修复文件扩展名检测
                    let ext = 'mp4'; // 默认视频扩展名
                    if (url.startsWith('data:image')) {
                        ext = 'png';
                    } else if (url.startsWith('data:video')) {
                        ext = 'mp4';
                    } else if (firstItem.type === 'video' || url.includes('/video/') || url.includes('video_mp4')) {
                        ext = 'mp4';
                    } else if (firstItem.type === 'image') {
                        ext = 'png';
                    } else {
                        // 尝试从 URL 路径提取扩展名 (仅对简单 URL)
                        const urlPath = url.split('?')[0];
                        const lastSegment = urlPath.split('/').pop();
                        if (lastSegment && lastSegment.includes('.')) {
                            const possibleExt = lastSegment.split('.').pop();
                            if (possibleExt && possibleExt.length <= 5 && /^[a-z0-9]+$/i.test(possibleExt)) {
                                ext = possibleExt;
                            }
                        }
                    }
                    const promptSlug = (firstItem.prompt || 'download').replace(/[\\/:*?"<>|]/g, '_').slice(0, 50);
                    const filename = `${promptSlug}.${ext}`;

                    if (url.startsWith('data:')) {
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        a.click();
                    } else {
                        const useProxy = getItemProxyPreference(firstItem);
                        const { blob } = await fetchCacheSource(url, { useProxy });
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = filename;
                        a.click();
                    }
                    setDownloadProgress({ active: false, current: 1, total: 1 });
                } catch (e) {
                    console.error('单文件下载失败:', e);
                    setDownloadProgress({ active: false, current: 0, total: 0 });
                    alert('下载失败: ' + e.message);
                }
                return;
            }
        }

        // 批量打包
        const zip = new JSZip();
        let count = 0;
        const totalItems = items.length;
        const totalSteps = totalItems;

        // V3.5.12: Set download progress for visible progress bar
        setDownloadProgress({ active: true, current: 0, total: totalSteps });

        try {
            for (const item of items) {
                if (!item) continue;

                // 统一处理所有资源链接
                const resources = [];
                if (item.mjImages && item.mjImages.length > 0) {
                    item.mjImages.forEach((url, idx) => {
                        resources.push({ url, suffix: `_${idx + 1}` });
                    });
                } else {
                    const resolvedUrl = resolveHistoryUrl(item);
                    if (resolvedUrl) {
                        resources.push({ url: resolvedUrl, suffix: '' });
                    }
                }

                for (const res of resources) {
                    try {
                        let blob;
                        if (res.url.startsWith('data:')) {
                            const arr = res.url.split(',');
                            const mime = arr[0].match(/:(.*?);/)[1];
                            const bstr = atob(arr[1]);
                            let n = bstr.length;
                            const u8arr = new Uint8Array(n);
                            while (n--) u8arr[n] = bstr.charCodeAt(n);
                            blob = new Blob([u8arr], { type: mime });
                        } else {
                            const useProxy = getItemProxyPreference(item);
                            const result = await fetchCacheSource(res.url, { useProxy });
                            blob = result.blob;
                        }

                        let ext = blob.type.split('/')[1] || 'png';
                        const resolvedUrl = resolveHistoryUrl(item);
                        if (resolvedUrl && !resolvedUrl.startsWith('data:')) {
                            const urlExt = resolvedUrl.split('.').pop().split('?')[0];
                            if (urlExt && urlExt.length < 5) ext = urlExt;
                        }

                        const promptSlug = (item.prompt || 'untitled').replace(/[\\/:*?"<>|]/g, '_').slice(0, 40);
                        const itemIdSuffix = item.id ? `_${item.id.slice(-4)}` : '';
                        const filename = `${promptSlug}${itemIdSuffix}${res.suffix}.${ext}`;

                        zip.file(filename, blob);
                        count++;
                    } catch (err) {
                        console.error(`打包资源失败 [${item.id}]:`, err);
                    }
                }
                // V3.5.12: Update download progress
                setDownloadProgress(prev => ({ ...prev, current: prev.current + 1 }));
            }

            if (count === 0) {
                setDownloadProgress({ active: false, current: 0, total: 0 });
                alert(t('没有可下载的有效资源'));
                return;
            }

            const content = await zip.generateAsync({ type: 'blob' });
            setDownloadProgress(prev => ({ ...prev, current: totalSteps }));
            const now = new Date();
            const timestamp = `${now.getFullYear().toString().slice(2)}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}-${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;
            saveAs(content, `tapnow-assets-${timestamp}.zip`);

            // V3.5.12: Reset download progress
            setDownloadProgress({ active: false, current: totalSteps, total: totalSteps });
        } catch (e) {
            console.error('打包过程出错:', e);
            setDownloadProgress({ active: false, current: 0, total: 0 });
            alert('打包失败: ' + e.message);
        }
    };

    const buildStoryboardDownloadItems = (node, scope = 'all') => {
        const mode = node.settings?.mode || 'video';
        const shots = node.settings?.shots || [];
        const projectTitle = node.settings?.projectTitle || '未命名分镜';
        const projectSlug = sanitizeCacheId(projectTitle) || '未命名分镜';
        const items = [];

        const getShotLabel = (shot) => {
            const raw = (shot.description || shot.prompt || '').trim();
            return sanitizeCacheId(raw) || '未命名镜头';
        };

        const pushImageItem = (shot, shotIndex, imageUrl, imageIndex) => {
            if (!imageUrl) return;
            const ext = imageUrl.startsWith('data:') ? (getDataUrlExt(imageUrl, '.png') || '.png') : (getUrlExt(imageUrl, '.png') || '.png');
            const shotLabel = getShotLabel(shot);
            const filename = `${projectSlug}-${shotLabel}-${shotIndex}-${imageIndex}${ext}`;
            items.push({ url: imageUrl, filename });
        };

        const pushVideoItem = (shot, shotIndex, videoUrl) => {
            if (!videoUrl) return;
            const ext = videoUrl.startsWith('data:') ? (getDataUrlExt(videoUrl, '.mp4') || '.mp4') : (getUrlExt(videoUrl, '.mp4') || '.mp4');
            const shotLabel = getShotLabel(shot);
            const filename = `${projectSlug}-${shotLabel}-${shotIndex}${ext}`;
            items.push({ url: videoUrl, filename });
        };

        const hasLockedShot = scope !== 'all' && shots.some(s => s.outputEnabled);

        shots.forEach((shot, idx) => {
            const shotIndex = shot.scene_index || idx + 1;

            if (mode === 'image') {
                const outputImages = shot.output_images?.length ? shot.output_images : (shot.output_url ? [shot.output_url] : []);
                if (outputImages.length === 0) return;

                if (scope === 'all') {
                    outputImages.forEach((url, imageIdx) => pushImageItem(shot, shotIndex, url, imageIdx + 1));
                    return;
                }

                const selectedIndex = Number.isInteger(shot.selectedImageIndex) ? shot.selectedImageIndex : -1;
                const isLocked = !!shot.outputEnabled;

                if (hasLockedShot) {
                    if (!isLocked) return;
                    if (selectedIndex >= 0 && outputImages[selectedIndex]) {
                        pushImageItem(shot, shotIndex, outputImages[selectedIndex], selectedIndex + 1);
                        return;
                    }
                    outputImages.forEach((url, imageIdx) => pushImageItem(shot, shotIndex, url, imageIdx + 1));
                    return;
                }

                if (selectedIndex >= 0 && outputImages[selectedIndex]) {
                    pushImageItem(shot, shotIndex, outputImages[selectedIndex], selectedIndex + 1);
                }
            } else {
                const videoUrl = shot.video_url || shot.output_url;
                if (!videoUrl) return;

                if (scope === 'all') {
                    pushVideoItem(shot, shotIndex, videoUrl);
                    return;
                }

                if (shot.outputEnabled) {
                    pushVideoItem(shot, shotIndex, videoUrl);
                }
            }
        });

        return items;
    };

    const handleStoryboardBatchDownload = async (node, scope = 'all') => {
        const items = buildStoryboardDownloadItems(node, scope);
        if (!items.length) {
            alert(t('没有可下载的资源'));
            return;
        }

        const now = new Date();
        const timestamp = `${now.getFullYear().toString().slice(2)}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
        const projectTitle = node.settings?.projectTitle || '未命名分镜';
        const zipName = `${sanitizeCacheId(projectTitle) || '未命名分镜'}-batch-${timestamp}.zip`;

        const toBlob = async (url) => {
            if (url.startsWith('data:')) {
                const parts = url.split(',');
                const mime = parts[0].match(/:(.*?);/i)?.[1] || 'application/octet-stream';
                const bstr = atob(parts[1] || '');
                const u8arr = new Uint8Array(bstr.length);
                for (let i = 0; i < bstr.length; i++) u8arr[i] = bstr.charCodeAt(i);
                return new Blob([u8arr], { type: mime });
            }
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            return await resp.blob();
        };

        if (items.length === 1) {
            try {
                setDownloadProgress({ active: true, current: 0, total: 1 });
                const blob = await toBlob(items[0].url);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = items[0].filename;
                a.click();
                URL.revokeObjectURL(a.href);
                setDownloadProgress({ active: false, current: 1, total: 1 });
            } catch (e) {
                setDownloadProgress({ active: false, current: 0, total: 0 });
                alert('下载失败: ' + e.message);
            }
            return;
        }

        const zip = new JSZip();
        const totalSteps = items.length;
        setDownloadProgress({ active: true, current: 0, total: totalSteps });
        let added = 0;

        for (const item of items) {
            try {
                const blob = await toBlob(item.url);
                zip.file(item.filename, blob);
                added += 1;
            } catch (e) {
                console.error('下载资源失败:', item.filename, e);
            }
            setDownloadProgress(prev => ({ ...prev, current: Math.min(totalSteps, prev.current + 1) }));
        }

        if (added === 0) {
            setDownloadProgress({ active: false, current: 0, total: 0 });
            alert(t('没有可下载的有效资源'));
            return;
        }

        const content = await zip.generateAsync({ type: 'blob' });
        setDownloadProgress(prev => ({ ...prev, current: totalSteps }));
        saveAs(content, zipName);
        setDownloadProgress({ active: false, current: totalSteps, total: totalSteps });
    };


    const handlePreviewRightClick = (e, item) => {
        if (!item?.url) return;
        e.preventDefault();
        e.stopPropagation();
        setPreviewContextMenu({ visible: true, x: e.clientX, y: e.clientY, item });
    };
    const closePreviewContextMenu = () => setPreviewContextMenu({ visible: false, x: 0, y: 0, item: null });

    const sendPreviewToChat = () => {
        const item = previewContextMenu.item;
        if (!item?.url) return;
        const isImage = item.type !== 'video';
        const isVideo = item.type === 'video';
        const fileExt = isImage ? 'png' : 'mp4';
        const mimeType = isImage ? 'image/png' : 'video/mp4';
        const newFile = { name: `Preview-${Date.now()}.${fileExt}`, type: mimeType, content: item.url, isImage, isVideo, isAudio: false, fileExt };
        setChatFiles(prev => [...prev, newFile]);
        setIsChatOpen(true);
        closePreviewContextMenu();
    };

    const sendPreviewToCanvas = async () => {
        const item = previewContextMenu.item;
        if (!item?.url) return;
        const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
        let dims = { w: 512, h: 512 };
        try { dims = await getImageDimensions(item.url); } catch (e) { console.warn('Preview dims fail', e); }
        addNode('input-image', world.x + 50, world.y + 50, null, item.url, dims);
        closePreviewContextMenu();
    };

    // 图片输入节点右键菜单处理
    const handleInputImageRightClick = (e, nodeId) => {
        e.preventDefault();
        e.stopPropagation();
        const node = nodesMap.get(nodeId);
        if (!node || !node.content) return;
        setInputImageContextMenu({ visible: true, x: e.clientX, y: e.clientY, nodeId });
    };

    const closeInputImageContextMenu = () => {
        setInputImageContextMenu({ visible: false, x: 0, y: 0, nodeId: null });
    };

    const sendInputImageToChat = () => {
        const nodeId = inputImageContextMenu.nodeId;
        const node = nodesMap.get(nodeId);
        if (!node || !node.content) return;

        const isImage = !isVideoUrl(node.content);
        const isVideo = isVideoUrl(node.content);
        const fileExt = isImage ? 'png' : 'mp4';
        const mimeType = isImage ? 'image/png' : 'video/mp4';
        const newFile = {
            name: `InputImage-${Date.now()}.${fileExt}`,
            type: mimeType,
            content: node.content,
            isImage,
            isVideo,
            isAudio: false,
            fileExt
        };
        setChatFiles(prev => [...prev, newFile]);
        setIsChatOpen(true);
        closeInputImageContextMenu();
    };

    // ... (rest of render logic unchanged) ...
    // ConnectionLayer 组件：提取连接线渲染逻辑，使用 React.memo 优化
    const ConnectionLayer = memo(({
        connections,
        nodesMap,
        connectionsByNode,
        connectingSource,
        connectingTarget,
        connectingInputType,
        mousePos,
        apiConfigsMap,
        selectedNodeId,
        onDisconnectConnection,
        visibleNodes
    }) => {
        // 连接线虚拟化：只渲染可见节点的连接线
        const visibleNodeIds = useMemo(() => {
            return new Set(visibleNodes.map(n => n.id));
        }, [visibleNodes]);

        const visibleConnections = useMemo(() => {
            return connections.filter(conn =>
                visibleNodeIds.has(conn.from) || visibleNodeIds.has(conn.to)
            );
        }, [connections, visibleNodeIds]);

        return (
            <div className="absolute inset-0 pointer-events-none overflow-visible w-full h-full">
                <svg className="absolute inset-0 overflow-visible w-full h-full pointer-events-none">
                    {visibleConnections.map((conn) => {
                        // 使用 nodesMap 快速查找，O(1) 复杂度
                        const fromNode = nodesMap.get(conn.from);
                        const toNode = nodesMap.get(conn.to);
                        if (!fromNode || !toNode) return null;

                        // 检查连接线是否与选中节点相关
                        const isRelatedToSelected = selectedNodeId && (
                            fromNode.id === selectedNodeId ||
                            toNode.id === selectedNodeId
                        );
                        // 设置透明度：选中节点相关为100%，其他为35%
                        const opacity = isRelatedToSelected ? 1 : 0.35;

                        const startX = fromNode.x + fromNode.width - 4;
                        const startY = fromNode.y + fromNode.height / 2;

                        const endX = toNode.x + 4;
                        let endY = toNode.y + toNode.height / 2;

                        // 处理image-compare节点的多个输入点
                        if (toNode.type === 'image-compare') {
                            // 使用缓存的 connectionsByNode，避免重复 filter
                            const relevantConns = connectionsByNode.to.get(toNode.id) || [];
                            const idx = relevantConns.findIndex(c => c.id === conn.id);
                            if (idx === 0) endY = toNode.y + toNode.height * 0.33;
                            else if (idx >= 1) endY = toNode.y + toNode.height * 0.66;
                        }

                        // 处理Midjourney节点的oref和sref输入点
                        // 检查inputType是否为oref或sref（注意：default连接时inputType可能是undefined）
                        if (toNode.type === 'gen-image' && (conn.inputType === 'oref' || conn.inputType === 'sref')) {
                            const currentModel = getApiConfigByKey(toNode.settings?.model);
                            const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));

                            if (isMidjourney) {
                                // 使用基于节点世界坐标的计算，考虑实际DOM结构
                                // 节点结构：p-3(12px) + 计时器(如果有，约28px + mb-2=8px) + 标题(约16px + mb-2=8px) + 引用状态区域(如果有，约60px + mb-2=8px) + 提示词区域(约100px + mb-2=8px) + 指令区域
                                // 指令区域：gap-1.5(6px) + oref项(约16px) + gap-1.5(6px) + ow项(约16px + input高度) + gap-1.5(6px) + sref项(约16px)
                                const paddingTop = 12; // 节点顶部padding (p-3 = 12px)
                                const timerHeight = 28; // 计时器区域高度（px-2 py-1 + text-[10px] ≈ 28px）
                                const timerMarginBottom = 8; // 计时器下方margin (mb-2 = 8px)
                                const titleHeight = 16; // 标题高度 (text-xs ≈ 12px + line-height ≈ 16px，flex items-center)
                                const titleMarginBottom = 8; // 标题下方margin (mb-2 = 8px)
                                const refAreaHeight = 60; // 引用状态区域高度（p-2 + 内容，约60px）
                                const refAreaMarginBottom = 8; // 引用区域下方margin (mb-2 = 8px)
                                const promptAreaHeight = 100; // 提示词区域高度（p-3 + textarea，约100px）
                                const promptAreaMarginBottom = 8; // 提示词区域下方margin (mb-2 = 8px)
                                const instructionGap = 6; // 指令项之间的gap (gap-1.5 = 6px)
                                const instructionItemHeight = 16; // 每个指令项的实际高度（text-[10px] + flex items-center ≈ 16px）
                                const owInputHeight = 28; // ow输入框高度（px-2 py-1 + text-[10px] ≈ 28px）

                                // 检查是否有计时器（正在生成或已完成）
                                const hasTimer = false; // 计时器是动态的，这里简化处理，实际应该从节点状态判断

                                // 使用缓存的 connectionsByNode，避免重复 some 计算
                                const toNodeConns = connectionsByNode.to.get(toNode.id) || [];
                                const hasRefArea = toNodeConns.some(c => !c.inputType || c.inputType === 'default');

                                // 计算基础偏移（到指令区域开始的位置）
                                let baseOffset = paddingTop;
                                if (hasTimer) {
                                    baseOffset += timerHeight + timerMarginBottom;
                                }
                                baseOffset += titleHeight + titleMarginBottom;
                                if (hasRefArea) {
                                    baseOffset += refAreaHeight + refAreaMarginBottom;
                                }
                                baseOffset += promptAreaHeight + promptAreaMarginBottom;

                                if (conn.inputType === 'oref') {
                                    // oref在第一个指令位置（第一个指令项的中心）
                                    // 指令区域开始 + 第一个指令项的中心
                                    endY = toNode.y + baseOffset + instructionItemHeight * 0.5;
                                } else if (conn.inputType === 'sref') {
                                    // sref在第三个指令位置
                                    // 指令区域开始 + oref项(16px) + gap(6px) + ow项(owInputHeight ≈ 28px) + gap(6px) + sref项的中心(8px)
                                    endY = toNode.y + baseOffset + instructionItemHeight + instructionGap + owInputHeight + instructionGap + instructionItemHeight * 0.5;
                                }
                            }
                        }

                        // 处理首尾帧输入点
                        if (toNode.type === 'gen-video' && (conn.inputType === 'veo_start' || conn.inputType === 'veo_end')) {
                            const paddingTop = 12; // 节点顶部 padding
                            const timerHeight = 28;
                            const timerMarginBottom = 8;
                            const titleHeight = 16;
                            const titleMarginBottom = 8;
                            const refAreaHeight = 60;
                            const refAreaMarginBottom = 8;
                            const promptAreaHeight = Math.max(110, Math.min(180, toNode.height * 0.4));
                            const promptAreaMarginBottom = 8;
                            const panelPaddingTop = 12;
                            const panelTitleHeight = 14;
                            const panelDescHeight = 12;
                            const panelGap = 8;
                            const panelRowHeight = 18;
                            const panelRowGap = 8;

                            const hasTimer = false;
                            const toNodeConns = connectionsByNode.to.get(toNode.id) || [];
                            const hasRefArea = toNodeConns.some(c => !c.inputType || c.inputType === 'default');

                            let baseOffset = paddingTop;
                            if (hasTimer) {
                                baseOffset += timerHeight + timerMarginBottom;
                            }
                            baseOffset += titleHeight + titleMarginBottom;
                            if (hasRefArea) {
                                baseOffset += refAreaHeight + refAreaMarginBottom;
                            }
                            baseOffset += promptAreaHeight + promptAreaMarginBottom;

                            const panelTop = baseOffset;
                            const firstRowCenter = panelTop + panelPaddingTop + panelTitleHeight + panelGap + panelDescHeight + panelGap + panelRowHeight * 0.5;
                            const secondRowCenter = firstRowCenter + panelRowHeight + panelRowGap;

                            endY = toNode.y + (conn.inputType === 'veo_start' ? firstRowCenter : secondRowCenter);
                        }

                        const dist = Math.abs(endX - startX);
                        const cp1X = startX + dist * 0.5;
                        const cp2X = endX - dist * 0.5;
                        const midX = (startX + endX) / 2;
                        const midY = (startY + endY) / 2;

                        return (
                            <g key={conn.id} className="connection-group" style={{ opacity }}>
                                {/* 透明路径用于点击检测连接线 */}
                                <path
                                    d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`}
                                    stroke="transparent"
                                    strokeWidth="20"
                                    fill="none"
                                    style={{ pointerEvents: 'stroke' }}
                                />
                                <path d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`} stroke="#18181b" strokeWidth="4" fill="none" />
                                <path d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`} stroke="#71717a" strokeWidth="2" fill="none" />
                                <circle cx={startX} cy={startY} r="2" fill="#71717a" />
                                <circle cx={endX} cy={endY} r="2" fill="#71717a" />
                                {/* 删除按钮：使用更大的透明热区确保可点击，必须在最后渲染以覆盖透明 path */}
                                <g
                                    className="connection-delete cursor-pointer"
                                    style={{
                                        opacity: isRelatedToSelected ? 1 : 0.35,
                                        pointerEvents: 'auto',
                                        cursor: 'pointer'
                                    }}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        e.preventDefault();
                                        onDisconnectConnection(conn.id);
                                    }}
                                    onMouseDown={(e) => {
                                        // 阻止事件冒泡，防止触发画布拖动
                                        e.stopPropagation();
                                        e.preventDefault();
                                        // 立即执行断开连接，不等待 onClick（修复点击无法断开的问题）
                                        onDisconnectConnection(conn.id);
                                    }}
                                >
                                    {/* 大的透明点击热区（半径25），确保完全覆盖透明 path 的 stroke（宽度20） */}
                                    <circle
                                        cx={midX}
                                        cy={midY}
                                        r="25"
                                        fill="transparent"
                                        style={{ pointerEvents: 'auto', cursor: 'pointer' }}
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            e.preventDefault();
                                            onDisconnectConnection(conn.id);
                                        }}
                                        onMouseDown={(e) => {
                                            // 阻止事件冒泡，防止触发画布拖动
                                            e.stopPropagation();
                                            e.preventDefault();
                                            // 立即执行断开连接，不等待 onClick（修复点击无法断开的问题）
                                            onDisconnectConnection(conn.id);
                                        }}
                                    />
                                    {/* 视觉元素 */}
                                    <circle cx={midX} cy={midY} r="12" fill="#ef4444" opacity="0.8" style={{ pointerEvents: 'none' }} />
                                    <circle cx={midX} cy={midY} r="8" fill="#ef4444" style={{ pointerEvents: 'none' }} />
                                    <Unlink size={10} className="text-white" x={midX - 5} y={midY - 5} style={{ pointerEvents: 'none' }} />
                                </g>
                            </g>
                        );
                    })}
                    {connectingSource && (() => {
                        // 使用 nodesMap 快速查找
                        const node = nodesMap.get(connectingSource);
                        if (!node) return null;
                        return <path d={`M ${node.x + node.width - 4} ${node.y + node.height / 2} C ${node.x + node.width + 100} ${node.y + node.height / 2}, ${mousePos.x - 100} ${mousePos.y}, ${mousePos.x} ${mousePos.y}`} stroke="#60a5fa" strokeWidth="2" fill="none" strokeDasharray="4,4" />;
                    })()}
                    {connectingTarget && (() => {
                        // 使用 nodesMap 快速查找
                        const node = nodesMap.get(connectingTarget);
                        if (!node) return null;
                        // 从输入端口向左拖拽，连接线从左侧开始
                        const startX = node.x + 4;
                        let startY = node.y + node.height / 2;

                        // 处理Midjourney节点的oref和sref输入点
                        if (node.type === 'gen-image' && connectingInputType) {
                            const currentModel = getApiConfigByKey(node.settings?.model);
                            const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));

                            if (isMidjourney) {
                                // 使用与连接线渲染相同的计算逻辑
                                const paddingTop = 12;
                                const timerHeight = 28;
                                const timerMarginBottom = 8;
                                const titleHeight = 16; // 标题高度 (text-xs ≈ 12px + line-height ≈ 16px)
                                const titleMarginBottom = 8;
                                const refAreaHeight = 60;
                                const refAreaMarginBottom = 8;
                                const promptAreaHeight = 100;
                                const promptAreaMarginBottom = 8;
                                const instructionGap = 6;
                                const instructionItemHeight = 16; // 每个指令项的实际高度（text-[10px] + flex items-center ≈ 16px）
                                const owInputHeight = 28; // ow输入框高度（px-2 py-1 + text-[10px] ≈ 28px）

                                const hasTimer = false; // 计时器是动态的，这里简化处理
                                // 使用缓存的 connectionsByNode，避免重复 some 计算
                                const toNodeConns = connectionsByNode.to.get(node.id) || [];
                                const hasRefArea = toNodeConns.some(c => !c.inputType || c.inputType === 'default');

                                let baseOffset = paddingTop;
                                if (hasTimer) {
                                    baseOffset += timerHeight + timerMarginBottom;
                                }
                                baseOffset += titleHeight + titleMarginBottom;
                                if (hasRefArea) {
                                    baseOffset += refAreaHeight + refAreaMarginBottom;
                                }
                                baseOffset += promptAreaHeight + promptAreaMarginBottom;

                                if (connectingInputType === 'oref') {
                                    startY = node.y + baseOffset + instructionItemHeight * 0.5;
                                } else if (connectingInputType === 'sref') {
                                    // sref在第三个指令位置：oref项(16px) + gap(6px) + ow项(owInputHeight ≈ 28px) + gap(6px) + sref项的中心(8px)
                                    startY = node.y + baseOffset + instructionItemHeight + instructionGap + owInputHeight + instructionGap + instructionItemHeight * 0.5;
                                }
                            }
                        }
                        else if (node.type === 'gen-video' && (connectingInputType === 'veo_start' || connectingInputType === 'veo_end')) {
                            const paddingTop = 12;
                            const timerHeight = 28;
                            const timerMarginBottom = 8;
                            const titleHeight = 16;
                            const titleMarginBottom = 8;
                            const refAreaHeight = 60;
                            const refAreaMarginBottom = 8;
                            const promptAreaHeight = Math.max(110, Math.min(180, node.height * 0.4));
                            const promptAreaMarginBottom = 8;
                            const panelPaddingTop = 12;
                            const panelTitleHeight = 14;
                            const panelDescHeight = 12;
                            const panelGap = 8;
                            const panelRowHeight = 18;
                            const panelRowGap = 8;

                            const hasTimer = false;
                            const toNodeConns = connectionsByNode.to.get(node.id) || [];
                            const hasRefArea = toNodeConns.some(c => !c.inputType || c.inputType === 'default');

                            let baseOffset = paddingTop;
                            if (hasTimer) {
                                baseOffset += timerHeight + timerMarginBottom;
                            }
                            baseOffset += titleHeight + titleMarginBottom;
                            if (hasRefArea) {
                                baseOffset += refAreaHeight + refAreaMarginBottom;
                            }
                            baseOffset += promptAreaHeight + promptAreaMarginBottom;

                            const panelTop = baseOffset;
                            const firstRowCenter = panelTop + panelPaddingTop + panelTitleHeight + panelGap + panelDescHeight + panelGap + panelRowHeight * 0.5;
                            const secondRowCenter = firstRowCenter + panelRowHeight + panelRowGap;

                            startY = node.y + (connectingInputType === 'veo_start' ? firstRowCenter : secondRowCenter);
                        }
                        // 处理image-compare节点的多个输入点
                        else if (node.type === 'image-compare') {
                            // 这里可以根据鼠标位置判断是哪个输入点，暂时使用中间位置
                            startY = node.y + node.height / 2;
                        }

                        return <path d={`M ${startX} ${startY} C ${startX - 100} ${startY}, ${mousePos.x + 100} ${mousePos.y}, ${mousePos.x} ${mousePos.y}`} stroke="#60a5fa" strokeWidth="2" fill="none" strokeDasharray="4,4" />;
                    })()}
                </svg>
            </div>
        );
    }, (prevProps, nextProps) => {
        // 自定义对比函数：仅当 connections 数组、可见节点或相关选中状态变化时才重渲染
        return (
            prevProps.connections === nextProps.connections &&
            prevProps.visibleNodes === nextProps.visibleNodes &&
            prevProps.selectedNodeId === nextProps.selectedNodeId &&
            prevProps.connectingSource === nextProps.connectingSource &&
            prevProps.connectingTarget === nextProps.connectingTarget &&
            prevProps.connectingInputType === nextProps.connectingInputType &&
            prevProps.mousePos.x === nextProps.mousePos.x &&
            prevProps.mousePos.y === nextProps.mousePos.y
        );
    });

    // 使用 useMemo 优化连接线渲染函数，避免重复查找和计算
    const renderConnections = useCallback(() => {
        return (
            <ConnectionLayer
                connections={connections}
                nodesMap={nodesMap}
                connectionsByNode={connectionsByNode}
                connectingSource={connectingSource}
                connectingTarget={connectingTarget}
                connectingInputType={connectingInputType}
                mousePos={mousePos}
                apiConfigsMap={apiConfigsMap}
                selectedNodeId={selectedNodeId}
                onDisconnectConnection={disconnectConnection}
                visibleNodes={visibleNodes}
            />
        );
    }, [connections, nodesMap, connectionsByNode, connectingSource, connectingTarget, connectingInputType, mousePos, apiConfigsMap, selectedNodeId, disconnectConnection, visibleNodes]);

    // 使用 useMemo 缓存节点的连接状态，避免每次渲染时重复计算
    const nodeConnectedStatus = useMemo(() => {
        const status = new Map(); // nodeId -> boolean
        connections.forEach(conn => {
            if (!conn.inputType || conn.inputType === 'default') {
                status.set(conn.to, true);
            }
        });
        return status;
    }, [connections]);

    // 功能3：获取相邻节点（上游和下游）- 使用缓存的连接映射优化性能
    const getAdjacentNodes = useCallback((nodeId) => {
        const adjacent = new Set();
        const fromConns = connectionsByNode.from.get(nodeId) || [];
        const toConns = connectionsByNode.to.get(nodeId) || [];
        fromConns.forEach(conn => adjacent.add(conn.to));
        toConns.forEach(conn => adjacent.add(conn.from));
        return adjacent;
    }, [connectionsByNode]);

    // 缓存相邻节点集合，避免在renderNode中重复计算
    const adjacentNodesCache = useMemo(() => {
        const cache = new Map();
        if (selectedNodeId || selectedNodeIds.size > 0) {
            const selectedId = selectedNodeId || (selectedNodeIds.size === 1 ? Array.from(selectedNodeIds)[0] : null);
            if (selectedId) {
                cache.set(selectedId, getAdjacentNodes(selectedId));
            }
        }
        return cache;
    }, [selectedNodeId, selectedNodeIds, getAdjacentNodes]);

    // NodeItem 组件：提取节点渲染逻辑，使用 React.memo 优化
    // 注意：由于 renderNode 的 JSX 内容非常长（约 2700 行），完整提取需要大量工作
    // 我们采用更实用的方法：保持 renderNode 函数的结构，但通过 React.memo 优化
    // 关键优化点：
    // 1. 所有回调函数都使用 useCallback 优化（已完成）
    // 2. ConnectionLayer 已提取并优化（已完成）
    // 3. CSS 渲染优化（已完成）
    // 4. 通过计算 props 减少不必要的重渲染

    const renderNode = useCallback((node) => {
        // LOD (Level of Detail) 阈值
        const LOD_THRESHOLD = 0.4;
        const isLowDetail = view.zoom < LOD_THRESHOLD;

        const isSelected = selectedNodeId === node.id || selectedNodeIds.has(node.id);
        const connectedImages = getConnectedInputImages(node.id);
        const isHoverTarget = hoverTargetId === node.id;
        // 使用缓存的连接状态，O(1) 查找
        const isConnected = nodeConnectedStatus.get(node.id) || false;
        // 判断节点是否正在被拖动（包括多选拖动），用于提升 z-index 避免被遮挡
        const isDragging = dragNodeId === node.id || (dragNodeId && selectedNodeIds.has(node.id));

        // 功能3：检查是否为相邻节点（当有节点被选中时）- 使用缓存的相邻节点集合
        const selectedId = selectedNodeId || (selectedNodeIds.size === 1 ? Array.from(selectedNodeIds)[0] : null);
        const adjacentSet = selectedId ? adjacentNodesCache.get(selectedId) : null;
        const isAdjacent = selectedId && selectedId !== node.id && adjacentSet && adjacentSet.has(node.id);

        // 判断是否为Nano Banana 2模型 - 使用 Map 优化查找（O(1)）
        const currentModel = getApiConfigByKey(node.settings?.model);
        const isNanoBanana2 = currentModel
            ? ((currentModel.modelName || currentModel.id || '').includes('nano-banana-2'))
            : ((node.settings?.model || '').includes('nano-banana-2'));
        const enableSmartDrop = node.type === 'gen-image' || node.type === 'gen-video' || node.type === 'image-compare';

        // 低细节模式：只渲染核心内容
        if (isLowDetail) {
            return (
                <div
                    key={node.id}
                    data-node-id={node.id}
                    className={`absolute node-wrapper flex flex-col ${isSelected
                        ? 'ring-1 ring-blue-500'
                        : theme === 'dark'
                            ? 'border border-zinc-800'
                        : theme === 'solarized'
                            ? 'border border-[#eee8d5]'
                        : 'border border-zinc-200'
                        } ${theme === 'dark' ? 'bg-[#18181b]' : theme === 'solarized' ? 'bg-[#eee8d5]' : 'bg-white'}`}
                    style={{
                        left: node.x,
                        top: node.y,
                        width: node.width,
                        height: node.height,
                        cursor: (dragNodeId === node.id || (dragNodeId && selectedNodeIds.has(node.id))) ? 'grabbing' : 'default',
                        zIndex: isDragging ? 50 : 10, // 拖动时提升 z-index，避免被其他节点遮挡
                        border: `1px solid ${theme === 'dark' ? '#3f3f46' : theme === 'solarized' ? '#eee8d5' : '#e4e4e7'}`,
                        background: theme === 'dark' ? '#18181b' : theme === 'solarized' ? '#eee8d5' : '#fff',
                        boxShadow: 'none',
                        borderRadius: '0',
                        transform: 'translateZ(0)',
                        backfaceVisibility: 'hidden'
                    }}
                    onDragOver={enableSmartDrop ? handleCanvasDragOver : undefined}
                    onDrop={enableSmartDrop ? (e) => handleGenNodeDrop(node.id, e) : undefined}
                    onMouseDownCapture={(e) => {
                        if (e.button !== 0 || e.target === e.currentTarget) return;
                        const interactive = e.target.closest('input, textarea, select, button, a, [contenteditable="true"]');
                        if (!interactive) return;
                        if (e.nativeEvent) e.nativeEvent.__tapnowSelectionHandled = true;
                        if (e.ctrlKey || e.metaKey) {
                            setSelectedNodeIds(prev => {
                                const newSet = new Set(prev);
                                if (newSet.has(node.id)) {
                                    newSet.delete(node.id);
                                } else {
                                    newSet.add(node.id);
                                }
                                if (newSet.size === 1) {
                                    setSelectedNodeId(Array.from(newSet)[0]);
                                } else {
                                    setSelectedNodeId(null);
                                }
                                return newSet;
                            });
                            return;
                        }
                        const isAlreadySelected = selectedNodeIds.has(node.id);
                        if (isAlreadySelected && selectedNodeIds.size > 1) {
                            setSelectedNodeId(node.id);
                        } else {
                            setSelectedNodeId(node.id);
                            setSelectedNodeIds(new Set([node.id]));
                        }
                    }}
                    onMouseDown={(e) => {
                        if (e.nativeEvent?.__tapnowSelectionHandled) return;
                        if (e.button === 0) {
                            e.stopPropagation();
                            markInteraction('node');
                            if (e.ctrlKey || e.metaKey) {
                                setSelectedNodeIds(prev => {
                                    const newSet = new Set(prev);
                                    if (newSet.has(node.id)) {
                                        newSet.delete(node.id);
                                    } else {
                                        newSet.add(node.id);
                                    }
                                    if (newSet.size === 1) {
                                        setSelectedNodeId(Array.from(newSet)[0]);
                                    } else {
                                        setSelectedNodeId(null);
                                    }
                                    return newSet;
                                });
                            } else {
                                const isAlreadySelected = selectedNodeIds.has(node.id);
                                if (isAlreadySelected && selectedNodeIds.size > 1) {
                                    setSelectedNodeId(node.id);
                                } else {
                                    setSelectedNodeId(node.id);
                                    setSelectedNodeIds(new Set([node.id]));
                                }
                            }
                            setDragNodeId(node.id);
                        }
                    }}
                    onMouseEnter={() => { if (connectingSource || connectingTarget) setHoverTargetId(node.id); }}
                    onMouseLeave={() => { if ((connectingSource || connectingTarget) && hoverTargetId === node.id) setHoverTargetId(null); }}
                    onMouseUp={(e) => handleNodeMouseUp(node.id, e)}
                >
                    {/* 仅显示核心图片/视频 */}
                    {node.type === 'input-image' && node.content && (
                        <div className="w-full h-full relative">
                            {isVideoUrl(node.content) ? (
                                <ResolvedVideo
                                    src={node.content}
                                    className="w-full h-full object-cover opacity-80"
                                    muted
                                    playsInline
                                />
                            ) : (
                                <LazyBase64Image
                                    src={node.content}
                                    className="w-full h-full object-cover opacity-80"
                                    alt=""
                                />
                            )}
                        </div>
                    )}
                    {node.type === 'video-input' && node.content && (
                        <ResolvedVideo
                            src={node.content}
                            className="w-full h-full object-cover opacity-80"
                            muted
                            playsInline
                        />
                    )}
                    {!node.content && (
                        <div className={`p-2 font-bold text-sm truncate ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                            {node.type === 'input-image' ? '图片' :
                                node.type === 'video-input' ? '视频' :
                                    node.type === 'gen-image' ? '生成图片' :
                                        node.type === 'gen-image' ? '生成图片' :
                                            node.type === 'gen-video' ? '生成视频' :
                                                node.type === 'text-node' ? '文字' :
                                                    node.type === 'preview' ? '预览' :
                                                        node.type === 'novel-input' ? '小说输入' :
                                                            node.type === 'extract-characters-scenes' ? '提取角色和场景' :
                                                                node.type === 'character-description' ? '角色描述' :
                                                                    node.type === 'scene-description' ? '场景描述' :
                                                                        node.type === 'generate-character-video' ? '生成角色视频' :
                                                                            node.type === 'generate-scene-video' ? '生成场景视频' :
                                                                                node.type === 'generate-character-image' ? '生成角色图片' :
                                                                                    node.type === 'generate-scene-image' ? '生成场景图片' :
                                                                                        node.type === 'create-character' ? '创建角色' :
                                                                                            node.type === 'create-scene' ? '创建场景' :
                                                                                                node.type === 'save-to-local' ? '保存到本地' :
                                                                                                    node.type === 'local-save' ? '保存到本地' :
                                                                                                        node.type || '节点'}
                        </div>
                    )}

                    {/* 保留连接点占位符，确保连线位置正确（简化样式） */}
                    {node.type !== 'input-image' && node.type !== 'video-input' && node.type !== 'video-analyze' && node.type !== 'preview' && (
                        node.type === 'image-compare' ? (
                            <>
                                <div
                                    className="input-point"
                                    style={{
                                        top: '33%',
                                        left: '-0.25rem',
                                        width: '0.5rem',
                                        height: '0.5rem',
                                        backgroundColor: isConnected ? '#60a5fa' : '#52525b',
                                        borderRadius: '50%',
                                        position: 'absolute',
                                        zIndex: 20,
                                        pointerEvents: 'auto'
                                    }}
                                    onMouseDown={(e) => {
                                        e.stopPropagation();
                                        e.preventDefault();
                                        const world = screenToWorld(e.clientX, e.clientY);
                                        setMousePos(world);
                                        setConnectingTarget(node.id);
                                        setConnectingInputType('default');
                                    }}
                                    onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')}
                                />
                                <div
                                    className="input-point"
                                    style={{
                                        top: '66%',
                                        left: '-0.25rem',
                                        width: '0.5rem',
                                        height: '0.5rem',
                                        backgroundColor: isConnected ? '#60a5fa' : '#52525b',
                                        borderRadius: '50%',
                                        position: 'absolute',
                                        zIndex: 20,
                                        pointerEvents: 'auto'
                                    }}
                                    onMouseDown={(e) => {
                                        e.stopPropagation();
                                        e.preventDefault();
                                        const world = screenToWorld(e.clientX, e.clientY);
                                        setMousePos(world);
                                        setConnectingTarget(node.id);
                                        setConnectingInputType('default');
                                    }}
                                    onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')}
                                />
                            </>
                        ) : (
                            <div
                                className="input-point"
                                style={{
                                    top: '50%',
                                    left: '-0.25rem',
                                    width: '0.5rem',
                                    height: '0.5rem',
                                    backgroundColor: isConnected ? '#60a5fa' : '#52525b',
                                    borderRadius: '50%',
                                    position: 'absolute',
                                    zIndex: 20,
                                    pointerEvents: 'auto'
                                }}
                                onMouseDown={(e) => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    const world = screenToWorld(e.clientX, e.clientY);
                                    setMousePos(world);
                                    setConnectingTarget(node.id);
                                    setConnectingInputType('default');
                                }}
                                onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')}
                            />
                        )
                    )}
                    {node.type !== 'preview' && (
                        <div
                            className="connector connector-right"
                            style={{
                                position: 'absolute',
                                top: '50%',
                                right: '-0.45rem',
                                width: '0.9rem',
                                height: '0.9rem',
                                backgroundColor: connectingSource === node.id ? '#d4d4d8' : '#27272a',
                                border: '1px solid #71717a',
                                borderRadius: '50%',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                cursor: 'crosshair',
                                zIndex: 30,
                                opacity: connectingSource === node.id ? 1 : 0.5,
                                pointerEvents: 'auto'
                            }}
                            onMouseDown={(e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                const world = screenToWorld(e.clientX, e.clientY);
                                setMousePos(world);
                                setConnectingSource(node.id);
                            }}
                        >
                            <Plus size={10} />
                        </div>
                    )}
                </div>
            );
        }

        // 高细节模式：完整渲染逻辑
        return (
            <div
                key={node.id}
                data-node-id={node.id}
                className={`absolute rounded-xl shadow-xl transition-shadow duration-150 group flex flex-col node-wrapper ${isSelected
                    ? 'ring-1 ring-blue-500 shadow-blue-500/20'
                    : isAdjacent
                        ? 'ring-2 ring-blue-300/60 shadow-blue-300/30'
                        : theme === 'dark'
                            ? 'border border-zinc-800 shadow-black/40'
                        : theme === 'solarized'
                            ? 'border border-[#eee8d5] shadow-black/10'
                        : 'border border-zinc-200 shadow-black/10'
                    } ${isHoverTarget && ((connectingSource && connectingSource !== node.id) || (connectingTarget && connectingTarget !== node.id)) ? 'ring-2 ring-green-500/50' : ''} ${theme === 'dark' ? 'bg-[#18181b]' : theme === 'solarized' ? 'bg-[#eee8d5]' : 'bg-white'
                    }`}
                style={{
                    left: node.x,
                    top: node.y,
                    width: node.width,
                    height: node.height,
                    cursor: (dragNodeId === node.id || (dragNodeId && selectedNodeIds.has(node.id))) ? 'grabbing' : 'default',
                    zIndex: isDragging ? 50 : 10, // 拖动时提升 z-index，避免被其他节点遮挡
                    WebkitFontSmoothing: 'antialiased',
                    MozOsxFontSmoothing: 'grayscale',
                    textRendering: 'optimizeLegibility',
                    transform: 'translateZ(0)',
                    backfaceVisibility: 'hidden'
                }}
                onDragOver={enableSmartDrop ? handleCanvasDragOver : undefined}
                onDrop={enableSmartDrop ? (e) => handleGenNodeDrop(node.id, e) : undefined}
                onMouseDownCapture={(e) => {
                    if (e.button !== 0 || e.target === e.currentTarget) return;
                    const interactive = e.target.closest('input, textarea, select, button, a, [contenteditable="true"]');
                    if (!interactive) return;
                    if (e.nativeEvent) e.nativeEvent.__tapnowSelectionHandled = true;
                    if (e.ctrlKey || e.metaKey) {
                        setSelectedNodeIds(prev => {
                            const newSet = new Set(prev);
                            if (newSet.has(node.id)) {
                                newSet.delete(node.id);
                            } else {
                                newSet.add(node.id);
                            }
                            if (newSet.size === 1) {
                                setSelectedNodeId(Array.from(newSet)[0]);
                            } else {
                                setSelectedNodeId(null);
                            }
                            return newSet;
                        });
                        return;
                    }
                    const isAlreadySelected = selectedNodeIds.has(node.id);
                    if (isAlreadySelected && selectedNodeIds.size > 1) {
                        setSelectedNodeId(node.id);
                    } else {
                        setSelectedNodeId(node.id);
                        setSelectedNodeIds(new Set([node.id]));
                    }
                }}
                onMouseDown={(e) => {
                    if (e.nativeEvent?.__tapnowSelectionHandled) return;
                    if (e.button === 0) {
                        e.stopPropagation();
                        markInteraction('node');
                        // 如果按住了Ctrl键，添加到多选
                        if (e.ctrlKey || e.metaKey) {
                            setSelectedNodeIds(prev => {
                                const newSet = new Set(prev);
                                if (newSet.has(node.id)) {
                                    newSet.delete(node.id);
                                } else {
                                    newSet.add(node.id);
                                }
                                // 如果多选集合为空或只有一个，更新selectedNodeId
                                if (newSet.size === 1) {
                                    setSelectedNodeId(Array.from(newSet)[0]);
                                } else {
                                    setSelectedNodeId(null);
                                }
                                return newSet;
                            });
                        } else {
                            // 如果没有按住Ctrl，检查该节点是否已经在多选集合中
                            const isAlreadySelected = selectedNodeIds.has(node.id);
                            if (isAlreadySelected && selectedNodeIds.size > 1) {
                                // 如果节点已经在多选集合中，保持多选状态，不重置
                                // 只更新 selectedNodeId 为当前节点（用于显示详情等）
                                setSelectedNodeId(node.id);
                            } else {
                                // 单选模式：重置为只选中当前节点
                                setSelectedNodeId(node.id);
                                setSelectedNodeIds(new Set([node.id]));
                            }
                        }
                        setDragNodeId(node.id);
                        setActiveDropdown(null);
                    }
                }}
                onMouseEnter={() => { if (connectingSource || connectingTarget) setHoverTargetId(node.id); }}
                onMouseLeave={() => { if ((connectingSource || connectingTarget) && hoverTargetId === node.id) setHoverTargetId(null); }}
                onMouseUp={(e) => handleNodeMouseUp(node.id, e)}
                onDoubleClick={(e) => {
                    // V3.5.26: Prevent canvas double-click menu for ALL nodes
                    e.stopPropagation();

                    // 功能6：双击图片或视频节点显示预览弹窗
                    if ((node.type === 'input-image' || node.type === 'video-input') && node.content) {
                        setLightboxItem({ url: node.content, type: isVideoUrl(node.content) ? 'video' : 'image' });
                    }
                }}
            >
                <button
                    onClick={(e) => { e.stopPropagation(); deleteNode(node.id); }}
                    className={`absolute -top-2.5 -right-2.5 z-50 p-1 rounded-full shadow border opacity-0 group-hover:opacity-100 transition-opacity scale-90 hover:scale-100 ${theme === 'dark'
                        ? 'bg-zinc-800 text-zinc-400 hover:text-red-500 hover:bg-zinc-700 border-zinc-700'
                        : 'bg-zinc-100 text-zinc-500 hover:text-red-500 hover:bg-zinc-200 border-zinc-300'
                        }`}
                    onMouseDown={(e) => e.stopPropagation()}
                >
                    <X size={12} />
                </button>
                <div className="absolute bottom-1 right-1 w-4 h-4 z-[100] resize-handle flex items-end justify-end p-0.5" onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setResizingNodeId(node.id); }}><svg width="6" height="6" viewBox="0 0 8 8" fill="none" className="text-zinc-600"><path d="M8 0L8 8L0 8" stroke="currentColor" strokeWidth="2" /></svg></div>

                {node.type !== 'input-image' && node.type !== 'video-input' && node.type !== 'video-analyze' && node.type !== 'preview' && (
                    node.type === 'image-compare' ? (
                        <>
                            <div
                                className={`input-point ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`}
                                style={{ top: '33%' }}
                                title={t('图 1 输入')}
                                onMouseDown={(e) => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                    const world = screenToWorld(e.clientX, e.clientY);
                                    setMousePos(world);
                                    setConnectingTarget(node.id);
                                    setConnectingInputType('default');
                                }}
                                onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')}
                            />
                            <div
                                className={`input-point ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`}
                                style={{ top: '66%' }}
                                title={t('图 2 输入')}
                                onMouseDown={(e) => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                    const world = screenToWorld(e.clientX, e.clientY);
                                    setMousePos(world);
                                    setConnectingTarget(node.id);
                                    setConnectingInputType('default');
                                }}
                                onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')}
                            />
                        </>
                    ) : (
                        <div
                            className={`input-point ${isConnected ? 'connected' : ''} ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`}
                            title={t('输入')}
                            onMouseDown={(e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                const world = screenToWorld(e.clientX, e.clientY);
                                setMousePos(world);
                                setConnectingTarget(node.id);
                                setConnectingInputType('default');
                            }}
                            onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')}
                        />
                    )
                )}

                {node.type !== 'preview' && (
                    <div
                        className={`connector connector-right ${connectingSource === node.id ? 'active' : ''} ${connectingTarget && hoverTargetId === node.id ? 'ring-2 ring-green-500/50' : ''}`}
                        title={t('输出')}
                        onMouseDown={(e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                            const world = screenToWorld(e.clientX, e.clientY);
                            setMousePos(world);
                            setConnectingSource(node.id);
                        }}
                        onMouseEnter={() => { if (connectingTarget) setHoverTargetId(node.id); }}
                        onMouseLeave={() => { if (connectingTarget && hoverTargetId === node.id) setHoverTargetId(null); }}
                    >
                        <Plus size={10} />
                    </div>
                )}


                <div
                    className={`overflow-hidden rounded-xl flex-1 flex flex-col pointer-events-none h-full w-full relative ${theme === 'dark' ? 'bg-[#18181b]' : theme === 'solarized' ? 'bg-[#eee8d5]' : 'bg-white'
                        }`}
                >
                    {/* V2.6.1 Feature: New Node Types Rendering */}
                    {node.type === 'novel-input' && (
                        <div className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${theme === 'dark' ? 'bg-zinc-900/80' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100'}`}>
                            <div className="flex items-center gap-1.5 px-3 py-2 border-b text-xs font-semibold shrink-0">
                                <FileText size={12} className="text-blue-500" />
                                <span>{t('小说输入')}</span>
                            </div>
                            <div className="flex-1 flex flex-col gap-2 p-3 overflow-hidden min-h-0">
                                <textarea
                                    value={node.settings?.content || ''}
                                    onChange={(e) => {
                                        const newValue = e.target.value;
                                        if (newValue.length <= 10000) {
                                            updateNodeSettings(node.id, { content: newValue });
                                        }
                                    }}
                                    placeholder={t('输入小说内容（最多10,000字）...')}
                                    maxLength={10000}
                                    className={`w-full flex-1 resize-none outline-none text-sm p-2 rounded border ${theme === 'dark'
                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500'
                                        : theme === 'solarized'
                                            ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400'
                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                        }`}
                                    onMouseDown={(e) => e.stopPropagation()}
                                />
                                <div className="text-right text-[10px] text-zinc-500 shrink-0">
                                    {(node.settings?.content || '').length}/10,000
                                </div>
                                <button
                                    className="w-full py-2 rounded text-xs font-medium transition-colors flex items-center justify-center gap-1.5 bg-blue-600 hover:bg-blue-500 text-white shrink-0"
                                    onMouseDown={(e) => e.stopPropagation()}
                                    onClick={(e) => { e.stopPropagation(); handleNovelExtract(node.id); }}
                                >
                                    <Sparkles size={12} /> {t('提取角色和场景')}
                                </button>
                            </div>
                        </div>
                    )}
                    {node.type === 'extract-characters-scenes' && (
                        <div className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${theme === 'dark' ? 'bg-zinc-900/80' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100'}`}>
                            <div className="flex items-center justify-between px-3 py-2 border-b shrink-0">
                                <div className="flex items-center gap-1.5 text-xs font-semibold">
                                    <Users size={12} className="text-purple-500" />
                                    <span>{t('角色与场景提取')}</span>
                                </div>
                                {node.settings?.analysisResults && (
                                    <span className="text-[10px] opacity-70">
                                        {(node.settings.analysisResults.characters?.length || 0) + (node.settings.analysisResults.scenes?.length || 0)}
                                    </span>
                                )}
                            </div>
                            <div className="flex-1 flex flex-col p-3 overflow-hidden min-h-0">
                                <div className="flex flex-col gap-3">
                                    <div className="flex flex-col gap-1.5">
                                        <label className="text-[10px] font-medium opacity-70">分析模型</label>
                                        {/* V3.4.10: 双层模型选择器 Provider -> Model */}
                                        <div className="relative">
                                            <button
                                                onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.nodeId === node.id && activeDropdown.type === 'extract-model' ? null : { nodeId: node.id, type: 'extract-model' }); }}
                                                className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-xs border transition-colors ${theme === 'dark'
                                                    ? 'bg-zinc-800 border-zinc-700 text-zinc-300 hover:border-zinc-600'
                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                    }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                            >
                                                <span className="truncate font-mono">{getModelLabelWithProvider(node.settings?.model)}</span>
                                                <ChevronDown size={12} className="opacity-50 shrink-0" />
                                            </button>
                                            {activeDropdown?.nodeId === node.id && activeDropdown.type === 'extract-model' && (
                                                <div
                                                    className={`absolute top-full left-0 mt-1 w-64 rounded-lg shadow-xl p-1 z-[60] border flex ${theme === 'dark'
                                                        ? 'bg-[#18181b] border-zinc-700'
                                                        : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    onMouseLeave={() => setHoveredProvider(null)}
                                                >
                                                    {/* Provider 列表 */}
                                                    <div className={`w-24 border-r pr-1 max-h-80 overflow-y-auto custom-scrollbar flex flex-col ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-200'}`}>
                                                        {Object.entries(groupedApiConfigs)
                                                            .filter(([, group]) => group.models.some(m => isChatModelType(m.type)))
                                                            .map(([providerKey, group]) => (
                                                                <button
                                                                    key={providerKey}
                                                                    onMouseEnter={() => setHoveredProvider(providerKey)}
                                                                    className={`w-full text-left px-2 py-1.5 text-[10px] rounded transition-colors ${hoveredProvider === providerKey
                                                                        ? theme === 'dark' ? 'bg-zinc-800 text-white' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-zinc-100 text-zinc-900'
                                                                        : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : theme === 'solarized' ? 'text-zinc-600 hover:text-zinc-700' : 'text-zinc-600 hover:text-zinc-800'
                                                                        }`}
                                                                >
                                                                    {group.name || providerKey}
                                                                </button>
                                                            ))}
                                                    </div>
                                                    {/* Model 列表 */}
                                                    <div className="flex-1 pl-1 max-h-80 overflow-y-auto custom-scrollbar">
                                                        {hoveredProvider && groupedApiConfigs[hoveredProvider]?.models
                                                            .filter(m => isChatModelType(m.type))
                                                            .map((m) => {
                                                                const modelKey = m._uid || m.id;
                                                                const currentModelKey = resolveModelKey(node.settings?.model);
                                                                return (
                                                                    <button
                                                                        key={modelKey}
                                                                        onClick={() => {
                                                                            updateNodeSettings(node.id, { model: modelKey });
                                                                            setLastUsedExtractModel(modelKey);
                                                                            try { localStorage.setItem('tapnow_last_extract_model', modelKey); } catch { }
                                                                            setActiveDropdown(null);
                                                                            setHoveredProvider(null);
                                                                        }}
                                                                        className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${currentModelKey === modelKey
                                                                            ? theme === 'dark' ? 'bg-blue-600/30 text-blue-300' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-blue-100 text-blue-700'
                                                                            : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-300' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'
                                                                            }`}
                                                                    >
                                                                        <span className="text-[10px] font-medium truncate font-mono">{getModelLabelWithProvider(m._uid || m.id)}</span>
                                                                        <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(modelKey)}`}></div>
                                                                    </button>
                                                                );
                                                            })}
                                                        {!hoveredProvider && (
                                                            <div className={`text-[10px] px-2 py-3 text-center ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                                ← 选择 Provider
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>

                                <div className="flex-1 overflow-y-auto custom-scrollbar mt-2">
                                    {(() => {
                                        const results = node.settings?.analysisResults;
                                        if (!results) {
                                            return (
                                                <div className="flex flex-col items-center justify-center py-6 text-[11px] opacity-70">
                                                    <Wand2 size={18} className="mb-1 opacity-70" />
                                                    <span>{t('点击“开始提取”开始分析')}</span>
                                                </div>
                                            );
                                        }
                                        const characters = Array.isArray(results.characters) ? results.characters : [];
                                        const scenes = Array.isArray(results.scenes) ? results.scenes : [];
                                        return (
                                            <div className="flex flex-col gap-3">
                                                {characters.length > 0 && (
                                                    <div>
                                                        <div className="text-[10px] font-medium mb-1 opacity-70">角色 ({characters.length})</div>
                                                        {characters.map((char, idx) => (
                                                            <div key={`${char.name || 'char'}-${idx}`} className={`p-2 rounded mb-1 ${theme === 'dark' ? 'bg-zinc-800' : 'bg-white border border-zinc-200'}`}>
                                                                <div className="flex items-center gap-1 text-[11px]">
                                                                    <span className={`w-2 h-2 rounded-full shrink-0 ${idx === 0 ? 'bg-red-500' : idx === 1 ? 'bg-purple-500' : idx === 2 ? 'bg-blue-500' : 'bg-zinc-400'}`}></span>
                                                                    <span className="font-medium">{char.name || '未命名角色'}</span>
                                                                </div>
                                                                {char.description && (
                                                                    <div className="mt-1 text-[10px] opacity-70 leading-snug">{char.description}</div>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {scenes.length > 0 && (
                                                    <div>
                                                        <div className="text-[10px] font-medium mb-1 opacity-70">场景 ({scenes.length})</div>
                                                        {scenes.map((scene, idx) => (
                                                            <div key={`${scene.location || 'scene'}-${idx}`} className={`p-2 rounded mb-1 ${theme === 'dark' ? 'bg-zinc-800' : 'bg-white border border-zinc-200'}`}>
                                                                <div className="flex items-center gap-1 text-[11px]">
                                                                    <span className="w-2 h-2 rounded-full bg-green-500 shrink-0"></span>
                                                                    <span className="font-medium">{scene.location || scene.name || '未命名场景'}</span>
                                                                </div>
                                                                {scene.description && (
                                                                    <div className="mt-1 text-[10px] opacity-70 leading-snug">{scene.description}</div>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {characters.length === 0 && scenes.length === 0 && (
                                                    <div className="text-[11px] text-zinc-500">未返回角色/场景数据</div>
                                                )}
                                            </div>
                                        );
                                    })()}
                                    {node.settings?.errorMsg && (
                                        <div className="mt-2 text-[10px] text-red-500 break-words">{node.settings.errorMsg}</div>
                                    )}
                                </div>

                                {node.settings?.isAnalyzing && (
                                    <div className="mt-2">
                                        <div className="text-[10px] mb-1 opacity-70">正在分析小说内容...</div>
                                        <div className={`w-full h-1.5 rounded-full overflow-hidden ${theme === 'dark' ? 'bg-zinc-800' : 'bg-zinc-200'}`}>
                                            <div
                                                className="h-full bg-blue-500 transition-all duration-300"
                                                style={{ width: `${node.settings?.progress || 0}%` }}
                                            />
                                        </div>
                                        <div className="text-[10px] mt-1 opacity-70">{node.settings?.progress || 0}%</div>
                                    </div>
                                )}

                                <button
                                    className={`mt-2 w-full py-2 rounded text-xs font-medium transition-colors flex items-center justify-center gap-1.5 ${node.settings?.isAnalyzing ? 'bg-zinc-700 text-zinc-400 cursor-not-allowed' : 'bg-purple-600 hover:bg-purple-500 text-white'}`}
                                    onMouseDown={(e) => e.stopPropagation()}
                                    onClick={(e) => { e.stopPropagation(); handleExtractAnalysis(node.id); }}
                                >
                                    {node.settings?.isAnalyzing ? <><Loader2 size={12} className="animate-spin" />分析中...</> : <><Sparkles size={12} />开始提取</>}
                                </button>
                            </div>
                        </div>
                    )}
                    {(node.type === 'character-description' || node.type === 'scene-description') && (
                        <div className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${theme === 'dark' ? 'bg-zinc-900/80' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100'}`}>
                            {(() => {
                                const isCharacter = node.type === 'character-description';
                                const title = isCharacter ? '角色描述' : '场景描述';
                                const mode = node.settings?.mode || 'video';
                                const baseCharacter = {
                                    name: node.settings?.characterName || node.settings?.name || '角色',
                                    role: node.settings?.role || '',
                                    description: node.settings?.description || '',
                                    age: node.settings?.age || '',
                                    gender: node.settings?.gender || ''
                                };
                                const baseScene = {
                                    name: node.settings?.sceneName || node.settings?.location || '场景',
                                    location: node.settings?.sceneName || node.settings?.location || '',
                                    description: node.settings?.description || ''
                                };
                                const defaultPrompt = isCharacter
                                    ? generateCharacterPrompt(baseCharacter, mode)
                                    : generateScenePrompt(baseScene);
                                const promptValue = node.settings?.prompt || defaultPrompt;

                                return (
                                    <>
                                        <div className={`flex items-center justify-between px-3 py-2 border-b text-xs font-semibold shrink-0 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                            <div className="flex items-center gap-1.5">
                                                <FileText size={12} className={isCharacter ? "text-red-500" : "text-green-500"} />
                                                <span>{title}</span>
                                            </div>
                                            {isCharacter ? (
                                                baseCharacter.name ? <div className="text-[10px] text-zinc-500">角色: {baseCharacter.name}</div> : null
                                            ) : (
                                                baseScene.name ? <div className="text-[10px] text-zinc-500">场景: {baseScene.name}</div> : null
                                            )}
                                        </div>

                                        <div className="flex-1 flex flex-col gap-3 p-3 overflow-y-auto custom-scrollbar min-h-0">
                                            <div className="flex items-center gap-2 shrink-0">
                                                <button
                                                    className={`px-2 py-1 rounded text-[10px] transition-colors ${mode === 'video'
                                                        ? 'bg-blue-500 text-white'
                                                        : theme === 'dark'
                                                            ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                            : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    onClick={() => {
                                                        const currentPrompt = node.settings?.prompt || (isCharacter ? generateCharacterPrompt(baseCharacter, 'image') : defaultPrompt);
                                                        const updatedPrompt = isCharacter ? ensureCharacterVideoSuffix(currentPrompt) : currentPrompt;
                                                        updateNodeSettings(node.id, { mode: 'video', prompt: updatedPrompt });
                                                        setTimeout(() => ensureVideoNodeForDescription(node.id), 0);
                                                    }}
                                                >
                                                    视频模式
                                                </button>
                                                <button
                                                    className={`px-2 py-1 rounded text-[10px] transition-colors ${mode === 'image'
                                                        ? 'bg-blue-500 text-white'
                                                        : theme === 'dark'
                                                            ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                            : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    onClick={() => {
                                                        const currentPrompt = node.settings?.prompt || (isCharacter ? generateCharacterPrompt(baseCharacter, 'video') : defaultPrompt);
                                                        const updatedPrompt = isCharacter
                                                            ? stripCharacterVideoSuffix(currentPrompt)
                                                            : currentPrompt;
                                                        updateNodeSettings(node.id, { mode: 'image', prompt: updatedPrompt });
                                                        setTimeout(() => ensureImageNodeForDescription(node.id), 0);
                                                    }}
                                                >
                                                    图片模式
                                                </button>
                                                <div className="ml-auto flex items-center gap-2">
                                                    <button
                                                        onClick={() => runDescriptionPromptAction(node.id, 'enhance')}
                                                        disabled={node.settings?.isEnhancing}
                                                        className={`px-2 py-1 rounded text-[10px] transition-colors ${node.settings?.isEnhancing
                                                            ? theme === 'dark'
                                                                ? 'bg-zinc-700 text-zinc-500 cursor-not-allowed'
                                                                : 'bg-zinc-200 text-zinc-400 cursor-not-allowed'
                                                            : theme === 'dark'
                                                                ? 'bg-purple-600/80 text-white hover:bg-purple-500'
                                                                : 'bg-purple-600 text-white hover:bg-purple-500'
                                                            }`}
                                                    >
                                                        {isCharacter ? '增强角色描述' : '增强场景描述'}
                                                    </button>
                                                    <button
                                                        onClick={() => runDescriptionPromptAction(node.id, 'filter')}
                                                        disabled={node.settings?.isEnhancing}
                                                        className={`px-2 py-1 rounded text-[10px] transition-colors ${node.settings?.isEnhancing
                                                            ? theme === 'dark'
                                                                ? 'bg-zinc-700 text-zinc-500 cursor-not-allowed'
                                                                : 'bg-zinc-200 text-zinc-400 cursor-not-allowed'
                                                            : theme === 'dark'
                                                                ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                                : 'bg-zinc-200 text-zinc-700 hover:bg-zinc-300'
                                                            }`}
                                                    >
                                                        过滤提示词
                                                    </button>
                                                </div>
                                            </div>

                                            <div className="flex flex-col gap-1">
                                                <div className="flex items-center justify-between text-[10px] text-zinc-500">
                                                    <span>{t('提示词')}</span>
                                                    {node.settings?.isEnhancing && (
                                                        <span className="flex items-center gap-1 text-blue-400">
                                                            <Loader2 size={10} className="animate-spin" />
                                                            处理中
                                                        </span>
                                                    )}
                                                </div>
                                                <textarea
                                                    value={promptValue}
                                                    onChange={(e) => updateNodeSettings(node.id, { prompt: e.target.value })}
                                                    placeholder={t('输入角色/场景描述提示词...')}
                                                    className={`w-full h-28 resize-none outline-none text-sm p-2 rounded border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                />
                                            </div>

                                            <div className="flex flex-col gap-1.5">
                                                <label className="text-[10px] font-medium opacity-70">大模型选择（用于增强/过滤）</label>
                                                <div className="relative">
                                                    <button
                                                        onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.nodeId === node.id && activeDropdown.type === 'desc-model' ? null : { nodeId: node.id, type: 'desc-model' }); }}
                                                        className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-xs border transition-colors ${theme === 'dark'
                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-300 hover:border-zinc-600'
                                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                            }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        <span className="truncate font-mono">{getModelLabelWithProvider(node.settings?.chatModel)}</span>
                                                        <ChevronDown size={12} className="opacity-50 shrink-0" />
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'desc-model' && (
                                                        <div
                                                            className={`absolute top-full left-0 mt-1 w-64 rounded-lg shadow-xl p-1 z-[60] border flex ${theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                }`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                            onMouseLeave={() => setHoveredProvider(null)}
                                                        >
                                                            <div className={`w-24 border-r pr-1 max-h-80 overflow-y-auto custom-scrollbar flex flex-col ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-200'}`}>
                                                                {Object.entries(groupedApiConfigs)
                                                                    .filter(([, group]) => group.models.some(m => isChatModelType(m.type)))
                                                                    .map(([providerKey, group]) => (
                                                                        <button
                                                                            key={providerKey}
                                                                            onMouseEnter={() => setHoveredProvider(providerKey)}
                                                                            className={`w-full text-left px-2 py-1.5 text-[10px] rounded transition-colors ${hoveredProvider === providerKey
                                                                                ? theme === 'dark' ? 'bg-zinc-800 text-white' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-zinc-100 text-zinc-900'
                                                                                : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : theme === 'solarized' ? 'text-zinc-600 hover:text-zinc-700' : 'text-zinc-600 hover:text-zinc-800'
                                                                                }`}
                                                                        >
                                                                            {group.name || providerKey}
                                                                        </button>
                                                                    ))}
                                                            </div>
                                                            <div className="flex-1 pl-1 max-h-80 overflow-y-auto custom-scrollbar">
                                                                {hoveredProvider && groupedApiConfigs[hoveredProvider]?.models
                                                                    .filter(m => isChatModelType(m.type))
                                                                    .map((m) => {
                                                                        const modelKey = m._uid || m.id;
                                                                        const currentModelKey = resolveModelKey(node.settings?.chatModel);
                                                                        return (
                                                                            <button
                                                                                key={modelKey}
                                                                                onClick={() => {
                                                                                    updateNodeSettings(node.id, { chatModel: modelKey });
                                                                                    setLastUsedExtractModel(modelKey);
                                                                                    try { localStorage.setItem('tapnow_last_extract_model', modelKey); } catch { }
                                                                                    setActiveDropdown(null);
                                                                                    setHoveredProvider(null);
                                                                                }}
                                                                                className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${currentModelKey === modelKey
                                                                                    ? theme === 'dark' ? 'bg-blue-600/30 text-blue-300' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-blue-100 text-blue-700'
                                                                                    : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-300' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'
                                                                                    }`}
                                                                            >
                                                                                <span className="text-[10px] font-medium truncate font-mono">{getModelLabelWithProvider(m._uid || m.id)}</span>
                                                                                <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(modelKey)}`}></div>
                                                                            </button>
                                                                        );
                                                                    })}
                                                                {!hoveredProvider && (
                                                                    <div className={`text-[10px] px-2 py-3 text-center ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                                        ← 选择 Provider
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>

                                            <div className="flex flex-col gap-1.5">
                                                <label className="text-[10px] font-medium opacity-70">风格</label>
                                                <select
                                                    value={node.settings?.style || 'none'}
                                                    onChange={(e) => {
                                                        const newStyle = e.target.value;
                                                        const stylePrefix = getDescriptionStylePrefix(newStyle);
                                                        const currentPrompt = node.settings?.prompt || defaultPrompt;
                                                        const updatedPrompt = currentPrompt.includes('，')
                                                            ? currentPrompt.replace(/^[^，]+，/, `${stylePrefix}，`)
                                                            : `${stylePrefix}，${currentPrompt}`;
                                                        updateNodeSettings(node.id, { style: newStyle, prompt: updatedPrompt });
                                                    }}
                                                    className={`w-full text-xs border rounded px-2 py-1.5 outline-none focus:border-blue-500 ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-300'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {DESCRIPTION_STYLE_OPTIONS.map((option) => (
                                                        <option key={option.value} value={option.value}>{option.label}</option>
                                                    ))}
                                                </select>
                                            </div>

                                            <div className="flex flex-col gap-1.5">
                                                <label className="text-[10px] font-medium opacity-70">参考图</label>
                                                <div
                                                    className={`rounded-lg border-2 border-dashed p-2 transition-colors drop-zone ${theme === 'dark'
                                                        ? 'border-zinc-700 bg-zinc-800/60'
                                                        : 'border-zinc-300 bg-white'
                                                        }`}
                                                    onDrop={(e) => handleDescReferenceDrop(node.id, e)}
                                                    onDragOver={handleDragOver}
                                                    onDragLeave={handleDragLeave}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {node.settings?.referenceImages?.length > 0 ? (
                                                        <div className="grid grid-cols-4 gap-2">
                                                            {node.settings.referenceImages.map((img, idx) => (
                                                                <div key={`${node.id}-ref-${idx}`} className="relative aspect-square rounded overflow-hidden">
                                                                    <LazyBase64Image src={img} className="w-full h-full object-cover" />
                                                                    <button
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            const nextRefs = [...node.settings.referenceImages];
                                                                            nextRefs.splice(idx, 1);
                                                                            updateNodeSettings(node.id, { referenceImages: nextRefs });
                                                                        }}
                                                                        className="absolute top-1 right-1 p-1 rounded-full bg-black/60 text-white hover:bg-red-500"
                                                                        title={t('删除')}
                                                                    >
                                                                        <X size={10} />
                                                                    </button>
                                                                </div>
                                                            ))}
                                                            <label className="aspect-square rounded border border-dashed border-zinc-500/60 flex items-center justify-center text-[10px] text-zinc-400 cursor-pointer hover:border-blue-400 hover:text-blue-400">
                                                                + 添加
                                                                <input
                                                                    type="file"
                                                                    className="hidden"
                                                                    accept="image/*"
                                                                    multiple
                                                                    onChange={(e) => handleDescReferenceSelect(node.id, e)}
                                                                />
                                                            </label>
                                                        </div>
                                                    ) : (
                                                        <label className="flex flex-col items-center justify-center gap-1 text-[10px] text-zinc-500 cursor-pointer">
                                                            <FolderOpen size={16} />
                                                            点击或拖拽添加参考图
                                                            <input
                                                                type="file"
                                                                className="hidden"
                                                                accept="image/*"
                                                                multiple
                                                                onChange={(e) => handleDescReferenceSelect(node.id, e)}
                                                            />
                                                        </label>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    </>
                                );
                            })()}
                        </div>
                    )}
                    {(node.type === 'generate-character-video' || node.type === 'generate-scene-video') && (
                        <div className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${theme === 'dark' ? 'bg-zinc-900/80' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100'}`}>
                            {(() => {
                                const isCharacter = node.type === 'generate-character-video';
                                const descType = isCharacter ? 'character-description' : 'scene-description';
                                const imageType = isCharacter ? 'generate-character-image' : 'generate-scene-image';
                                const descriptionNode = connections
                                    .filter(c => c.to === node.id)
                                    .map(c => nodesMap.get(c.from))
                                    .find(n => n?.type === descType);
                                const imageNode = connections
                                    .filter(c => c.to === node.id)
                                    .map(c => nodesMap.get(c.from))
                                    .find(n => n?.type === imageType);

                                const latestCompleted = history.find(h => h.sourceNodeId === node.id && h.status === 'completed');
                                const latestGenerating = history.find(h => h.sourceNodeId === node.id && h.status === 'generating');
                                const latestFailed = history.find(h => h.sourceNodeId === node.id && h.status === 'failed');
                                const resolvedVideoUrl = resolveHistoryUrl(latestCompleted);

                                const imageHistory = imageNode ? history.find(h => h.sourceNodeId === imageNode.id && h.status === 'completed') : null;
                                const imageUrls = imageHistory?.output_images?.length
                                    ? imageHistory.output_images
                                    : (imageHistory?.mjImages?.length ? imageHistory.mjImages : []);
                                const fallbackImage = resolveHistoryUrl(imageHistory);
                                const normalizedImageUrls = imageUrls.length > 0 ? imageUrls : (fallbackImage ? [fallbackImage] : []);
                                const selectedImageIndex = imageNode?.settings?.selectedImageIndex;
                                const selectedImageUrl = (selectedImageIndex !== null && selectedImageIndex !== undefined && normalizedImageUrls[selectedImageIndex])
                                    ? normalizedImageUrls[selectedImageIndex]
                                    : null;

                                const basePrompt = node.settings?.videoPrompt || descriptionNode?.settings?.prompt || '';
                                const elapsedSeconds = nodeTimers[node.id] || 0;
                                const finalDuration = latestCompleted?.durationMs ? (latestCompleted.durationMs / 1000).toFixed(1) : null;
                                const isGenerating = !!latestGenerating;
                                const defaultVideoModel = resolveModelKey(lastUsedVideoModel)
                                    || resolveModelKey(apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'))?.id)
                                    || resolveModelKey(apiConfigs.find(c => c.type === 'Video')?.id)
                                    || '';
                                const modelId = resolveModelKey(node.settings?.model || defaultVideoModel);
                                const durationOptions = getDefaultDurationsForModel(modelId);
                                const storedDuration = node.settings?.duration;
                                const currentDuration = durationOptions.includes(storedDuration)
                                    ? storedDuration
                                    : (durationOptions[0] || '5s');
                                if (durationOptions.length > 0 && storedDuration && !durationOptions.includes(storedDuration)) {
                                    setTimeout(() => {
                                        updateNodeSettings(node.id, { duration: durationOptions[0] || '5s' });
                                    }, 0);
                                }
                                const resolutionOptions = getVideoResolutionsForModel(modelId);
                                const resolutionConfig = getApiConfigByKey(modelId);
                                const currentResolution = normalizeVideoResolution(node.settings?.resolution || lastUsedVideoResolution || '720P');
                                const fallbackResolution = resolutionOptions.find((res) => res !== 'Auto') || '720P';
                                const resolvedResolution = resolutionOptions.includes(currentResolution) ? currentResolution : fallbackResolution;
                                if (resolvedResolution !== currentResolution) {
                                    setTimeout(() => {
                                        updateNodeSettings(node.id, { resolution: resolvedResolution });
                                    }, 0);
                                }

                                return (
                                    <>
                                        {(isGenerating || finalDuration) && (
                                            <div className={`m-3 mb-0 px-2 py-1 rounded text-[10px] font-mono text-center ${theme === 'dark'
                                                ? 'bg-blue-500/20 text-blue-400 border border-blue-500/30'
                                                : 'bg-blue-50 text-blue-600 border border-blue-200'
                                                }`}>
                                                {isGenerating ? <span>? {elapsedSeconds.toFixed(1)}s</span> : <span>? {t('完成')} {finalDuration}s</span>}
                                            </div>
                                        )}
                                        <div className={`flex items-center gap-1.5 px-3 py-2 border-b text-xs font-semibold shrink-0 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                            <FileVideo size={12} className="text-green-500" />
                                            <span>{isCharacter ? t('生成角色视频') : t('生成场景视频')}</span>
                                        </div>

                                        <div className="flex-1 flex flex-col gap-3 p-3 overflow-y-auto min-h-0">
                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">选择模型</label>
                                                <div className="relative">
                                                    <button
                                                        onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.nodeId === node.id && activeDropdown.type === 'role-video-model' ? null : { nodeId: node.id, type: 'role-video-model' }); }}
                                                        className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-xs border transition-colors ${theme === 'dark'
                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-300 hover:border-zinc-600'
                                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                            }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        <span className="truncate font-mono">{getModelLabelWithProvider(modelId)}</span>
                                                        <ChevronDown size={12} className="opacity-50 shrink-0" />
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'role-video-model' && (
                                                        <div
                                                            className={`absolute top-full left-0 mt-1 w-64 rounded-lg shadow-xl p-1 z-[60] border flex ${theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                }`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                            onMouseLeave={() => setHoveredProvider(null)}
                                                        >
                                                            <div className={`w-24 border-r pr-1 max-h-80 overflow-y-auto custom-scrollbar flex flex-col ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-200'}`}>
                                                                {Object.entries(groupedApiConfigs)
                                                                    .filter(([, group]) => group.models.some(m => m.type === 'Video'))
                                                                    .map(([providerKey, group]) => (
                                                                        <button
                                                                            key={providerKey}
                                                                            onMouseEnter={() => setHoveredProvider(providerKey)}
                                                                            className={`w-full text-left px-2 py-1.5 text-[10px] rounded transition-colors ${hoveredProvider === providerKey
                                                                                ? theme === 'dark' ? 'bg-zinc-800 text-white' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-zinc-100 text-zinc-900'
                                                                                : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : theme === 'solarized' ? 'text-zinc-600 hover:text-zinc-700' : 'text-zinc-600 hover:text-zinc-800'
                                                                                }`}
                                                                        >
                                                                            {group.name || providerKey}
                                                                        </button>
                                                                    ))}
                                                            </div>
                                                            <div className="flex-1 pl-1 max-h-80 overflow-y-auto custom-scrollbar">
                                                                {hoveredProvider && groupedApiConfigs[hoveredProvider]?.models
                                                                    .filter(m => m.type === 'Video')
                                                                    .map((m) => {
                                                                        const modelKey = m._uid || m.id;
                                                                        const currentModelKey = resolveModelKey(node.settings?.model);
                                                                        return (
                                                                            <button
                                                                                key={modelKey}
                                                                                onClick={() => {
                                                                                    updateNodeSettings(node.id, { model: modelKey });
                                                                                    setLastUsedVideoModel(modelKey);
                                                                                    try { localStorage.setItem('tapnow_last_video_model', modelKey); } catch { }
                                                                                    setActiveDropdown(null);
                                                                                    setHoveredProvider(null);
                                                                                }}
                                                                                className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${currentModelKey === modelKey
                                                                                    ? theme === 'dark' ? 'bg-blue-600/30 text-blue-300' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-blue-100 text-blue-700'
                                                                                    : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-300' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'
                                                                                    }`}
                                                                            >
                                                                                <span className="text-[10px] font-medium truncate font-mono">{getModelLabelWithProvider(m._uid || m.id)}</span>
                                                                                <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(modelKey)}`}></div>
                                                                            </button>
                                                                        );
                                                                    })}
                                                                {!hoveredProvider && (
                                                                    <div className={`text-[10px] px-2 py-3 text-center ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                                        ← 选择 Provider
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>

                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">时长</label>
                                                <select
                                                    value={currentDuration}
                                                    onChange={(e) => updateNodeSettings(node.id, { duration: e.target.value })}
                                                    className={`w-full px-2 py-1 rounded text-xs border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {(durationOptions.length > 0 ? durationOptions : ['5s', '10s', '15s']).map(d => (
                                                        <option key={d} value={d}>
                                                            {getValueLabelWithNotes(d, !!resolutionConfig?.durationNotesEnabled, resolutionConfig?.durationNotes || {})}
                                                        </option>
                                                    ))}
                                                </select>
                                            </div>

                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">比例</label>
                                                <select
                                                    value={node.settings?.ratio || '16:9'}
                                                    onChange={(e) => updateNodeSettings(node.id, { ratio: e.target.value })}
                                                    className={`w-full px-2 py-1 rounded text-xs border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {getRatiosForModel(modelId).map((ratio) => (
                                                        <option key={ratio} value={ratio}>
                                                            {ratio === 'Auto'
                                                                ? 'Auto'
                                                                : getValueLabelWithNotes(ratio, !!resolutionConfig?.ratioNotesEnabled, resolutionConfig?.ratioNotes || {})}
                                                        </option>
                                                    ))}
                                                </select>
                                            </div>

                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">{t('分辨率')}</label>
                                                <select
                                                    value={resolvedResolution}
                                                    onChange={(e) => {
                                                        const nextValue = e.target.value;
                                                        updateNodeSettings(node.id, { resolution: nextValue });
                                                        if (nextValue !== 'Auto') {
                                                            setLastUsedVideoResolution(nextValue);
                                                            try { localStorage.setItem('tapnow_last_video_res', nextValue); } catch { }
                                                        }
                                                    }}
                                                    className={`w-full px-2 py-1 rounded text-xs border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {resolutionOptions.map(res => (
                                                        <option key={res} value={res}>
                                                            {res === 'Auto'
                                                                ? '不选'
                                                                : getValueLabelWithNotes(res, !!resolutionConfig?.videoResolutionNotesEnabled, resolutionConfig?.videoResolutionNotes || {})}
                                                        </option>
                                                    ))}
                                                </select>
                                            </div>

                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">{t('提示词')}</label>
                                                <textarea
                                                    value={basePrompt}
                                                    onChange={(e) => updateNodeSettings(node.id, { videoPrompt: e.target.value })}
                                                    placeholder={t('输入视频生成提示词...')}
                                                    className={`w-full h-20 resize-none outline-none text-sm p-2 rounded border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                />
                                            </div>

                                            {resolvedVideoUrl ? (
                                                <div
                                                    className="relative w-full aspect-video bg-black rounded-lg overflow-hidden cursor-pointer"
                                                    onDoubleClick={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        setLightboxItem({ id: `preview-video-${node.id}`, url: resolvedVideoUrl, type: 'video' });
                                                        setLightboxOpen(true);
                                                    }}
                                                    onContextMenu={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        const world = screenToWorld(e.clientX, e.clientY);
                                                        addNode('video-input', world.x, world.y, null, resolvedVideoUrl, { w: 400, h: 300 });
                                                    }}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    <ResolvedVideo
                                                        src={resolvedVideoUrl}
                                                        controls
                                                        className="w-full h-full object-contain"
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    />
                                                </div>
                                            ) : (
                                                <div className={`w-full aspect-video rounded border-2 border-dashed flex items-center justify-center ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'}`}>
                                                    <span className={`text-sm ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>点击下方按钮开始生成</span>
                                                </div>
                                            )}

                                            {latestGenerating && (
                                                <div className="mb-2">
                                                    <div className="text-[10px] mb-1 text-zinc-500">正在生成视频...</div>
                                                    <div className={`w-full h-1.5 rounded-full overflow-hidden ${theme === 'dark' ? 'bg-zinc-800' : 'bg-zinc-200'}`}>
                                                        <div
                                                            className="h-full bg-blue-500 transition-all duration-300"
                                                            style={{ width: `${latestGenerating.progress || 0}%` }}
                                                        />
                                                    </div>
                                                    <div className="text-[10px] text-zinc-500 mt-1">{latestGenerating.progress || 0}%</div>
                                                </div>
                                            )}

                                            {latestFailed?.errorMsg && (
                                                <div className="text-[10px] text-red-500">{latestFailed.errorMsg}</div>
                                            )}
                                        </div>

                                        <div className="px-3 py-2 border-t shrink-0">
                                            <button
                                                className={`w-full py-2 rounded text-xs font-medium transition-colors ${latestGenerating
                                                    ? 'bg-zinc-400 cursor-not-allowed text-white'
                                                    : theme === 'dark'
                                                        ? 'bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white'
                                                        : 'bg-green-600 hover:bg-green-500 text-white'
                                                    }`}
                                                disabled={!!latestGenerating}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={() => {
                                                    const prompt = basePrompt;
                                                    const referenceImages = node.settings?.referenceImages || descriptionNode?.settings?.referenceImages || [];
                                                    const sourceImages = selectedImageUrl ? [selectedImageUrl] : referenceImages;
                                                    if (!prompt && sourceImages.length === 0) {
                                                        alert(t('请先输入提示词或选择图片'));
                                                        return;
                                                    }
                                                    if (!modelId) {
                                                        alert(t('请先选择模型'));
                                                        return;
                                                    }
                                                    startGeneration(
                                                        prompt || '',
                                                        'video',
                                                        sourceImages,
                                                        node.id,
                                                        {
                                                            model: modelId,
                                                            ratio: node.settings?.ratio || '16:9',
                                                            duration: currentDuration,
                                                            resolution: resolvedResolution
                                                        }
                                                    );
                                                }}
                                            >
                                                {latestGenerating ? '生成中...' : '生成视频'}
                                            </button>
                                        </div>
                                    </>
                                );
                            })()}
                        </div>
                    )}
                    {(node.type === 'generate-character-image' || node.type === 'generate-scene-image') && (
                        <div className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${theme === 'dark' ? 'bg-zinc-900/80' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100'}`}>
                            {(() => {
                                const isScene = node.type === 'generate-scene-image';
                                const latestCompleted = history.find(h => h.sourceNodeId === node.id && h.status === 'completed');
                                const latestGenerating = history.find(h => h.sourceNodeId === node.id && h.status === 'generating');
                                const latestFailed = history.find(h => h.sourceNodeId === node.id && h.status === 'failed');
                                const resolvedUrl = resolveHistoryUrl(latestCompleted);
                                const outputImages = latestCompleted?.output_images?.length
                                    ? latestCompleted.output_images
                                    : (latestCompleted?.mjImages?.length ? latestCompleted.mjImages : (resolvedUrl ? [resolvedUrl] : []));
                                const selectedImageIndex = node.settings?.selectedImageIndex ?? null;
                                const defaultImageModel = resolveModelKey(lastUsedImageModel) || resolveModelKey(apiConfigs.find(c => isImageModelType(c.type))?.id) || '';
                                const modelId = resolveModelKey(node.settings?.model || defaultImageModel);

                                return (
                                    <>
                                        <div className={`flex items-center gap-1.5 px-3 py-2 border-b text-xs font-semibold shrink-0 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                            <FileText size={12} className="text-blue-500" />
                                            <span>{isScene ? t('生成场景图片') : t('生成角色图片')}</span>
                                        </div>

                                        <div className="flex-1 flex flex-col gap-3 p-3 overflow-y-auto min-h-0">
                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">选择模型</label>
                                                <div className="relative">
                                                    <button
                                                        onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.nodeId === node.id && activeDropdown.type === 'role-image-model' ? null : { nodeId: node.id, type: 'role-image-model' }); }}
                                                        className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-xs border transition-colors ${theme === 'dark'
                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-300 hover:border-zinc-600'
                                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                            }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        <span className="truncate font-mono">{getModelLabelWithProvider(modelId)}</span>
                                                        <ChevronDown size={12} className="opacity-50 shrink-0" />
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'role-image-model' && (
                                                        <div
                                                            className={`absolute top-full left-0 mt-1 w-64 rounded-lg shadow-xl p-1 z-[60] border flex ${theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                }`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                            onMouseLeave={() => setHoveredProvider(null)}
                                                        >
                                                            <div className={`w-24 border-r pr-1 max-h-80 overflow-y-auto custom-scrollbar flex flex-col ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-200'}`}>
                                                                {Object.entries(groupedApiConfigs)
                                                                    .filter(([, group]) => group.models.some(m => isImageModelType(m.type)))
                                                                    .map(([providerKey, group]) => (
                                                                        <button
                                                                            key={providerKey}
                                                                            onMouseEnter={() => setHoveredProvider(providerKey)}
                                                                            className={`w-full text-left px-2 py-1.5 text-[10px] rounded transition-colors ${hoveredProvider === providerKey
                                                                                ? theme === 'dark' ? 'bg-zinc-800 text-white' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-zinc-100 text-zinc-900'
                                                                                : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : theme === 'solarized' ? 'text-zinc-600 hover:text-zinc-700' : 'text-zinc-600 hover:text-zinc-800'
                                                                                }`}
                                                                        >
                                                                            {group.name || providerKey}
                                                                        </button>
                                                                    ))}
                                                            </div>
                                                            <div className="flex-1 pl-1 max-h-80 overflow-y-auto custom-scrollbar">
                                                                {hoveredProvider && groupedApiConfigs[hoveredProvider]?.models
                                                                    .filter(m => isImageModelType(m.type))
                                                                    .map((m) => {
                                                                        const modelKey = m._uid || m.id;
                                                                        const currentModelKey = resolveModelKey(node.settings?.model);
                                                                        return (
                                                                            <button
                                                                                key={modelKey}
                                                                                onClick={() => {
                                                                                    updateNodeSettings(node.id, { model: modelKey });
                                                                                    setLastUsedImageModel(modelKey);
                                                                                    try { localStorage.setItem('tapnow_last_image_model', modelKey); } catch { }
                                                                                    setActiveDropdown(null);
                                                                                    setHoveredProvider(null);
                                                                                }}
                                                                                className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${currentModelKey === modelKey
                                                                                    ? theme === 'dark' ? 'bg-blue-600/30 text-blue-300' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-blue-100 text-blue-700'
                                                                                    : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-300' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'
                                                                                    }`}
                                                                            >
                                                                                <span className="text-[10px] font-medium truncate font-mono">{getModelLabelWithProvider(m._uid || m.id)}</span>
                                                                                <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(modelKey)}`}></div>
                                                                            </button>
                                                                        );
                                                                    })}
                                                                {!hoveredProvider && (
                                                                    <div className={`text-[10px] px-2 py-3 text-center ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                                        ← 选择 Provider
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>

                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">比例</label>
                                                <select
                                                    value={node.settings?.ratio || '16:9'}
                                                    onChange={(e) => updateNodeSettings(node.id, { ratio: e.target.value })}
                                                    className={`w-full px-2 py-1 rounded text-xs border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    <option value="16:9">16:9</option>
                                                    <option value="9:16">9:16</option>
                                                    <option value="1:1">1:1</option>
                                                </select>
                                            </div>

                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">{t('分辨率')}</label>
                                                <select
                                                    value={node.settings?.resolution || '2K'}
                                                    onChange={(e) => updateNodeSettings(node.id, { resolution: e.target.value })}
                                                    className={`w-full px-2 py-1 rounded text-xs border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    <option value="1K">1K</option>
                                                    <option value="2K">2K</option>
                                                    <option value="4K">4K</option>
                                                    <option value="Auto">Auto</option>
                                                </select>
                                            </div>

                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">{t('提示词')}</label>
                                                <textarea
                                                    value={node.settings?.prompt || ''}
                                                    onChange={(e) => updateNodeSettings(node.id, { prompt: e.target.value })}
                                                    placeholder={t('输入图片生成提示词...')}
                                                    className={`w-full h-20 resize-none outline-none text-sm p-2 rounded border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                />
                                            </div>

                                            {outputImages.length > 0 ? (
                                                <div className="grid grid-cols-2 gap-2">
                                                    {outputImages.map((url, idx) => (
                                                        <div
                                                            key={`${url}-${idx}`}
                                                            className={`relative aspect-square bg-black rounded-lg overflow-hidden cursor-pointer transition-all ${selectedImageIndex === idx
                                                                ? 'ring-2 ring-blue-500 ring-offset-2'
                                                                : 'hover:ring-1 hover:ring-zinc-400'
                                                                }`}
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                const newIndex = selectedImageIndex === idx ? null : idx;
                                                                updateNodeSettings(node.id, { selectedImageIndex: newIndex });
                                                            }}
                                                            onDoubleClick={(e) => {
                                                                e.preventDefault();
                                                                e.stopPropagation();
                                                                setLightboxItem({ id: `preview-${node.id}-${idx}`, url, type: 'image', mjImages: outputImages, selectedMjImageIndex: idx });
                                                                setLightboxOpen(true);
                                                            }}
                                                            onContextMenu={(e) => {
                                                                e.preventDefault();
                                                                e.stopPropagation();
                                                                const world = screenToWorld(e.clientX, e.clientY);
                                                                addNode('input-image', world.x, world.y, null, url, { w: 400, h: 300 });
                                                            }}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                        >
                                                            <LazyBase64Image src={url} className="w-full h-full object-contain" />
                                                            <div className="absolute top-1 left-1 bg-black/50 text-white text-[10px] px-1 py-0.5 rounded">
                                                                {idx + 1}/{outputImages.length}
                                                            </div>
                                                            {selectedImageIndex === idx && (
                                                                <div className="absolute top-1 right-1 bg-blue-500 text-white text-[10px] px-1 py-0.5 rounded">
                                                                    {t('已选中')}
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                </div>
                                            ) : (
                                                <div className={`w-full h-28 rounded border-2 border-dashed flex items-center justify-center ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'}`}>
                                                    <span className={`text-sm ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>点击下方按钮开始生成</span>
                                                </div>
                                            )}

                                            {latestGenerating && (
                                                <div className="mb-2">
                                                    <div className="text-[10px] mb-1 text-zinc-500">{t('正在生成图片...')}</div>
                                                    <div className={`w-full h-1.5 rounded-full overflow-hidden ${theme === 'dark' ? 'bg-zinc-800' : 'bg-zinc-200'}`}>
                                                        <div
                                                            className="h-full bg-blue-500 transition-all duration-300"
                                                            style={{ width: `${latestGenerating.progress || 0}%` }}
                                                        />
                                                    </div>
                                                    <div className="text-[10px] text-zinc-500 mt-1">{latestGenerating.progress || 0}%</div>
                                                </div>
                                            )}

                                            {latestFailed?.errorMsg && (
                                                <div className="text-[10px] text-red-500">{latestFailed.errorMsg}</div>
                                            )}
                                        </div>

                                        <div className="px-3 py-2 border-t shrink-0">
                                            <button
                                                className={`w-full py-2 rounded text-xs font-medium transition-colors ${latestGenerating
                                                    ? 'bg-zinc-400 cursor-not-allowed text-white'
                                                    : theme === 'dark'
                                                        ? 'bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white'
                                                        : 'bg-blue-600 hover:bg-blue-500 text-white'
                                                    }`}
                                                disabled={!!latestGenerating}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={() => {
                                                    const prompt = node.settings?.prompt || '';
                                                    const modelId = resolveModelKey(node.settings?.model || lastUsedImageModel || apiConfigs.find(c => isImageModelType(c.type))?.id || '');
                                                    if (!prompt && (!node.settings?.referenceImages || node.settings.referenceImages.length === 0)) {
                                                        alert(t('请先输入提示词或添加参考图'));
                                                        return;
                                                    }
                                                    if (!modelId) {
                                                        alert(t('请先选择模型'));
                                                        return;
                                                    }
                                                    startGeneration(
                                                        prompt,
                                                        'image',
                                                        node.settings?.referenceImages || [],
                                                        node.id,
                                                        {
                                                            model: modelId,
                                                            ratio: node.settings?.ratio || '16:9',
                                                            resolution: node.settings?.resolution || lastUsedImageResolution || '2K'
                                                        }
                                                    );
                                                }}
                                            >
                                                {latestGenerating ? '生成中...' : '生成图片'}
                                            </button>
                                        </div>
                                    </>
                                );
                            })()}
                        </div>
                    )}
                    {(node.type === 'create-character' || node.type === 'create-scene') && (
                        <div className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${theme === 'dark' ? 'bg-zinc-900/80' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100'}`}>
                            {(() => {
                                const isCharacter = node.type === 'create-character';
                                const title = isCharacter ? '创建角色' : '创建场景';
                                const startSecond = Number.isFinite(node.settings?.startSecond) ? node.settings.startSecond : 1;
                                const endSecond = Number.isFinite(node.settings?.endSecond) ? node.settings.endSecond : 3;

                                return (
                                    <>
                                        <div className={`flex items-center gap-1.5 px-3 py-2 border-b text-xs font-semibold shrink-0 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                            <User size={12} className={isCharacter ? "text-blue-500" : "text-green-500"} />
                                            <span>{title}</span>
                                        </div>

                                        <div className="flex-1 flex flex-col gap-3 p-3 overflow-y-auto min-h-0">
                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">{isCharacter ? '角色名称' : '场景名称'}</label>
                                                <input
                                                    type="text"
                                                    value={node.settings?.name || ''}
                                                    onChange={(e) => updateNodeSettings(node.id, { name: e.target.value })}
                                                    className={`w-full px-2 py-1 rounded text-xs border ${theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                        }`}
                                                    placeholder={isCharacter ? "输入角色名称..." : "输入场景名称..."}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                />
                                            </div>

                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">{t('时间范围（秒，间隔需在 1-3 秒之间）')}</label>
                                                <div className="flex gap-2 items-center flex-wrap">
                                                    <input
                                                        type="number"
                                                        min="0"
                                                        step="0.1"
                                                        value={startSecond}
                                                        onChange={(e) => updateNodeSettings(node.id, { startSecond: parseFloat(e.target.value) || 0 })}
                                                        className={`w-20 px-2 py-1 rounded text-xs border ${theme === 'dark'
                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                            }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    />
                                                    <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>到</span>
                                                    <input
                                                        type="number"
                                                        min="0"
                                                        step="0.1"
                                                        value={endSecond}
                                                        onChange={(e) => updateNodeSettings(node.id, { endSecond: parseFloat(e.target.value) || 0 })}
                                                        className={`w-20 px-2 py-1 rounded text-xs border ${theme === 'dark'
                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                            }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    />
                                                    <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>
                                                        秒（间隔: {(endSecond - startSecond).toFixed(1)}s）
                                                    </span>
                                                </div>
                                            </div>
                                        </div>

                                        {node.settings?.isCreating && (
                                            <div className="px-3 py-2 border-t shrink-0">
                                                <div className="flex items-center gap-2 mb-2">
                                                    <div className="flex-1">
                                                        <div className="flex items-center justify-between mb-1">
                                                            <span className="text-[10px] text-zinc-500">{title}中...</span>
                                                            <span className="text-[10px] text-zinc-500">{node.settings?.createProgress || 0}%</span>
                                                        </div>
                                                        <div className={`w-full h-1.5 rounded-full overflow-hidden ${theme === 'dark' ? 'bg-zinc-800' : 'bg-zinc-200'}`}>
                                                            <div
                                                                className="h-full bg-blue-500 transition-all duration-300"
                                                                style={{ width: `${node.settings?.createProgress || 0}%` }}
                                                            />
                                                        </div>
                                                    </div>
                                                </div>
                                                {node.settings?.createError && (
                                                    <div className="text-[10px] text-red-500 mt-1">{node.settings.createError}</div>
                                                )}
                                            </div>
                                        )}

                                        <div className="px-3 py-2 border-t shrink-0">
                                            <button
                                                className={`w-full py-2 rounded text-xs font-medium transition-colors ${(node.settings?.isCreating)
                                                    ? 'bg-zinc-400 cursor-not-allowed text-white'
                                                    : theme === 'dark'
                                                        ? 'bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white'
                                                        : 'bg-blue-600 hover:bg-blue-500 text-white'
                                                    }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                type="button"
                                                disabled={node.settings?.isCreating}
                                                onClick={async () => {
                                                    const name = node.settings?.name || '';
                                                    if (!name || name.trim().length === 0) {
                                                        alert(`请填写${isCharacter ? '角色' : '场景'}名称`);
                                                        return;
                                                    }
                                                    const start = startSecond ?? 1;
                                                    const end = endSecond ?? 3;
                                                    if (end - start < 1 || end - start > 3) {
                                                        alert(t('时间范围必须在 1-3 秒之间'));
                                                        return;
                                                    }

                                                    const targetVideoType = isCharacter ? 'generate-character-video' : 'generate-scene-video';
                                                    const videoNode = connections
                                                        .filter(c => c.to === node.id)
                                                        .map(c => nodesMap.get(c.from))
                                                        .find(n => n?.type === targetVideoType);
                                                    if (!videoNode) {
                                                        alert(t('找不到关联的视频节点'));
                                                        return;
                                                    }

                                                    const historyItem = history.find(h => h.sourceNodeId === videoNode.id && h.status === 'completed');
                                                    const videoUrl = historyItem?.localCacheUrl || historyItem?.url || historyItem?.originalUrl || videoNode.content || '';
                                                    if (!videoUrl) {
                                                        alert(t('视频节点没有视频URL'));
                                                        return;
                                                    }

                                                    const fromTaskId = historyItem?.remoteTaskId || null;
                                                    updateNodeSettings(node.id, { isCreating: true, createProgress: 10, createError: null });

                                                    try {
                                                        const soraConfig = apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'));
                                                        if (!soraConfig) {
                                                            updateNodeSettings(node.id, { isCreating: false, createError: '未找到 Sora 2 模型配置' });
                                                            alert(t('未找到 Sora 2 模型配置，请先在设置中配置 Sora 2 或 Sora 2 Pro'));
                                                            return;
                                                        }

                                                        const credentials = getApiCredentials(soraConfig.id);
                                                        const apiKey = credentials.key;
                                                        if (!apiKey) {
                                                            updateNodeSettings(node.id, { isCreating: false, createError: '请先配置 API Key' });
                                                            alert(t('请先配置 API Key'));
                                                            setSettingsOpen(true);
                                                            return;
                                                        }

                                                        updateNodeSettings(node.id, { createProgress: 40 });

                                                        const baseUrl = (credentials.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                                                        const endpoint = (createCharacterEndpoint && createCharacterEndpoint.trim())
                                                            ? createCharacterEndpoint.trim()
                                                            : `${baseUrl}/sora/v1/characters`;
                                                        const timestamps = `${start},${end}`;
                                                        const payload = fromTaskId
                                                            ? { from_task: fromTaskId, timestamps }
                                                            : { url: videoUrl, timestamps };

                                                        updateNodeSettings(node.id, { createProgress: 70 });

                                                        const resp = await fetch(endpoint, {
                                                            method: 'POST',
                                                            headers: {
                                                                'Authorization': `Bearer ${apiKey}`,
                                                                'Content-Type': 'application/json'
                                                            },
                                                            body: JSON.stringify(payload)
                                                        });

                                                        updateNodeSettings(node.id, { createProgress: 90 });

                                                        if (!resp.ok) {
                                                            const errText = await resp.text();
                                                            let errorData = null;
                                                            try { errorData = JSON.parse(errText); } catch { }
                                                            if (resp.status === 500 || (errorData && (errorData.code === 'get_origin_task_failed' || errorData.message?.includes('get_origin_task_failed')))) {
                                                                throw new Error('TASK_NOT_FOUND');
                                                            }
                                                            throw new Error(`API错误 (${resp.status}): ${errText || resp.statusText}`);
                                                        }

                                                        const data = await resp.json();
                                                        if (!data?.id || !data?.username) {
                                                            throw new Error('返回数据缺少 id 或 username');
                                                        }

                                                        const newCharacter = {
                                                            id: data.id,
                                                            username: data.username,
                                                            profile_picture_url: data.profile_picture_url || '',
                                                            permalink: data.permalink || ''
                                                        };
                                                        setCharacterLibrary(prev => [...prev, newCharacter]);

                                                        setTimeout(() => {
                                                            updateNodeSettings(node.id, {
                                                                isCreating: false,
                                                                createProgress: 0,
                                                                createError: null,
                                                                characterId: data.id,
                                                                characterUsername: data.username
                                                            });
                                                            alert(`${isCharacter ? '角色' : '场景'} "${data.username}" 创建成功！`);
                                                        }, 300);
                                                    } catch (err) {
                                                        let msg = err.message || '创建失败';
                                                        if (msg === 'TASK_NOT_FOUND') {
                                                            msg = '原任务已过期或无法访问';
                                                        } else if (msg.includes('Failed to fetch') || err.name === 'TypeError' || err.message.includes('NetworkError')) {
                                                            msg = '连接失败。可能原因：\n\n1. API 地址填写错误\n   - 请检查 API 接口地址是否多余了 "/sora" 前缀\n   - 有些服务商的路径可能不同，请询问服务商 Sora 创建接口的准确路径\n\n2. 跨域限制 (CORS)\n   - 请尝试安装 Allow CORS 浏览器插件\n\n3. 网络问题\n   - 请检查网络连接';
                                                        }
                                                        updateNodeSettings(node.id, { isCreating: false, createProgress: 0, createError: msg });
                                                        alert(`${isCharacter ? '创建角色' : '创建场景'}失败: ${msg}`);
                                                    }
                                                }}
                                            >
                                                {isCharacter ? '创建角色' : '创建场景'}
                                            </button>
                                        </div>
                                    </>
                                );
                            })()}
                        </div>
                    )}
                    {node.type === 'local-save' && (() => {
                        const pendingItems = getLocalSaveMediaItems(node.id);
                        const pendingCount = pendingItems.length;
                        const isSaving = !!node.settings?.isSaving;
                        const serverUrlOverride = (node.settings?.serverUrl || '').trim();
                        const serverConnected = serverUrlOverride
                            ? node.settings?.serverStatus === 'connected'
                            : localCacheServerConnected;

                        return (
                            <div className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${theme === 'dark' ? 'bg-zinc-900/80' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100'}`}>
                                <div className="flex items-center justify-between px-3 py-2 border-b shrink-0">
                                    <div className="flex items-center gap-1.5 text-xs font-semibold">
                                        <HardDrive size={12} className="text-green-500" />
                                        <span>{t('保存到本地')}</span>
                                    </div>
                                    <div className={`w-2 h-2 rounded-full ${serverConnected ? 'bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]' : 'bg-red-500'}`} title={serverConnected ? "已连接本地服务" : "未连接"} />
                                </div>
                                <div className="flex-1 overflow-y-auto p-3 custom-scrollbar flex flex-col gap-3">
                                    <div className="flex flex-col gap-1.5">
                                        <label className="text-[10px] font-medium opacity-70">{t('服务器地址')}</label>
                                        <div className="flex items-center gap-2">
                                            <input
                                                type="text"
                                                value={node.settings?.serverUrl ?? ''}
                                                onChange={(e) => updateNodeSettings(node.id, { serverUrl: e.target.value })}
                                                placeholder={localServerUrl || 'http://127.0.0.1:9527'}
                                                className={`flex-1 text-xs border rounded px-2 py-1.5 outline-none focus:border-blue-500 ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300 placeholder-zinc-600' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'}`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                            />
                                            <button
                                                className={`px-2 py-1 text-[10px] rounded border transition-colors ${theme === 'dark'
                                                    ? 'bg-zinc-800 border-zinc-700 text-zinc-300 hover:border-blue-500'
                                                    : 'bg-white border-zinc-300 text-zinc-700 hover:border-blue-500'
                                                    }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={() => testLocalSaveServer(node.id, node.settings?.serverUrl || '')}
                                            >
                                                {t('测试')}
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex flex-col gap-1.5">
                                        <label className="text-[10px] font-medium opacity-70">{t('子文件夹')}</label>
                                        <input
                                            type="text"
                                            value={node.settings?.subfolder || ''}
                                            onChange={(e) => updateNodeSettings(node.id, { subfolder: e.target.value })}
                                            placeholder="v1_characters"
                                            className={`w-full text-xs border rounded px-2 py-1.5 outline-none focus:border-blue-500 ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300 placeholder-zinc-600' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'}`}
                                            onMouseDown={(e) => e.stopPropagation()}
                                        />
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <label className="text-[10px] font-medium opacity-70">{t('自动保存 (新图片)')}</label>
                                        <button
                                            className={`w-10 h-5 rounded-full relative transition-colors ${node.settings?.autoSave ? 'bg-green-600' : theme === 'solarized' ? 'bg-zinc-300' : 'bg-zinc-600'}`}
                                            onClick={() => updateNodeSettings(node.id, { autoSave: !node.settings?.autoSave })}
                                            onMouseDown={(e) => e.stopPropagation()}
                                        >
                                            <div className={`absolute top-1 w-3 h-3 rounded-full bg-white transition-all ${node.settings?.autoSave ? 'left-6' : 'left-1'}`} />
                                        </button>
                                    </div>

                                    <div className="flex items-center justify-between text-[10px] text-zinc-500 mt-1">
                                        <span>{t('待保存文件')}</span>
                                        <span>{pendingCount}</span>
                                    </div>
                                    {pendingCount > 0 ? (
                                        <div className="grid grid-cols-4 gap-2">
                                            {pendingItems.slice(0, 4).map((item, idx) => {
                                                const isVideo = item.type === 'video' || isVideoUrl(item.url) || item.url.startsWith('data:video');
                                                return (
                                                    <div key={`${item.url}-${idx}`} className="relative aspect-square rounded-lg overflow-hidden bg-black/40 border border-zinc-700/40">
                                                        {isVideo ? (
                                                            <div className="w-full h-full flex items-center justify-center text-[10px] text-zinc-300">
                                                                <Video size={14} className="text-purple-300" />
                                                            </div>
                                                        ) : (
                                                            <LazyBase64Image src={item.url} className="w-full h-full object-cover" />
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ) : (
                                        <div className="text-[10px] text-zinc-500">{t('暂无待保存文件')}</div>
                                    )}

                                    <div className="mt-auto border-t pt-2 border-zinc-700/50">
                                        <div className="text-[10px] text-zinc-500 flex justify-between">
                                            <span>{t('上次保存:')}</span>
                                            <span>{node.settings?.lastSaved ? node.settings.lastSaved.split(' ')[1] : t('无')}</span>
                                        </div>
                                        <div className="text-[10px] text-zinc-500 flex justify-between mt-1">
                                            <span>{t('已保存:')}</span>
                                            <span>{node.settings?.savedFiles?.length || 0} {t('个')}</span>
                                        </div>
                                    </div>

                                    <button
                                        className={`w-full py-2 rounded text-xs font-medium transition-colors ${isSaving
                                            ? 'bg-zinc-600 cursor-not-allowed text-white'
                                            : theme === 'dark'
                                                ? 'bg-green-600 hover:bg-green-500 text-white'
                                                : 'bg-green-600 hover:bg-green-500 text-white'
                                            }`}
                                        disabled={isSaving || pendingCount === 0}
                                        onMouseDown={(e) => e.stopPropagation()}
                                        onClick={async () => {
                                            if (pendingCount === 0) {
                                                showToast('暂无待保存文件', 'warning');
                                                return;
                                            }
                                            updateNodeSettings(node.id, { isSaving: true });
                                            try {
                                                await runLocalSaveBatch(node, pendingItems);
                                            } catch (err) {
                                                showToast(`保存失败: ${err.message || '未知错误'}`, 'error');
                                            } finally {
                                                updateNodeSettings(node.id, { isSaving: false });
                                            }
                                        }}
                                    >
                                        {isSaving ? '保存中...' : '保存到本地'}
                                    </button>
                                </div>
                            </div>
                        );
                    })()}

                    {node.type === 'input-image' && (
                        <div
                            className={`relative w-full h-full flex flex-col items-center justify-center transition-colors pointer-events-auto drop-zone ${theme === 'dark'
                                ? 'bg-zinc-900 group-hover:bg-zinc-800'
                                : theme === 'solarized'
                                    ? 'bg-[#eee8d5] group-hover:bg-[#e4dcc2]'
                                    : 'bg-zinc-100 group-hover:bg-zinc-200'
                                }`}
                            onDrop={(e) => handleDrop(node.id, e)}
                            onDragOver={handleDragOver}
                            onDragLeave={handleDragLeave}
                            onContextMenu={(e) => handleInputImageRightClick(e, node.id)}
                        >
                            {node.content ? (
                                <div className="relative w-full h-full">
                                    {isVideoUrl(node.content) ? (
                                        <ResolvedVideo
                                            src={node.content}
                                            controls
                                            className={`w-full h-full object-contain ${theme === 'dark'
                                                ? 'bg-black/50'
                                                : theme === 'solarized'
                                                    ? 'bg-[#eee8d5]'
                                                    : 'bg-zinc-100'
                                                }`}
                                            draggable={false}
                                            style={{
                                                imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges',
                                                WebkitFontSmoothing: 'antialiased',
                                                transform: 'translateZ(0)',
                                                backfaceVisibility: 'hidden',
                                                WebkitBackfaceVisibility: 'hidden'
                                            }}
                                        />
                                    ) : (
                                        <LazyBase64Image
                                            src={node.content}
                                            className={`w-full h-full object-contain ${theme === 'dark'
                                                ? 'bg-black/50'
                                                : theme === 'solarized'
                                                    ? 'bg-[#eee8d5]'
                                                    : 'bg-zinc-100'
                                                }`}
                                            draggable={false}
                                            loading="lazy"
                                            style={{
                                                imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges',
                                                WebkitFontSmoothing: 'antialiased',
                                                transform: 'translateZ(0)',
                                                backfaceVisibility: 'hidden',
                                                WebkitBackfaceVisibility: 'hidden'
                                            }}
                                        />
                                    )}
                                    {node.dimensions && (
                                        <div
                                            className={`absolute bottom-2 right-2 text-[10px] px-1.5 py-0.5 rounded backdrop-blur-sm border ${theme === 'dark'
                                                ? 'bg-black/70 text-white border-white/10'
                                                : 'bg-white/80 text-zinc-800 border-zinc-200'
                                                }`}
                                        >
                                            {node.dimensions.w}x{node.dimensions.h}
                                        </div>
                                    )}
                                    {/* 悬浮菜单：当 isMasking 为 true 时强制隐藏 */}
                                    {!node.isMasking && (
                                        <div className="absolute inset-0 bg-black/40 transition-opacity gap-2 opacity-0 group-hover:opacity-100 flex flex-col items-center justify-center">
                                            <div className="flex items-center gap-2">
                                                <label
                                                    className={`cursor-pointer px-3 py-1.5 rounded-lg text-xs backdrop-blur-sm border transition-colors ${theme === 'dark'
                                                        ? 'bg-white/10 hover:bg-white/20 text-white border-white/10'
                                                        : 'bg-white hover:bg-zinc-100 text-zinc-800 border-zinc-300'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {t('更换')} <input type="file" className="hidden" accept="image/*" onChange={(e) => handleFileUpload(node.id, e)} />
                                                </label>
                                                {!isVideoUrl(node.content) && (
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setNodes((prev) => prev.map((n) =>
                                                                n.id === node.id
                                                                    ? { ...n, isMasking: !n.isMasking }
                                                                    : n
                                                            ));
                                                        }}
                                                        className={`px-3 py-1.5 rounded-lg text-xs backdrop-blur-sm border transition-colors flex items-center gap-1 ${theme === 'dark'
                                                            ? node.isMasking
                                                                ? 'bg-red-500/80 hover:bg-red-500 text-white border-red-400'
                                                                : 'bg-white/10 hover:bg-white/20 text-white border-white/10'
                                                            : node.isMasking
                                                                ? 'bg-red-500 hover:bg-red-600 text-white border-red-400'
                                                                : 'bg-white hover:bg-zinc-100 text-zinc-800 border-zinc-300'
                                                            }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        <Brush size={12} />
                                                        {t('局部重绘')}
                                                    </button>
                                                )}
                                            </div>
                                            <div
                                                className={`text-[10px] text-center px-2 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-500'
                                                    }`}
                                            >
                                                {t('或拖放图片到此处')}
                                                <br />
                                                {t('或 Ctrl+V 粘贴')}
                                            </div>
                                        </div>
                                    )}
                                    {/* 非编辑模式下的蒙版回显 */}
                                    {!node.isMasking && node.maskContent && (
                                        <div
                                            className="absolute inset-0 z-20 pointer-events-none"
                                            style={{
                                                background: 'rgba(255, 0, 0, 0.3)',
                                                mixBlendMode: 'multiply',
                                                WebkitMaskImage: `url(${node.maskContent})`,
                                                maskImage: `url(${node.maskContent})`,
                                                WebkitMaskSize: '100% 100%',
                                                maskSize: '100% 100%',
                                                WebkitMaskRepeat: 'no-repeat',
                                                maskRepeat: 'no-repeat'
                                            }}
                                        />
                                    )}
                                    {/* MaskEditor 组件 */}
                                    {node.isMasking && !isVideoUrl(node.content) && (
                                        <MaskEditor
                                            nodeId={node.id}
                                            imageUrl={node.content}
                                            imageDimensions={node.dimensions}
                                            isActive={node.isMasking}
                                            onClose={() => {
                                                setNodes((prev) => prev.map((n) =>
                                                    n.id === node.id
                                                        ? { ...n, isMasking: false }
                                                        : n
                                                ));
                                            }}
                                            onSave={(maskDataUrl) => {
                                            }}
                                            onUpdateNode={(nodeId, updates) => {
                                                setNodes((prev) => prev.map((n) =>
                                                    n.id === nodeId
                                                        ? { ...n, ...updates }
                                                        : n
                                                ));
                                            }}
                                            theme={theme}
                                            view={view}
                                            maskContent={node.maskContent}
                                        />
                                    )}
                                </div>
                            ) : (
                                <div className="flex flex-col items-center justify-center h-full w-full">
                                    <div
                                        className={`w-12 h-12 rounded-2xl flex items-center justify-center mb-3 border ${theme === 'dark'
                                            ? 'bg-zinc-800 border-zinc-700/50'
                                            : 'bg-zinc-100 border-zinc-300'
                                            }`}
                                    >
                                        <ImageIcon
                                            className={`w-6 h-6 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'
                                                }`}
                                        />
                                    </div>
                                    <label
                                        className={`px-4 py-2 rounded-lg text-xs font-medium transition-colors cursor-pointer pointer-events-auto ${theme === 'solarized'
                                            ? 'bg-[#616161] hover:bg-[#4b4b4b] text-white'
                                            : 'bg-blue-600 hover:bg-blue-500 text-white'
                                            }`}
                                        onMouseDown={(e) => e.stopPropagation()}
                                    >
                                        {t('选择图片')}
                                        <input type="file" className="hidden" accept="image/*" onChange={(e) => handleFileUpload(node.id, e)} />
                                    </label>
                                    <div
                                        className={`text-[10px] text-center mt-2 pointer-events-none ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                            }`}
                                    >
                                        {t('或拖放图片到此处')}
                                        <br />
                                        {t('或 Ctrl+V 粘贴')}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {node.type === 'video-input' && (
                        <div
                            className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto drop-zone video-input-container ${theme === 'dark'
                                ? 'bg-zinc-900/80'
                            : theme === 'solarized'
                                ? 'bg-[#eee8d5]'
                                    : 'bg-zinc-100'
                                }`}
                            /* V3.5.20: Remove global onDrop from container to separate zones */
                            /* onDrop={(e) => handleVideoDrop(node.id, e)} */
                            onDragOver={handleDragOver}
                            onDragLeave={handleDragLeave}
                        >
                            <div className="flex items-center justify-between px-3 py-2 border-b text-xs font-semibold">
                                <div className="flex items-center gap-1.5">
                                    <Video size={13} className="text-blue-500" />
                                    <span>{t('视频输入 / 关键帧整理')}</span>
                                    <button
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            const isExpanding = node.settings?.videoExpanded === false;

                                            // V3.5.36: Adjusted column split threshold (threshold ~290 for wider node)
                                            const framesCount = (node.frames || []).length;
                                            const cols = isExpanding ? Math.max(1, Math.floor(node.width / 290)) : 1;
                                            const rows = Math.max(1, Math.ceil(framesCount / cols));

                                            const headerAreaH = 72; // Banner(44) + MetaRow(28)
                                            const videoAreaH = isExpanding ? (node.content ? 230 : 190) : 0;
                                            const controlsH = (node.content && isExpanding) ? 48 : 0;
                                            const thumbnailsTitleH = 36;
                                            const flexPaddingH = 30;

                                            const rowH = isExpanding ? 158 : 106; // card + gap + borders + buffer

                                            // Calculate new height to fit all content perfectly
                                            const calculatedH = headerAreaH + videoAreaH + controlsH + thumbnailsTitleH + (rows * rowH) + flexPaddingH;

                                            // Update node root height property directly to trigger "Manual Resize" effect
                                            setNodes(prev => prev.map(n => n.id === node.id ? {
                                                ...n,
                                                height: Math.max(isExpanding ? 500 : 220, calculatedH),
                                                settings: { ...n.settings, videoExpanded: isExpanding }
                                            } : n));
                                        }}
                                        className={`p-1 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded transition-colors ml-1 ${node.settings?.videoExpanded === false ? 'bg-zinc-200 dark:bg-zinc-700' : ''}`}
                                        title={node.settings?.videoExpanded === false ? "展开视频" : "收起视频"}
                                    >
                                        {node.settings?.videoExpanded === false ? <ChevronDown size={12} /> : <ChevronUp size={12} />}
                                    </button>
                                </div>
                                <div className="flex items-center gap-2 text-[10px] text-zinc-500">
                                    {node.videoMeta?.duration ? <span>{t('时长')} {node.videoMeta.duration.toFixed(1)}s</span> : null}
                                    {node.videoMeta?.w ? <span>{node.videoMeta.w}x{node.videoMeta.h}</span> : null}
                                    {node.selectedKeyframes?.length ? <span className="text-blue-500">关键帧 {node.selectedKeyframes.length} 个</span> : null}
                                </div>
                            </div>

                            <div className="flex-1 flex flex-col gap-3 p-3 overflow-hidden min-h-0">
                                {node.content ? (
                                    <div className="space-y-2">
                                        {node.settings?.videoExpanded !== false && (
                                            <div
                                                className="relative w-full max-w-[360px] aspect-video bg-black rounded-lg overflow-hidden flex items-center justify-center mx-auto"
                                                onDrop={(e) => handleVideoDrop(node.id, e)} /* V3.5.20: Explicit drop zone */
                                            >
                                                <ResolvedVideo
                                                    src={node.content}
                                                    controls
                                                    className="w-full h-full object-contain"
                                                    draggable={false}
                                                />
                                            </div>
                                        )}
                                        <div className="flex items-center gap-2">
                                            <label
                                                className="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1.5 rounded text-xs font-medium transition-colors cursor-pointer"
                                                onMouseDown={(e) => e.stopPropagation()}
                                            >
                                                {t('更换视频')}
                                                <input
                                                    type="file"
                                                    className="hidden"
                                                    accept="video/*"
                                                    onChange={(e) => handleVideoFileUpload(node.id, e.target.files?.[0])}
                                                />
                                            </label>
                                            <button
                                                className={`px-3 py-1.5 rounded text-xs border transition-colors ${theme === 'dark'
                                                    ? 'border-zinc-700 bg-zinc-800 text-zinc-300 hover:border-blue-500 hover:text-blue-400'
                                                    : 'border-zinc-300 hover:border-blue-500 hover:text-blue-600'
                                                    }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={() => handleAutoExtractKeyframes(node.id, 2)}
                                            >
                                                <span className="whitespace-nowrap">{t('自动抽帧（2fps）')}</span>
                                            </button>
                                            <button
                                                className={`px-3 py-1.5 rounded text-xs border transition-colors ${theme === 'dark'
                                                    ? 'bg-green-600/40 border-green-500 text-green-200 hover:bg-green-600/60 hover:border-green-400'
                                                    : 'bg-green-50 border-green-300 hover:border-green-500 hover:text-green-600'
                                                    }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={() => handleSmartExtractKeyframes(node.id, 30)}
                                            >
                                                <span className="whitespace-nowrap">{t('智能抽帧')}</span>
                                            </button>
                                            {node.extractingFrames && (
                                                <span className="text-[11px] text-blue-500">{t('抽帧中...')}</span>
                                            )}
                                        </div>
                                    </div>
                                ) : (
                                    /* Fix: Allow folding upload box when empty */
                                    (node.settings?.videoExpanded !== false) && (
                                        <div className="flex flex-col items-center justify-center gap-3 w-full px-4 mx-auto shrink-0 transition-colors border-2 border-transparent hover:border-blue-500/30 rounded-lg p-4"
                                            onDrop={(e) => handleVideoDrop(node.id, e)} /* V3.5.20: Explicit drop zone */
                                        >
                                            <div className="flex flex-col gap-2 items-center justify-center shrink-0 w-full">
                                                {/* V3.5.21 Layout Fix: Enforce Fixed Size Container */}
                                                <div className={`relative w-full h-64 flex flex-col items-center justify-center border-2 border-dashed rounded-lg transition-colors ${dragOverNodeId === node.id && !dragInsertNodeId
                                                    ? 'border-blue-500 bg-blue-500/10'
                                                    : theme === 'dark' ? 'border-zinc-700 hover:border-zinc-500' : 'border-zinc-300 hover:border-zinc-400'
                                                    }`}>

                                                    <label className="cursor-pointer flex flex-col items-center justify-center w-full h-full">
                                                        <UploadCloud size={48} className={`mb-2 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`} />
                                                        <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>
                                                            {t('点击选择或拖入视频')}
                                                        </span>
                                                        <input
                                                            type="file"
                                                            className="hidden"
                                                            accept="video/*"
                                                            onChange={(e) => handleVideoFileUpload(node.id, e.target.files?.[0])}
                                                        />
                                                    </label>
                                                </div>
                                                <div className="text-[10px] text-center text-zinc-500 pointer-events-none">
                                                    {t('支持 MP4/WEBM，拖拽或 Ctrl+V 不可用')}
                                                </div>
                                            </div>
                                        </div>
                                    )
                                )
                                }

                                <div className="flex items-center justify-between text-[11px] text-zinc-500">
                                    <span>{t('抽帧缩略图')}</span>
                                    <div className="flex items-center gap-2 flex-nowrap shrink-0 whitespace-nowrap">
                                        <span>{(node.frames || []).length} {t('张')}</span>
                                        {(node.frames || []).length > 0 && (
                                            <>
                                                <button
                                                    onClick={() => {
                                                        const frames = node.frames || [];
                                                        const currentSelected = node.selectedKeyframes || [];
                                                        let newSelected = [];

                                                        if (currentSelected.length === 0) {
                                                            // Select All
                                                            // Select All - FIX: Store Ref Objects, not Indices
                                                            newSelected = frames.map(f => ({ url: f.url, time: f.time, filename: f.filename }));
                                                        } else {
                                                            // Deselect All (if any selected)
                                                            newSelected = [];
                                                        }

                                                        setNodes(prev => prev.map(n =>
                                                            n.id === node.id ? { ...n, selectedKeyframes: newSelected } : n
                                                        ));
                                                    }}
                                                    className={`text-[10px] px-1.5 py-0.5 rounded transition-colors flex items-center gap-1 ${theme === 'dark'
                                                        ? 'bg-blue-600/30 text-blue-300 hover:bg-blue-600/50'
                                                        : 'bg-blue-100 text-blue-600 hover:bg-blue-200'}`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    title={(node.selectedKeyframes || []).length > 0 ? t('取消全选') : t('全选')}
                                                >
                                                    {(node.selectedKeyframes || []).length > 0 ? <Square size={10} /> : <CheckSquare size={10} />}
                                                    {(node.selectedKeyframes || []).length > 0 ? t('取消') : t('全选')}
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        if (confirm(t('确定要清空所有抽帧缩略图吗？'))) {
                                                            setNodes(prev => prev.map(n =>
                                                                n.id === node.id
                                                                    ? { ...n, frames: [], selectedKeyframes: [] }
                                                                    : n
                                                            ));
                                                        }
                                                    }}
                                                    className={`text-[10px] px-1.5 py-0.5 rounded transition-colors flex items-center gap-1 flex-nowrap ${theme === 'dark'
                                                        ? 'bg-red-600/30 text-red-300 hover:bg-red-600/50'
                                                        : 'bg-red-100 text-red-600 hover:bg-red-200'}`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    title={t('清空所有缩略图')}
                                                >
                                                    <Trash2 size={10} />
                                                    {t('清空')}
                                                </button>
                                            </>
                                        )}
                                    </div>
                                </div>
                                <div
                                    className="grid gap-3 w-full overflow-y-auto custom-scrollbar flex-1 min-h-0 relative p-1 content-start items-start"
                                    style={{
                                        gridTemplateColumns: node.settings?.videoExpanded === false ? '1fr' : 'repeat(auto-fill, minmax(260px, 1fr))',
                                        gridAutoRows: 'auto'
                                    }}
                                    /* V3.5.20: Insert keyframe drop zone */
                                    onDrop={(e) => handleKeyframeListDrop(node.id, e)}
                                    // Pass length to indicate "append" if dropped on empty space
                                    onDragOver={(e) => handleKeyframeContainerDragOver(e, node.id, (node.frames || []).length)}
                                    /* V3.5.31: Clear insert line when drag leaves container */
                                    onDragLeave={(e) => {
                                        // Only clear if leaving the container entirely (not entering a child)
                                        if (!e.currentTarget.contains(e.relatedTarget)) {
                                            setDragInsertNodeId(null);
                                            setDragInsertIndex(null);
                                        }
                                    }}
                                >
                                    {(node.frames || []).length === 0 ? (
                                        <div className={`col-span-full text-[11px] text-zinc-500 text-center py-4 border rounded ${theme === 'dark' ? 'bg-zinc-800/40 border-zinc-700' : 'bg-white/40 border-zinc-300'
                                            }`}>
                                            {t('点击「自动抽帧」即可生成缩略图')}
                                            <div className="mt-1 opacity-50 text-[9px]">{t('可拖拽图片插入')}</div>
                                        </div>
                                    ) : (
                                        (node.frames || []).map((frame, idx) => {
                                            const selected = (node.selectedKeyframes || []).some(f => f.url === frame.url && f.time === frame.time);
                                            // V3.5.20: Insert visualization
                                            const showInsertLineBefore = dragInsertNodeId === node.id && dragInsertIndex === idx;
                                            const showInsertLineAfter = dragInsertNodeId === node.id && dragInsertIndex === (node.frames || []).length && idx === (node.frames || []).length - 1;

                                            return (
                                                <div key={`${frame.url}-${idx}`} className="relative">
                                                    {/* V3.5.31: Insertion Line Before - outside button */}
                                                    {showInsertLineBefore && (
                                                        <div className="absolute -top-1.5 left-0 right-0 h-1 bg-red-500 rounded-full shadow-[0_0_8px_rgba(239,68,68,0.8)] z-50" />
                                                    )}
                                                    <button
                                                        className={`relative w-full rounded overflow-hidden group transition-all ${selected
                                                            ? 'ring-2 ring-blue-500 border-2 border-blue-500 bg-blue-900/30'
                                                            : theme === 'dark' ? 'border border-zinc-700 hover:border-zinc-500' : 'border border-zinc-300 hover:border-zinc-400'}`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        onClick={(e) => handleToggleKeyframe(node.id, frame, idx, e)}
                                                        onContextMenu={(e) => openFrameContextMenu(e, node.id, frame)}
                                                        /* V3.5.20: Item drag over for insert position */
                                                        onDragOver={(e) => handleKeyframeItemDragOver(e, node.id, idx)}
                                                    >

                                                        <LazyBase64Image
                                                            src={frame.url}
                                                            className={`w-full bg-black ${node.settings?.videoExpanded === false ? 'h-[90px] object-cover' : 'aspect-video object-contain max-h-[140px]'}`}
                                                            alt={`frame-${idx}`}
                                                        />
                                                        <div className="absolute left-1 top-1 text-[10px] px-1 py-0.5 rounded bg-black/60 text-white">
                                                            {typeof frame.time === 'number' ? frame.time.toFixed(2) : frame.time}s
                                                        </div>
                                                        {/* V3.5.30: Show filename in tooltip */}
                                                        {frame.filename && (
                                                            <div
                                                                className="absolute left-0 bottom-0 right-0 bg-black/80 text-white text-[9px] px-1 py-0.5 opacity-0 group-hover:opacity-100 transition-opacity truncate"
                                                                title={frame.filename}
                                                            >
                                                                {frame.filename}
                                                            </div>
                                                        )}
                                                        {/* Right Vertical Control Strip */}
                                                        <div className="absolute top-1 bottom-1 right-1 flex flex-col justify-between items-center z-20 pointer-events-none">
                                                            {/* Top: Selection */}
                                                            <div className="pointer-events-auto w-5 h-5 rounded-full border border-white/80 bg-black/40 flex items-center justify-center shrink-0 mb-auto">
                                                                {selected ? <CheckCircle2 size={12} className="text-white" /> : null}
                                                            </div>

                                                            {/* Middle: Delete (Visible on Hover) */}
                                                            {/* V3.5.18: Delete button */}
                                                            <button
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    setNodes(prev => prev.map(n => {
                                                                        if (n.id !== node.id) return n;
                                                                        const newFrames = (n.frames || []).filter((_, i) => i !== idx);
                                                                        const newSelected = (n.selectedKeyframes || []).filter(f => f.url !== frame.url);
                                                                        return { ...n, frames: newFrames, selectedKeyframes: newSelected };
                                                                    }));
                                                                }}
                                                                className="pointer-events-auto w-5 h-5 rounded bg-red-600/80 text-white flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-500 my-1 shrink-0"
                                                                title={t('删除此帧')}
                                                            >
                                                                <X size={12} />
                                                            </button>

                                                            {/* Bottom: Sort Buttons (Visible on Hover) */}
                                                            {/* V3.5.17: Reorder buttons */}
                                                            <div className="pointer-events-auto flex flex-col gap-0.5 opacity-0 group-hover:opacity-100 transition-opacity shrink-0 mt-auto">
                                                                {idx > 0 && (
                                                                    <button
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            // Swap with previous
                                                                            setNodes(prev => prev.map(n => {
                                                                                if (n.id !== node.id) return n;
                                                                                const newFrames = [...(n.frames || [])];
                                                                                [newFrames[idx - 1], newFrames[idx]] = [newFrames[idx], newFrames[idx - 1]];
                                                                                // Also update selectedKeyframes order
                                                                                const newSelected = [...(n.selectedKeyframes || [])];
                                                                                const selIdx = newSelected.findIndex(f => f.url === frame.url);
                                                                                if (selIdx > 0) {
                                                                                    [newSelected[selIdx - 1], newSelected[selIdx]] = [newSelected[selIdx], newSelected[selIdx - 1]];
                                                                                }
                                                                                return { ...n, frames: newFrames, selectedKeyframes: newSelected };
                                                                            }));
                                                                        }}
                                                                        className="w-5 h-5 rounded bg-black/70 text-white flex items-center justify-center hover:bg-blue-600"
                                                                        title={t('上移')}
                                                                    >
                                                                        <ChevronUp size={12} />
                                                                    </button>
                                                                )}
                                                                {idx < (node.frames || []).length - 1 && (
                                                                    <button
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            // Swap with next
                                                                            setNodes(prev => prev.map(n => {
                                                                                if (n.id !== node.id) return n;
                                                                                const newFrames = [...(n.frames || [])];
                                                                                [newFrames[idx], newFrames[idx + 1]] = [newFrames[idx + 1], newFrames[idx]];
                                                                                // Also update selectedKeyframes order
                                                                                const newSelected = [...(n.selectedKeyframes || [])];
                                                                                const selIdx = newSelected.findIndex(f => f.url === frame.url);
                                                                                if (selIdx >= 0 && selIdx < newSelected.length - 1) {
                                                                                    [newSelected[selIdx], newSelected[selIdx + 1]] = [newSelected[selIdx + 1], newSelected[selIdx]];
                                                                                }
                                                                                return { ...n, frames: newFrames, selectedKeyframes: newSelected };
                                                                            }));
                                                                        }}
                                                                        className="w-5 h-5 rounded bg-black/70 text-white flex items-center justify-center hover:bg-blue-600"
                                                                        title={t('下移')}
                                                                    >
                                                                        <ChevronDown size={12} />
                                                                    </button>
                                                                )}
                                                            </div>
                                                        </div>
                                                    </button>
                                                    {/* V3.5.31: Insertion Line After - for last item */}
                                                    {showInsertLineAfter && (
                                                        <div className="absolute -bottom-1.5 left-0 right-0 h-1 bg-red-500 rounded-full shadow-[0_0_8px_rgba(239,68,68,0.8)] z-50" />
                                                    )}
                                                </div>
                                            );
                                        })
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {node.type === 'text-node' && (
                        <div
                            className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${theme === 'dark'
                                ? 'bg-zinc-900/80'
                            : theme === 'solarized'
                                ? 'bg-[#eee8d5]'
                                    : 'bg-zinc-100'
                                }`}
                        >
                            <div className="flex items-center justify-between px-3 py-2 border-b text-xs font-semibold">
                                <div className="flex items-center gap-1.5">
                                    <FileText size={13} className="text-blue-500" />
                                    <span>{t('文字节点')}</span>
                                </div>
                            </div>
                            <div className="flex-1 p-3">
                                <textarea
                                    data-node-type="text-node"
                                    data-node-id={node.id}
                                    value={node.settings?.text || ''}
                                    onChange={(e) => {
                                        updateNodeSettings(node.id, { text: e.target.value });
                                    }}
                                    placeholder={t('输入文字内容...')}
                                    className={`w-full h-full resize-none outline-none text-sm p-2 rounded border ${theme === 'dark'
                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500'
                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                        }`}
                                    onMouseDown={(e) => e.stopPropagation()}
                                />
                            </div>
                        </div>
                    )}

                    {node.type === 'video-analyze' && (
                        <div
                            className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto video-analyze-container ${theme === 'dark' ? 'bg-zinc-900/80' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100'}`}
                            onDrop={(e) => handleVideoAnalyzeDrop(node.id, e)}
                            onDragOver={handleCanvasDragOver}
                            onClick={(e) => {
                                // 检查是否有文本选择，如果有则不阻止事件
                                const selection = window.getSelection();
                                if (selection && selection.toString().length > 0) {
                                    return; // 允许文本选择
                                }
                                // 检查是否点击在可交互元素上
                                const target = e.target;
                                if (target && (
                                    target.tagName === 'INPUT' ||
                                    target.tagName === 'TEXTAREA' ||
                                    target.tagName === 'SELECT' ||
                                    target.tagName === 'BUTTON' ||
                                    target.isContentEditable ||
                                    target.closest('input, textarea, select, button, [contenteditable="true"]')
                                )) {
                                    return; // 允许交互元素正常工作
                                }
                                e.stopPropagation();
                            }}
                        >
                            <div className="flex items-center justify-between px-3 py-2 border-b text-xs font-semibold">
                                <div className="flex items-center gap-1.5">
                                    <FileSearch size={13} className="text-blue-500" />
                                    <span>{t('视频拆解 / 提示词反推')}</span>
                                </div>
                            </div>

                            <div className="flex-1 flex flex-col gap-3 p-3 overflow-hidden min-h-0">
                                {(() => {
                                    const videoInputNode = getConnectedVideoInputNode(node.id);
                                    if (!videoInputNode) {
                                        return (
                                            <div className="flex flex-col items-center justify-center flex-1 gap-2 text-[11px] text-zinc-500">
                                                <LinkIcon size={24} className="text-zinc-400" />
                                                <span>{t('请连接一个视频输入节点')}</span>
                                            </div>
                                        );
                                    }

                                    const videoFileName = videoInputNode.videoFileName || '未命名视频';
                                    const videoDuration = videoInputNode.videoMeta?.duration || 0;
                                    const selectedKeyframes = videoInputNode.selectedKeyframes || [];

                                    return (
                                        <>
                                            <div className="space-y-2">
                                                <div className={`text-[11px] px-2 py-1.5 rounded border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700' : 'bg-zinc-50 border-zinc-300'}`}>
                                                    <div className="flex items-center justify-between mb-1">
                                                        <span className="text-zinc-500">{videoInputNode.isImageInput ? '关联的图片' : '关联的视频'}</span>
                                                    </div>
                                                    <div className="text-zinc-700 dark:text-zinc-300">
                                                        <div>{t('文件名:')} {videoInputNode.isImageInput ? t('图片输入') : videoFileName}</div>
                                                        {!videoInputNode.isImageInput && <div>{t('总时长:')} {videoDuration.toFixed(1)}s</div>}
                                                        <div>{t('已选关键帧:')} {selectedKeyframes.length} {t('个')}</div>
                                                    </div>
                                                </div>

                                                {/* 模式选择切换按钮 */}
                                                <div className={`flex items-center gap-2 p-1 rounded-lg border shadow-inner ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-100 border-zinc-200'
                                                    }`}>
                                                    <button
                                                        onClick={() => updateNodeSettings(node.id, { analysisMode: 'manual' })}
                                                        className={`flex-1 py-1 px-2 text-[11px] rounded transition-all flex justify-center items-center gap-1 ${(node.settings?.analysisMode || 'manual') === 'manual'
                                                            ? theme === 'dark'
                                                                ? 'bg-zinc-600 shadow-md text-blue-300 font-bold'
                                                                : 'bg-white shadow-md text-blue-600 font-bold'
                                                            : theme === 'dark'
                                                                ? 'text-zinc-500 hover:text-zinc-300'
                                                                : 'text-zinc-500 hover:text-zinc-700'
                                                            }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        <Camera size={12} /> 手动选帧拆解
                                                    </button>
                                                    <button
                                                        onClick={() => updateNodeSettings(node.id, { analysisMode: 'auto' })}
                                                        className={`flex-1 py-1 px-2 text-[11px] rounded transition-all flex justify-center items-center gap-1 ${node.settings?.analysisMode === 'auto'
                                                            ? theme === 'dark'
                                                                ? 'bg-zinc-600 shadow-md text-purple-300 font-bold'
                                                                : 'bg-white shadow-md text-purple-600 font-bold'
                                                            : theme === 'dark'
                                                                ? 'text-zinc-500 hover:text-zinc-300'
                                                                : 'text-zinc-500 hover:text-zinc-700'
                                                            }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        <Sparkles size={12} /> AI 导演拆解
                                                    </button>
                                                </div>

                                                {(node.settings?.analysisMode || 'manual') === 'manual' && (
                                                    <>
                                                        <div className="flex items-center gap-2">
                                                            <label className="text-[11px] text-zinc-500">按时间段分组:</label>
                                                            <input
                                                                type="number"
                                                                min="1"
                                                                max="30"
                                                                value={node.settings?.segmentDuration || 3}
                                                                onChange={(e) => {
                                                                    const val = parseInt(e.target.value) || 3;
                                                                    updateNodeSettings(node.id, { segmentDuration: val });
                                                                    setLastUsedSegmentDuration(val.toString());
                                                                    try { localStorage.setItem('tapnow_last_segment_duration', val.toString()); } catch { }
                                                                }}
                                                                className={`w-16 px-2 py-1 text-[11px] rounded border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'}`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            />
                                                            <span className="text-[11px] text-zinc-500">秒</span>
                                                        </div>

                                                        <div className="flex items-center gap-2">
                                                            <label className="text-[11px] text-zinc-500">模型:</label>
                                                            {/* V3.4.10: 双层模型选择器 Provider -> Model */}
                                                            <div className="relative flex-1">
                                                                <button
                                                                    onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.nodeId === node.id && activeDropdown.type === 'analyze-model' ? null : { nodeId: node.id, type: 'analyze-model' }); }}
                                                                    className={`w-full flex items-center justify-between px-2 py-1 rounded text-[11px] border transition-colors ${theme === 'dark'
                                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-300 hover:border-zinc-600'
                                                                        : 'bg-zinc-50 border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                        }`}
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                >
                                                                    <span className="truncate font-mono">{getApiConfigByKey(node.settings?.model)?.id || node.settings?.model || 'gemini-3-pro'}</span>
                                                                    <ChevronDown size={10} className="opacity-50 shrink-0 ml-1" />
                                                                </button>
                                                                {activeDropdown?.nodeId === node.id && activeDropdown.type === 'analyze-model' && (
                                                                    <div
                                                                        className={`absolute top-full left-0 mt-1 w-64 rounded-lg shadow-xl p-1 z-[60] border flex ${theme === 'dark'
                                                                            ? 'bg-[#18181b] border-zinc-700'
                                                                            : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                            }`}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                        onMouseLeave={() => setHoveredProvider(null)}
                                                                    >
                                                                        {/* Provider 列表 */}
                                                                        <div className={`w-24 border-r pr-1 max-h-80 overflow-y-auto custom-scrollbar ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-200'}`}>
                                                                            {Object.entries(groupedApiConfigs)
                                                                                .filter(([, group]) => group.models.some(m => isChatModelType(m.type)))
                                                                                .map(([providerKey, group]) => (
                                                                                    <button
                                                                                        key={providerKey}
                                                                                        onMouseEnter={() => setHoveredProvider(providerKey)}
                                                                                        className={`w-full text-left px-2 py-1.5 text-[10px] rounded transition-colors ${hoveredProvider === providerKey
                                                                                            ? theme === 'dark' ? 'bg-zinc-800 text-white' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-zinc-100 text-zinc-900'
                                                                                            : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : theme === 'solarized' ? 'text-zinc-600 hover:text-zinc-700' : 'text-zinc-600 hover:text-zinc-800'
                                                                                            }`}
                                                                                    >
                                                                                        {group.name || providerKey}
                                                                                    </button>
                                                                                ))}
                                                                        </div>
                                                                        {/* Model 列表 */}
                                                                        <div className="flex-1 pl-1 max-h-80 overflow-y-auto custom-scrollbar">
                                                                            {hoveredProvider && groupedApiConfigs[hoveredProvider]?.models
                                                                                .filter(m => isChatModelType(m.type))
                                                                                .map((m) => {
                                                                                    const modelKey = m._uid || m.id;
                                                                                    const currentModelKey = resolveModelKey(node.settings?.model);
                                                                                    return (
                                                                                        <button
                                                                                            key={modelKey}
                                                                                            onClick={() => {
                                                                                                updateNodeSettings(node.id, { model: modelKey });
                                                                                                setLastUsedAnalyzeModel(modelKey);
                                                                                                try { localStorage.setItem('tapnow_last_analyze_model', modelKey); } catch { }
                                                                                                setActiveDropdown(null);
                                                                                                setHoveredProvider(null);
                                                                                            }}
                                                                                            className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${currentModelKey === modelKey
                                                                                                ? theme === 'dark' ? 'bg-blue-600/30 text-blue-300' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-blue-100 text-blue-700'
                                                                                                : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-300' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'
                                                                                                }`}
                                                                                        >
                                                                                            <span className="text-[10px] font-medium truncate font-mono">{m.id}</span>
                                                                                            <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(modelKey)}`}></div>
                                                                                        </button>
                                                                                    );
                                                                                })}
                                                                            {!hoveredProvider && (
                                                                                <div className={`text-[10px] px-2 py-3 text-center ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                                                    ← 选择 Provider
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    </>
                                                )}

                                                <button
                                                    onClick={() => node.settings?.analysisMode === 'auto' ? handleAutoVideoAnalysis(node.id) : handleGeneratePrompts(node.id)}
                                                    disabled={node.isGenerating || ((node.settings?.analysisMode || 'manual') === 'manual' && selectedKeyframes.length === 0)}
                                                    className={`w-full px-3 py-2 rounded text-xs font-medium transition-colors flex items-center justify-center gap-2 ${node.isGenerating
                                                        ? 'bg-zinc-600 text-zinc-400 cursor-not-allowed'
                                                        : node.settings?.analysisMode === 'auto'
                                                            ? 'bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 text-white shadow-lg'
                                                            : 'bg-blue-600 hover:bg-blue-500 text-white'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {node.isGenerating ? (
                                                        <>
                                                            <Loader2 size={14} className="animate-spin" />
                                                            <span>{node.settings?.analysisMode === 'auto' ? t('AI 正在拉片分析中...') : t('生成中...')}</span>
                                                        </>
                                                    ) : (
                                                        <>
                                                            <Sparkles size={14} />
                                                            <span>{node.settings?.analysisMode === 'auto' ? t('开始全自动拆解视频') : t('为选中关键帧生成提示词')}</span>
                                                        </>
                                                    )}
                                                </button>

                                                {node.errorMsg && (
                                                    <div className="text-[10px] text-red-500 px-2 py-1 rounded bg-red-500/10">
                                                        {node.errorMsg}
                                                    </div>
                                                )}
                                            </div>

                                            {/* 结果展示区 (Auto 模式) */}
                                            {node.settings?.analysisMode === 'auto' && node.settings?.analysisResults?.length > 0 && (
                                                <div className="flex-1 overflow-y-auto custom-scrollbar pt-2">
                                                    {/* 口播文案 (Voiceover) */}
                                                    {node.settings.voiceoverResults?.length > 0 && (
                                                        <div className={`p-2 rounded-lg mb-4 ${theme === 'dark' ? 'bg-zinc-700/50 border border-zinc-700' : 'bg-zinc-50 border border-blue-200'}`}>
                                                            <h4 className={`text-xs font-semibold mb-2 flex items-center gap-1 ${theme === 'dark' ? 'text-white' : 'text-blue-700'}`}>
                                                                <Mic2 size={12} /> 提取口播文案
                                                            </h4>
                                                            <div className="space-y-1">
                                                                {node.settings.voiceoverResults.map((v, i) => (
                                                                    <p
                                                                        key={i}
                                                                        className={`text-[10px] select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    >
                                                                        <span className="font-mono text-xs mr-2 opacity-70">[{v.time_range || `${v.time}s`}]</span>
                                                                        {v.text || <span className="text-zinc-400 italic">（无口播）</span>}
                                                                    </p>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* 场景拆解结果 */}
                                                    <h4 className={`text-xs font-semibold mb-3 flex items-center gap-1 ${theme === 'dark' ? 'text-white' : 'text-zinc-800'}`}>
                                                        <Camera size={12} /> 导演级场景分析 ({node.settings.analysisResults.length} 场景)
                                                    </h4>

                                                    <div className="space-y-4">
                                                        {node.settings.analysisResults.map((scene, i) => (
                                                            <div key={i} className={`p-3 rounded-lg ${theme === 'dark' ? 'bg-zinc-800 border border-zinc-700' : 'bg-zinc-50 border border-zinc-200'}`}>
                                                                <h5 className={`text-sm font-bold mb-2 ${theme === 'dark' ? 'text-purple-400' : 'text-purple-700'}`}>
                                                                    场景 {scene.scene_index || scene.scene_id || i + 1} <span className="text-xs font-normal opacity-70 ml-2">({scene.time_range})</span>
                                                                </h5>

                                                                {/* 视觉分析 */}
                                                                <div className="text-[11px] space-y-1 mb-3">
                                                                    {scene.keyframes?.[0]?.description && (
                                                                        <p
                                                                            className={`select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}
                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                        >
                                                                            <span className="font-semibold mr-1">运镜/动态:</span> {scene.keyframes[0].description}
                                                                        </p>
                                                                    )}
                                                                    {scene.global_tags?.style?.[0] && (
                                                                        <p
                                                                            className={`select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}
                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                        >
                                                                            <span className="font-semibold mr-1">氛围/风格:</span> {scene.global_tags.style[0]}
                                                                        </p>
                                                                    )}
                                                                </div>

                                                                {/* 提示词输出 */}
                                                                <div className="space-y-2">
                                                                    {/* 即梦 Prompt */}
                                                                    {scene.keyframes?.[0]?.jimeng_prompt && (
                                                                        <div className={`p-2 rounded ${theme === 'dark' ? 'bg-zinc-700 border border-zinc-600' : 'bg-zinc-50 border border-gray-300'}`}>
                                                                            <h6 className={`text-[10px] font-semibold mb-1 flex items-center gap-1 ${theme === 'dark' ? 'text-yellow-300' : 'text-yellow-700'}`}><Code size={10} /> 即梦 Prompt</h6>
                                                                            <p
                                                                                className={`text-[10px] whitespace-pre-wrap select-text cursor-text ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}
                                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                            >{scene.keyframes[0].jimeng_prompt}</p>
                                                                            <button onClick={() => navigator.clipboard.writeText(scene.keyframes[0].jimeng_prompt)} className="mt-1 flex items-center text-[9px] text-blue-400 hover:text-blue-300" onMouseDown={(e) => e.stopPropagation()}>
                                                                                <ClipboardCopy size={10} className="mr-1" /> {t('复制')}
                                                                            </button>
                                                                        </div>
                                                                    )}

                                                                    {/* MJ Prompt */}
                                                                    {scene.keyframes?.[0]?.mj_prompt && (
                                                                        <div className={`p-2 rounded ${theme === 'dark' ? 'bg-zinc-700 border border-zinc-600' : 'bg-zinc-50 border border-gray-300'}`}>
                                                                            <h6 className={`text-[10px] font-semibold mb-1 flex items-center gap-1 ${theme === 'dark' ? 'text-green-300' : 'text-green-700'}`}><Code size={10} /> MJ Prompt</h6>
                                                                            <p
                                                                                className={`text-[10px] whitespace-pre-wrap select-text cursor-text ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}
                                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                            >{scene.keyframes[0].mj_prompt}</p>
                                                                            <button onClick={() => navigator.clipboard.writeText(scene.keyframes[0].mj_prompt)} className="mt-1 flex items-center text-[9px] text-blue-400 hover:text-blue-300" onMouseDown={(e) => e.stopPropagation()}>
                                                                                <ClipboardCopy size={10} className="mr-1" /> {t('复制')}
                                                                            </button>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                            {/* 结果展示区 (Manual 模式) */}
                                            {(node.settings?.analysisMode || 'manual') === 'manual' && node.analysisResults && node.analysisResults.length > 0 ? (
                                                <div className="space-y-3 flex-1 flex flex-col min-h-0">
                                                    <div className="text-[11px] font-medium text-zinc-700 dark:text-zinc-300 shrink-0">拆解提示词 ({node.analysisResults.length} 个场景)</div>
                                                    <div className="space-y-3 flex-1 overflow-y-auto custom-scrollbar min-h-0">
                                                        {node.analysisResults.map((result, idx) => {
                                                            // 获取关键帧对应的图片URL（从videoInputNode的frames或selectedKeyframes中查找）
                                                            const getFrameImageUrl = (frameTime) => {
                                                                // 先从selectedKeyframes中查找
                                                                const selectedFrame = videoInputNode.selectedKeyframes?.find(f => Math.abs(f.time - frameTime) < 0.1);
                                                                if (selectedFrame) return selectedFrame.url;
                                                                // 再从frames中查找
                                                                const frame = videoInputNode.frames?.find(f => Math.abs(f.time - frameTime) < 0.1);
                                                                return frame?.url || null;
                                                            };

                                                            // 获取当前场景的主要关键帧（prev/current/next）
                                                            const currentKeyframe = result.keyframes?.find(k => k.type === 'current') || result.keyframes?.[0];
                                                            const prevKeyframe = result.keyframes?.find(k => k.type === 'prev');
                                                            const nextKeyframe = result.keyframes?.find(k => k.type === 'next');

                                                            // 获取简短描述（使用current的描述，如果没有则使用第一个）
                                                            const shortDescription = currentKeyframe?.description || result.keyframes?.[0]?.description || '无描述';

                                                            return (
                                                                <div
                                                                    key={idx}
                                                                    className={`p-3 rounded-lg border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700' : 'bg-white border-zinc-300'}`}
                                                                >
                                                                    {/* 场景标题和时间区间 */}
                                                                    <div className="flex items-center justify-between mb-2">
                                                                        <div className="font-medium text-[11px] text-zinc-800 dark:text-zinc-200">
                                                                            场景 {result.scene_index || idx + 1}
                                                                        </div>
                                                                        <div className="text-[10px] text-zinc-500">
                                                                            {result.time_range}
                                                                        </div>
                                                                    </div>

                                                                    {/* 简短描述 */}
                                                                    <div
                                                                        className="text-[10px] text-zinc-600 dark:text-zinc-400 mb-3 line-clamp-2 select-text cursor-text"
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    >
                                                                        {shortDescription}
                                                                    </div>

                                                                    {/* 关键帧缩略图 */}
                                                                    <div className="grid grid-cols-3 gap-2 mb-3">
                                                                        {[prevKeyframe, currentKeyframe, nextKeyframe].map((kf, kfIdx) => {
                                                                            if (!kf) return <div key={kfIdx} className="aspect-video bg-zinc-200 dark:bg-zinc-700 rounded"></div>;
                                                                            const imageUrl = getFrameImageUrl(kf.time);
                                                                            return (
                                                                                <div key={kfIdx} className="relative aspect-video bg-black rounded overflow-hidden">
                                                                                    {imageUrl ? (
                                                                                        <LazyBase64Image src={imageUrl} className="w-full h-full object-cover" alt={`关键帧 ${kfIdx + 1}`} loading="lazy" />
                                                                                    ) : (
                                                                                        <div className="w-full h-full flex items-center justify-center text-[8px] text-zinc-500">
                                                                                            {kf.type === 'prev' ? '上一帧' : kf.type === 'current' ? '当前帧' : '下一帧'}
                                                                                        </div>
                                                                                    )}
                                                                                    <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-[8px] px-1 py-0.5 text-center">
                                                                                        {kf.time.toFixed(1)}s
                                                                                    </div>
                                                                                </div>
                                                                            );
                                                                        })}
                                                                    </div>

                                                                    {/* 提示词列表 */}
                                                                    <div className="space-y-2">
                                                                        {result.keyframes?.map((kf, kfIdx) => (
                                                                            <div key={kfIdx} className="space-y-1.5">
                                                                                <div className="text-[9px] text-zinc-500">
                                                                                    {kf.type === 'prev' ? '上一帧' : kf.type === 'current' ? '当前帧' : '下一帧'} ({kf.time.toFixed(1)}s)
                                                                                </div>

                                                                                {/* MJ 提示词 */}
                                                                                {kf.mj_prompt && (
                                                                                    <div className={`p-2 rounded border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-600' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'}`}>
                                                                                        <div className="flex items-start justify-between gap-2">
                                                                                            <div className="flex-1">
                                                                                                <div className="text-[9px] text-zinc-500 mb-1">Midjourney 提示词</div>
                                                                                                <div
                                                                                                    className="text-[10px] text-zinc-700 dark:text-zinc-300 break-words select-text cursor-text"
                                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                                >{kf.mj_prompt}</div>
                                                                                            </div>
                                                                                            <div className="flex items-center gap-1 shrink-0">
                                                                                                <button
                                                                                                    onClick={async () => {
                                                                                                        try {
                                                                                                            await navigator.clipboard.writeText(kf.mj_prompt);
                                                                                                            alert(t('已复制到剪贴板'));
                                                                                                        } catch (e) {
                                                                                                            alert(t('复制失败'));
                                                                                                        }
                                                                                                    }}
                                                                                                    className={`p-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors ${theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : 'text-zinc-500 hover:text-zinc-700'}`}
                                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                                    title={t('复制')}
                                                                                                >
                                                                                                    <CopyPlus size={12} />
                                                                                                </button>
                                                                                                <button
                                                                                                    onClick={() => {
                                                                                                        const world = screenToWorld(node.x + node.width + 100, node.y + node.height / 2);
                                                                                                        const newNodeId = `node-${Date.now()}`;

                                                                                                        // 创建图生图节点
                                                                                                        const genImageNode = {
                                                                                                            id: newNodeId,
                                                                                                            type: 'gen-image',
                                                                                                            x: world.x - 180,
                                                                                                            y: world.y - 170,
                                                                                                            width: 360,
                                                                                                            height: 340,
                                                                                                             settings: {
                                                                                                                 model: 'mj-v6',
                                                                                                                 prompt: kf.mj_prompt,
                                                                                                                 ratio: 'Auto',
                                                                                                                resolution: '2K'
                                                                                                             }
                                                                                                         };

                                                                                                        setNodes((prev) => [...prev, genImageNode]);

                                                                                                        // 创建预览节点并连接
                                                                                                        setTimeout(() => {
                                                                                                            const previewWorld = screenToWorld(node.x + node.width + 200, node.y + node.height / 2);
                                                                                                            const previewNodeId = `node-${Date.now() + 1}`;
                                                                                                            const previewNode = {
                                                                                                                id: previewNodeId,
                                                                                                                type: 'preview',
                                                                                                                x: previewWorld.x - 160,
                                                                                                                y: previewWorld.y - 130,
                                                                                                                width: 320,
                                                                                                                height: 260
                                                                                                            };

                                                                                                            setNodes((prev) => [...prev, previewNode]);

                                                                                                            // 连接图生图节点到预览节点
                                                                                                            setConnections((prev) => [...prev, {
                                                                                                                id: `conn-${Date.now()}`,
                                                                                                                from: newNodeId,
                                                                                                                to: previewNodeId
                                                                                                            }]);
                                                                                                        }, 50);
                                                                                                    }}
                                                                                                    className={`p-1 rounded hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors text-blue-600 dark:text-blue-400`}
                                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                                    title={t('生成图生图节点')}
                                                                                                >
                                                                                                    <ImagePlus size={12} />
                                                                                                </button>
                                                                                            </div>
                                                                                        </div>
                                                                                    </div>
                                                                                )}

                                                                                {/* 即梦提示词 */}
                                                                                {kf.jimeng_prompt && (
                                                                                    <div className={`p-2 rounded border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-600' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'}`}>
                                                                                        <div className="flex items-start justify-between gap-2">
                                                                                            <div className="flex-1">
                                                                                                <div className="text-[9px] text-zinc-500 mb-1">即梦提示词</div>
                                                                                                <div
                                                                                                    className="text-[10px] text-zinc-700 dark:text-zinc-300 break-words select-text cursor-text"
                                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                                >{kf.jimeng_prompt}</div>
                                                                                            </div>
                                                                                            <button
                                                                                                onClick={async () => {
                                                                                                    try {
                                                                                                        await navigator.clipboard.writeText(kf.jimeng_prompt);
                                                                                                        alert(t('已复制到剪贴板'));
                                                                                                    } catch (e) {
                                                                                                        alert(t('复制失败'));
                                                                                                    }
                                                                                                }}
                                                                                                className={`p-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors ${theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : 'text-zinc-500 hover:text-zinc-700'}`}
                                                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                                                title={t('复制')}
                                                                                            >
                                                                                                <CopyPlus size={12} />
                                                                                            </button>
                                                                                        </div>
                                                                                    </div>
                                                                                )}
                                                                            </div>
                                                                        ))}
                                                                    </div>

                                                                    {/* 全局标签 */}
                                                                    {result.global_tags && (
                                                                        <div className="mt-2 pt-2 border-t border-zinc-300 dark:border-zinc-700">
                                                                            <div className="text-[9px] text-zinc-500 mb-1">全局标签</div>
                                                                            <div className="flex flex-wrap gap-1">
                                                                                {Object.entries(result.global_tags).map(([key, values]) => (
                                                                                    Array.isArray(values) && values.map((val, valIdx) => (
                                                                                        <span key={`${key}-${valIdx}`} className="text-[8px] px-1.5 py-0.5 rounded bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300">
                                                                                            {val}
                                                                                        </span>
                                                                                    ))
                                                                                ))}
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            ) : null}
                                        </>
                                    );
                                })()}
                            </div>
                        </div>
                    )}

                    {node.type === 'storyboard-node' && (() => {
                        // --- 辅助函数：处理单个镜头的图片上传 ---
                        const handleShotImageUpload = (e, shotId) => {
                            const file = e.target.files?.[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (ev) => updateShot(node.id, shotId, { image_url: ev.target.result });
                                reader.readAsDataURL(file);
                            }
                        };

                        // --- 辅助函数：处理单个镜头的粘贴 (Ctrl+V) ---
                        const handleShotPaste = (e, shotId) => {
                            const items = e.clipboardData.items;
                            for (let i = 0; i < items.length; i++) {
                                if (items[i].type.indexOf('image') !== -1) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    const blob = items[i].getAsFile();
                                    const reader = new FileReader();
                                    reader.onload = (ev) => updateShot(node.id, shotId, { image_url: ev.target.result });
                                    reader.readAsDataURL(blob);
                                    return;
                                }
                            }
                        };

                        // --- 辅助函数：处理单个镜头的拖拽 (Drop) ---
                        const handleShotDrop = (e, shotId) => {
                            e.preventDefault();
                            e.stopPropagation();

                            const currentShot = (node.settings?.shots || []).find(s => isSameShotId(s.id, shotId));
                            const currentMode = node.settings?.mode || 'video';
                            const applyDroppedImage = (imageUrl) => {
                                if (!imageUrl) return false;
                                if (currentMode === 'video') {
                                    const useLastFrame = currentShot?.useFirstLastFrame && currentShot?.activeInput === 'last';
                                    const field = useLastFrame ? 'lastFrame' : 'image_url';
                                    updateShot(node.id, shotId, { [field]: imageUrl, image_filename: '' });
                                    return true;
                                }
                                if (currentShot?.useMultiRef) {
                                    const existingRefs = currentShot.referenceImages && currentShot.referenceImages.length > 0
                                        ? currentShot.referenceImages
                                        : (currentShot.image_url ? [currentShot.image_url] : []);
                                    const nextRefs = existingRefs.slice(0, 5);
                                    if (nextRefs.length < 5) {
                                        nextRefs.push(imageUrl);
                                    } else {
                                        nextRefs[0] = imageUrl;
                                    }
                                    updateShot(node.id, shotId, { referenceImages: nextRefs, image_url: nextRefs[0] || imageUrl });
                                    return true;
                                }
                                updateShot(node.id, shotId, { image_url: imageUrl, image_filename: '', referenceImages: [] });
                                return true;
                            };

                            // 1. 尝试从浏览器外部拖入文件
                            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                                const file = e.dataTransfer.files[0];
                                if (file.type.startsWith('image/')) {
                                    const reader = new FileReader();
                                    reader.onload = (ev) => applyDroppedImage(ev.target.result);
                                    reader.readAsDataURL(file);
                                    return;
                                }
                            }

                            // 2. 尝试从左侧历史记录拖入 (dataTransfer)
                            const rawPayload = e.dataTransfer.getData('application/x-tapnow-history');
                            if (rawPayload) {
                                try {
                                    const payload = JSON.parse(rawPayload);
                                    const dragUrl = payload?.url || payload?.originalUrl || payload?.previewUrl || '';
                                    if (applyDroppedImage(dragUrl)) return;
                                } catch (err) {
                                    console.warn('[StoryboardDrop] Failed to parse payload', err);
                                }
                            }

                            // 3. 尝试读取 URL 文本 (浏览器内拖拽图片/链接)
                            const uriList = e.dataTransfer.getData('text/uri-list') || '';
                            const uriCandidate = uriList.split('\n').find(line => line && !line.startsWith('#')) || '';
                            const plainText = e.dataTransfer.getData('text/plain') || '';
                            const urlCandidate = (uriCandidate || plainText).trim();
                            if (urlCandidate && /^(https?:|data:image\/|blob:|file:)/i.test(urlCandidate)) {
                                applyDroppedImage(urlCandidate);
                            }
                        };

                        const previewPanelWidth = 220;
                        const nodeQueueItems = batchQueueItems.filter(item => item.nodeId === node.id);
                        const nodeRunningItems = batchRunningItems.filter(item => item.nodeId === node.id);

                        return (
                            <div className="flex h-full">
                                <div
                                    className={`flex flex-col h-full rounded-xl overflow-hidden pointer-events-auto transition-colors flex-1 ${theme === 'dark'
                                        ? 'bg-zinc-950 border border-zinc-800'
                                        : theme === 'solarized'
                                            ? 'bg-[#eee8d5] border border-[#d7cfb2]'
                                        : 'bg-white border border-zinc-300 shadow-sm'
                                        }`}
                                    onMouseEnter={() => setIsMouseOverStoryboard(true)}
                                    onMouseLeave={() => setIsMouseOverStoryboard(false)}
                                >
                                    {/* Header */}
                                    <div className={`px-4 py-3 border-b flex items-center shrink-0 flex-nowrap overflow-x-auto no-scrollbar ${theme === 'dark'
                                        ? 'bg-zinc-900 border-zinc-800'
                                        : theme === 'solarized'
                                            ? 'bg-[#eee8d5] border-[#eee8d5]'
                                            : 'bg-zinc-50 border-zinc-200'
                                        }`}>
                                        <div className="flex items-center gap-1 shrink-0">
                                            <LayoutGrid size={16} className="text-purple-500" />
                                            <span className={`font-bold text-xs ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}>
                                                {t('智能分镜')}
                                            </span>
                                            <span className={`text-xs ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>/</span>
                                            {/* V3.7.25: 点击画笔才能编辑，否则可拖动 */}
                                            {node.settings?.isEditingTitle ? (
                                                <input
                                                    type="text"
                                                    value={node.settings?.projectTitle || ''}
                                                    onChange={(e) => updateNodeSettings(node.id, { projectTitle: e.target.value })}
                                                    placeholder={t('项目名称')}
                                                    className={`font-bold text-xs bg-transparent border-b border-blue-500 outline-none w-32 transition-colors ${theme === 'dark' ? 'text-zinc-200 placeholder-zinc-500' : 'text-zinc-800 placeholder-zinc-400'}`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    onClick={(e) => e.stopPropagation()}
                                                    onKeyDown={(e) => {
                                                        e.stopPropagation();
                                                        if (e.key === 'Enter' || e.key === 'Escape') {
                                                            updateNodeSettings(node.id, { isEditingTitle: false });
                                                        }
                                                    }}
                                                    onBlur={() => updateNodeSettings(node.id, { isEditingTitle: false })}
                                                    autoFocus
                                                />
                                            ) : (
                                                <span
                                                    className={`font-bold text-xs cursor-move ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'} ${!node.settings?.projectTitle ? (theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400') : ''}`}
                                                    title={t('拖动移动窗口')}
                                                >
                                                    {node.settings?.projectTitle || '项目名称'}
                                                </span>
                                            )}
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    updateNodeSettings(node.id, { isEditingTitle: !node.settings?.isEditingTitle });
                                                }}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                className={`p-0.5 rounded transition-colors ${node.settings?.isEditingTitle
                                                    ? 'text-blue-500'
                                                    : theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                title={t('编辑项目名称')}
                                            >
                                                <Pencil size={12} />
                                            </button>
                                            {/* V3.6.1: 图片/视频模式切换滑块 */}
                                            <div className={`flex items-center ml-2 p-0.5 rounded-full ${theme === 'dark' ? 'bg-zinc-800' : theme === 'solarized' ? 'bg-[#eee8d5]' : 'bg-zinc-200'}`}>
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        // V3.7.19: 切换模式时更新所有镜头的模型为对应类型
                                                        const newMode = 'image';
                                                        const defaultModel = resolveModelKey(localStorage.getItem('tapnow_last_image_model') || apiConfigs.find(c => isImageModelType(c.type))?.id || '');
                                                        const currentShots = node.settings?.shots || [];
                                                        // 只更新那些使用了错误类型模型的镜头
                                                        const updatedShots = currentShots.map(shot => {
                                                            const shotConfig = getApiConfigByKey(shot.model);
                                                            // 如果当前模型是视频类型，则更新为图片模型
                                                            if (!shotConfig || shotConfig.type === 'Video') {
                                                                return { ...shot, model: defaultModel, duration: undefined };
                                                            }
                                                            return shot;
                                                        });
                                                        updateNodeSettings(node.id, { mode: newMode, shots: updatedShots });
                                                    }}
                                                    className={`text-[10px] px-2 py-0.5 rounded-full transition-all ${(node.settings?.mode || 'video') === 'image'
                                                        ? 'bg-blue-500 text-white shadow-sm'
                                                        : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-200' : 'text-zinc-500 hover:text-zinc-700'}`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    title={t('切换到图片生成模式')}
                                                >
                                                    {t('图片')}
                                                </button>
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        // V3.7.19: 切换模式时更新所有镜头的模型为对应类型
                                                        const newMode = 'video';
                                                        const defaultModel = resolveModelKey(localStorage.getItem('tapnow_last_video_model') || apiConfigs.find(c => c.type === 'Video')?.id || '');
                                                        const currentShots = node.settings?.shots || [];
                                                        // 只更新那些使用了错误类型模型的镜头
                                                        const updatedShots = currentShots.map(shot => {
                                                            const shotConfig = getApiConfigByKey(shot.model);
                                                            // 如果当前模型是图片类型，则更新为视频模型
                                                            if (!shotConfig || isImageModelType(shotConfig.type)) {
                                                                return { ...shot, model: defaultModel, duration: getDefaultDurationForModel(defaultModel) };
                                                            }
                                                            return shot;
                                                        });
                                                        updateNodeSettings(node.id, { mode: newMode, shots: updatedShots });
                                                    }}
                                                    className={`text-[10px] px-2 py-0.5 rounded-full transition-all ${(node.settings?.mode || 'video') === 'video'
                                                        ? 'bg-green-500 text-white shadow-sm'
                                                        : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-200' : 'text-zinc-500 hover:text-zinc-700'}`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    title={t('切换到视频生成模式')}
                                                >
                                                    {t('视频')}
                                                </button>
                                            </div>
                                        </div>
                                        <div className="flex items-center gap-2 ml-auto relative z-10 shrink-0">
                                            {/* V3.5.26: Clear Button Moved Here */}
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (confirm(t('确定要清空所有镜头吗？'))) {
                                                        updateNodeSettings(node.id, { shots: [] });
                                                    }
                                                }}
                                                className="p-1 hover:bg-red-100 hover:text-red-500 rounded text-zinc-400 transition-colors"
                                                title={t('清空所有镜头')}
                                            >
                                                <Trash2 size={14} />
                                            </button>
                                            {/* V3.5.18: 拆分脚本按钮 */}
                                            <button
                                                onClick={() => {
                                                    const connectedTexts = getConnectedTextNodes(node.id);
                                                    if (connectedTexts.length > 0) {
                                                        // 有上游文本节点，直接拆分导入
                                                        const text = connectedTexts.join('\n');
                                                        // V3.5.36: Updated regex to match enhanced pattern
                                                        const combinedPattern = /#\s*(\d+)\s*([^#【]*)|【\s*(\d+)\s*】\s*([^#【]*)/g;
                                                        const matches = [];
                                                        let m;
                                                        while ((m = combinedPattern.exec(text)) !== null) {
                                                            const num = parseInt(m[1] || m[3]);
                                                            const content = (m[2] || m[4] || '').trim();
                                                            if (content) matches.push({ num, text: content });
                                                        }

                                                        // Fallback for 1. 2. 
                                                        if (matches.length === 0) {
                                                            const lines = text.split('\n').filter(l => l.trim());
                                                            lines.forEach((line, i) => {
                                                                const numMatch = line.match(/^(\d+)[.、\s]+(.*)/);
                                                                if (numMatch) matches.push({ num: parseInt(numMatch[1]), text: numMatch[2].trim() });
                                                                else matches.push({ num: i + 1, text: line.trim() });
                                                            });
                                                        }

                                                        if (matches.length > 0) {
                                                            const existingShots = node.settings?.shots || [];
                                                            const mergedShots = [...existingShots];
                                                            const mode = node.settings?.mode || 'video';
                                                            const defaultModel = mode === 'image'
                                                                ? resolveModelKey(localStorage.getItem('tapnow_last_image_model') || apiConfigs.find(c => isImageModelType(c.type))?.id || '')
                                                                : resolveModelKey(localStorage.getItem('tapnow_last_video_model') || apiConfigs.find(c => c.type === 'Video')?.id || '');
                                                            const defaultRatio = mode === 'image' ? '1:1' : '16:9';
                                                            const defaultDuration = mode === 'video' ? getDefaultDurationForModel(defaultModel) : undefined;
                                                            matches.forEach((m, i) => {
                                                                if (i < existingShots.length) {
                                                                    mergedShots[i] = { ...mergedShots[i], prompt: m.text, description: m.text };
                                                                } else {
                                                                    mergedShots.push({
                                                                        id: Date.now() + Math.random() + i,
                                                                        prompt: m.text,
                                                                        description: m.text,
                                                                        model: defaultModel,
                                                                        ratio: defaultRatio,
                                                                        duration: defaultDuration,
                                                                        status: 'draft',
                                                                        outputEnabled: false,
                                                                        selectedImageIndex: -1
                                                                    });
                                                                }
                                                            });
                                                            updateNodeSettings(node.id, { shots: mergedShots });
                                                        } else {
                                                            alert(t('未在文本中找到分镜标记 (例如: #1 镜头内容)。请检查上游节点文本格式。'));
                                                        }
                                                    } else {
                                                        // 无上游节点，显示手动输入框
                                                        updateNodeSettings(node.id, { scriptExpanded: !node.settings?.scriptExpanded });
                                                    }
                                                }}
                                                className={`text-xs px-2 py-1 rounded transition-colors flex items-center gap-1 ${theme === 'dark' ? 'bg-purple-600 hover:bg-purple-500 text-white' : 'bg-purple-500 hover:bg-purple-400 text-white'}`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                title={getConnectedTextNodes(node.id).length > 0 ? t('从上游文本节点导入脚本') : t('展开脚本输入区')}
                                            >
                                                <FileText size={12} />
                                                <span className="whitespace-nowrap">{t('脚本')}</span>
                                            </button>
                                            {/* V3.5.18: 导入关键帧按钮 */}
                                            {(() => {
                                                const connectedVideoNode = getConnectedVideoInputNode(node.id);
                                                const keyframeCount = connectedVideoNode?.selectedKeyframes?.length || 0;
                                                return (
                                                    <button
                                                        onClick={async () => {
                                                            if (!connectedVideoNode || keyframeCount === 0) {
                                                                alert(t('请先连接视频输入节点并选择关键帧'));
                                                                return;
                                                            }
                                                            const keyframes = connectedVideoNode.selectedKeyframes;
                                                            const currentShots = node.settings?.shots || [];
                                                            const maxLen = Math.max(currentShots.length, keyframes.length);
                                                            const mergedShots = Array.from({ length: maxLen }, (_, i) => ({
                                                                id: currentShots[i]?.id || `shot-${Date.now()}-${i}`,
                                                                ...currentShots[i],
                                                                prompt: currentShots[i]?.prompt ?? '',
                                                                description: currentShots[i]?.description ?? '',
                                                                model: resolveModelKey(currentShots[i]?.model || localStorage.getItem('tapnow_last_video_model') || ''),
                                                                image_url: keyframes[i]?.url ?? currentShots[i]?.image_url ?? '',
                                                                image_filename: keyframes[i]?.filename || currentShots[i]?.image_filename || '',
                                                                status: currentShots[i]?.status || 'draft'
                                                            }));
                                                            saveToUndoStack();

                                                            // V3.7.6: Fix file:// URLs AND IndexedDB IDs (img_*) using LocalImageManager
                                                            if (window.LocalImageManager) {
                                                                for (let s of mergedShots) {
                                                                    const needsResolve = s.image_url && (s.image_url.startsWith('file://') || s.image_url.startsWith('img_'));
                                                                    if (needsResolve) {
                                                                        // For img_* IDs, use the ID directly; for file://, use imgId or filename
                                                                        const idOrFilename = s.image_url.startsWith('img_')
                                                                            ? s.image_url
                                                                            : (s.imgId || s.image_filename);
                                                                        if (idOrFilename) {
                                                                            try {
                                                                                const blob = await window.LocalImageManager.getImage(idOrFilename);
                                                                                if (blob) s.image_url = URL.createObjectURL(blob);
                                                                            } catch (e) { console.error('[KeyframeImport] Failed to load local image:', idOrFilename, e); }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            updateNodeSettings(node.id, { shots: mergedShots });
                                                        }}
                                                        className={`text-xs px-2 py-1 rounded transition-colors flex items-center gap-1 ${keyframeCount > 0
                                                            ? 'bg-blue-600 hover:bg-blue-500 text-white'
                                                            : theme === 'dark' ? 'bg-zinc-700 text-zinc-400 cursor-not-allowed' : 'bg-zinc-200 text-zinc-500 cursor-not-allowed'}`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        disabled={keyframeCount === 0}
                                                        title={keyframeCount > 0
                                                            ? `${t('导入')} ${keyframeCount} ${t('张关键帧')}`
                                                            : t('请先连接视频输入节点并选择关键帧')}
                                                    >
                                                        <ImageIcon size={12} />
                                                        <span className="whitespace-nowrap">{t('导入')}{keyframeCount > 0 ? ` (${keyframeCount})` : ''}</span>
                                                    </button>
                                                );
                                            })()}
                                            {/* V3.7.25: 同步参数按钮 - 从前置节点同步配置 */}
                                            {(() => {
                                                const currentMode = node.settings?.mode || 'video';
                                                // 查找连接到当前分镜的匹配类型节点
                                                const connectedGenNode = connections
                                                    .filter(c => c.to === node.id)
                                                    .map(c => nodesMap.get(c.from))
                                                    .find(n => n && (
                                                        (currentMode === 'image' && n.type === 'gen-image') ||
                                                        (currentMode === 'video' && n.type === 'gen-video')
                                                    ));
                                                if (!connectedGenNode) return null;
                                                const sourceSettings = connectedGenNode.settings || {};
                                                return (
                                                    <button
                                                        onClick={() => {
                                                            const currentShots = node.settings?.shots || [];
                                                            if (currentShots.length === 0) {
                                                                updateNodeSettings(node.id, { errorMsg: '请先拆分脚本' });
                                                                return;
                                                            }
                                                            saveToUndoStack();
                                                            const syncedShots = currentShots.map(shot => ({
                                                                ...shot,
                                                                model: sourceSettings.model || shot.model,
                                                                ratio: sourceSettings.ratio || shot.ratio,
                                                                resolution: sourceSettings.resolution || shot.resolution,
                                                                duration: sourceSettings.duration || shot.duration,
                                                                customParams: sourceSettings.customParams || shot.customParams
                                                            }));
                                                            updateNodeSettings(node.id, { shots: syncedShots });
                                                            // V3.7.29: 显示同步参数 Toast
                                                            showToast(`✓ 已同步 ${syncedShots.length} 个镜头参数 | ${sourceSettings.model || '?'} / ${sourceSettings.ratio || '?'}`, 'success', 5000);
                                                        }}
                                                        className={`text-xs px-2 py-1 rounded transition-colors flex items-center gap-1 ${theme === 'dark' ? 'bg-green-600 hover:bg-green-500 text-white' : 'bg-green-500 hover:bg-green-400 text-white'}`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        title={`从 ${currentMode === 'image' ? '图片' : '视频'}节点同步: ${sourceSettings.model || '?'} / ${sourceSettings.ratio || '?'} / ${sourceSettings.resolution || '?'}${currentMode === 'video' ? ` / ${sourceSettings.duration || '?'}` : ''}`}
                                                    >
                                                        <RefreshCw size={12} />
                                                        <span className="whitespace-nowrap">{t('参数')}</span>
                                                    </button>
                                                );
                                            })()}
                                            {/* V3.5.24: Batch Generate */}
                                            <div className={`flex items-center gap-1 border-l pl-2 ml-1 ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'}`}>
                                                <input
                                                    type="number"
                                                    min="0"
                                                    max="20"
                                                    value={batchConcurrency}
                                                    onChange={(e) => setBatchConcurrency(Math.max(0, parseInt(e.target.value) || 0))}
                                                    className={`w-8 text-center text-xs rounded border outline-none py-0.5 ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300' : 'bg-white border-zinc-300'}`}
                                                    title={t('并发数量 (0=全部)')}
                                                />
                                                <button
                                                    onClick={() => {
                                                        const mode = node.settings?.mode || 'video';
                                                        const allShots = node.settings?.shots || [];

                                                        // V3.7.27: 检测是否有卡住的 generating 镜头
                                                        const stuckGenerating = allShots.filter(s => s.status === 'generating');
                                                        if (stuckGenerating.length > 0) {
                                                            // V3.7.29: 使用 prompt 实现三选项（确定=终止/取消=跳过/空=放弃）
                                                            const userChoice = prompt(
                                                                `检测到 ${stuckGenerating.length} 个镜头正在生成中。\n\n` +
                                                                `可能是任务卡住或等待中。\n\n` +
                                                                `请选择操作：\n` +
                                                                `● 输入 "1" 或 "ok" = 强制终止并重新开始\n` +
                                                                `● 输入 "2" 或 "skip" = 跳过这些镜头，继续其余\n` +
                                                                `● 点击取消或留空 = 放弃操作`,
                                                                ''
                                                            );

                                                            if (userChoice === null || userChoice.trim() === '') {
                                                                // 放弃操作
                                                                return;
                                                            }

                                                            const choice = userChoice.trim().toLowerCase();
                                                            if (choice === '1' || choice === 'ok' || choice === '确定') {
                                                                // 强制重置为 failed，并准备重新开始
                                                                stuckGenerating.forEach(s => {
                                                                    // V3.7.29: 立即视觉上重置为 pending，因为要重新加入队列
                                                                    updateShot(node.id, s.id, { status: 'pending', errorMsg: '' });

                                                                    // 手动修改当前快照中的状态，以便通过下方的过滤器
                                                                    s.status = 'pending';
                                                                });
                                                            }
                                                            // choice === '2' 或其他 = 跳过，保持 generating 状态（会被下方过滤器排除）
                                                        }

                                                        // 1. First Pass: Find unfinished shots (not done)
                                                        // V3.7.29: 这里 stuckGenerating 如果被重置为 pending，就会被包含进来
                                                        // V3.8: 也要跳过已锁定的镜头 (outputEnabled=true)
                                                        let targetShots = allShots.filter(s => s.status !== 'done' && s.status !== 'generating' && !s.outputEnabled);
                                                        let isReroll = false;

                                                        // 2. Second Pass: If all finished, check for Re-roll (unlocked items)
                                                        if (targetShots.length === 0) {
                                                            // Filter: Not locked (outputEnabled == false) AND status is done
                                                            targetShots = allShots.filter(s => !s.outputEnabled && s.status === 'done');

                                                            if (targetShots.length === 0) {
                                                                const isAllLocked = allShots.every(s => s.outputEnabled);
                                                                const hasGenerating = allShots.some(s => s.status === 'generating');
                                                                if (hasGenerating) {
                                                                    alert(t('有镜头正在生成中，请等待完成后再试。'));
                                                                } else if (isAllLocked && allShots.length > 0) {
                                                                    alert('所有镜头已锁定（灰框已勾选），无法重新生成。\n请取消勾选需要重新生成的镜头。');
                                                                } else {
                                                                    alert(t('没有待生成的镜头'));
                                                                }
                                                                return;
                                                            }
                                                            isReroll = true;
                                                        }

                                                        // Confirm before re-roll
                                                        if (isReroll) {
                                                            const confirmMsg = `所有镜头已生成完毕。\n\n即将对 ${targetShots.length} 个未锁定（灰框未勾选）的镜头进行重新生成。\n\n● 继续批量生成会覆盖原有输出但是资产在左侧可以查看\n● 已锁定（灰框勾选）的镜头将保持不变\n\n是否继续？`;
                                                            if (!confirm(confirmMsg)) return;
                                                        }

                                                        // V3.8: 记录批次分组与任务编号
                                                        const totalCount = targetShots.length;
                                                        const batchConcurrencyValue = batchConcurrency === 0 ? totalCount : Math.max(1, batchConcurrency);
                                                        const taskIndex = (batchTaskCounterRef.current.get(node.id) || 0) + 1;
                                                        batchTaskCounterRef.current.set(node.id, taskIndex);
                                                        const batchId = `batch-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
                                                        const shotIds = targetShots.map(s => s.id);
                                                        shotIds.forEach((shotId, idx) => {
                                                            shotBatchMapRef.current.set(`${node.id}:${shotId}`, {
                                                                batchId,
                                                                batchOrder: idx,
                                                                taskIndex
                                                            });
                                                        });
                                                        setBatchGroups(prev => [
                                                            ...prev,
                                                            {
                                                                id: batchId,
                                                                nodeId: node.id,
                                                                projectTitle: node.settings?.projectTitle || '未命名分镜',
                                                                total: totalCount,
                                                                concurrency: batchConcurrencyValue,
                                                                createdAt: Date.now(),
                                                                mode,
                                                                taskIndex,
                                                                shotIds
                                                            }
                                                        ]);

                                                        // V3.7.5: 统一图片和视频模式的队列管理
                                                        const newQueueItems = targetShots.map((s, idx) => ({
                                                            nodeId: node.id,
                                                            shotId: s.id,
                                                            retryCount: 0,
                                                            mode: mode,
                                                            batchId,
                                                            batchOrder: idx,
                                                            batchConcurrency: batchConcurrencyValue,
                                                            taskIndex
                                                        }));
                                                        setBatchQueue(prev => [...prev, ...newQueueItems]);

                                                        // V3.7.29: 强制重置状态机，防止 cooling/running 状态阻塞
                                                        if (batchStateRef.current !== 'running') {
                                                            batchStateRef.current = 'idle';
                                                        }
                                                        // V3.7.28: 手动触发队列处理器
                                                        setBatchTick(t => t + 1);

                                                        showToast(`✓ 已添加 ${newQueueItems.length} 个${mode === 'image' ? '图片' : '视频'}任务 | 线程: ${batchConcurrency === 0 ? '∞' : batchConcurrency}${isReroll ? ' (重新生成)' : ''}`, 'success', 5000);
                                                    }}
                                                    className={`p-1 rounded transition-colors ${(node.settings?.mode || 'video') === 'image'
                                                        ? theme === 'dark' ? 'bg-blue-600 hover:bg-blue-500 text-white' : 'bg-blue-500 hover:bg-blue-400 text-white'
                                                        : theme === 'dark' ? 'bg-yellow-600 hover:bg-yellow-500 text-white' : 'bg-yellow-500 hover:bg-yellow-400 text-white'}`}
                                                    title={`批量全部生成${(node.settings?.mode || 'video') === 'image' ? '图片' : '视频'}`}
                                                >
                                                    <div className="flex items-center gap-1">
                                                        {(node.settings?.mode || 'video') === 'image' ? <ImageIcon size={12} /> : <Zap size={12} fill="currentColor" />}
                                                        <span className="text-[10px] font-medium whitespace-nowrap">{t('批量')}</span>
                                                    </div>
                                                </button>
                                                {/* V3.8: 批量下载按钮（全部/选中） */}
                                                <div className="relative">
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            const rect = e.currentTarget.getBoundingClientRect();
                                                            setActiveDropdown(activeDropdown?.nodeId === node.id && activeDropdown.type === 'storyboard-download'
                                                                ? null
                                                                : {
                                                                    nodeId: node.id,
                                                                    type: 'storyboard-download',
                                                                    anchor: {
                                                                        top: rect.top,
                                                                        left: rect.left,
                                                                        right: rect.right,
                                                                        bottom: rect.bottom,
                                                                        width: rect.width,
                                                                        height: rect.height
                                                                    }
                                                                });
                                                        }}
                                                        className={`p-1 rounded transition-colors flex items-center gap-0.5 ${theme === 'dark' ? 'bg-zinc-700 hover:bg-zinc-600 text-zinc-300' : 'bg-zinc-200 hover:bg-zinc-300 text-zinc-600'}`}
                                                        title={t('批量下载')}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        <Download size={12} />
                                                        <ChevronDown size={10} />
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'storyboard-download' && activeDropdown.anchor && createPortal(
                                                        <div
                                                            className={`fixed mt-1 w-32 rounded-lg shadow-xl py-1 z-[9999] border ${theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                }`}
                                                            style={{
                                                                top: activeDropdown.anchor.bottom + 6,
                                                                left: activeDropdown.anchor.right,
                                                                transform: 'translateX(-100%)'
                                                            }}
                                                            onMouseLeave={() => setActiveDropdown(null)}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                        >
                                                            <button
                                                                onClick={() => {
                                                                    setActiveDropdown(null);
                                                                    handleStoryboardBatchDownload(node, 'all');
                                                                }}
                                                                className={`w-full text-left px-3 py-2 text-xs transition-colors ${theme === 'dark'
                                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                                    : 'text-zinc-700 hover:bg-zinc-100'
                                                                    }`}
                                                            >
                                                                全部下载
                                                            </button>
                                                            <button
                                                                onClick={() => {
                                                                    setActiveDropdown(null);
                                                                    handleStoryboardBatchDownload(node, 'selected');
                                                                }}
                                                                className={`w-full text-left px-3 py-2 text-xs transition-colors ${theme === 'dark'
                                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                                    : 'text-zinc-700 hover:bg-zinc-100'
                                                                    }`}
                                                            >
                                                                选中下载
                                                            </button>
                                                        </div>,
                                                        document.body
                                                    )}
                                                </div>
                                                {/* V3.8: 批量队列可视化 */}
                                                <div className="relative">
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            const rect = e.currentTarget.getBoundingClientRect();
                                                            setActiveDropdown(activeDropdown?.nodeId === node.id && activeDropdown.type === 'batch-queue'
                                                                ? null
                                                                : {
                                                                    nodeId: node.id,
                                                                    type: 'batch-queue',
                                                                    anchor: {
                                                                        top: rect.top,
                                                                        left: rect.left,
                                                                        right: rect.right,
                                                                        bottom: rect.bottom,
                                                                        width: rect.width,
                                                                        height: rect.height
                                                                    }
                                                                });
                                                        }}
                                                        className={`p-1 rounded transition-colors relative ${theme === 'dark'
                                                            ? 'bg-zinc-700 hover:bg-zinc-600 text-zinc-300'
                                                            : 'bg-zinc-200 hover:bg-zinc-300 text-zinc-600'}`}
                                                        title={`队列：运行 ${nodeRunningItems.length} | 排队 ${nodeQueueItems.length}`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        <Layers size={12} />
                                                        {nodeQueueItems.length > 0 && (
                                                            <span className={`absolute -top-1 -right-1 text-[8px] px-1 rounded-full ${theme === 'dark'
                                                                ? 'bg-blue-500 text-white'
                                                                : 'bg-blue-600 text-white'}`}>
                                                                {nodeQueueItems.length}
                                                            </span>
                                                        )}
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'batch-queue' && activeDropdown.anchor && createPortal(
                                                        <div
                                                            className={`fixed mt-1 w-64 rounded-lg shadow-xl py-2 z-[9999] border ${theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                }`}
                                                            style={{
                                                                top: activeDropdown.anchor.bottom + 6,
                                                                left: activeDropdown.anchor.right,
                                                                transform: 'translateX(-100%)'
                                                            }}
                                                            onMouseLeave={() => setActiveDropdown(null)}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                        >
                                                            <div className={`px-3 pb-2 text-[10px] ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>
                                                                运行 {nodeRunningItems.length} · 排队 {nodeQueueItems.length}
                                                            </div>
                                                            <div className="px-3 pb-2 flex gap-2">
                                                                <button
                                                                    onClick={() => {
                                                                        setActiveDropdown(null);
                                                                        if (nodeQueueItems.length === 0) return;
                                                                        if (confirm(t('确定清空排队任务吗？'))) clearNodeQueue(node.id, false);
                                                                    }}
                                                                    className={`text-[10px] px-2 py-1 rounded ${theme === 'dark'
                                                                        ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                                        : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'}`}
                                                                >
                                                                    {t('清空排队')}
                                                                </button>
                                                                <button
                                                                    onClick={() => {
                                                                        setActiveDropdown(null);
                                                                        if (nodeRunningItems.length === 0 && nodeQueueItems.length === 0) return;
                                                                        if (confirm(t('确定终止当前节点所有生成并清空队列吗？'))) clearNodeQueue(node.id, true);
                                                                    }}
                                                                    className={`text-[10px] px-2 py-1 rounded ${theme === 'dark'
                                                                        ? 'bg-red-900/40 text-red-300 hover:bg-red-900/60'
                                                                        : 'bg-red-50 text-red-600 hover:bg-red-100'}`}
                                                                >
                                                                    {t('终止全部')}
                                                                </button>
                                                            </div>
                                                            {nodeRunningItems.length > 0 && (
                                                                <div className="px-3 pb-2">
                                                                    <div className={`text-[10px] mb-1 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>运行中</div>
                                                                    <div className="space-y-1">
                                                                        {nodeRunningItems.slice(0, 6).map((item, idx) => (
                                                                            <div key={`${item.nodeId}-${item.shotId}-${idx}`} className={`text-[10px] flex items-center justify-between gap-2 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-600'}`}>
                                                                                <span className="truncate max-w-[150px]">{item.projectTitle} · 镜头{item.sceneIndex}</span>
                                                                                <div className="flex items-center gap-1 shrink-0">
                                                                                    <span className="text-green-500">{t('运行')}</span>
                                                                                    <button
                                                                                        onClick={() => {
                                                                                            if (confirm(t('确定终止该生成任务吗？'))) stopRunningShot(item.nodeId, item.shotId);
                                                                                        }}
                                                                                        className={`p-0.5 rounded ${theme === 'dark'
                                                                                            ? 'text-zinc-500 hover:text-red-300'
                                                                                            : 'text-zinc-400 hover:text-red-500'}`}
                                                                                        title={t('终止任务')}
                                                                                    >
                                                                                        <Trash2 size={10} />
                                                                                    </button>
                                                                                </div>
                                                                            </div>
                                                                        ))}
                                                                        {nodeRunningItems.length > 6 && (
                                                                            <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>仅显示前 6 项</div>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                            )}
                                                            <div className="px-3">
                                                                <div className={`text-[10px] mb-1 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>排队中</div>
                                                                {nodeQueueItems.length === 0 ? (
                                                                    <div className={`text-[10px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'}`}>队列为空</div>
                                                                ) : (
                                                                    <div className="space-y-1 max-h-40 overflow-y-auto pr-1">
                                                                        {nodeQueueItems.slice(0, 12).map((item) => (
                                                                            <div key={`${item.nodeId}-${item.shotId}-${item.order}`} className={`text-[10px] flex items-center justify-between gap-2 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-600'}`}>
                                                                                <span className="truncate max-w-[150px]">#{item.order} {item.projectTitle} · 镜头{item.sceneIndex}</span>
                                                                                <div className="flex items-center gap-1 shrink-0">
                                                                                    <span className="text-blue-400">{item.mode === 'image' ? '图' : '视'}</span>
                                                                                    <button
                                                                                        onClick={() => {
                                                                                            if (confirm(t('确定移除该排队任务吗？'))) removeQueuedBatchItem(item.nodeId, item.shotId);
                                                                                        }}
                                                                                        className={`p-0.5 rounded ${theme === 'dark'
                                                                                            ? 'text-zinc-500 hover:text-red-300'
                                                                                            : 'text-zinc-400 hover:text-red-500'}`}
                                                                                        title={t('移除任务')}
                                                                                    >
                                                                                        <Trash2 size={10} />
                                                                                    </button>
                                                                                </div>
                                                                            </div>
                                                                        ))}
                                                                        {nodeQueueItems.length > 12 && (
                                                                            <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>仅显示前 12 项</div>
                                                                        )}
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>,
                                                        document.body
                                                    )}
                                                </div>
                                                {/* V3.6.1: 预览展开按钮 */}
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        setNodes(prev => prev.map(n => {
                                                            if (n.id === node.id) {
                                                                const isShowing = n.settings?.showOutputPreview;
                                                                // 展开时增加宽度，收起时减少宽度
                                                                // 默认增加预览列宽度
                                                                const newWidth = isShowing ? Math.max(380, n.width - previewPanelWidth) : n.width + previewPanelWidth;
                                                                return {
                                                                    ...n,
                                                                    width: newWidth,
                                                                    settings: { ...n.settings, showOutputPreview: !isShowing }
                                                                };
                                                            }
                                                            return n;
                                                        }));
                                                    }}
                                                    className={`p-1 rounded transition-colors ${node.settings?.showOutputPreview
                                                        ? 'bg-blue-500 text-white'
                                                        : theme === 'dark' ? 'bg-zinc-700 hover:bg-zinc-600 text-zinc-400' : 'bg-zinc-200 hover:bg-zinc-300 text-zinc-500'}`}
                                                    title={node.settings?.showOutputPreview ? '收起输出预览' : '展开输出预览'}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    <ChevronRight size={12} className={`transition-transform ${node.settings?.showOutputPreview ? 'rotate-90' : ''}`} />
                                                </button>
                                            </div>
                                            {/* V3.7.18: 预览面板标题栏 - 独立区域 */}
                                            {node.settings?.showOutputPreview && (
                                                <div
                                                    className={`shrink-0 flex items-center justify-center gap-2 ml-1 ${theme === 'dark' ? '' : ''}`}
                                                    style={{ width: previewPanelWidth }}
                                                >
                                                {(node.settings?.mode || 'video') === 'image' ? (
                                                    <>
                                                        {/* 图片模式: 两个按钮 */}
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                const shots = node.settings?.shots || [];
                                                                const allEnabled = shots.length > 0 && shots.every(s => s.outputEnabled);
                                                                updateNodeSettings(node.id, { shots: shots.map(s => ({ ...s, outputEnabled: !allEnabled })) });
                                                            }}
                                                            className={`text-[10px] px-2 py-1 rounded transition-colors whitespace-nowrap ${theme === 'dark' ? 'bg-zinc-700 hover:bg-zinc-600 text-zinc-300' : 'bg-zinc-200 hover:bg-zinc-300 text-zinc-600'}`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                            title={t('全选/取消锁定（灰框勾选的不参与批量生成）')}
                                                        >
                                                            {(node.settings?.shots || []).every(s => s.outputEnabled) ? t('取消') : t('全选')}
                                                        </button>
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                const shots = node.settings?.shots || [];
                                                                const hasSelectable = shots.some(s => (Array.isArray(s.output_images) && s.output_images.length > 0) || s.output_url);
                                                                const anySelected = shots.some(s => s.selectedImageIndex >= 0 && ((Array.isArray(s.output_images) && s.output_images.length > 0) || s.output_url));
                                                                const shouldSelect = hasSelectable && !anySelected;
                                                                updateNodeSettings(node.id, {
                                                                    shots: shots.map(s => ({
                                                                        ...s,
                                                                        selectedImageIndex: s.outputEnabled
                                                                            ? s.selectedImageIndex
                                                                            : (shouldSelect
                                                                                ? (((Array.isArray(s.output_images) && s.output_images.length > 0) || s.output_url)
                                                                                    ? (Number.isInteger(s.selectedImageIndex) && s.selectedImageIndex >= 0 ? s.selectedImageIndex : 0)
                                                                                    : -1)
                                                                                : -1)
                                                                    }))
                                                                });
                                                            }}
                                                            className={`text-[10px] px-2 py-1 rounded transition-colors flex items-center gap-1 whitespace-nowrap ${theme === 'dark' ? 'bg-blue-600 hover:bg-blue-500 text-white' : 'bg-blue-500 hover:bg-blue-400 text-white'}`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                            title={t('暂定=全选输出（选中所有图片），重选=取消全部')}
                                                        >
                                                            <ImageIcon size={10} />
                                                            <span>{(node.settings?.shots || []).some(s => s.selectedImageIndex >= 0) ? t('重选') : t('暂定')}</span>
                                                        </button>
                                                    </>
                                                ) : (
                                                    /* 视频模式: 单个全选按钮 */
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            const shots = node.settings?.shots || [];
                                                            const allEnabled = shots.length > 0 && shots.every(s => s.outputEnabled);
                                                            updateNodeSettings(node.id, { shots: shots.map(s => ({ ...s, outputEnabled: !allEnabled })) });
                                                        }}
                                                        className={`text-[10px] px-2 py-1 rounded transition-colors whitespace-nowrap ${theme === 'dark' ? 'bg-zinc-700 hover:bg-zinc-600 text-zinc-300' : 'bg-zinc-200 hover:bg-zinc-300 text-zinc-600'}`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        title={t('全选/取消锁定')}
                                                    >
                                                        {(node.settings?.shots || []).every(s => s.outputEnabled) ? t('取消') : t('全选')}
                                                    </button>
                                                )}
                                                </div>
                                            )}
                                        </div>
                                    </div>

                                    {/* V3.5.17: Script Splitter Manual Input (Banner removed in V3.5.24) */}
                                    {
                                        node.settings?.scriptExpanded && (
                                            <div className={`border-b shrink-0 p-3 space-y-2 ${theme === 'dark'
                                                ? 'bg-zinc-900/30 border-zinc-800'
                                                : theme === 'solarized'
                                                    ? 'bg-[#fdf6e3] border-[#d7cfb2]'
                                                    : 'bg-zinc-50/50 border-zinc-200'
                                                }`}>
                                                <textarea
                                                    value={node.settings?.scriptText || ''}
                                                    onChange={(e) => updateNodeSettings(node.id, { scriptText: e.target.value })}
                                                    placeholder={t('格式: #1 第一个镜头描述 #2 第二个镜头描述 ...')}
                                                    className={`w-full h-24 p-2 text-xs rounded border resize-none overflow-y-auto custom-scrollbar ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'}`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    onWheel={(e) => { e.stopPropagation(); }}
                                                />
                                                <div className="flex gap-2 flex-wrap">
                                                    <button
                                                        onClick={() => {
                                                            // V3.5.17 fix: Use getConnectedTextNodes helper
                                                            const connectedTexts = getConnectedTextNodes(node.id);
                                                            const connectedText = connectedTexts.join('\n');
                                                            const internalText = node.settings?.scriptText || '';
                                                            const text = connectedText || internalText;
                                                            const mode = node.settings?.mode || 'video';
                                                            const defaultModel = mode === 'image'
                                                                ? resolveModelKey(localStorage.getItem('tapnow_last_image_model') || apiConfigs.find(c => isImageModelType(c.type))?.id || '')
                                                                : resolveModelKey(localStorage.getItem('tapnow_last_video_model') || apiConfigs.find(c => c.type === 'Video')?.id || '');
                                                            const defaultRatio = mode === 'image' ? '1:1' : '16:9';
                                                            const defaultDuration = mode === 'video' ? getDefaultDurationForModel(defaultModel) : undefined;

                                                            const matches = [];
                                                            // Enhanced split pattern: #1, 【1】, or 1.
                                                            const combinedPattern = /#\s*(\d+)\s*([^#【]*)|【\s*(\d+)\s*】\s*([^#【]*)/g;
                                                            let m;
                                                            while ((m = combinedPattern.exec(text)) !== null) {
                                                                const num = parseInt(m[1] || m[3]);
                                                                const content = (m[2] || m[4] || '').trim();
                                                                if (content) {
                                                                    matches.push({ num, text: content });
                                                                }
                                                            }

                                                            // If still empty, try numeric prefix 1. 2. 
                                                            if (matches.length === 0) {
                                                                const lines = text.split('\n').filter(l => l.trim());
                                                                lines.forEach((line, i) => {
                                                                    const numMatch = line.match(/^(\d+)[.、\s]+(.*)/);
                                                                    if (numMatch) {
                                                                        matches.push({ num: parseInt(numMatch[1]), text: numMatch[2].trim() });
                                                                    } else {
                                                                        matches.push({ num: i + 1, text: line.trim() });
                                                                    }
                                                                });
                                                            }

                                                            if (matches.length === 0) {
                                                                alert(t('未检测到有效分镜。请使用格式: #1 描述 #2 描述'));
                                                                return;
                                                            }

                                                            // Sort by number and create shots
                                                            matches.sort((a, b) => a.num - b.num);

                                                            // V3.5.19: Smart Merge Logic (Update existing shots if possible)
                                                            const existingShots = node.settings?.shots || [];
                                                            const mergedShots = [...existingShots];

                                                            matches.forEach((m, i) => {
                                                                if (i < existingShots.length) {
                                                                    // Update existing shot (Text only)
                                                                    mergedShots[i] = {
                                                                        ...mergedShots[i],
                                                                        prompt: m.text,
                                                                        description: m.text
                                                                    };
                                                                } else {
                                                                    // Create new shot
                                                                    mergedShots.push({
                                                                        id: Date.now() + Math.random() + i,
                                                                        prompt: m.text,
                                                                        description: m.text,
                                                                        model: defaultModel,
                                                                        ratio: defaultRatio,
                                                                        duration: defaultDuration,
                                                                        status: 'draft',
                                                                        outputEnabled: false,
                                                                        selectedImageIndex: -1
                                                                    });
                                                                }
                                                            });

                                                            updateNodeSettings(node.id, {
                                                                shots: mergedShots,
                                                                scriptExpanded: false // Collapse after split
                                                            });
                                                        }}
                                                        className="px-3 py-1.5 text-xs bg-purple-600 text-white rounded hover:bg-purple-500 transition-colors"
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        {t('程序拆分')}
                                                    </button>
                                                    {/* V3.7.25: LLM 智能拆分按钮 */}
                                                    <button
                                                        onClick={async () => {
                                                            const scriptText = node.settings?.scriptText || '';
                                                            if (!scriptText.trim()) {
                                                                updateNodeSettings(node.id, { errorMsg: '请先输入分镜脚本' });
                                                                return;
                                                            }
                                                            const currentShots = node.settings?.shots || [];
                                                            if (currentShots.length > 0) {
                                                                const choice = window.confirm('当前已有镜头内容，是否覆盖？\n点击"确定"覆盖，点击"取消"追加到末尾');
                                                                // choice: true=覆盖, false=追加
                                                                if (!choice) {
                                                                    // 追加模式将在下面处理
                                                                }
                                                            }
                                                            const { key: apiKey, url: baseUrl } = getApiCredentials(chatModel);
                                                            if (!apiKey) {
                                                                updateNodeSettings(node.id, { errorMsg: '请配置 Chat 模型 Key' });
                                                                return;
                                                            }
                                                            try {
                                                                saveToUndoStack();
                                                                updateNodeSettings(node.id, { isGenerating: true, errorMsg: '' });
                                                                const systemPrompt = node.settings?.llmSplitPrompt || `你是一个分镜脚本分析专家。请将用户提供的脚本按镜头拆分，每个镜头生成一个简洁的画面描述提示词。
输出格式为 JSON 数组: [{"prompt": "镜头1的画面描述"}, {"prompt": "镜头2的画面描述"}, ...]
只输出 JSON，不要其他内容。`;
                                                                const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                                                                    method: 'POST',
                                                                    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
                                                                    body: JSON.stringify({
                                                                        model: chatModel,
                                                                        messages: [
                                                                            { role: 'system', content: systemPrompt },
                                                                            { role: 'user', content: scriptText }
                                                                        ],
                                                                        stream: false
                                                                    })
                                                                });
                                                                const data = await response.json();
                                                                const content = data.choices?.[0]?.message?.content || '';
                                                                const jsonMatch = content.match(/\[[\s\S]*\]/);
                                                                if (jsonMatch) {
                                                                    const shots = JSON.parse(jsonMatch[0]);
                                                                    // V3.7.27: 获取当前模式的默认模型
                                                                    const mode = node.settings?.mode || 'video';
                                                                    const defaultModel = mode === 'image'
                                                                        ? resolveModelKey(localStorage.getItem('tapnow_last_image_model') || apiConfigs.find(c => isImageModelType(c.type))?.id || '')
                                                                        : resolveModelKey(localStorage.getItem('tapnow_last_video_model') || apiConfigs.find(c => c.type === 'Video')?.id || '');
                                                                    const defaultRatio = mode === 'image' ? '1:1' : '16:9';
                                                                    const defaultDuration = mode === 'video' ? getDefaultDurationForModel(defaultModel) : undefined;

                                                                    const newShots = shots.map((s, i) => ({
                                                                        id: `shot-${Date.now()}-${i}`,
                                                                        scene_index: i + 1,
                                                                        prompt: s.prompt || s.description || '',
                                                                        description: s.description || s.prompt || '',
                                                                        image_url: '',
                                                                        video_url: '',
                                                                        output_url: '',
                                                                        model: defaultModel,  // V3.7.27: 明确设置模型
                                                                        ratio: defaultRatio,
                                                                        duration: defaultDuration,
                                                                        status: 'draft',      // V3.7.27: 明确设置状态
                                                                        outputEnabled: false, // V3.7.27: 默认不锁定
                                                                        selectedImageIndex: -1
                                                                    }));
                                                                    // 根据用户选择决定是覆盖还是追加
                                                                    const existingShots = node.settings?.shots || [];
                                                                    const shouldAppend = existingShots.length > 0 && !window.lastLlmSplitOverwrite;
                                                                    const finalShots = shouldAppend ? [...existingShots, ...newShots] : newShots;
                                                                    updateNodeSettings(node.id, { shots: finalShots, scriptExpanded: false, isGenerating: false });
                                                                } else {
                                                                    throw new Error('AI 返回格式不正确');
                                                                }
                                                            } catch (err) {
                                                                console.error('[LLM Split] Error:', err);
                                                                updateNodeSettings(node.id, { isGenerating: false, errorMsg: err.message });
                                                            }
                                                        }}
                                                        className="px-2 py-1.5 text-xs bg-blue-600 text-white rounded hover:bg-blue-500 transition-colors flex items-center gap-1"
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        disabled={node.settings?.isGenerating}
                                                        title={t('使用 AI 智能拆分脚本')}
                                                    >
                                                        <Sparkles size={12} />
                                                        {node.settings?.isGenerating ? '拆分中...' : 'LLM拆分'}
                                                    </button>
                                                    {/* V3.7.25: 自定义 prompt 展开按钮 */}
                                                    <button
                                                        onClick={() => updateNodeSettings(node.id, { showLlmPromptEditor: !node.settings?.showLlmPromptEditor })}
                                                        className={`p-1.5 text-xs rounded transition-colors ${node.settings?.showLlmPromptEditor
                                                            ? 'bg-blue-500 text-white'
                                                            : theme === 'dark' ? 'bg-zinc-700 hover:bg-zinc-600 text-zinc-300' : 'bg-zinc-200 hover:bg-zinc-300 text-zinc-700'}`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        title={t('自定义 LLM 拆分 Prompt')}
                                                    >
                                                        <Edit3 size={12} />
                                                    </button>
                                                    {/* V3.7.25: 说明文字（隐藏时显示） */}
                                                    {!node.settings?.showLlmPromptEditor && (
                                                        <div className={`flex flex-col text-[10px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                            <span>{t('程序拆分: #1 #2 或换行')}</span>
                                                            <span>{t('LLM拆分: 左下角聊天窗口模型')}</span>
                                                        </div>
                                                    )}
                                                </div>
                                                {/* V3.7.25: 自定义 LLM Prompt 展开输入框 */}
                                                {node.settings?.showLlmPromptEditor && (
                                                    <div className="flex items-start gap-2 mt-2">
                                                        <span className={`text-[10px] shrink-0 pt-1 ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>
                                                            LLM Prompt:
                                                        </span>
                                                        <textarea
                                                            value={node.settings?.llmSplitPrompt || `你是一个分镜脚本分析专家。请将用户提供的脚本按镜头拆分，每个镜头生成一个简洁的画面描述提示词。
输出格式为 JSON 数组: [{"prompt": "镜头1的画面描述"}, {"prompt": "镜头2的画面描述"}, ...]
只输出 JSON，不要其他内容。`}
                                                            onChange={(e) => updateNodeSettings(node.id, { llmSplitPrompt: e.target.value })}
                                                            className={`flex-1 text-xs p-2 rounded resize-none overflow-y-auto custom-scrollbar ${theme === 'dark'
                                                                ? 'bg-zinc-800 text-zinc-200 border-zinc-700'
                                                                : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800 border-[#eee8d5]' : 'bg-white text-zinc-800 border-zinc-300'} border`}
                                                            rows={3}
                                                            placeholder={t('输入自定义 LLM 拆分 Prompt...')}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                            onClick={(e) => e.stopPropagation()}
                                                            onKeyDown={(e) => e.stopPropagation()}
                                                            onWheel={(e) => { e.stopPropagation(); }}
                                                        />
                                                    </div>
                                                )}
                                            </div>
                                        )
                                    }



                                    {/* List */}
                                    <div
                                        className={`flex-1 overflow-y-auto custom-scrollbar p-3 space-y-3 min-h-0 bg-opacity-50 ${theme === 'solarized' ? 'bg-[#fdf6e3]' : ''}`}
                                        onWheel={(e) => {
                                            e.stopPropagation();
                                        }}
                                    >
                                        {node.settings?.shots?.length > 0 ? (
                                            node.settings.shots.map((shot, idx) => {
                                                const isActiveShot = activeShot?.nodeId === node.id && activeShot?.shotId === shot.id;
                                                return (
                                                    <React.Fragment key={shot.id}>
                                                        {/* V3.5.20: Insert Shot Zone (T-junction) */}
                                                        <div
                                                            className="relative h-2 -mt-1 -mb-1 z-10 group/insert flex items-center justify-center cursor-pointer hover:h-6 transition-all"
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                const newShots = [...(node.settings.shots || [])];
                                                                newShots.splice(idx, 0, {
                                                                    id: Date.now() + Math.random(),
                                                                    prompt: '',
                                                                    description: '',
                                                                    model: resolveModelKey(localStorage.getItem('tapnow_last_video_model') || ''),
                                                                    duration: 5,
                                                                    status: 'draft',
                                                                    outputEnabled: false,
                                                                    selectedImageIndex: -1
                                                                });
                                                                updateNodeSettings(node.id, { shots: newShots });
                                                            }}
                                                            title={t('在此处插入新镜头')}
                                                        >
                                                            <div className="w-full h-[2px] bg-blue-500 opacity-0 group-hover/insert:opacity-100 transition-opacity" />
                                                            <div className="absolute w-5 h-5 rounded-full bg-blue-600 text-white flex items-center justify-center opacity-0 group-hover/insert:opacity-100 transition-opacity shadow-sm scale-75 group-hover/insert:scale-100">
                                                                <Plus size={12} />
                                                            </div>
                                                        </div>

                                                        <div className="flex items-stretch gap-2 w-full">
                                                            <div
                                                                // key={shot.id} // moved to Fragment
                                                                tabIndex={0} // 允许聚焦以响应键盘事件
                                                                onClick={(e) => {
                                                                    e.stopPropagation(); // 防止触发节点选择
                                                                    setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                    e.currentTarget.focus(); // 关键：点击行即聚焦，激活粘贴
                                                                }}
                                                                onPaste={(e) => handleShotPaste(e, shot.id)} // 关键：在行级别监听粘贴
                                                                className={`relative flex-1 flex gap-3 p-3 rounded-lg border transition-all group/shot cursor-pointer outline-none focus:ring-2 focus:ring-blue-500/50 ${isActiveShot
                                                                    ? 'border-blue-500 ring-1 ring-blue-500 bg-blue-500/5 z-10'
                                                                    : theme === 'dark'
                                                                        ? 'bg-zinc-900/50 border-zinc-800 hover:border-zinc-600'
                                                                        : theme === 'solarized'
                                                                            ? 'bg-[#fdf6e3] border-[#eee8d5] hover:border-[#d7cfb2]'
                                                                            : 'bg-white border-zinc-200 hover:border-blue-300 hover:shadow-md'
                                                                    }`}
                                                            >
                                                                {/* Index */}
                                                                <div className={`font-mono text-sm w-6 shrink-0 flex items-start pt-1 font-bold ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'}`}>{idx + 1}</div>

                                                                {/* V3.7.4: Input Preview (Horizontal Video Split, Import Fix) */}
                                                                {/* V3.7.5: Container width increased to support horizontal layout better */}
                                                                <div
                                                                    className="flex flex-col gap-2 shrink-0 mr-2 h-full min-h-[14rem] w-52"
                                                                    onDragOver={(e) => {
                                                                        e.preventDefault();
                                                                    }}
                                                                    onDrop={(e) => handleShotDrop(e, shot.id)}
                                                                >
                                                                    {(() => {
                                                                        const mode = node.settings?.mode || 'video';
                                                                        const isVideo = mode === 'video';
                                                                        const supportsFirstLastFrame = !!getApiConfigByKey(shot.model)?.supportsFirstLastFrame;
                                                                        const showLastFrame = supportsFirstLastFrame && shot.useFirstLastFrame;
                                                                        const activeInput = shot.activeInput || 'first';
                                                                        const showMultiRef = shot.useMultiRef; // Toggle State

                                                                        const borderColor = theme === 'dark'
                                                                            ? 'border-zinc-800'
                                                                            : theme === 'solarized'
                                                                                ? 'border-[#eee8d5]'
                                                                                : 'border-zinc-300';
                                                                        const bgColor = theme === 'dark'
                                                                            ? 'bg-black'
                                                                            : theme === 'solarized'
                                                                                ? 'bg-[#fdf6e3]'
                                                                                : 'bg-zinc-50';



                                                                        const handleUpload = (e, field) => {
                                                                            const file = e.target.files?.[0];
                                                                            if (!file) return;
                                                                            const reader = new FileReader();
                                                                            reader.onload = (ev) => {
                                                                                updateShot(node.id, shot.id, { [field]: ev.target.result });
                                                                            };
                                                                            reader.readAsDataURL(file);
                                                                            e.target.value = '';
                                                                        };

                                                                        // VIDEO MODE RENDER (Horizontal Split)
                                                                        if (isVideo) {
                                                                            const renderVideoCard = (type, isMain) => {
                                                                                const field = type === 'first' ? 'image_url' : 'lastFrame';
                                                                                const imgUrl = shot[field];
                                                                                const label = type === 'first' ? t('首帧') : t('尾帧');
                                                                                // V3.7.5: H-Split Logic: Main = flex-1 (wider), Sub = w-14 (narrower)
                                                                                const sizeClass = isMain ? 'flex-1 h-full' : 'w-14 h-full shrink-0';

                                                                                return (
                                                                                    <div key={type} className={`relative rounded-lg border overflow-hidden group ${sizeClass} ${bgColor} ${borderColor} flex flex-col items-center justify-center cursor-pointer hover:border-blue-500 transition-all`} onClick={(e) => { e.stopPropagation(); if (!isMain) updateShot(node.id, shot.id, { activeInput: type }); }}>
                                                                                        {imgUrl ? <LazyBase64Image src={imgUrl} className={`w-full h-full object-cover ${!isMain ? 'opacity-60 hover:opacity-100' : ''}`} /> : <div className="flex flex-col items-center gap-1 text-zinc-500"><FolderOpen size={isMain ? 20 : 14} />{isMain && <span className="text-[10px]">选择{label}</span>}</div>}
                                                                                        <div className="absolute top-0 left-0 bg-black/60 text-white text-[9px] px-1.5 py-0.5 rounded-br z-20 backdrop-blur-md pointer-events-none">{label}</div>

                                                                                        {/* V3.7.5: Restore Preview (Maximize) Button */}
                                                                                        {imgUrl && (
                                                                                            <button
                                                                                                onClick={(e) => { e.stopPropagation(); setLightboxItem({ url: imgUrl, type: 'image' }); }}
                                                                                                className="absolute bottom-1 left-1 p-1 rounded-full bg-black/60 text-white hover:bg-blue-500 opacity-0 group-hover:opacity-100 transition-opacity z-30"
                                                                                                title={t('预览图片')}
                                                                                            >
                                                                                                <Maximize2 size={10} />
                                                                                            </button>
                                                                                        )}

                                                                                        {isMain && (
                                                                                            <>
                                                                                                {imgUrl && <button onClick={(e) => { e.stopPropagation(); updateShot(node.id, shot.id, { [field]: '' }); }} className="absolute top-1 right-1 p-1 rounded-full bg-black/60 text-white hover:bg-red-500 opacity-0 group-hover:opacity-100 transition-opacity z-30"><X size={12} /></button>}
                                                                                                <label className="absolute inset-0 z-10 flex items-center justify-center cursor-pointer opacity-0 hover:opacity-100">
                                                                                                    <input type="file" className="hidden" accept="image/*" onChange={(e) => handleUpload(e, field)} />
                                                                                                    <div className="p-2 rounded-full bg-black/50 text-white"><FolderOpen size={16} /></div>
                                                                                                </label>
                                                                                                {/* Split mode toggle - V3.7.13: 放到右下角 */}
                                                                                                {supportsFirstLastFrame && (
                                                                                                    <div className="absolute bottom-1 right-1 p-1 rounded bg-black/40 hover:bg-blue-500 text-white transition-colors cursor-pointer z-30" onClick={(e) => { e.stopPropagation(); updateShot(node.id, shot.id, { useFirstLastFrame: !showLastFrame, activeInput: !showLastFrame ? 'last' : 'first' }); }} title="切换首尾帧模式">
                                                                                                        <Split size={12} />
                                                                                                    </div>
                                                                                                )}
                                                                                                {/* V3.7.13: 文件名只在该帧有图片时显示 */}
                                                                                                {imgUrl && shot.image_filename && (
                                                                                                    <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-[9px] pl-8 pr-8 py-0.5 truncate opacity-0 group-hover:opacity-100 transition-opacity z-20" title={shot.image_filename}>
                                                                                                        {shot.image_filename}
                                                                                                    </div>
                                                                                                )}
                                                                                            </>
                                                                                        )}
                                                                                    </div>
                                                                                );
                                                                            };

                                                                            if (!showLastFrame) return renderVideoCard('first', true);

                                                                            // Stable Horizontal Layout: First (Left) | Last (Right)
                                                                            return (
                                                                                <div className="flex flex-row gap-2 h-full w-full">
                                                                                    {renderVideoCard('first', activeInput === 'first')}
                                                                                    {renderVideoCard('last', activeInput === 'last')}
                                                                                </div>
                                                                            );

                                                                        } else {
                                                                            // V3.7.11: IMAGE MODE - 左侧只显示输入图片！
                                                                            // 输入图片: referenceImages 或 image_url
                                                                            // 输出图片(output_images)只在右侧预览面板显示
                                                                            const inputImages = shot.referenceImages && shot.referenceImages.length > 0
                                                                                ? shot.referenceImages
                                                                                : (shot.image_url ? [shot.image_url] : []);
                                                                            const mainInputImg = inputImages[0] || '';

                                                                            return (
                                                                                <div className="flex flex-col gap-2 h-full w-full">
                                                                                    {/* 主图容器 - 只显示输入图片 */}
                                                                                    <div className={`relative flex-1 rounded-lg border overflow-hidden group ${bgColor} ${borderColor} flex flex-col items-center justify-center`}>
                                                                                        {mainInputImg ? (
                                                                                            <>
                                                                                                <LazyBase64Image src={mainInputImg} className="w-full h-full object-cover" />
                                                                                                <button
                                                                                                    onClick={(e) => { e.stopPropagation(); setLightboxItem({ url: mainInputImg, type: 'image' }); }}
                                                                                                    className="absolute bottom-1 left-1 p-1 rounded-full bg-black/60 text-white hover:bg-blue-500 opacity-0 group-hover:opacity-100 transition-opacity z-30"
                                                                                                    title={t('预览原图')}
                                                                                                >
                                                                                                    <Maximize2 size={12} />
                                                                                                </button>
                                                                                                {/* V3.7.11: 文件名显示 */}
                                                                                                {shot.image_filename && (
                                                                                                    <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-[9px] px-8 py-0.5 truncate opacity-0 group-hover:opacity-100 transition-opacity z-20" title={shot.image_filename}>
                                                                                                        {shot.image_filename}
                                                                                                    </div>
                                                                                                )}
                                                                                                {/* 删除按钮 */}
                                                                                                <button onClick={(e) => { e.stopPropagation(); updateShot(node.id, shot.id, { image_url: '', image_filename: '', referenceImages: [] }); }} className="absolute top-1 right-1 p-1 rounded-full bg-black/60 text-white hover:bg-red-500 opacity-0 group-hover:opacity-100 transition-opacity z-30" title={t('删除')}><X size={12} /></button>
                                                                                            </>
                                                                                        ) : (
                                                                                            <div className="flex flex-col items-center gap-1 text-zinc-500">
                                                                                                <FolderOpen size={20} />
                                                                                                <span className="text-[10px]">{t('选择图片')}</span>
                                                                                            </div>
                                                                                        )}
                                                                                        {/* 上传覆盖层 */}
                                                                                        <label className={`absolute inset-0 z-10 flex items-center justify-center cursor-pointer ${mainInputImg ? 'opacity-0 hover:opacity-100' : 'opacity-100'}`}>
                                                                                            <input type="file" className="hidden" accept="image/*" onChange={(e) => {
                                                                                                const f = e.target.files?.[0];
                                                                                                if (f) {
                                                                                                    const r = new FileReader();
                                                                                                    r.onload = (v) => {
                                                                                                        updateShot(node.id, shot.id, { image_url: v.target.result, image_filename: f.name });
                                                                                                    };
                                                                                                    r.readAsDataURL(f);
                                                                                                }
                                                                                            }} />
                                                                                            {mainInputImg && <div className="p-2 rounded-full bg-black/50 text-white"><FolderOpen size={16} /></div>}
                                                                                        </label>
                                                                                        {/* V3.7.11: 多图参考开关按钮 */}
                                                                                        <div
                                                                                            className={`absolute bottom-1 right-1 p-1 rounded bg-black/40 hover:bg-blue-500 text-white transition-colors cursor-pointer z-30 ${showMultiRef ? 'text-blue-400 bg-blue-500/30' : 'text-zinc-400'}`}
                                                                                            onClick={(e) => { e.stopPropagation(); updateShot(node.id, shot.id, { useMultiRef: !showMultiRef }); }}
                                                                                            title={t('多图参考开关')}
                                                                                        >
                                                                                            <LayoutGrid size={12} />
                                                                                        </div>
                                                                                    </div>

                                                                                    {/* V3.7.11: 多图参考缩略图行 */}
                                                                                    {showMultiRef && (
                                                                                        <div className="flex gap-2 h-14 shrink-0 overflow-x-auto no-scrollbar items-center">
                                                                                            {inputImages.slice(1).map((img, idx) => (
                                                                                                <div
                                                                                                    key={idx + 1}
                                                                                                    className={`relative w-12 h-14 shrink-0 rounded border overflow-hidden cursor-pointer hover:border-blue-500 transition-all ${borderColor} ${bgColor}`}
                                                                                                    onClick={(e) => {
                                                                                                        e.stopPropagation();
                                                                                                        // 点击缩略图切换为主图
                                                                                                        const newRefs = [...inputImages];
                                                                                                        const clickedIdx = idx + 1;
                                                                                                        [newRefs[0], newRefs[clickedIdx]] = [newRefs[clickedIdx], newRefs[0]];
                                                                                                        updateShot(node.id, shot.id, { referenceImages: newRefs, image_url: newRefs[0] });
                                                                                                    }}
                                                                                                >
                                                                                                    <LazyBase64Image src={img} className="w-full h-full object-cover" />
                                                                                                    <div className="absolute top-0 left-0 bg-black/50 text-white text-[8px] px-1 backdrop-blur-sm">{idx + 2}</div>
                                                                                                </div>
                                                                                            ))}
                                                                                            {inputImages.length < 5 && (
                                                                                                <label className={`w-12 h-14 shrink-0 rounded border border-dashed flex items-center justify-center cursor-pointer hover:bg-zinc-100 dark:hover:bg-zinc-800 ${borderColor} text-zinc-400 hover:text-blue-500 hover:border-blue-500 transition-colors`}>
                                                                                                    <Plus size={16} />
                                                                                                    <input type="file" className="hidden" accept="image/*" onChange={(e) => {
                                                                                                        const f = e.target.files?.[0];
                                                                                                        if (f) {
                                                                                                            const r = new FileReader();
                                                                                                            r.onload = (v) => {
                                                                                                                updateShot(node.id, shot.id, { referenceImages: [...inputImages, v.target.result] });
                                                                                                            };
                                                                                                            r.readAsDataURL(f);
                                                                                                        }
                                                                                                    }} />
                                                                                                </label>
                                                                                            )}
                                                                                        </div>
                                                                                    )}
                                                                                </div>
                                                                            );
                                                                        }
                                                                    })()}
                                                                </div>

                                                                {/* Content */}
                                                                <div className="flex-1 min-w-0 flex flex-col gap-2">
                                                                    {/* Control Bar: Model, Ratio, Duration */}
                                                                    <div className="flex gap-2 items-center flex-wrap">
                                                                        {/* Video Model Select - V3.4.11: 双层 Provider -> Model 选择器 */}
                                                                        <div className="relative">
                                                                            <button
                                                                                onClick={(e) => {
                                                                                    e.stopPropagation();
                                                                                    setActiveDropdown(activeDropdown?.nodeId === node.id && activeDropdown.type === 'shot-model' && activeDropdown.shotId === shot.id
                                                                                        ? null
                                                                                        : { nodeId: node.id, type: 'shot-model', shotId: shot.id });
                                                                                }}
                                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                                className={`flex items-center justify-between gap-1 px-2 py-1 rounded border text-xs transition-colors min-w-[100px] ${theme === 'dark'
                                                                                    ? 'bg-zinc-800 border-zinc-700 text-zinc-200 hover:border-zinc-600'
                                                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                                    }`}
                                                                            >
                                                                                <span className="truncate font-mono text-[10px]">
                                                                                    {(() => {
                                                                                        const mode = node.settings?.mode || 'video';
                                                                                        const lastModelKey = mode === 'image' ? 'tapnow_last_image_model' : 'tapnow_last_video_model';
                                                                                        // V3.7.29: 只显示 shot.model，不 fallback 到 localStorage（避免假联动）
                                                                                        return getApiConfigByKey(shot.model)?.id || shot.model || '选择模型';
                                                                                    })()}
                                                                                </span>
                                                                                <ChevronDown size={10} className="opacity-50 shrink-0" />
                                                                            </button>
                                                                            {activeDropdown?.nodeId === node.id && activeDropdown.type === 'shot-model' && activeDropdown.shotId === shot.id && (
                                                                                <div
                                                                                    className={`absolute top-full left-0 mt-1 w-64 rounded-lg shadow-xl p-1 z-[60] border flex ${theme === 'dark'
                                                                                        ? 'bg-[#18181b] border-zinc-700'
                                                                                        : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                                        }`}
                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                    onMouseLeave={() => setHoveredProvider(null)}
                                                                                >
                                                                                    {/* Provider 列表 */}
                                                                                    <div className={`w-24 border-r pr-1 max-h-80 overflow-y-auto custom-scrollbar ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-200'}`}>
                                                                                        {(() => {
                                                                                            const mode = node.settings?.mode || 'video';
                                                                                            const isImageMode = mode === 'image';
                                                                                            return Object.entries(groupedApiConfigs)
                                                                                                .filter(([, group]) => group.models.some(m => (isImageMode ? isImageModelType(m.type) : m.type === 'Video')))
                                                                                                .map(([providerKey, group]) => (
                                                                                                    <button
                                                                                                        key={providerKey}
                                                                                                        onMouseEnter={() => setHoveredProvider(providerKey)}
                                                                                                        className={`w-full text-left px-2 py-1.5 text-[10px] rounded transition-colors ${hoveredProvider === providerKey
                                                                                                            ? theme === 'dark' ? 'bg-zinc-800 text-white' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-zinc-100 text-zinc-900'
                                                                                                            : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : theme === 'solarized' ? 'text-zinc-600 hover:text-zinc-700' : 'text-zinc-600 hover:text-zinc-800'
                                                                                                            }`}
                                                                                                    >
                                                                                                        {group.name || providerKey}
                                                                                                    </button>
                                                                                                ));
                                                                                        })()}
                                                                                    </div>
                                                                                    {/* Model 列表 */}
                                                                                    <div className="flex-1 pl-1 max-h-80 overflow-y-auto custom-scrollbar">
                                                                                        {(() => {
                                                                                            const mode = node.settings?.mode || 'video';
                                                                                            const isImageMode = mode === 'image';
                                                                                            return hoveredProvider && groupedApiConfigs[hoveredProvider]?.models
                                                                                                .filter(m => (isImageMode ? isImageModelType(m.type) : m.type === 'Video'))
                                                                                                .map((m) => {
                                                                                                    const modelKey = m._uid || m.id;
                                                                                                    const currentModelKey = resolveModelKey(shot.model);
                                                                                                    return (
                                                                                                        <button
                                                                                                            key={modelKey}
                                                                                                            onClick={() => {
                                                                                                                const mode = node.settings?.mode || 'video';
                                                                                                                const defaultDuration = getDefaultDurationForModel(modelKey);
                                                                                                                updateShot(node.id, shot.id, {
                                                                                                                    model: modelKey,
                                                                                                                    duration: shot.duration || defaultDuration
                                                                                                                });
                                                                                                                // V3.6.0.fuckedup: 根据模式保存最后使用的模型
                                                                                                                const lastModelKey = mode === 'image' ? 'tapnow_last_image_model' : 'tapnow_last_video_model';
                                                                                                                localStorage.setItem(lastModelKey, modelKey);
                                                                                                                // 同步到 state
                                                                                                                if (mode === 'image') {
                                                                                                                    setLastUsedImageModel(modelKey);
                                                                                                                } else {
                                                                                                                    setLastUsedVideoModel(modelKey);
                                                                                                                }
                                                                                                                setActiveDropdown(null);
                                                                                                                setHoveredProvider(null);
                                                                                                            }}
                                                                                                            className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${currentModelKey === modelKey
                                                                                                                ? theme === 'dark' ? 'bg-blue-600/30 text-blue-300' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-blue-100 text-blue-700'
                                                                                                                : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-300' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'
                                                                                                                }`}
                                                                                                        >
                                                                                                            <span className="text-[10px] font-medium truncate font-mono">{m.id}</span>
                                                                                                            <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(modelKey)}`}></div>
                                                                                                        </button>
                                                                                                    );
                                                                                                });
                                                                                        })()}
                                                                                        {!hoveredProvider && (
                                                                                            <div className={`text-[10px] px-2 py-3 text-center ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                                                                ← 选择 Provider
                                                                                            </div>
                                                                                        )}
                                                                                    </div>
                                                                                </div>
                                                                            )}
                                                                        </div>

                                                                        {/* Ratio Select - V3.6.1 动态适配模式 */}
                                                                        {(() => {
                                                                            const mode = node.settings?.mode || 'video';
                                                                            const ratioOptions = mode === 'video'
                                                                                ? getRatiosForModel(shot.model)
                                                                                : RATIOS;
                                                                            const ratioConfig = getApiConfigByKey(shot.model);
                                                                            return (
                                                                                <select
                                                                                    value={shot.ratio || (mode === 'video' ? '16:9' : '1:1')}
                                                                                    onChange={(e) => updateShot(node.id, shot.id, { ratio: e.target.value })}
                                                                                    onClick={(e) => e.stopPropagation()}
                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                    className={`text-xs px-2 py-1 rounded border outline-none transition-colors ${theme === 'dark'
                                                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-200 hover:border-zinc-600'
                                                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                                        }`}
                                                                                >
                                                                                    {ratioOptions.map(ratio => (
                                                                                        <option key={ratio} value={ratio}>
                                                                                            {ratio === 'Auto'
                                                                                                ? 'Auto'
                                                                                                : getValueLabelWithNotes(ratio, !!ratioConfig?.ratioNotesEnabled, ratioConfig?.ratioNotes || {})}
                                                                                        </option>
                                                                                    ))}
                                                                                </select>
                                                                            );
                                                                        })()}

                                                                        {/* Resolution Select - V3.6.1 视频模式显示720p/1080p，图片模式显示Auto/1K/2K/4K */}
                                                                        {(() => {
                                                                            const mode = node.settings?.mode || 'video';
                                                                            if (mode === 'video') {
                                                                                const resOptions = getVideoResolutionsForModel(shot.model);
                                                                                if (!resOptions.length) return null;
                                                                                const resConfig = getApiConfigByKey(shot.model);
                                                                                const currentRes = normalizeVideoResolution(shot.resolution || resOptions[0] || '720P');
                                                                                const fallbackRes = resOptions[0] || '720P';
                                                                                const resolvedRes = resOptions.includes(currentRes) ? currentRes : fallbackRes;
                                                                                if (resolvedRes !== currentRes) {
                                                                                    setTimeout(() => updateShot(node.id, shot.id, { resolution: resolvedRes }), 0);
                                                                                }
                                                                                return (
                                                                                    <select
                                                                                        value={resolvedRes}
                                                                                        onChange={(e) => updateShot(node.id, shot.id, { resolution: e.target.value })}
                                                                                        onClick={(e) => e.stopPropagation()}
                                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                                        className={`text-xs px-2 py-1 rounded border outline-none transition-colors ${theme === 'dark'
                                                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-200 hover:border-zinc-600'
                                                                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                                            }`}
                                                                                        title={t('分辨率')}
                                                                                    >
                                                                                        {resOptions.map((res) => (
                                                                                            <option key={res} value={res}>
                                                                                                {getValueLabelWithNotes(res, !!resConfig?.videoResolutionNotesEnabled, resConfig?.videoResolutionNotes || {})}
                                                                                            </option>
                                                                                        ))}
                                                                                    </select>
                                                                                );
                                                                            } else {
                                                                                // 图片模式：显示Auto/1K/2K/4K
                                                                                const resOptions = getResolutionsForModel(shot.model);
                                                                                const resConfig = getApiConfigByKey(shot.model);
                                                                                const currentRes = normalizeImageResolution(shot.resolution || '2K');
                                                                                const fallbackRes = resOptions[0] || '2K';
                                                                                const resolvedRes = resOptions.includes(currentRes) ? currentRes : fallbackRes;
                                                                                if (resolvedRes !== currentRes) {
                                                                                    setTimeout(() => updateShot(node.id, shot.id, { resolution: resolvedRes }), 0);
                                                                                }
                                                                                return (
                                                                                    <select
                                                                                        value={resolvedRes}
                                                                                        onChange={(e) => updateShot(node.id, shot.id, { resolution: e.target.value })}
                                                                                        onClick={(e) => e.stopPropagation()}
                                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                                        className={`text-xs px-2 py-1 rounded border outline-none transition-colors ${theme === 'dark'
                                                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-200 hover:border-zinc-600'
                                                                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                                            }`}
                                                                                        title={t('分辨率')}
                                                                                    >
                                                                                        {resOptions.map(res => (
                                                                                            <option key={res} value={res}>
                                                                                                {getValueLabelWithNotes(res, !!resConfig?.resolutionNotesEnabled, resConfig?.resolutionNotes || {})}
                                                                                            </option>
                                                                                        ))}
                                                                                    </select>
                                                                                );
                                                                            }
                                                                        })()}

                                                                        {/* Duration Select - V3.7.18: 只在视频模式显示 */}
                                                                        {(node.settings?.mode || 'video') === 'video' && (() => {
                                                                            const currentModel = shot.model || (apiConfigs.find(c => c.type === 'Video' && c.id === 'sora-2')?.id || apiConfigs.find(c => c.type === 'Video')?.id || '');
                                                                            const config = getApiConfigByKey(currentModel);
                                                                            const availableDurations = config?.durations || getDefaultDurationsForModel(currentModel);
                                                                            const defaultDuration = getDefaultDurationForModel(currentModel);
                                                                            return (
                                                                                <select
                                                                                    value={shot.duration || defaultDuration}
                                                                                    onChange={(e) => updateShot(node.id, shot.id, { duration: e.target.value })}
                                                                                    onClick={(e) => e.stopPropagation()}
                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                className={`text-xs px-2 py-1 rounded border outline-none transition-colors ${theme === 'dark'
                                                                                    ? 'bg-zinc-800 border-zinc-700 text-zinc-200 hover:border-zinc-600'
                                                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 hover:border-[#d7cfb2]' : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                                    }`}
                                                                            >
                                                                                {availableDurations.map(duration => (
                                                                                    <option key={duration} value={duration}>
                                                                                        {getValueLabelWithNotes(duration, !!config?.durationNotesEnabled, config?.durationNotes || {})}
                                                                                    </option>
                                                                                ))}
                                                                            </select>
                                                                        );
                                                                    })()}
                                                                        {(node.settings?.mode || 'video') === 'video' && (() => {
                                                                            const modelId = shot.model || '';
                                                                            const config = getApiConfigByKey(modelId);
                                                                            const supportsFirstLastFrame = !!config?.supportsFirstLastFrame;
                                                                            const supportsHD = !!config?.supportsHD;
                                                                            if (!supportsFirstLastFrame && !supportsHD) return null;
                                                                            return (
                                                                                <div className="flex items-center gap-2">
                                                                                    {supportsFirstLastFrame && (
                                                                                        <label className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border cursor-pointer transition-colors ${theme === 'dark'
                                                                                            ? shot.useFirstLastFrame ? 'bg-emerald-600/25 border-emerald-500 text-emerald-200' : 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                                            : theme === 'solarized'
                                                                                                ? shot.useFirstLastFrame ? 'bg-[#eee8d5] border-[#d7cfb2] text-zinc-800' : 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-700 border-[#d7cfb2]'
                                                                                                : shot.useFirstLastFrame ? 'bg-emerald-500/20 border-emerald-300 text-emerald-700' : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                                                            }`} onClick={e => e.stopPropagation()}>
                                                                                            <input
                                                                                                type="checkbox"
                                                                                                checked={!!shot.useFirstLastFrame}
                                                                                                onChange={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    updateShot(node.id, shot.id, { useFirstLastFrame: e.target.checked });
                                                                                                }}
                                                                                                className="w-3 h-3 cursor-pointer"
                                                                                                onMouseDown={e => e.stopPropagation()}
                                                                                            />
                                                                                            <span>{t('首尾帧')}</span>
                                                                                        </label>
                                                                                    )}
                                                                                    {supportsHD && (
                                                                                        <label className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border cursor-pointer transition-colors ${theme === 'dark'
                                                                                            ? shot.isHD ? 'bg-blue-600/30 border-blue-500 text-blue-300' : 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                                            : theme === 'solarized'
                                                                                                ? shot.isHD ? 'bg-[#eee8d5] border-[#d7cfb2] text-zinc-800' : 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-700 border-[#d7cfb2]'
                                                                                                : shot.isHD ? 'bg-blue-500/30 border-blue-400 text-blue-700' : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                                                            }`} onClick={e => e.stopPropagation()}>
                                                                                            <input
                                                                                                type="checkbox"
                                                                                                checked={!!shot.isHD}
                                                                                                onChange={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    updateShot(node.id, shot.id, { isHD: e.target.checked });
                                                                                                }}
                                                                                                className="w-3 h-3 cursor-pointer"
                                                                                                onMouseDown={e => e.stopPropagation()}
                                                                                            />
                                                                                            <span>HD</span>
                                                                                        </label>
                                                                                    )}
                                                                                </div>
                                                                            );
                                                                        })()}


                                                                    </div>

                                                                    {(() => {
                                                                        const customParamsView = renderCustomParamInputs(
                                                                            shot.model,
                                                                            shot.customParams,
                                                                            (nextParams) => updateShot(node.id, shot.id, { customParams: nextParams })
                                                                        );
                                                                        if (!customParamsView) return null;
                                                                        return (
                                                                            <div className="mt-2" onMouseDown={(e) => e.stopPropagation()}>
                                                                                {customParamsView}
                                                                            </div>
                                                                        );
                                                                    })()}

                                                                    <textarea
                                                                        className={`text-sm outline-none resize-none bg-transparent transition-all ${theme === 'dark'
                                                                            ? 'text-zinc-200 placeholder:text-zinc-700'
                                                                            : 'text-zinc-800 placeholder:text-zinc-400'
                                                                            }`}
                                                                        value={shot.description || ''}
                                                                        placeholder={t('画面描述...')}
                                                                        title={shot.description || ''} /* V3.5.20: Tooltip */
                                                                        onChange={(e) => updateShot(node.id, shot.id, { description: e.target.value })}
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            // 确保点击文本框时也激活卡片
                                                                            if (!isActiveShot) {
                                                                                setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                            }
                                                                        }}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                        onFocus={(e) => {
                                                                            e.stopPropagation();
                                                                            // 确保聚焦时激活卡片
                                                                            if (!isActiveShot) {
                                                                                setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                            }
                                                                        }}
                                                                        onInput={(e) => {
                                                                            // 输入时自动调整高度（仅在激活状态下）
                                                                            if (isActiveShot) {
                                                                                e.currentTarget.style.height = 'auto';
                                                                                e.currentTarget.style.height = e.currentTarget.scrollHeight + 'px';
                                                                            }
                                                                        }}
                                                                        ref={(el) => {
                                                                            // 当卡片激活时，自动调整高度以显示所有内容
                                                                            if (el && isActiveShot) {
                                                                                el.style.height = 'auto';
                                                                                el.style.height = el.scrollHeight + 'px';
                                                                            }
                                                                        }}
                                                                        style={{
                                                                            minHeight: isActiveShot ? '8rem' : '2.5rem',
                                                                            height: isActiveShot ? 'auto' : '2.5rem',
                                                                            transition: 'all 0.2s ease-in-out'
                                                                        }}
                                                                    />
                                                                    <div className={`p-2 rounded text-xs font-mono border transition-all relative ${theme === 'dark'
                                                                        ? 'bg-zinc-950 border-zinc-800 text-zinc-400'
                                                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-600' : 'bg-zinc-50 border-zinc-200 text-zinc-600'
                                                                        }`}
                                                                        style={{
                                                                            minHeight: isActiveShot ? '8rem' : '2rem',
                                                                            transition: 'all 0.2s ease-in-out'
                                                                        }}>
                                                                        <textarea
                                                                            className="w-full bg-transparent outline-none resize-none placeholder:text-opacity-50 transition-all pr-8"
                                                                            value={shot.prompt || ''}
                                                                            placeholder={t('等待生成提示词...')}
                                                                            onChange={(e) => updateShot(node.id, shot.id, { prompt: e.target.value })}
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                // 确保点击文本框时也激活卡片
                                                                                if (!isActiveShot) {
                                                                                    setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                                }
                                                                            }}
                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                            onFocus={(e) => {
                                                                                e.stopPropagation();
                                                                                // 确保聚焦时激活卡片
                                                                                if (!isActiveShot) {
                                                                                    setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                                }
                                                                            }}
                                                                            onInput={(e) => {
                                                                                // 输入时自动调整高度（仅在激活状态下）
                                                                                if (isActiveShot) {
                                                                                    e.currentTarget.style.height = 'auto';
                                                                                    e.currentTarget.style.height = e.currentTarget.scrollHeight + 'px';
                                                                                }
                                                                            }}
                                                                            ref={(el) => {
                                                                                // 当卡片激活时，自动调整高度以显示所有内容
                                                                                if (el && isActiveShot) {
                                                                                    el.style.height = 'auto';
                                                                                    el.style.height = el.scrollHeight + 'px';
                                                                                }
                                                                            }}
                                                                            style={{
                                                                                minHeight: isActiveShot ? '8rem' : '2rem',
                                                                                height: isActiveShot ? 'auto' : '2rem',
                                                                                transition: 'all 0.2s ease-in-out'
                                                                            }}
                                                                        />
                                                                        {(shot.model === 'sora-2' || shot.model === 'sora-2-pro') && characterLibrary.length > 0 && (
                                                                            <button
                                                                                onClick={(e) => {
                                                                                    e.stopPropagation();
                                                                                    setCharactersOpen(true);
                                                                                }}
                                                                                className={`absolute top-2 right-2 p-1 rounded transition-colors ${theme === 'dark'
                                                                                    ? 'text-zinc-500 hover:text-zinc-200 hover:bg-zinc-800'
                                                                                    : 'text-zinc-400 hover:text-zinc-700 hover:bg-zinc-200'
                                                                                    }`}
                                                                                title={t('插入角色')}
                                                                            >
                                                                                <Users size={12} />
                                                                            </button>
                                                                        )}
                                                                    </div>

                                                                    {/* 角色引用栏 (仅 Sora 模型) */}
                                                                    {(() => {
                                                                        const currentModel = shot.model || '';
                                                                        const isSora = currentModel && (currentModel.includes('sora') || currentModel === 'sora-2' || currentModel === 'sora-2-pro');

                                                                        if (!isSora || characterLibrary.length === 0) return null;

                                                                        const currentPrompt = shot.prompt || '';
                                                                        const expandKey = `${node.id}-${shot.id}`;
                                                                        const isExpanded = characterReferenceBarExpanded[expandKey] || false;
                                                                        const maxVisible = 5; // 最多显示5个角色，超过则显示展开按钮
                                                                        const shouldShowExpand = characterLibrary.length > maxVisible;

                                                                        return (
                                                                            <div className="border-t border-dashed mt-1" style={{
                                                                                borderColor: theme === 'dark' ? 'rgba(63, 63, 70, 0.5)' : 'rgba(161, 161, 170, 0.5)'
                                                                            }}>
                                                                                <div className="flex items-center justify-between py-1 px-1">
                                                                                    <div className="flex gap-2 overflow-x-auto py-2 flex-1 custom-scrollbar">
                                                                                        {(isExpanded ? characterLibrary : characterLibrary.slice(0, maxVisible)).map(char => {
                                                                                            const tag = `@${char.username}`;
                                                                                            const isActive = currentPrompt.includes(tag);

                                                                                            return (
                                                                                                <button
                                                                                                    key={char.id}
                                                                                                    onClick={(e) => {
                                                                                                        e.stopPropagation();
                                                                                                        let newPrompt = currentPrompt || '';
                                                                                                        if (isActive) {
                                                                                                            // 移除标签，并清理多余空格
                                                                                                            newPrompt = newPrompt.replace(tag, '').replace(/\s{2,}/g, ' ').trim();
                                                                                                        } else {
                                                                                                            // 添加标签到末尾（前后加空格）
                                                                                                            newPrompt = newPrompt.trim();
                                                                                                            newPrompt = newPrompt ? `${newPrompt} ${tag} ` : `${tag} `;
                                                                                                        }
                                                                                                        updateShot(node.id, shot.id, { prompt: newPrompt });
                                                                                                    }}
                                                                                                    className={`relative shrink-0 transition-all ${isActive ? 'scale-110' : 'opacity-70 hover:opacity-100'}`}
                                                                                                    title={char.username}
                                                                                                >
                                                                                                    <img
                                                                                                        src={char.localCacheUrl || char.profile_picture_url || ''}
                                                                                                        alt={char.username}
                                                                                                        className={`w-8 h-8 rounded-full object-cover border-2 ${isActive
                                                                                                            ? 'border-blue-500 ring-2 ring-blue-500'
                                                                                                            : 'border-transparent'
                                                                                                            }`}
                                                                                                        onError={(e) => {
                                                                                                            e.target.style.display = 'none';
                                                                                                        }}
                                                                                                    />
                                                                                                    {/* 右下角显示小的链接图标表示可用 */}
                                                                                                    <div className="absolute -bottom-0.5 -right-0.5 bg-black/50 rounded-full p-0.5">
                                                                                                        <LinkIcon size={8} className="text-green-400" />
                                                                                                    </div>
                                                                                                </button>
                                                                                            );
                                                                                        })}
                                                                                    </div>
                                                                                    {shouldShowExpand && (
                                                                                        <button
                                                                                            onClick={(e) => {
                                                                                                e.stopPropagation();
                                                                                                if (isExpanded) {
                                                                                                    // 收起：关闭展开状态
                                                                                                    setCharacterReferenceBarExpanded(prev => {
                                                                                                        const updated = { ...prev };
                                                                                                        delete updated[expandKey];
                                                                                                        return updated;
                                                                                                    });
                                                                                                } else {
                                                                                                    // 展开：打开角色库侧边栏
                                                                                                    setCharactersOpen(true);
                                                                                                    setCharacterReferenceBarExpanded(prev => ({ ...prev, [expandKey]: true }));
                                                                                                }
                                                                                            }}
                                                                                            className={`shrink-0 px-2 py-1 text-[10px] rounded transition-colors ml-2 ${theme === 'dark'
                                                                                                ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                                                                : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                                                                }`}
                                                                                            title={isExpanded ? "收起" : "打开角色库"}
                                                                                        >
                                                                                            {isExpanded ? '收起' : `+${characterLibrary.length - maxVisible}`}
                                                                                        </button>
                                                                                    )}
                                                                                </div>
                                                                            </div>
                                                                        );
                                                                    })()}

                                                                    <div className="flex gap-1 flex-wrap items-center mt-1">
                                                                        {shot.tags?.map((tag, tagIdx) => (
                                                                            <span key={tagIdx} className={`px-1.5 py-0.5 text-[10px] rounded border ${theme === 'dark'
                                                                                ? 'bg-blue-900/30 text-blue-300 border-blue-800'
                                                                                : 'bg-blue-50 text-blue-600 border-blue-200'
                                                                                }`}>{tag}</span>
                                                                        ))}
                                                                        {shot.camera && (
                                                                            <span className={`px-1.5 py-0.5 text-[10px] rounded border flex items-center gap-1 ${theme === 'dark'
                                                                                ? 'bg-purple-900/30 text-purple-300 border-purple-800'
                                                                                : 'bg-purple-50 text-purple-600 border-purple-200'
                                                                                }`}>
                                                                                <Video size={8} /> {shot.camera}
                                                                            </span>
                                                                        )}
                                                                        {shot.time_range && (
                                                                            <span className={`text-[10px] ml-auto font-mono ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'
                                                                                }`}>{shot.time_range}</span>
                                                                        )}
                                                                    </div>
                                                                </div>

                                                                {/* Actions */}
                                                                <div className={`flex flex-col items-center gap-3 justify-between border-l pl-6 pr-2 shrink-0 w-16 ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                                                    }`}>
                                                                    <div className="flex flex-col items-center gap-2">
                                                                        {(shot.status === 'generating' || shot.status === 'done' || shot.status === 'completed' || shot.status === 'failed' || shot.status === 'error') && (
                                                                            <div
                                                                                className={`px-1.5 py-0.5 rounded text-[11px] font-mono flex items-center justify-center gap-1 ${theme === 'dark'
                                                                                    ? 'bg-blue-500/20 text-blue-400 border border-blue-500/30'
                                                                                    : 'bg-blue-50 text-blue-600 border border-blue-200'
                                                                                    }`}
                                                                            >
                                                                                <Clock size={12} />
                                                                                <span>
                                                                                    {shot.status === 'generating'
                                                                                        ? (shotTimers[`${node.id}-${shot.id}`] ? shotTimers[`${node.id}-${shot.id}`].replace('⏱ ', '') : '0.0s')
                                                                                        : `${(shot.durationCost || 0).toFixed(1)}s`
                                                                                    }
                                                                                </span>
                                                                            </div>
                                                                        )}
                                                                        <button
                                                                            onClick={() => {
                                                                                if (confirm(t('确定要删除该镜头吗？'))) deleteShot(node.id, shot.id);
                                                                            }}
                                                                            className={`p-1.5 transition-colors ${theme === 'dark'
                                                                                ? 'text-zinc-600 hover:text-red-500'
                                                                                : 'text-zinc-400 hover:text-red-600'
                                                                                }`}
                                                                            title={t('删除镜头')}
                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                        >
                                                                            <Trash2 size={16} />
                                                                        </button>
                                                                    </div>
                                                                    {/* V3.6.1: 生成按钮 - 根据模式调用不同函数 */}
                                                                    {(() => {
                                                                        const mode = node.settings?.mode || 'video';
                                                                        const outputUrl = mode === 'image' ? shot.output_url : shot.video_url;
                                                                        const isDone = shot.status === 'done' && outputUrl;
                                                                        return (
                                                                            <button
                                                                                onClick={(e) => {
                                                                                    e.stopPropagation();
                                                                                    if (shot.status === 'generating') {
                                                                                        // V3.5.20: Stop/Cancel Generation
                                                                                        updateShot(node.id, shot.id, { status: 'draft', errorMsg: null });
                                                                                    } else {
                                                                                        // V3.6.1: 根据模式调用不同的生成函数
                                                                                        if (mode === 'image') {
                                                                                            generateSingleImage(node.id, shot);
                                                                                        } else {
                                                                                            generateSingleShot(node.id, shot);
                                                                                        }
                                                                                    }
                                                                                }}
                                                                                className={`p-3 rounded text-white shadow-sm transition-all active:scale-95 ${shot.status === 'generating'
                                                                                    ? 'bg-zinc-500 hover:bg-red-500'
                                                                                    : isDone
                                                                                        ? 'bg-blue-500 hover:bg-green-600'
                                                                                        : mode === 'image' ? 'bg-blue-600 hover:bg-blue-500' : 'bg-green-600 hover:bg-green-500'
                                                                                    }`}
                                                                                title={shot.status === 'generating' ? '停止生成' : (isDone ? '重新生成' : `生成${mode === 'image' ? '图片' : '视频'}`)}
                                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                            >
                                                                                {shot.status === 'generating' ? (
                                                                                    <div className="relative w-4 h-4 flex items-center justify-center">
                                                                                        <Loader2 size={18} className="animate-spin absolute" />
                                                                                        <Square size={14} fill="currentColor" className="opacity-0 hover:opacity-100 absolute z-10 transition-opacity" />
                                                                                    </div>
                                                                                ) : isDone ? (
                                                                                    <CheckCircle2 size={18} />
                                                                                ) : mode === 'image' ? (
                                                                                    <ImageIcon size={18} />
                                                                                ) : (
                                                                                    <Play size={18} fill="currentColor" />
                                                                                )}
                                                                            </button>
                                                                        );
                                                                    })()}
                                                                    {/* V3.5.17: Move up/down buttons for manual reordering */}
                                                                    <div className="flex flex-col items-center gap-1.5">
                                                                        <button
                                                                            onClick={() => {
                                                                                const shots = [...(node.settings?.shots || [])];
                                                                                const currentIdx = shots.findIndex(s => s.id === shot.id);
                                                                                if (currentIdx > 0) {
                                                                                    [shots[currentIdx - 1], shots[currentIdx]] = [shots[currentIdx], shots[currentIdx - 1]];
                                                                                    updateNodeSettings(node.id, { shots });
                                                                                }
                                                                            }}
                                                                            disabled={idx === 0}
                                                                            className={`p-1.5 rounded transition-colors ${idx === 0 ? 'opacity-30 cursor-not-allowed' : ''} ${theme === 'dark'
                                                                                ? 'text-zinc-500 hover:text-blue-400 hover:bg-zinc-800'
                                                                                : 'text-zinc-400 hover:text-blue-500 hover:bg-zinc-100'
                                                                                }`}
                                                                            title={t('上移')}
                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                        >
                                                                            <ChevronUp size={16} />
                                                                        </button>
                                                                        <button
                                                                            onClick={() => {
                                                                                const shots = [...(node.settings?.shots || [])];
                                                                                const currentIdx = shots.findIndex(s => s.id === shot.id);
                                                                                if (currentIdx < shots.length - 1) {
                                                                                    [shots[currentIdx], shots[currentIdx + 1]] = [shots[currentIdx + 1], shots[currentIdx]];
                                                                                    updateNodeSettings(node.id, { shots });
                                                                                }
                                                                            }}
                                                                            disabled={idx === (node.settings?.shots?.length || 0) - 1}
                                                                            className={`p-1.5 rounded transition-colors ${idx === (node.settings?.shots?.length || 0) - 1 ? 'opacity-30 cursor-not-allowed' : ''} ${theme === 'dark'
                                                                                ? 'text-zinc-500 hover:text-blue-400 hover:bg-zinc-800'
                                                                                : 'text-zinc-400 hover:text-blue-500 hover:bg-zinc-100'
                                                                                }`}
                                                                            title={t('下移')}
                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                        >
                                                                            <ChevronDown size={16} />
                                                                        </button>
                                                                    </div>
                                                                </div>

                                                                {/* V3.6.1: 输出预览区已移至右侧弹出面板 */}
                                                            </div>

                                                            {/* V3.7.10: 右侧预览面板 - 4图网格 */}
                                                            {node.settings?.showOutputPreview && (
                                                                <div
                                                                    className={`shrink-0 p-2 ml-1 flex flex-col gap-2 rounded-lg border transition-all ${theme === 'dark'
                                                                        ? 'bg-zinc-900/50 border-zinc-800'
                                                                        : theme === 'solarized'
                                                                            ? 'bg-[#fdf6e3] border-[#d7cfb2]'
                                                                            : 'bg-white border-zinc-200'
                                                                        } ${shot.outputEnabled ? (theme === 'dark' ? 'bg-blue-900/20 border-blue-800' : 'bg-blue-50 border-blue-300') : ''}`}
                                                                    style={{ width: previewPanelWidth }}
                                                                >
                                                                    {/* Header: Checkbox + Status */}
                                                                    <div className="flex items-center justify-between">
                                                                        <div
                                                                            className={`w-4 h-4 rounded border cursor-pointer flex items-center justify-center transition-colors ${shot.outputEnabled
                                                                                ? 'bg-blue-500 border-blue-500 text-white'
                                                                                : theme === 'dark' ? 'border-zinc-600 hover:border-blue-400' : 'border-zinc-400 hover:border-blue-400'
                                                                                }`}
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                updateShot(node.id, shot.id, { outputEnabled: !shot.outputEnabled });
                                                                            }}
                                                                            title={shot.outputEnabled ? '取消输出' : '允许输出'}
                                                                        >
                                                                            {shot.outputEnabled && <Check size={10} />}
                                                                        </div>
                                                                        <span className={`text-[10px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                                            {shot.output_images?.length > 0 ? '已就绪' : '等待'}
                                                                        </span>
                                                                    </div>
                                                                    {/* 4-Image Grid or Single Thumbnail */}
                                                                    {(() => {
                                                                        const outputImages = shot.output_images || [];
                                                                        const selectedIndex = shot.selectedImageIndex ?? 0;
                                                                        const mode = node.settings?.mode || 'video';
                                                                        const getPreviewBgClass = (index) => theme === 'solarized'
                                                                            ? (index % 2 === 0 ? 'bg-[#fdf6e3]' : 'bg-[#eee8d5]')
                                                                            : '';

                                                                        // 视频模式 - 显示单个视频缩略图
                                                                        if (mode === 'video') {
                                                                            return (
                                                                                <div
                                                                                    className={`flex-1 min-h-[80px] rounded overflow-hidden relative group/preview cursor-pointer border ${theme === 'dark'
                                                                                        ? 'border-zinc-800 bg-black'
                                                                                        : theme === 'solarized'
                                                                                            ? `border-[#eee8d5] ${getPreviewBgClass(0)}`
                                                                                            : 'border-zinc-200 bg-zinc-50'
                                                                                        }`}
                                                                                    onClick={(e) => {
                                                                                        e.stopPropagation();
                                                                                        if (shot.video_url) setLightboxItem({ url: shot.video_url, type: 'video', prompt: shot.prompt });
                                                                                    }}
                                                                                >
                                                                                    {shot.video_url ? (
                                                                                        <video src={shot.video_url} className="w-full h-full object-cover" muted />
                                                                                    ) : (
                                                                                        <div className="absolute inset-0 flex items-center justify-center opacity-30">
                                                                                            <Eye size={16} />
                                                                                        </div>
                                                                                    )}
                                                                                    {shot.video_url && (
                                                                                        <div className="absolute inset-0 bg-black/40 opacity-0 group-hover/preview:opacity-100 flex items-center justify-center transition-opacity">
                                                                                            <Maximize2 size={16} className="text-white drop-shadow-md" />
                                                                                        </div>
                                                                                    )}
                                                                                    {/* V3.7.10: 视频文件名 */}
                                                                                    {shot.video_filename && (
                                                                                        <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-[8px] px-1 py-0.5 truncate opacity-0 group-hover/preview:opacity-100 transition-opacity" title={shot.video_filename}>
                                                                                            {shot.video_filename}
                                                                                        </div>
                                                                                    )}
                                                                                </div>
                                                                            );
                                                                        }

                                                                        // 图片模式 - V3.7.12: 激活=1大+3小(始终), 非激活=2x2
                                                                        // selectedIndex >= 0 表示选中了某张图，-1 表示未选中
                                                                        // outputEnabled=true 时锁定选择，不能再改
                                                                        const isLocked = shot.outputEnabled;
                                                                        const hasSelection = selectedIndex >= 0;
                                                                        const displayMainIndex = hasSelection ? selectedIndex : 0; // 大图始终显示第一张或选中的

                                                                        if (outputImages.length >= 2) {
                                                                            if (isActiveShot) {
                                                                                // 激活状态: 始终 1大图 + 3小图
                                                                                const mainImg = outputImages[displayMainIndex] || outputImages[0];
                                                                                const thumbnails = outputImages.slice(0, 4).map((img, idx) => ({ img, idx })).filter(item => item.idx !== displayMainIndex);
                                                                                return (
                                                                                    <div className="flex flex-col gap-1 flex-1 min-h-[100px]">
                                                                                        {/* 主图 - 点击切换选中状态 */}
                                                                                        <div
                                                                                            className={`relative flex-1 rounded border overflow-hidden transition-all group/main ${hasSelection ? 'border-blue-500 ring-1 ring-blue-500/50' : (theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300')} ${theme === 'solarized' ? getPreviewBgClass(displayMainIndex) : ''} ${isLocked ? 'cursor-not-allowed opacity-80' : 'cursor-pointer'}`}
                                                                                            onClick={(e) => {
                                                                                                e.stopPropagation();
                                                                                                if (!isLocked) updateShot(node.id, shot.id, { selectedImageIndex: hasSelection ? -1 : displayMainIndex });
                                                                                            }}
                                                                                            onDoubleClick={(e) => {
                                                                                                e.stopPropagation();
                                                                                                setLightboxItem({
                                                                                                    url: mainImg,
                                                                                                    type: 'image',
                                                                                                    prompt: shot.prompt,
                                                                                                    mjImages: outputImages,
                                                                                                    selectedMjImageIndex: displayMainIndex,
                                                                                                    storyboardContext: { nodeId: node.id, shotId: shot.id, shotIndex: (node.settings?.shots || []).findIndex(s => s.id === shot.id), allShots: node.settings?.shots || [] }
                                                                                                });
                                                                                            }}
                                                                                            onContextMenu={(e) => {
                                                                                                // V3.7.29: 1大图+3小图模式的右键预览
                                                                                                handlePreviewRightClick(e, {
                                                                                                    url: mainImg,
                                                                                                    type: 'image',
                                                                                                    prompt: shot.prompt,
                                                                                                    mjImages: outputImages,
                                                                                                    selectedMjImageIndex: displayMainIndex,
                                                                                                    sourceNode: node
                                                                                                });
                                                                                            }}
                                                                                        >
                                                                                            <LazyBase64Image src={mainImg} className="w-full h-full object-cover" />
                                                                                            <div className={`absolute top-0 left-0 text-[8px] px-1 py-0.5 rounded-br ${hasSelection ? 'bg-blue-500 text-white' : 'bg-black/50 text-white'}`}>{displayMainIndex + 1}</div>
                                                                                            {/* 选中时显示勾 */}
                                                                                            {hasSelection && (
                                                                                                <div className="absolute top-0 right-0 bg-blue-500 text-white p-0.5 rounded-bl"><Check size={10} /></div>
                                                                                            )}
                                                                                            {/* 锁定标识 */}
                                                                                            {isLocked && (
                                                                                                <div className="absolute top-1 right-1 bg-yellow-500 text-black p-0.5 rounded text-[8px]">🔒</div>
                                                                                            )}
                                                                                            <button
                                                                                                onClick={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    setLightboxItem({
                                                                                                        url: mainImg,
                                                                                                        type: 'image',
                                                                                                        prompt: shot.prompt,
                                                                                                        mjImages: outputImages,
                                                                                                        selectedMjImageIndex: displayMainIndex,
                                                                                                        // V3.7.21: 镜头导航上下文
                                                                                                        storyboardContext: {
                                                                                                            nodeId: node.id,
                                                                                                            shotId: shot.id,
                                                                                                            shotIndex: (node.settings?.shots || []).findIndex(s => s.id === shot.id),
                                                                                                            allShots: node.settings?.shots || []
                                                                                                        }
                                                                                                    });
                                                                                                }}
                                                                                                className="absolute bottom-0 left-0 p-0.5 rounded-tr bg-black/60 text-white hover:bg-blue-500 opacity-0 group-hover/main:opacity-100 transition-opacity z-10"
                                                                                                title={t('预览原图')}
                                                                                            >
                                                                                                <Maximize2 size={10} />
                                                                                            </button>
                                                                                        </div>
                                                                                        {/* 缩略图行 - 点击切换到该图 */}
                                                                                        <div className="flex gap-1 h-10 shrink-0">
                                                                                            {thumbnails.map(({ img, idx }) => (
                                                                                                <div
                                                                                                    key={idx}
                                                                                                    className={`relative flex-1 rounded border overflow-hidden transition-all group/thumb ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'} ${theme === 'solarized' ? getPreviewBgClass(idx) : ''} ${isLocked ? 'cursor-not-allowed opacity-60' : 'cursor-pointer hover:border-blue-400'}`}
                                                                                                    onClick={(e) => { e.stopPropagation(); if (!isLocked) updateShot(node.id, shot.id, { selectedImageIndex: idx }); }}
                                                                                                    onContextMenu={(e) => {
                                                                                                        // V3.7.29: 缩略图右键预览
                                                                                                        handlePreviewRightClick(e, {
                                                                                                            url: img,
                                                                                                            type: 'image',
                                                                                                            prompt: shot.prompt,
                                                                                                            mjImages: outputImages,
                                                                                                            selectedMjImageIndex: idx,
                                                                                                            sourceNode: node
                                                                                                        });
                                                                                                    }}
                                                                                                >
                                                                                                    <LazyBase64Image src={img} className="w-full h-full object-cover" />
                                                                                                    <div className="absolute top-0 left-0 bg-black/50 text-white text-[7px] px-0.5">{idx + 1}</div>
                                                                                                </div>
                                                                                            ))}
                                                                                        </div>
                                                                                    </div>
                                                                                );
                                                                            } else {
                                                                                // 非激活状态: 2x2 四格
                                                                                return (
                                                                                    <div className="grid grid-cols-2 gap-1 flex-1 min-h-[100px]">
                                                                                        {outputImages.slice(0, 4).map((img, idx) => (
                                                                                            <div
                                                                                                key={idx}
                                                                                                className={`relative rounded border overflow-hidden transition-all group/cell ${selectedIndex === idx
                                                                                                    ? 'border-blue-500 ring-1 ring-blue-500/50'
                                                                                                    : theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                                                                    } ${theme === 'solarized' ? getPreviewBgClass(idx) : ''} ${isLocked ? 'cursor-not-allowed opacity-80' : 'cursor-pointer hover:border-blue-400'}`}
                                                                                                onClick={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    if (!isLocked) updateShot(node.id, shot.id, { selectedImageIndex: selectedIndex === idx ? -1 : idx });
                                                                                                }}
                                                                                                onDoubleClick={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    setLightboxItem({
                                                                                                        url: img,
                                                                                                        type: 'image',
                                                                                                        prompt: shot.prompt,
                                                                                                        mjImages: outputImages,
                                                                                                        selectedMjImageIndex: idx,
                                                                                                        storyboardContext: { nodeId: node.id, shotId: shot.id, shotIndex: (node.settings?.shots || []).findIndex(s => s.id === shot.id), allShots: node.settings?.shots || [] }
                                                                                                    });
                                                                                                }}
                                                                                                onContextMenu={(e) => {
                                                                                                    // V3.7.29: 右键菜单支持
                                                                                                    handlePreviewRightClick(e, {
                                                                                                        url: img,
                                                                                                        type: 'image',
                                                                                                        prompt: shot.prompt,
                                                                                                        mjImages: outputImages,
                                                                                                        selectedMjImageIndex: idx,
                                                                                                        sourceNode: node
                                                                                                    });
                                                                                                }}
                                                                                            >
                                                                                                <LazyBase64Image src={img} className="w-full h-full object-cover" />
                                                                                                <div className={`absolute top-0 left-0 text-[7px] px-0.5 rounded-br ${selectedIndex === idx ? 'bg-blue-500 text-white' : 'bg-black/50 text-white'}`}>{idx + 1}</div>
                                                                                                {selectedIndex === idx && (
                                                                                                    <div className="absolute top-0 right-0 bg-blue-500 text-white p-0.5 rounded-bl"><Check size={8} /></div>
                                                                                                )}
                                                                                                <button
                                                                                                    onClick={(e) => {
                                                                                                        e.stopPropagation();
                                                                                                        setLightboxItem({
                                                                                                            url: img,
                                                                                                            type: 'image',
                                                                                                            prompt: shot.prompt,
                                                                                                            mjImages: outputImages,
                                                                                                            selectedMjImageIndex: idx,
                                                                                                            // V3.7.21: 镜头导航上下文
                                                                                                            storyboardContext: {
                                                                                                                nodeId: node.id,
                                                                                                                shotId: shot.id,
                                                                                                                // 获取镜头在数组中的正确索引
                                                                                                                shotIndex: (node.settings?.shots || []).findIndex(s => s.id === shot.id),
                                                                                                                allShots: node.settings?.shots || []
                                                                                                            }
                                                                                                        });
                                                                                                    }}
                                                                                                    className="absolute bottom-0 left-0 p-0.5 rounded-tr bg-black/60 text-white hover:bg-blue-500 opacity-0 group-hover/cell:opacity-100 transition-opacity z-10"
                                                                                                    title={t('预览原图')}
                                                                                                >
                                                                                                    <Maximize2 size={8} />
                                                                                                </button>
                                                                                            </div>
                                                                                        ))}
                                                                                    </div>
                                                                                );
                                                                            }
                                                                        }

                                                                        // 单图或无图 - 显示单个缩略图
                                                                        const singleUrl = outputImages[0] || shot.output_url;
                                                                        return (
                                                                            <div
                                                                                className={`flex-1 min-h-[80px] rounded overflow-hidden relative group/preview cursor-pointer border ${theme === 'dark'
                                                                                    ? 'border-zinc-800 bg-black'
                                                                                    : theme === 'solarized'
                                                                                        ? `border-[#eee8d5] ${getPreviewBgClass(0)}`
                                                                                        : 'border-zinc-200 bg-zinc-50'
                                                                                    }`}
                                                                                onClick={(e) => {
                                                                                    e.stopPropagation();
                                                                                    if (singleUrl) setLightboxItem({ url: singleUrl, type: 'image', prompt: shot.prompt });
                                                                                }}
                                                                                onContextMenu={(e) => {
                                                                                    // V3.7.29: 右键菜单支持
                                                                                    if (singleUrl) handlePreviewRightClick(e, {
                                                                                        url: singleUrl,
                                                                                        type: 'image',
                                                                                        prompt: shot.prompt,
                                                                                        sourceNode: node
                                                                                    });
                                                                                }}
                                                                            >
                                                                                {singleUrl ? (
                                                                                    <LazyBase64Image src={singleUrl} className="w-full h-full object-cover" />
                                                                                ) : (
                                                                                    <div className="absolute inset-0 flex items-center justify-center opacity-30">
                                                                                        <Eye size={16} />
                                                                                    </div>
                                                                                )}
                                                                                {singleUrl && (
                                                                                    <div className="absolute inset-0 bg-black/40 opacity-0 group-hover/preview:opacity-100 flex items-center justify-center transition-opacity">
                                                                                        <Maximize2 size={16} className="text-white drop-shadow-md" />
                                                                                    </div>
                                                                                )}
                                                                                {/* V3.7.10: 图片文件名 */}
                                                                                {shot.image_filename && (
                                                                                    <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-[8px] px-1 py-0.5 truncate opacity-0 group-hover/preview:opacity-100 transition-opacity" title={shot.image_filename}>
                                                                                        {shot.image_filename}
                                                                                    </div>
                                                                                )}
                                                                            </div>
                                                                        );
                                                                    })()}
                                                                </div>
                                                            )}

                                                        </div>{/* Close Outer Wrapper */}
                                                    </React.Fragment>
                                                );
                                            })
                                        ) : (
                                            <div
                                                className={`flex flex-col items-center justify-center h-40 gap-3 rounded-lg border-2 border-dashed cursor-pointer transition-colors ${theme === 'dark'
                                                    ? 'border-zinc-800 text-zinc-600 hover:border-zinc-700'
                                                    : 'border-zinc-300 text-zinc-400 hover:border-blue-300 hover:text-blue-500'
                                                    }`}
                                                onClick={() => addEmptyShot(node.id)}
                                                onMouseDown={(e) => e.stopPropagation()}
                                            >
                                                <LayoutGrid size={32} className="opacity-50" />
                                                <span className="text-xs">{t('暂无分镜，请添加或同步分析结果')}</span>
                                            </div>
                                        )}
                                    </div>

                                    {/* Footer */}
                                    <div className={`p-3 border-t shrink-0 ${theme === 'dark'
                                        ? 'bg-zinc-900 border-zinc-800'
                                        : theme === 'solarized'
                                            ? 'bg-[#eee8d5] border-[#eee8d5]'
                                            : 'bg-zinc-50 border-zinc-200'
                                        }`}>
                                        <button
                                            onClick={() => addEmptyShot(node.id)}
                                            className={`w-full py-2 border border-dashed text-xs rounded transition-colors flex items-center justify-center gap-2 ${theme === 'dark'
                                                ? 'border-zinc-700 text-zinc-400 hover:bg-zinc-800 hover:text-zinc-200'
                                                : 'border-zinc-300 text-zinc-500 hover:bg-white hover:text-blue-600 hover:border-blue-400'
                                                }`}
                                            onMouseDown={(e) => e.stopPropagation()}
                                        >
                                            <Plus size={14} /> {t('添加空白镜头')}
                                        </button>
                                    </div>
                                </div>

                                {/* V3.6.1: 独立右侧面板已移除，改用行内布局实现对齐 */}
                            </div>
                        );
                    })()}

                    {node.type === 'image-compare' && (
                        <div className="w-full h-full pointer-events-auto">
                            <ImageCompareView
                                img1={connectedImages[0]}
                                img2={connectedImages[1]}
                                theme={theme}
                                language={language}
                            />
                        </div>
                    )
                    }

                    {
                        node.type === 'preview' && (
                            <div className="flex flex-col h-full pointer-events-auto">
                                <div
                                    className={`flex items-center justify-between px-3 py-2 border-b text-xs font-semibold ${theme === 'dark'
                                        ? 'border-zinc-800 text-zinc-200'
                                        : 'border-zinc-200 text-zinc-700'
                                        }`}
                                >
                                    <div className="flex items-center gap-1.5">
                                        <Maximize2 size={13} className="text-blue-500" />
                                        <span>{t('预览窗口')}</span>
                                    </div>
                                    <span className="text-[10px] text-zinc-500">
                                        {node.previewType === 'video' ? '视频预览' : '图片预览'}
                                    </span>
                                </div>
                                <div className="flex-1 flex flex-col p-2 gap-2 min-h-0">
                                    <div
                                        className={`relative flex-1 rounded-lg overflow-hidden flex items-center justify-center min-h-0 ${theme === 'dark'
                                            ? 'bg-zinc-900'
                                            : theme === 'solarized'
                                                ? 'bg-[#fdf6e3]'
                                                : 'bg-zinc-100'
                                            }`}
                                        onDrop={(e) => handlePreviewDrop(node.id, e)}
                                        onDragOver={handleCanvasDragOver}
                                        onContextMenu={(e) => {
                                            const previewUrl = node.content || (node.previewMjImages && node.previewMjImages[0]);
                                            if (previewUrl) {
                                                handlePreviewRightClick(e, { url: previewUrl, type: node.previewType || (isVideoUrl(previewUrl) ? 'video' : 'image'), sourceNode: node });
                                            }
                                        }}
                                        onDoubleClick={(e) => {
                                            e.stopPropagation();
                                            e.preventDefault();
                                            const previewUrl = node.content || (node.previewMjImages && node.previewMjImages[0]);
                                            if (previewUrl) {
                                                setLightboxItem({ url: previewUrl, type: node.previewType || (isVideoUrl(previewUrl) ? 'video' : 'image') });
                                            }
                                        }}
                                    >
                                        {node.content || (node.previewMjImages && node.previewMjImages.length > 0) ? (
                                            isVideoUrl(node.content) || node.previewType === 'video' ? (
                                                <ResolvedVideo
                                                    src={node.content}
                                                    className={`w-full h-full object-contain ${theme === 'dark'
                                                        ? 'bg-black'
                                                        : theme === 'solarized'
                                                            ? 'bg-[#fdf6e3]'
                                                            : 'bg-zinc-100'
                                                        }`}
                                                    controls
                                                    draggable={false}
                                                />
                                            ) : node.previewMjImages && (node.previewMjImages.length === 4 || node.previewMjImages.length > 1) ? (
                                                // 多张图片网格显示（即梦回传的四张图）
                                                <div className={`w-full h-full grid gap-0.5 p-0.5 ${node.previewMjImages.length === 4 ? 'grid-cols-2 grid-rows-2' : 'grid-cols-2'}`}>
                                                    {node.previewMjImages.map((imgUrl, idx) => (
                                                        <div
                                                            key={idx}
                                                            className={`relative w-full h-full overflow-hidden flex items-center justify-center group ${theme === 'dark'
                                                                ? 'bg-black'
                                                                : theme === 'solarized'
                                                                    ? 'bg-[#fdf6e3]'
                                                                    : 'bg-zinc-100'
                                                                }`}
                                                        >
                                                            <LazyBase64Image
                                                                src={imgUrl}
                                                                className="max-w-full max-h-full w-auto h-auto object-contain"
                                                                alt={`预览图 ${idx + 1}`}
                                                                draggable={false}
                                                                onError={(e) => {
                                                                    console.error(`预览图片 ${idx + 1} 加载失败`);
                                                                    e.target.style.display = 'none';
                                                                }}
                                                            />
                                                        </div>
                                                    ))}
                                                </div>
                                            ) : (
                                                <div className="w-full h-full relative group/preview">
                                                    <LazyBase64Image
                                                        src={node.content || (node.previewMjImages && node.previewMjImages[0])}
                                                        className={`w-full h-full object-contain ${theme === 'dark'
                                                            ? 'bg-black'
                                                            : theme === 'solarized'
                                                                ? 'bg-[#fdf6e3]'
                                                                : 'bg-zinc-100'
                                                            }`}
                                                        draggable={false}
                                                        onError={(e) => {
                                                            // 错误处理：由于 LazyBase64Image 有内部状态，这里主要处理外部 URL 错误
                                                            console.warn('[Preview] Image load error');
                                                        }}
                                                    />
                                                    {/* V3.7.8: Filename Overlay */}
                                                    {node.previewFilename && (
                                                        <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-[10px] px-2 py-1 truncate opacity-0 group-hover/preview:opacity-100 transition-opacity backdrop-blur-sm" title={node.previewFilename}>
                                                            {node.previewFilename}
                                                        </div>
                                                    )}
                                                </div>
                                            )
                                        ) : (
                                            <div
                                                className={`flex flex-col items-center justify-center text-[11px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                                    }`}
                                            >
                                                <ImageIcon className="w-6 h-6 mb-1 text-zinc-400" />
                                                <span>{t('连接 AI 绘图 / AI 视频 节点')}</span>
                                                <span>{t('或从历史记录发送到此处进行预览')}</span>
                                            </div>
                                        )}
                                    </div>
                                    <div className="flex items-center justify-between gap-2 text-[11px]">
                                        <button
                                            className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${theme === 'dark'
                                                ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                            onMouseDown={(e) => e.stopPropagation()}
                                            onClick={async () => {
                                                if (!node.content) return;
                                                try {
                                                    await navigator.clipboard.writeText(node.content);
                                                } catch { }
                                            }}
                                        >
                                            <CopyPlus size={13} />
                                            {t('复制链接')}
                                        </button>
                                        <button
                                            className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${theme === 'dark'
                                                ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                            onMouseDown={(e) => e.stopPropagation()}
                                            onClick={async () => {
                                                if (!node.content) return;
                                                const world = screenToWorld(node.x + node.width + 100, node.y + node.height / 2);
                                                let dims;
                                                if (!isVideoUrl(node.content)) {
                                                    try {
                                                        const real = await getImageDimensions(node.content);
                                                        if (real?.w && real?.h) dims = { w: real.w, h: real.h };
                                                    } catch { }
                                                }
                                                addNode('input-image', world.x, world.y, null, node.content, dims);
                                            }}
                                        >
                                            <ArrowRightSquare size={13} />
                                            {t('发送到画布')}
                                        </button>
                                        <button
                                            className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${theme === 'dark'
                                                ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                            onMouseDown={(e) => e.stopPropagation()}
                                            onClick={() => {
                                                if (!node.content) return;
                                                const newFile = {
                                                    name: node.previewType === 'video' ? 'Preview.mp4' : 'Preview.png',
                                                    type: node.previewType === 'video' ? 'video/mp4' : 'image/png',
                                                    content: node.content,
                                                    isImage: node.previewType !== 'video',
                                                    isVideo: node.previewType === 'video',
                                                    isAudio: false,
                                                    fromPreview: true
                                                };
                                                setChatFiles((prev) => [...prev, newFile]);
                                                setIsChatOpen(true);
                                            }}
                                        >
                                            <MessageSquare size={13} />
                                            {t('发送到对话')}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )
                    }

                    {
                        (node.type === 'gen-image' || node.type === 'gen-video') && (() => {
                            // 查找当前节点对应的正在生成的历史记录
                            const activeTask = history.find(h =>
                                h.sourceNodeId === node.id &&
                                (h.status === 'generating' || h.status === 'completed')
                            );
                            const isGenerating = activeTask && activeTask.status === 'generating';
                            const finalDuration = activeTask?.durationMs
                                ? (activeTask.durationMs / 1000).toFixed(1)
                                : null;
                            const elapsedSeconds = nodeTimers[node.id] || 0;

                            return (
                                <div className="p-3 flex flex-col h-full pointer-events-auto">
                                    {/* 计时器显示 */}
                                    {(isGenerating || finalDuration) && (
                                        <div
                                            className={`mb-2 px-2 py-1 rounded text-[10px] font-mono text-center ${theme === 'dark'
                                                ? 'bg-blue-500/20 text-blue-400 border border-blue-500/30'
                                                : 'bg-blue-50 text-blue-600 border border-blue-200'
                                                }`}
                                        >
                                            {isGenerating ? (
                                                <span>⏱ {elapsedSeconds.toFixed(1)}s</span>
                                            ) : (
                                                <span>✓ {t('完成')} {finalDuration}s</span>
                                            )}
                                        </div>
                                    )}
                                    <div
                                        className={`flex items-center gap-1.5 mb-2 text-xs font-semibold shrink-0 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                            }`}
                                    >
                                        {node.type === 'gen-image' ? <Wand2 size={12} className="text-blue-400" /> : <Video size={12} className="text-purple-400" />}
                                        <span>{node.type === 'gen-image' ? t('AI 绘图') : t('AI 视频')}</span>
                                    </div>
                                    {connectedImages.length > 0 && (
                                        <div
                                            className={`mb-2 rounded-lg border p-2 relative group/ref ${theme === 'dark'
                                                ? 'bg-zinc-900/50 border-purple-500/20'
                                                : 'bg-violet-50 border-violet-200'
                                                }`}
                                        >
                                            <div className="flex justify-between items-center mb-1.5">
                                                <span
                                                    className={`text-[10px] font-medium flex items-center gap-1 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                                        }`}
                                                >
                                                    <ImagePlus size={10} />
                                                    引用成功
                                                </span>
                                                <span
                                                    className={`text-[9px] font-mono ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                                        }`}
                                                >
                                                    {connectedImages.length}/10
                                                </span>
                                            </div>
                                            <div className="flex -space-x-2 overflow-visible pb-1 items-center custom-scrollbar pl-1">
                                                {connectedImages.map((imgSrc, idx) => (
                                                    <div
                                                        key={idx}
                                                        className={`relative shrink-0 flex flex-col items-center gap-0 ${theme === 'dark' ? '' : ''
                                                            }`}
                                                    >
                                                        <div className="relative">
                                                            <span
                                                                className="absolute -top-1 -left-1 w-4 h-4 text-[9px] font-semibold rounded-full bg-zinc-700 text-white select-none flex items-center justify-center border border-white/70 shadow-sm leading-none pointer-events-none"
                                                                style={{ zIndex: 30 }}
                                                            >
                                                                {idx + 1}
                                                            </span>
                                                            <div
                                                                className={`relative w-8 h-8 rounded-full border-2 thumb-stack-item cursor-pointer overflow-hidden ${theme === 'dark'
                                                                    ? 'border-[#18181b] bg-zinc-800'
                                                                    : 'border-white bg-zinc-200'
                                                                    }`}
                                                                style={{ zIndex: 10 - idx }}
                                                            >
                                                                <LazyBase64Image src={imgSrc} className="w-full h-full object-cover" />
                                                            </div>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                    <div
                                        className={`rounded-lg p-3 mb-2 border focus-within:border-blue-500/30 transition-colors flex-1 flex flex-col ${theme === 'dark'
                                            ? 'bg-zinc-950/50 border-zinc-800'
                                            : theme === 'solarized'
                                                ? 'bg-[#fdf6e3] border-[#eee8d5]'
                                                : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                            }`}
                                    >
                                        {/* 蒙版已连接状态提示（仅 gen-image 节点） */}
                                        {node.type === 'gen-image' && (() => {
                                            // 检查当前节点或上游节点是否有蒙版
                                            const hasMaskInCurrent = node?.maskContent;

                                            // 查找连接到当前节点的源节点（优先查找 default 输入，如果没有则查找所有输入）
                                            let incomingConn = connections.find(c => c.to === node.id && (!c.inputType || c.inputType === 'default'));
                                            if (!incomingConn) {
                                                // 如果没有 default 连接，查找任何连接到该节点的连接
                                                incomingConn = connections.find(c => c.to === node.id);
                                            }

                                            // 使用 nodesMap 进行 O(1) 查找
                                            const sourceNode = incomingConn ? nodesMap.get(incomingConn.from) : null;
                                            const hasMaskFromSource = sourceNode && sourceNode.maskContent;
                                            const hasMask = hasMaskInCurrent || hasMaskFromSource;

                                            if (hasMask) {
                                                return (
                                                    <div className={`flex items-center gap-1.5 mb-2 px-2 py-1 rounded text-[10px] font-medium ${theme === 'dark'
                                                        ? 'bg-purple-900/30 text-purple-300 border border-purple-800'
                                                        : 'bg-purple-50 text-purple-600 border border-purple-200'
                                                        }`}>
                                                        <Eraser size={12} />
                                                        <span>{hasMaskFromSource ? t('已链接蒙版区域') : t('已设置蒙版区域')}</span>
                                                    </div>
                                                );
                                            }
                                            return null;
                                        })()}
                                        <div className="flex items-start gap-2 mb-1 flex-1 h-full min-h-0">
                                            <textarea
                                                className={`flex-1 h-full bg-transparent text-xs outline-none resize-none custom-scrollbar ${theme === 'dark'
                                                    ? 'text-zinc-300 placeholder-zinc-600'
                                                    : 'text-zinc-800 placeholder-zinc-400'
                                                    }`}
                                                placeholder={t('输入提示词...')}
                                                value={node.type === 'gen-image' ? (node.settings?.prompt || '') : (node.settings?.videoPrompt || '')}
                                                onChange={(e) => updateNodeSettings(node.id, node.type === 'gen-image' ? { prompt: e.target.value } : { videoPrompt: e.target.value })}
                                                onMouseDown={(e) => e.stopPropagation()}
                                            />
                                            {(node.type === 'gen-video' && (node.settings?.model === 'sora-2' || node.settings?.model === 'sora-2-pro')) && characterLibrary.length > 0 && (
                                                <div className="relative shrink-0">
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setCharactersOpen(true);
                                                        }}
                                                        className={`p-1.5 rounded transition-colors ${theme === 'dark'
                                                            ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                            : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                                            }`}
                                                        title={t('插入角色')}
                                                    >
                                                        <Users size={14} />
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    </div>

                                    {/* 角色引用栏 (仅 Sora 模型) */}
                                    {node.type === 'gen-video' && (() => {
                                        const currentModel = node.settings?.model || '';
                                        const modelConfig = getApiConfigByKey(currentModel);
                                        const modelName = modelConfig?.modelName || modelConfig?.id || currentModel;
                                        const isSora = modelName && (modelName.includes('sora') || currentModel.includes('sora'));

                                        if (!isSora || characterLibrary.length === 0) return null;

                                        const currentPrompt = node.settings?.videoPrompt || '';
                                        const isExpanded = characterReferenceBarExpanded[node.id] || false;
                                        const maxVisible = 5; // 最多显示5个角色，超过则显示展开按钮
                                        const shouldShowExpand = characterLibrary.length > maxVisible;

                                        return (
                                            <div className="border-t border-dashed mt-1" style={{
                                                borderColor: theme === 'dark' ? 'rgba(63, 63, 70, 0.5)' : 'rgba(161, 161, 170, 0.5)'
                                            }}>
                                                <div className="flex items-center justify-between py-1 px-1">
                                                    <div className="flex gap-2 overflow-x-auto py-2 flex-1 custom-scrollbar">
                                                        {(isExpanded ? characterLibrary : characterLibrary.slice(0, maxVisible)).map(char => {
                                                            const tag = `@${char.username}`;
                                                            const isActive = currentPrompt.includes(tag);

                                                            return (
                                                                <button
                                                                    key={char.id}
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        let newPrompt = currentPrompt || '';
                                                                        if (isActive) {
                                                                            // 移除标签，并清理多余空格
                                                                            newPrompt = newPrompt.replace(tag, '').replace(/\s{2,}/g, ' ').trim();
                                                                        } else {
                                                                            // 添加标签到末尾（前后加空格）
                                                                            newPrompt = newPrompt.trim();
                                                                            newPrompt = newPrompt ? `${newPrompt} ${tag} ` : `${tag} `;
                                                                        }
                                                                        updateNodeSettings(node.id, { videoPrompt: newPrompt });
                                                                    }}
                                                                    className={`relative shrink-0 transition-all ${isActive ? 'scale-110' : 'opacity-70 hover:opacity-100'}`}
                                                                    title={char.username}
                                                                >
                                                                    <LazyBase64Image
                                                                        src={char.localCacheUrl || char.profile_picture_url || ''}
                                                                        alt={char.username}
                                                                        className={`w-8 h-8 rounded-full object-cover border-2 ${isActive
                                                                            ? 'border-blue-500 ring-2 ring-blue-500'
                                                                            : 'border-transparent'
                                                                            }`}
                                                                        onError={(e) => {
                                                                            e.target.style.display = 'none';
                                                                        }}
                                                                    />
                                                                    {/* 右下角显示小的链接图标表示可用 */}
                                                                    <div className="absolute -bottom-0.5 -right-0.5 bg-black/50 rounded-full p-0.5">
                                                                        <LinkIcon size={8} className="text-green-400" />
                                                                    </div>
                                                                </button>
                                                            );
                                                        })}
                                                    </div>
                                                    {shouldShowExpand && (
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                if (isExpanded) {
                                                                    // 收起：关闭展开状态
                                                                    setCharacterReferenceBarExpanded(prev => {
                                                                        const updated = { ...prev };
                                                                        delete updated[node.id];
                                                                        return updated;
                                                                    });
                                                                } else {
                                                                    // 展开：打开角色库侧边栏
                                                                    setCharactersOpen(true);
                                                                    setCharacterReferenceBarExpanded(prev => ({ ...prev, [node.id]: true }));
                                                                }
                                                            }}
                                                            className={`shrink-0 px-2 py-1 text-[10px] rounded transition-colors ml-2 ${theme === 'dark'
                                                                ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                                : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                                }`}
                                                            title={isExpanded ? "收起" : "打开角色库"}
                                                        >
                                                            {isExpanded ? '收起' : `+${characterLibrary.length - maxVisible}`}
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })()}

                                    {/* 首尾帧 UI（仅支持首尾帧且开启时显示） */}
                                    {node.type === 'gen-video' && (() => {
                                        const currentModel = getApiConfigByKey(node.settings?.model);
                                        const supportsFirstLastFrame = !!currentModel?.supportsFirstLastFrame;
                                        const useFirstLastFrame = !!(node.settings?.useFirstLastFrame || node.settings?.veoFramesMode);
                                        if (!supportsFirstLastFrame || !useFirstLastFrame) return null;

                                        const startFrame = getConnectedImageForInput(node.id, 'veo_start');
                                        const endFrame = getConnectedImageForInput(node.id, 'veo_end');

                                        return (
                                            <div
                                                className={`mb-2 rounded-lg border p-3 space-y-2 ${theme === 'dark'
                                                    ? 'bg-zinc-900/40 border-emerald-500/20'
                                                    : 'bg-emerald-50 border-emerald-200'
                                                    }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                            >
                                                <div className={`text-[11px] font-semibold ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-700'}`}>
                                                    {t('首尾帧')}
                                                </div>
                                                <div className={`text-[10px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>
                                                    {t('第一张为首帧，第二张为尾帧（最多 2 张）')}
                                                </div>

                                                {/* 首帧 */}
                                                <div className="relative flex items-center gap-2">
                                                    <div
                                                        className={`input-point ${startFrame ? 'connected' : ''} ${connectingTarget === node.id && connectingInputType === 'veo_start' ? 'active' : ''}`}
                                                        title={t('首帧输入')}
                                                        onMouseDown={(e) => {
                                                            e.stopPropagation();
                                                            e.preventDefault();
                                                            const world = screenToWorld(e.clientX, e.clientY);
                                                            setMousePos(world);
                                                            setConnectingTarget(node.id);
                                                            setConnectingInputType('veo_start');
                                                        }}
                                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'veo_start')}
                                                        data-input-type="veo_start"
                                                        style={{ position: 'absolute', top: '50%', left: '0', transform: 'translateY(-50%)', width: '0.5rem', height: '0.5rem', zIndex: 20, cursor: 'crosshair' }}
                                                    />
                                                    <div className="flex items-center justify-between flex-1 ml-2">
                                                        <div className="flex items-center gap-2">
                                                            <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>{t('首帧')}</span>
                                                            {startFrame && <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>}
                                                        </div>
                                                        {startFrame ? (
                                                            <div className="w-8 h-8 rounded overflow-hidden border border-zinc-700/40">
                                                                <LazyBase64Image src={startFrame} className="w-full h-full object-cover" />
                                                            </div>
                                                        ) : (
                                                            <span className={`text-[10px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'}`}>{t('未连接')}</span>
                                                        )}
                                                    </div>
                                                </div>

                                                {/* 尾帧 */}
                                                <div className="relative flex items-center gap-2">
                                                    <div
                                                        className={`input-point ${endFrame ? 'connected' : ''} ${connectingTarget === node.id && connectingInputType === 'veo_end' ? 'active' : ''}`}
                                                        title={t('尾帧输入')}
                                                        onMouseDown={(e) => {
                                                            e.stopPropagation();
                                                            e.preventDefault();
                                                            const world = screenToWorld(e.clientX, e.clientY);
                                                            setMousePos(world);
                                                            setConnectingTarget(node.id);
                                                            setConnectingInputType('veo_end');
                                                        }}
                                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'veo_end')}
                                                        data-input-type="veo_end"
                                                        style={{ position: 'absolute', top: '50%', left: '0', transform: 'translateY(-50%)', width: '0.5rem', height: '0.5rem', zIndex: 20, cursor: 'crosshair' }}
                                                    />
                                                    <div className="flex items-center justify-between flex-1 ml-2">
                                                        <div className="flex items-center gap-2">
                                                            <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>{t('尾帧')}</span>
                                                            {endFrame && <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>}
                                                        </div>
                                                        {endFrame ? (
                                                            <div className="w-8 h-8 rounded overflow-hidden border border-zinc-700/40">
                                                                <LazyBase64Image src={endFrame} className="w-full h-full object-cover" />
                                                            </div>
                                                        ) : (
                                                            <span className={`text-[10px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'}`}>{t('未连接')}</span>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })()}

                                    {/* Midjourney指令UI: oref, ow, sref */}
                                    {node.type === 'gen-image' && (() => {
                                        const currentModel = getApiConfigByKey(node.settings?.model);
                                        const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                        return isMidjourney;
                                    })() && (() => {
                                        const orefConnected = getConnectedImageForInput(node.id, 'oref');
                                        const srefConnected = getConnectedImageForInput(node.id, 'sref');
                                        return (
                                            <div className="flex flex-col gap-1.5 mb-2 relative" data-mj-instructions="true">
                                                {/* oref指令 */}
                                                <div className="relative flex items-center gap-1.5" data-mj-oref="true">
                                                    <div className={`input-point ${orefConnected ? 'connected' : ''} ${connectingTarget === node.id && connectingInputType === 'oref' ? 'active' : ''}`}
                                                        title={t('oref输入')}
                                                        onMouseDown={(e) => {
                                                            e.stopPropagation();
                                                            e.preventDefault();
                                                            // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                                            const world = screenToWorld(e.clientX, e.clientY);
                                                            setMousePos(world);
                                                            setConnectingTarget(node.id);
                                                            setConnectingInputType('oref');
                                                        }}
                                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'oref')}
                                                        data-input-type="oref"
                                                        style={{ position: 'absolute', top: '50%', left: '-0.25rem', transform: 'translateY(-50%)', width: '0.5rem', height: '0.5rem', marginRight: '0.25rem', zIndex: 20, cursor: 'crosshair' }}
                                                    />
                                                    <div className="flex items-center gap-1.5 flex-1 ml-2">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>oref</span>
                                                        {orefConnected && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                </div>

                                                {/* ow指令 */}
                                                <div className="relative flex items-center gap-1.5">
                                                    <div className="w-0.5rem h-0.5rem mr-0.25rem ml-2"></div>
                                                    <div className="flex items-center gap-1.5 flex-1">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>ow</span>
                                                        {node.settings?.mjOw && node.settings.mjOw > 0 && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="1000"
                                                        placeholder="1-1000"
                                                        value={node.settings?.mjOw || ''}
                                                        onChange={(e) => {
                                                            const val = parseInt(e.target.value, 10);
                                                            if (isNaN(val) || val < 1) {
                                                                updateNodeSettings(node.id, { mjOw: '' });
                                                            } else if (val > 1000) {
                                                                updateNodeSettings(node.id, { mjOw: 1000 });
                                                            } else {
                                                                updateNodeSettings(node.id, { mjOw: val });
                                                            }
                                                        }}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        className={`flex-1 px-2 py-1 rounded text-[10px] border outline-none focus:border-blue-500/50 ${theme === 'dark'
                                                            ? 'bg-zinc-900/50 border-zinc-700 text-zinc-300 placeholder-zinc-600'
                                                            : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                            }`}
                                                    />
                                                </div>

                                                {/* sref指令 */}
                                                <div className="relative flex items-center gap-1.5" data-mj-sref="true">
                                                    <div className={`input-point ${srefConnected ? 'connected' : ''} ${connectingTarget === node.id && connectingInputType === 'sref' ? 'active' : ''}`}
                                                        title={t('sref输入')}
                                                        onMouseDown={(e) => {
                                                            e.stopPropagation();
                                                            e.preventDefault();
                                                            // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                                            const world = screenToWorld(e.clientX, e.clientY);
                                                            setMousePos(world);
                                                            setConnectingTarget(node.id);
                                                            setConnectingInputType('sref');
                                                        }}
                                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'sref')}
                                                        data-input-type="sref"
                                                        style={{ position: 'absolute', top: '50%', left: '-0.25rem', transform: 'translateY(-50%)', width: '0.5rem', height: '0.5rem', marginRight: '0.25rem', zIndex: 20, cursor: 'crosshair' }}
                                                    />
                                                    <div className="flex items-center gap-1.5 flex-1 ml-2">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>sref</span>
                                                        {srefConnected && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })()}
                                    {node.type === 'gen-image' && isNanoBanana2 && (
                                        <div
                                            className={`mb-2 rounded-lg border p-3 space-y-2 ${theme === 'dark'
                                                ? 'bg-zinc-900/50 border-zinc-800'
                                                : 'bg-white border-zinc-200'
                                                }`}
                                        >
                                            <div className="flex items-center justify-between">
                                                <button
                                                    className="flex items-center gap-1 text-[11px] font-semibold"
                                                    onClick={() => setPromptLibraryCollapsed((v) => !v)}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    <span className={theme === 'dark' ? 'text-zinc-200' : 'text-zinc-700'}>常用提示词库</span>
                                                    <ChevronRight
                                                        size={12}
                                                        className={`transition-transform ${promptLibraryCollapsed ? '' : 'rotate-90'} ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}
                                                    />
                                                </button>
                                                <div className="flex items-center gap-2 text-[10px]">
                                                    <span className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}>{promptLibrary.length} 项</span>
                                                    <button
                                                        className={`px-2 py-0.5 rounded text-[10px] border ${theme === 'dark' ? 'border-zinc-700 text-zinc-300 hover:bg-zinc-800' : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'}`}
                                                        onClick={() => setPromptLibraryEditorOpen((v) => !v)}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        {promptLibraryEditorOpen ? '收起' : '管理'}
                                                    </button>
                                                </div>
                                            </div>
                                            {!promptLibraryCollapsed && (
                                                <div className="space-y-2">
                                                    <div className="max-h-36 overflow-y-auto custom-scrollbar flex flex-wrap gap-2">
                                                        {promptLibrary.map((item) => (
                                                            <div
                                                                key={item.id}
                                                                className={`border rounded-lg px-2 py-1.5 flex items-center gap-2 text-[11px] ${theme === 'dark' ? 'border-zinc-700 bg-zinc-950/50 text-zinc-200' : 'border-zinc-200 bg-zinc-50 text-zinc-700'}`}
                                                            >
                                                                <span className="font-medium whitespace-nowrap">{item.name}</span>
                                                                <button
                                                                    onClick={() => applyLibraryPrompt(node.id, item.prompt)}
                                                                    className="px-2 py-0.5 rounded text-[10px] bg-blue-600 text-white hover:bg-blue-500 transition-colors"
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                >
                                                                    应用
                                                                </button>
                                                                {promptLibraryEditorOpen && (
                                                                    <button
                                                                        onClick={() => removePromptLibraryItem(item.id)}
                                                                        className={`px-2 py-0.5 rounded text-[10px] border ${theme === 'dark' ? 'border-red-500/50 text-red-400 hover:bg-red-500/10' : 'border-red-200 text-red-600 hover:bg-red-50'}`}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    >
                                                                        {t('删除')}
                                                                    </button>
                                                                )}
                                                            </div>
                                                        ))}
                                                        {promptLibrary.length === 0 && (
                                                            <div className={`text-[11px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>暂无常用提示词</div>
                                                        )}
                                                    </div>
                                                    {promptLibraryEditorOpen && (
                                                        <div className="grid grid-cols-1 gap-1.5">
                                                            <input
                                                                type="text"
                                                                value={promptLibraryForm.name}
                                                                onChange={(e) => setPromptLibraryForm((prev) => ({ ...prev, name: e.target.value }))}
                                                                placeholder={t('自定义名称（例如：柔光人像）')}
                                                                className={`w-full px-2 py-1 text-[11px] rounded border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-700 text-zinc-200 placeholder:text-zinc-600' : 'bg-white border-zinc-300 text-zinc-800 placeholder:text-zinc-400'}`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            />
                                                            <textarea
                                                                value={promptLibraryForm.prompt}
                                                                onChange={(e) => setPromptLibraryForm((prev) => ({ ...prev, prompt: e.target.value }))}
                                                                placeholder={t('输入提示词内容...')}
                                                                className={`w-full min-h-[70px] px-2 py-1 text-[11px] rounded border resize-none custom-scrollbar ${theme === 'dark' ? 'bg-zinc-900 border-zinc-700 text-zinc-200 placeholder:text-zinc-600' : 'bg-white border-zinc-300 text-zinc-800 placeholder:text-zinc-400'}`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            />
                                                            <button
                                                                onClick={addPromptLibraryItem}
                                                                className="w-full py-1.5 rounded text-[11px] font-medium bg-blue-600 hover:bg-blue-500 text-white transition-colors"
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                添加到常用提示词库
                                                            </button>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    )}
                                    {(() => {
                                        const customParamsView = renderCustomParamInputs(
                                            node.settings?.model,
                                            node.settings?.customParams,
                                            (nextParams) => updateNodeSettings(node.id, { customParams: nextParams })
                                        );
                                        if (!customParamsView) return null;
                                        return (
                                            <div className="mb-2">
                                                {customParamsView}
                                            </div>
                                        );
                                    })()}
                                    <div
                                        className={`mt-auto pt-2 flex items-center justify-between shrink-0 relative gap-2 border-t ${theme === 'dark' ? 'border-zinc-800/50' : 'border-zinc-200'
                                            }`}
                                    >
                                        <div className="relative flex-1 min-w-0">
                                            <button
                                                title={getModelLabelWithProvider(node.settings?.model)}
                                                onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'model' ? null : { nodeId: node.id, type: 'model' }); }}
                                                className={`flex items-center gap-2 pl-1 pr-2 py-1 rounded text-[10px] transition-colors border w-full ${theme === 'dark'
                                                    ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-300 border-zinc-700/50'
                                                    : theme === 'solarized'
                                                        ? 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-700 border-[#d7cfb2]'
                                                        : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-700 border-zinc-300'
                                                    }`}
                                            >
                                                <span className={`w-2 h-2 rounded-full ${getStatusColor(resolveModelKey(node.settings?.model))}`}></span>
                                                <span className="truncate font-mono">{getModelLabelWithProvider(node.settings?.model)}</span>
                                            </button>
                                            {activeDropdown?.nodeId === node.id && activeDropdown.type === 'model' && (
                                                <div
                                                    className={`absolute bottom-full left-0 mb-1 w-96 rounded-lg shadow-xl p-1 z-[60] border flex ${theme === 'dark'
                                                        ? 'bg-[#18181b] border-zinc-700'
                                                        : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                        }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                    onMouseLeave={() => setHoveredProvider(null)}
                                                >
                                                    {/* V3.4.6: 左侧 Provider 列表 */}
                                                    <div className={`w-36 border-r pr-1 max-h-64 overflow-y-auto custom-scrollbar flex flex-col justify-end ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-200'}`}>
                                                        {Object.entries(groupedApiConfigs)
                                                            .filter(([, group]) => group.models.some(m => (node.type === 'gen-image' ? isImageModelType(m.type) : m.type === 'Video')))
                                                            .map(([providerKey, group]) => (
                                                                <button
                                                                    key={providerKey}
                                                                    onMouseEnter={() => setHoveredProvider(providerKey)}
                                                                    className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left text-[10px] transition-colors ${hoveredProvider === providerKey
                                                                        ? theme === 'dark' ? 'bg-zinc-700 text-zinc-100' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-zinc-200 text-zinc-900'
                                                                        : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-400' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-600'
                                                                        }`}
                                                                >
                                                                    <span className="truncate font-medium">{group.name}</span>
                                                                    <ChevronRight size={10} className="opacity-50" />
                                                                </button>
                                                            ))}
                                                    </div>
                                                    {/* V3.4.6: 右侧 Model 列表 */}
                                                    <div className="flex-1 pl-1 max-h-64 overflow-y-auto custom-scrollbar flex flex-col justify-end">
                                                        {hoveredProvider && groupedApiConfigs[hoveredProvider]?.models
                                                            .filter(m => (node.type === 'gen-image' ? isImageModelType(m.type) : m.type === 'Video'))
                                                            .map((m) => {
                                                                const modelKey = m._uid || m.id;
                                                                const currentModelKey = resolveModelKey(node.settings?.model);
                                                                return (
                                                                    <button
                                                                        key={modelKey}
                                                                        onClick={() => {
                                                                            applyNodeModelSelection(node.id, node.type, modelKey);
                                                                            if (m.id === 'grok-3' && node.type === 'gen-video') {
                                                                                updateNodeSettings(node.id, { duration: '8s' });
                                                                            }
                                                                            // V3.4.8: 记住上次使用的模型
                                                                            if (node.type === 'gen-image') {
                                                                                setLastUsedImageModel(modelKey);
                                                                                try { localStorage.setItem('tapnow_last_image_model', modelKey); } catch { }
                                                                            } else if (node.type === 'gen-video') {
                                                                                setLastUsedVideoModel(modelKey);
                                                                                try { localStorage.setItem('tapnow_last_video_model', modelKey); } catch { }
                                                                            }
                                                                            setActiveDropdown(null);
                                                                            setHoveredProvider(null);
                                                                        }}
                                                                        className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${currentModelKey === modelKey
                                                                            ? theme === 'dark' ? 'bg-blue-600/30 text-blue-300' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-blue-100 text-blue-700'
                                                                            : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-300' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'
                                                                            }`}
                                                                    >
                                                                        <span className="text-[10px] font-medium truncate font-mono">{m.id}</span>
                                                                        <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(modelKey)}`}></div>
                                                                    </button>
                                                                );
                                                            })}
                                                        {!hoveredProvider && (
                                                            <div className={`text-[10px] px-2 py-3 text-center ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                                ← 选择 Provider
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            )}
                                        </div>

                                        {/* Midjourney版本选择器 */}
                                        {node.type === 'gen-image' && (() => {
                                            const currentModel = getApiConfigByKey(node.settings?.model);
                                            return currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                        })() && (
                                                <div className="relative flex-1 min-w-0">
                                                    <button
                                                        title={MJ_VERSIONS.find(v => v.value === node.settings?.mjVersion)?.label || 'MJ V7'}
                                                        onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'mjVersion' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'mjVersion' }); }}
                                                        className={`flex items-center gap-2 pl-1 pr-2 py-1 rounded text-[10px] transition-colors border w-full ${theme === 'dark'
                                                            ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-300 border-zinc-700/50'
                                                            : theme === 'solarized'
                                                                ? 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-700 border-[#d7cfb2]'
                                                                : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-700 border-zinc-300'
                                                            }`}
                                                    >
                                                        <span className="truncate">{MJ_VERSIONS.find(v => v.value === node.settings?.mjVersion)?.label || 'MJ V7'}</span>
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'mjVersion' && (
                                                        <div
                                                            className={`absolute bottom-full left-0 mb-1 w-32 rounded-lg shadow-xl p-1 z-[60] border max-h-64 overflow-y-auto custom-scrollbar ${theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                }`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                        >
                                                            {MJ_VERSIONS.map((v) => (
                                                                <button
                                                                    key={v.value}
                                                                    onClick={() => {
                                                                        updateNodeSettings(node.id, { mjVersion: v.value });
                                                                        setActiveDropdown(null);
                                                                    }}
                                                                    className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${theme === 'dark'
                                                                        ? 'hover:bg-zinc-800 text-zinc-300'
                                                                        : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'
                                                                        } ${node.settings?.mjVersion === v.value ? (theme === 'dark' ? 'bg-zinc-800' : theme === 'solarized' ? 'bg-[#fdf6e3]' : 'bg-zinc-100') : ''}`}
                                                                >
                                                                    <span className="text-xs font-medium">{v.label}</span>
                                                                    {node.settings?.mjVersion === v.value && (
                                                                        <svg className="w-3 h-3 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                                                                            <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                                        </svg>
                                                                    )}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                            )}

                                        <div className="flex gap-1 shrink-0">
                                            <div className="relative">
                                                <button
                                                    onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'ratio' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'ratio' }); }}
                                                    className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${theme === 'dark'
                                                        ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                        : theme === 'solarized'
                                                            ? 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-600 border-[#d7cfb2]'
                                                            : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                        }`}
                                                >
                                                    {(() => {
                                                        const ratioValue = node.settings?.ratio || 'Auto';
                                                        const ratioConfig = getApiConfigByKey(node.settings?.model);
                                                        return ratioValue === 'Auto'
                                                            ? 'Auto'
                                                            : getValueLabelWithNotes(ratioValue, !!ratioConfig?.ratioNotesEnabled, ratioConfig?.ratioNotes || {});
                                                    })()}
                                                </button>
                                                {activeDropdown?.nodeId === node.id && activeDropdown.type === 'ratio' && (
                                                    <div
                                                        className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-20 rounded-lg shadow-xl p-1 z-[60] border ${theme === 'dark'
                                                            ? 'bg-[#18181b] border-zinc-700'
                                                            : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                            }`}
                                                        onMouseDown={e => e.stopPropagation()}
                                                    >
                                                        {getRatiosForModel(node.settings?.model).map(r => {
                                                            const ratioConfig = getApiConfigByKey(node.settings?.model);
                                                            const label = r === 'Auto'
                                                                ? 'Auto'
                                                                : getValueLabelWithNotes(r, !!ratioConfig?.ratioNotesEnabled, ratioConfig?.ratioNotes || {});
                                                            return (
                                                                <button
                                                                    key={r}
                                                                    onClick={() => {
                                                                        updateNodeSettings(node.id, { ratio: r });
                                                                        setLastUsedRatio(r);
                                                                        try { localStorage.setItem('tapnow_last_ratio', r); } catch { }
                                                                        setActiveDropdown(null);
                                                                    }}
                                                                    className={`w-full text-center py-1 text-[10px] rounded ${theme === 'dark'
                                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                                        : theme === 'solarized' ? 'text-zinc-700 hover:bg-[#fdf6e3]' : 'text-zinc-700 hover:bg-zinc-100'
                                                                        }`}
                                                                >
                                                                    {label}
                                                                </button>
                                                            );
                                                        })}
                                                    </div>
                                                )}
                                            </div>

                                            {node.type === 'gen-video' && (() => {
                                                const currentModel = getApiConfigByKey(node.settings?.model);
                                                const modelId = currentModel?.id || currentModel?.modelName || '';
                                                const resolutionOptions = getVideoResolutionsForModel(modelId);
                                                if (!resolutionOptions.length) return null;
                                                const currentResolution = normalizeVideoResolution(node.settings?.resolution || lastUsedVideoResolution || '720P');
                                                const fallbackResolution = resolutionOptions.find((res) => res !== 'Auto') || '720P';
                                                const resolvedResolution = resolutionOptions.includes(currentResolution) ? currentResolution : fallbackResolution;
                                                if (resolvedResolution !== currentResolution) {
                                                    setTimeout(() => {
                                                        updateNodeSettings(node.id, { resolution: resolvedResolution });
                                                    }, 0);
                                                }
                                                return (
                                                    <div className="relative">
                                                        <button
                                                            onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'vres' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'vres' }); }}
                                                            className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${theme === 'dark'
                                                                ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                : theme === 'solarized'
                                                                    ? 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-600 border-[#d7cfb2]'
                                                                    : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                                }`}
                                                        >
                                                            {resolvedResolution === 'Auto'
                                                                ? '不选'
                                                                : getValueLabelWithNotes(
                                                                    resolvedResolution,
                                                                    !!currentModel?.videoResolutionNotesEnabled,
                                                                    currentModel?.videoResolutionNotes || {}
                                                                )}
                                                        </button>
                                                        {activeDropdown?.nodeId === node.id && activeDropdown.type === 'vres' && (
                                                            <div
                                                                className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-24 rounded-lg shadow-xl p-1 z-[60] border ${theme === 'dark'
                                                                    ? 'bg-[#18181b] border-zinc-700'
                                                                    : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                    }`}
                                                                onMouseDown={e => e.stopPropagation()}
                                                            >
                                                                {resolutionOptions.map(r => (
                                                                    <button
                                                                        key={r}
                                                                        onClick={() => {
                                                                            updateNodeSettings(node.id, { resolution: r });
                                                                            if (r !== 'Auto') {
                                                                                setLastUsedVideoResolution(r);
                                                                                try { localStorage.setItem('tapnow_last_video_res', r); } catch { }
                                                                            }
                                                                            setActiveDropdown(null);
                                                                        }}
                                                                className={`w-full text-center py-1 text-[10px] rounded ${theme === 'dark'
                                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                                    : theme === 'solarized' ? 'text-zinc-700 hover:bg-[#fdf6e3]' : 'text-zinc-700 hover:bg-zinc-100'
                                                                    }`}
                                                                    >
                                                                        {r === 'Auto'
                                                                            ? '不选'
                                                                            : getValueLabelWithNotes(
                                                                                r,
                                                                                !!currentModel?.videoResolutionNotesEnabled,
                                                                                currentModel?.videoResolutionNotes || {}
                                                                            )}
                                                                    </button>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })()}

                                            {node.type === 'gen-image' && (() => {
                                                const currentModel = getApiConfigByKey(node.settings?.model);
                                                const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                                return !isMidjourney;
                                            })() ? (
                                                <div className="relative">
                                                    <button
                                                        onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'res' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'res' }); }}
                                                        className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${theme === 'dark'
                                                            ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                            : theme === 'solarized'
                                                                ? 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-600 border-[#d7cfb2]'
                                                                : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                            }`}
                                                    >
                                                        {(() => {
                                                            const currentModel = getApiConfigByKey(node.settings?.model);
                                                            const modelId = currentModel?.id || currentModel?.modelName || '';
                                                            const availableResolutions = getResolutionsForModel(modelId);
                                                            const currentResolution = node.settings?.resolution || '2K';
                                                            const normalizedResolution = normalizeImageResolution(currentResolution);
                                                            // 如果当前分辨率不在可用选项中，使用第一个可用选项作为显示值
                                                            const displayResolution = availableResolutions.includes(normalizedResolution)
                                                                ? normalizedResolution
                                                                : (availableResolutions[0] || '2K');
                                                            const displayLabel = getValueLabelWithNotes(
                                                                displayResolution,
                                                                !!currentModel?.resolutionNotesEnabled,
                                                                currentModel?.resolutionNotes || {}
                                                            );
                                                            // 如果当前分辨率不在可用选项中，自动更新
                                                            if (currentResolution !== normalizedResolution && availableResolutions.includes(normalizedResolution)) {
                                                                setTimeout(() => {
                                                                    updateNodeSettings(node.id, { resolution: normalizedResolution });
                                                                }, 0);
                                                            } else if (!availableResolutions.includes(normalizedResolution) && availableResolutions.length > 0) {
                                                                setTimeout(() => {
                                                                    updateNodeSettings(node.id, { resolution: availableResolutions[0] });
                                                                }, 0);
                                                            }
                                                            return displayLabel;
                                                        })()}
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'res' && (() => {
                                                        const currentModel = getApiConfigByKey(node.settings?.model);
                                                        const modelId = currentModel?.id || currentModel?.modelName || '';
                                                        const availableResolutions = getResolutionsForModel(modelId);
                                                        return (
                                                            <div
                                                                className={`absolute bottom-full right-0 mb-1 w-24 rounded-lg shadow-xl p-1 z-[60] border ${theme === 'dark'
                                                                    ? 'bg-[#18181b] border-zinc-700'
                                                                    : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                    }`}
                                                                onMouseDown={e => e.stopPropagation()}
                                                            >
                                                                {availableResolutions.map(r => (
                                                                    <button
                                                                        key={r}
                                                                        onClick={() => {
                                                                            updateNodeSettings(node.id, { resolution: r });
                                                                            setLastUsedImageResolution(r);
                                                                            try { localStorage.setItem('tapnow_last_image_res', r); } catch { }
                                                                            setActiveDropdown(null);
                                                                        }}
                                                                        className={`w-full text-center py-1 text-[10px] rounded ${theme === 'dark'
                                                                            ? 'text-zinc-300 hover:bg-zinc-800'
                                                                            : theme === 'solarized' ? 'text-zinc-700 hover:bg-[#fdf6e3]' : 'text-zinc-700 hover:bg-zinc-100'
                                                                            }`}
                                                                    >
                                                                        {getValueLabelWithNotes(r, !!currentModel?.resolutionNotesEnabled, currentModel?.resolutionNotes || {})}
                                                                    </button>
                                                                ))}
                                                            </div>
                                                        );
                                                    })()}
                                                </div>
                                            ) : (
                                                (() => {
                                                    const currentModel = getApiConfigByKey(node.settings?.model);
                                                    const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                                    const durationOptions = getDefaultDurationsForModel(node.settings?.model);
                                                    const storedDuration = node.settings?.duration;
                                                    const currentDuration = durationOptions.includes(storedDuration)
                                                        ? storedDuration
                                                        : (durationOptions[0] || '5s');
                                                    if (!storedDuration || !durationOptions.includes(storedDuration)) {
                                                        setTimeout(() => {
                                                            updateNodeSettings(node.id, { duration: durationOptions[0] || '5s' });
                                                        }, 0);
                                                    }
                                                    return !isMidjourney ? (
                                                        <>
                                                            <div className="relative">
                                                                <button
                                                                    onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'duration' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'duration' }); }}
                                                                    className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${theme === 'dark'
                                                                        ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                        : theme === 'solarized'
                                                                            ? 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-700 border-[#d7cfb2]'
                                                                            : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                                        }`}
                                                                >
                                                                    {getValueLabelWithNotes(currentDuration, !!currentModel?.durationNotesEnabled, currentModel?.durationNotes || {})}
                                                                </button>
                                                                {activeDropdown?.nodeId === node.id && activeDropdown.type === 'duration' && (
                                                                    <div
                                                                        className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-20 rounded-lg shadow-xl p-1 z-[60] border ${theme === 'dark'
                                                                            ? 'bg-[#18181b] border-zinc-700'
                                                                            : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                            }`}
                                                                        onMouseDown={e => e.stopPropagation()}
                                                                    >
                                                                        {(durationOptions.length > 0 ? durationOptions : ['5s', '10s']).map(d => (
                                                                            <button
                                                                                key={d}
                                                                                onClick={() => {
                                                                                    updateNodeSettings(node.id, { duration: d });
                                                                                    setActiveDropdown(null);
                                                                                }}
                                                                                className={`w-full text-center py-1 text-[10px] rounded ${theme === 'dark'
                                                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                                                    : theme === 'solarized' ? 'text-zinc-700 hover:bg-[#fdf6e3]' : 'text-zinc-700 hover:bg-zinc-100'
                                                                                    }`}
                                                                            >
                                                                                {getValueLabelWithNotes(d, !!currentModel?.durationNotesEnabled, currentModel?.durationNotes || {})}
                                                                            </button>
                                                                        ))}
                                                                    </div>
                                                                )}
                                                            </div>

                                                            {node.type === 'gen-video' && currentModel?.supportsHD && (
                                                                <label className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border cursor-pointer transition-colors ${theme === 'dark'
                                                                    ? node.settings?.isHD ? 'bg-blue-600/30 border-blue-500 text-blue-300' : 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                    : theme === 'solarized'
                                                                        ? node.settings?.isHD ? 'bg-[#eee8d5] border-[#d7cfb2] text-zinc-800' : 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-700 border-[#d7cfb2]'
                                                                        : node.settings?.isHD ? 'bg-blue-500/30 border-blue-400 text-blue-700' : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                                    }`} onClick={e => e.stopPropagation()}>
                                                                    <input
                                                                        type="checkbox"
                                                                        checked={node.settings?.isHD || false}
                                                                        onChange={(e) => {
                                                                            e.stopPropagation();
                                                                            updateNodeSettings(node.id, { isHD: e.target.checked });
                                                                        }}
                                                                        className="w-3 h-3 cursor-pointer"
                                                                        onMouseDown={e => e.stopPropagation()}
                                                                />
                                                                <span>HD</span>
                                                            </label>
                                                            )}
                                                            {node.type === 'gen-video' && (() => {
                                                                const supportsFirstLastFrame = !!currentModel?.supportsFirstLastFrame;
                                                                const useFirstLastFrame = !!(node.settings?.useFirstLastFrame || node.settings?.veoFramesMode);
                                                                if (!supportsFirstLastFrame) return null;
                                                                return (
                                                                    <label className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border cursor-pointer transition-colors ${theme === 'dark'
                                                                        ? useFirstLastFrame ? 'bg-emerald-600/25 border-emerald-500 text-emerald-200' : 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                        : theme === 'solarized'
                                                                            ? useFirstLastFrame ? 'bg-[#eee8d5] border-[#d7cfb2] text-zinc-800' : 'bg-[#fdf6e3] hover:bg-[#eee8d5] text-zinc-700 border-[#d7cfb2]'
                                                                            : useFirstLastFrame ? 'bg-emerald-500/20 border-emerald-300 text-emerald-700' : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                                        }`} onClick={e => e.stopPropagation()}>
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={useFirstLastFrame}
                                                                            onChange={(e) => {
                                                                                e.stopPropagation();
                                                                                updateNodeSettings(node.id, { useFirstLastFrame: e.target.checked, veoFramesMode: e.target.checked });
                                                                            }}
                                                                            className="w-3 h-3 cursor-pointer"
                                                                            onMouseDown={e => e.stopPropagation()}
                                                                        />
                                                                        <span>{t('首尾帧')}</span>
                                                                    </label>
                                                                );
                                                            })()}
                                                        </>
                                                    ) : null;
                                                })()
                                            )}
                                        </div>
                                        <button onClick={() => {
                                            const basePrompt = node.type === 'gen-image' ? node.settings?.prompt || '' : node.settings?.videoPrompt || '';
                                            const connectedTexts = getConnectedTextNodes(node.id);
                                            const finalPrompt = connectedTexts.length > 0 ? connectedTexts.join(' ') + (basePrompt ? ' ' + basePrompt : '') : basePrompt;
                                            startGeneration(finalPrompt, node.type === 'gen-image' ? 'image' : 'video', connectedImages, node.id, {
                                                customParams: node.settings?.customParams
                                            });
                                        }} className="bg-blue-600 hover:bg-blue-500 text-white p-1.5 rounded-md shadow-lg active:scale-95 transition-transform shrink-0" title={t('生成')}>
                                            <Play size={12} fill="currentColor" />
                                        </button>
                                    </div>
                                </div>
                            );
                        })()
                    }
                </div>
            </div >
        );
    }, [selectedNodeId, selectedNodeIds, hoverTargetId, nodeConnectedStatus, adjacentNodesCache, apiConfigsMap, getConnectedInputImages, theme, view, dragNodeId, connectingSource, connectingTarget, connectingInputType, deleteNode, handleNodeMouseUp, screenToWorld, setDragNodeId, setSelectedNodeId, setSelectedNodeIds, setActiveDropdown, setHoverTargetId, setConnectingSource, setConnectingTarget, setConnectingInputType, setResizingNodeId, setLightboxItem, isVideoUrl, updateNodeSettings, getConnectedTextNodes, startGeneration, getDefaultDurationForModel, getDefaultDurationsForModel, getConnectedGenNodes, getConnectedVideoInputNode, getConnectedVideoAnalyzeNode, handleCanvasDragOver, handleGenNodeDrop, markInteraction]);

    // 高性能模式：当节点数量超过 50 或手动开启时启用
    const isPerfMode = nodes.length > 50 || globalPerformanceMode !== 'off';
    // 交互模式：正在拖拽或缩放时启用
    const isInteracting = isDragging || isPanning;

    return (
        <>
            {/* 极简艺术进度条 */}
            <ArtisticProgress
                visible={progressState.visible}
                progress={progressState.progress}
                status={progressState.status}
                type={progressState.type}
            />
            <div
                className={`w-full h-screen font-sans overflow-hidden select-none flex flex-col transition-colors duration-300 ${theme === 'dark'
                    ? 'bg-[#09090b] text-white'
                    : theme === 'solarized'
                        ? 'bg-[#fdf6e3] text-[#586e75]'
                        : 'bg-zinc-100 text-zinc-900'
                    } ${isPerfMode ? 'perf-mode' : ''} ${isInteracting ? 'interacting' : ''}`}
                onClick={() => {
                    if (historyContextMenu.visible) setHistoryContextMenu(prev => ({ ...prev, visible: false }));
                    if (historySendMenuOpen) setHistorySendMenuOpen(false);
                    if (frameContextMenu.visible) setFrameContextMenu(prev => ({ ...prev, visible: false }));
                }}
            >
                {/* Top Bar */}
                <div
                    className={`h-12 flex items-center justify-between px-4 z-50 shrink-0 border-b transition-colors duration-300 ${theme === 'dark'
                        ? 'bg-[#09090b] border-zinc-800'
                    : theme === 'solarized'
                        ? 'bg-[#eee8d5] border-[#d7cfb2]'
                            : 'bg-white border-zinc-200'
                        }`}
                >
                    <div className="flex items-center gap-3">
                        <div className="w-7 h-7 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-md flex items-center justify-center">
                            <Layers size={16} className="text-white" />
                        </div>
                        <span
                            className={`font-bold text-sm tracking-wide ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'
                                }`}
                        >
                            Tapnow Studio
                        </span>
                        {/* 功能4：项目名称编辑 */}
                        {isEditingProjectName ? (
                            <input
                                ref={projectNameInputRef}
                                type="text"
                                value={projectName}
                                onChange={(e) => setProjectName(e.target.value)}
                                onBlur={() => {
                                    setIsEditingProjectName(false);
                                    try {
                                        localStorage.setItem('tapnow_project_name', projectName);
                                    } catch (e) { }
                                }}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                        setIsEditingProjectName(false);
                                        try {
                                            localStorage.setItem('tapnow_project_name', projectName);
                                        } catch (e) { }
                                    }
                                }}
                                className={`ml-2 px-2 py-0.5 text-xs border rounded outline-none ${theme === 'dark'
                                    ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                    }`}
                                style={{ minWidth: '100px', maxWidth: '200px' }}
                            />
                        ) : (
                            <span
                                onClick={() => {
                                    setIsEditingProjectName(true);
                                    setTimeout(() => projectNameInputRef.current?.focus(), 0);
                                }}
                                className={`ml-2 text-xs cursor-pointer hover:underline ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'
                                    }`}
                                title={t('点击编辑项目名称')}
                            >
                                {projectName}
                            </span>
                        )}
                        <button
                            onClick={handleNewProject}
                            className={`p-1 rounded-md border transition-colors ${theme === 'dark'
                                ? 'border-zinc-700 text-zinc-300 hover:bg-zinc-800'
                                : theme === 'solarized'
                                    ? 'border-[#d7cfb2] text-[#586e75] hover:bg-[#fdf6e3]'
                                    : 'border-zinc-300 text-zinc-600 hover:bg-zinc-100'
                                }`}
                            title={t('新建空项目（清空当前内容）')}
                        >
                            <Plus size={12} />
                        </button>
                    </div>
                    <div className="flex items-center gap-2">
                        {/* 性能模式开关 V2.6.1 */}
                        <button
                            onClick={() => {
                                const modes = ['off', 'normal', 'ultra'];
                                const currentIdx = modes.indexOf(globalPerformanceMode);
                                const nextIdx = (currentIdx + 1) % modes.length;
                                const newMode = modes[nextIdx];
                                setGlobalPerformanceMode(newMode);
                            }}
                            className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors border ${globalPerformanceMode !== 'off'
                                ? theme === 'dark'
                                    ? 'bg-blue-600 border-blue-500 text-white hover:bg-blue-500'
                                    : theme === 'solarized'
                                        ? 'bg-blue-600 border-blue-500 text-[#fdf6e3] hover:bg-blue-500'
                                        : 'bg-blue-500 border-blue-400 text-white hover:bg-blue-600'
                                : theme === 'dark'
                                    ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                    : theme === 'solarized'
                                        ? 'bg-[#616161] border-[#525252] text-[#fdf6e3] hover:bg-[#555555]'
                                        : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                            title={
                                globalPerformanceMode === 'ultra' ? '极致性能模式（点击关闭）'
                                    : globalPerformanceMode === 'normal' ? '普通性能模式（点击切换极致）'
                                        : '性能模式已关闭（点击开启）'
                            }
                        >
                            <Zap size={14} className={globalPerformanceMode !== 'off' ? 'fill-current' : ''} />
                            <span>{globalPerformanceMode === 'ultra' ? t('极致模式') : t('性能模式')}</span>
                        </button>
                        {/* 功能1：下载按钮 */}
                        <button
                            onClick={handleBatchDownload}
                            className={`flex items-center gap-1 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors border ${theme === 'dark'
                                ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                : theme === 'solarized'
                                    ? 'bg-[#616161] border-[#525252] text-[#fdf6e3] hover:bg-[#555555]'
                                    : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                            title={t('批量下载选中的图片/视频节点')}
                        >
                            <Download size={14} />
                            <span>{t('下载')}</span>
                        </button>
                        <button
                            onClick={handleToggleTheme}
                            className={`flex items-center gap-1 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors border ${theme === 'dark'
                                ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                : theme === 'solarized'
                                    ? 'bg-[#616161] border-[#525252] text-[#fdf6e3] hover:bg-[#555555]'
                                    : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                            title={t('切换主题')}
                        >
                            {(() => {
                                if (theme === 'light') {
                                    return (
                                        <>
                                            <Sun size={14} className="text-amber-400" />
                                            <span>{t('亮光')}</span>
                                        </>
                                    );
                                }
                                if (theme === 'solarized') {
                                    return (
                                        <>
                                            <Sun size={14} className="text-yellow-600" />
                                            <span>{t('日光')}</span>
                                        </>
                                    );
                                }
                                return (
                                    <>
                                        <Moon size={14} className="text-blue-500" />
                                        <span>{t('暗光')}</span>
                                    </>
                                );
                            })()}
                        </button>
                        <button
                            onClick={() => setLanguage(prev => prev === 'zh' ? 'en' : 'zh')}
                            className={`flex items-center gap-1 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors border ${theme === 'dark'
                                ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                : theme === 'solarized'
                                    ? 'bg-[#616161] border-[#525252] text-[#fdf6e3] hover:bg-[#555555]'
                                    : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                            title={t('切换语言')}
                        >
                            <span>{language === 'zh' ? t('中文') : t('英文')}</span>
                        </button>
                        {/* V3.4.6: 撤销/重做按钮 */}
                        <button
                            onClick={undo}
                            disabled={undoStack.length === 0}
                            className={`flex items-center gap-1 px-2 py-1.5 rounded-lg text-xs font-medium transition-colors border ${undoStack.length === 0
                                ? theme === 'dark'
                                    ? 'bg-zinc-900/50 border-zinc-800 text-zinc-600 cursor-not-allowed'
                                    : theme === 'solarized'
                                        ? 'bg-[#616161]/60 border-[#525252] text-[#fdf6e3]/60 cursor-not-allowed'
                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-400 cursor-not-allowed' : 'bg-zinc-50 border-zinc-200 text-zinc-400 cursor-not-allowed'
                                : theme === 'dark'
                                    ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                    : theme === 'solarized'
                                        ? 'bg-[#616161] border-[#525252] text-[#fdf6e3] hover:bg-[#555555]'
                                        : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                            title={t('撤销 (Ctrl+Z)')}
                        >
                            <RotateCcw size={14} />
                        </button>
                        <button
                            onClick={redo}
                            disabled={redoStack.length === 0}
                            className={`flex items-center gap-1 px-2 py-1.5 rounded-lg text-xs font-medium transition-colors border ${redoStack.length === 0
                                ? theme === 'dark'
                                    ? 'bg-zinc-900/50 border-zinc-800 text-zinc-600 cursor-not-allowed'
                                    : theme === 'solarized'
                                        ? 'bg-[#616161]/60 border-[#525252] text-[#fdf6e3]/60 cursor-not-allowed'
                                        : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-400 cursor-not-allowed' : 'bg-zinc-50 border-zinc-200 text-zinc-400 cursor-not-allowed'
                                : theme === 'dark'
                                    ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                    : theme === 'solarized'
                                        ? 'bg-[#616161] border-[#525252] text-[#fdf6e3] hover:bg-[#555555]'
                                        : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                            title={t('重做 (Ctrl+Shift+Z)')}
                        >
                            <RotateCw size={14} />
                        </button>
                        <Button
                            variant="ghost"
                            onClick={handleNewProject}
                            className={theme === 'solarized' ? '!bg-[#616161] !border !border-[#525252] !text-[#fdf6e3] hover:!bg-[#555555]' : ''}
                        >
                            {t('清空')}
                        </Button>
                        <Button
                            variant="secondary"
                            icon={Settings}
                            onClick={() => setSettingsOpen(true)}
                            className={theme === 'solarized' ? '!bg-[#616161] !border-[#525252] !text-[#fdf6e3] hover:!bg-[#555555]' : ''}
                        >
                            {t('API 设置')}
                        </Button>
                    </div>
                </div>

                <div className={`flex-1 relative overflow-hidden flex transition-colors duration-300 ${theme === 'dark'
                    ? 'bg-[#09090b]'
                    : theme === 'solarized'
                        ? 'bg-[#fdf6e3]'
                        : 'bg-zinc-100'
                    }`}>
                    {/* Sidebar */}
                    <div
                        className={`w-14 border-r flex flex-col items-center py-3 gap-3 z-40 shrink-0 transition-colors duration-300 ${theme === 'dark'
                            ? 'bg-[#09090b] border-zinc-800'
                            : theme === 'solarized'
                                ? 'bg-[#eee8d5] border-[#d7cfb2]'
                                : 'bg-white border-zinc-200'
                            }`}
                    >
                        <button
                            onClick={autoArrangeNodes}
                            className={`p-2.5 rounded-lg transition-all mb-2 ${theme === 'dark'
                                ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                : 'text-zinc-500 hover:text-zinc-800 hover:bg-zinc-200'
                                }`}
                            title={t('自动整理节点（对齐、排列、去除堆叠）')}
                        >
                            <Layout size={18} />
                        </button>
                        {[{ id: 'select', icon: MousePointer2 }, { id: 'history', icon: History }, { id: 'characters', icon: Users }].map((tool) => (
                            <button
                                key={tool.id}
                                onClick={() => {
                                    setActiveTool(tool.id);
                                    if (tool.id === 'history') setHistoryOpen(!historyOpen);
                                    if (tool.id === 'characters') setCharactersOpen(!charactersOpen);
                                }}
                                className={`p-2.5 rounded-lg transition-all ${activeTool === tool.id
                                    ? theme === 'dark'
                                        ? 'bg-zinc-800 text-white'
                                        : theme === 'solarized'
                                            ? 'bg-[#616161] text-[#fdf6e3] hover:bg-[#555555]'
                                            : 'bg-zinc-200 text-zinc-900'
                                    : theme === 'dark'
                                        ? 'text-zinc-500 hover:text-zinc-300'
                                        : 'text-zinc-500 hover:text-zinc-800'
                                    }`}
                            >
                                <tool.icon size={18} />
                            </button>
                        ))}
                        <div className="flex-1"></div>
                        <button
                            onClick={() => setIsChatOpen(!isChatOpen)}
                            className={`p-2.5 rounded-lg transition-all mb-2 ${isChatOpen
                                ? theme === 'solarized'
                                    ? 'bg-[#616161] text-[#fdf6e3] hover:bg-[#555555]'
                                    : 'bg-blue-600 text-white'
                                : theme === 'dark'
                                    ? 'text-zinc-500 hover:text-zinc-300'
                                    : 'text-zinc-500 hover:text-zinc-800'
                                }`}
                            title={t('AI 对话')}
                        >
                            <MessageSquare size={18} />
                        </button>
                        {/* 功能5：保存和加载按钮 */}
                        <button
                            onClick={handleSaveProject}
                            className={`p-2.5 rounded-lg transition-all ${theme === 'dark'
                                ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                : 'text-zinc-500 hover:text-zinc-800 hover:bg-zinc-200'
                                }`}
                            title={t('保存项目')}
                        >
                            <Save size={18} />
                        </button>
                        <button
                            onClick={handleLoadProject}
                            className={`p-2.5 rounded-lg transition-all mb-2 ${theme === 'dark'
                                ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                : 'text-zinc-500 hover:text-zinc-800 hover:bg-zinc-200'
                                }`}
                            title={t('加载项目')}
                        >
                            <FolderOpen size={18} />
                        </button>
                        <button
                            onClick={handleImportWorkflow}
                            className={`p-2.5 rounded-lg transition-all mb-2 ${theme === 'dark'
                                ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                : 'text-zinc-500 hover:text-zinc-800 hover:bg-zinc-200'
                                }`}
                            title={t('导入工作流')}
                        >
                            <Download size={18} />
                        </button>
                    </div>

                    {/* History Panel */}
                    {historyOpen && (
                        <div
                            className={`w-72 z-30 flex flex-col animate-in slide-in-from-left border-r transition-colors duration-300 ${theme === 'dark'
                                ? 'bg-[#121214] border-zinc-800'
                                : theme === 'solarized'
                                    ? 'bg-[#fdf6e3] border-[#d7cfb2]'
                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                }`}
                        >
                            <div
                                className={`p-3 border-b flex justify-between items-center ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}
                            >
                                <div className="flex flex-col gap-1 min-w-0">
                                    <div className="flex items-end gap-2">
                                        <h3
                                            className={`font-bold text-xs leading-tight ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                                }`}
                                        >
                                            <span className="block">{t('生成')}</span>
                                            <span className="block">{t('历史')}</span>
                                        </h3>
                                        <span className="text-[9px] text-zinc-500 font-mono whitespace-nowrap">
                                            {downloadDisplay.visible
                                                ? `${downloadDisplay.current}/${downloadDisplay.total > 0 ? Math.round((downloadDisplay.current / downloadDisplay.total) * 100) : 0}%`
                                                : `${history.length}/${historyLimit > 0 ? Math.min(100, Math.round((history.length / historyLimit) * 100)) : 0}%`}
                                        </span>
                                    </div>
                                </div>
                                <div className="flex items-center gap-1">
                                    <button
                                        onClick={() => {
                                            const modes = ['off', 'normal', 'ultra'];
                                            const currentIdx = modes.indexOf(performanceMode);
                                            const nextIdx = (currentIdx + 1) % modes.length;
                                            setPerformanceMode(modes[nextIdx]);
                                        }}
                                        className={`p-1.5 rounded transition-colors flex items-center gap-1 ${performanceMode === 'ultra'
                                            ? theme === 'dark'
                                                ? 'text-orange-400 bg-orange-500/20 hover:bg-orange-500/30'
                                                : 'text-orange-600 bg-orange-100 hover:bg-orange-200'
                                            : performanceMode === 'normal'
                                                ? theme === 'dark'
                                                    ? 'text-green-400 bg-green-500/20 hover:bg-green-500/30'
                                                    : 'text-green-600 bg-green-100 hover:bg-green-200'
                                                : theme === 'dark'
                                                    ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                            }`}
                                        title={
                                            performanceMode === 'ultra' ? '极致性能模式（点击关闭）'
                                                : performanceMode === 'normal' ? '普通性能模式（点击切换极致）'
                                                    : '性能模式已关闭（点击开启）'
                                        }
                                    >
                                        <Zap size={14} />
                                    </button>
                                    <button
                                        onClick={() => setHistoryCachePanelOpen(prev => !prev)}
                                        className={`p-1.5 rounded transition-colors ${historyCachePanelOpen
                                            ? theme === 'dark'
                                                ? 'text-blue-400 bg-blue-500/20 hover:bg-blue-500/30'
                                                : 'text-blue-600 bg-blue-100 hover:bg-blue-200'
                                            : theme === 'dark'
                                                ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                            }`}
                                        title={t('本地缓存设置')}
                                    >
                                        <FolderOpen size={14} />
                                    </button>
                                    <button
                                        onClick={() => setHistoryQueuePanelOpen(prev => !prev)}
                                        className={`p-1.5 rounded transition-colors ${historyQueuePanelOpen
                                            ? theme === 'dark'
                                                ? 'text-blue-400 bg-blue-500/20 hover:bg-blue-500/30'
                                                : 'text-blue-600 bg-blue-100 hover:bg-blue-200'
                                            : theme === 'dark'
                                                ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                            }`}
                                        title={t('全局队列')}
                                    >
                                        <Layers size={14} />
                                    </button>
                                    {/* V3.5.8: 全选/取消全选按钮 */}
                                    <button
                                        onClick={() => {
                                            // V3.5.18 Fix: Smart Select All logic
                                            // If any filters (search/favorites) are active, select filtered items
                                            // If no filters, select ALL completed items (ignore 24h session logic which was confusing users)

                                            // Determine current visible/filtered list (simplified logic here as filtering is done in render)
                                            // Since we don't have direct access to the filtered list variable 'filteredHistory' inside this scope easily without refactoring,
                                            // We will assume the user wants to select ALL completed items in the history list if they click Select All.
                                            // TODO: Ideally we should select only currently VISIBLE items if search/filter is active.

                                            const allCompletedItems = history.filter(h => h.status === 'completed');
                                            const targetItems = allCompletedItems;

                                            if (historySelection.size > 0) {
                                                // 有选中的，清空选择
                                                setHistorySelection(new Set());
                                            } else {
                                                // 没有选中的，全选当前可见项目
                                                setHistorySelection(new Set(targetItems.map(h => h.id)));
                                            }
                                        }}
                                        className={`p-1.5 rounded transition-colors flex items-center gap-1 ${historySelection.size > 0
                                            ? theme === 'dark'
                                                ? 'text-blue-400 bg-blue-500/20 hover:bg-blue-500/30'
                                                : 'text-blue-600 bg-blue-100 hover:bg-blue-200'
                                            : theme === 'dark'
                                                ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                            }`}
                                        title={historySelection.size > 0 ? `${t('取消全选')} (${historySelection.size})` : t('全选')}
                                    >
                                        {historySelection.size > 0 ? <CheckCircle2 size={14} /> : <Circle size={14} />}
                                        {historySelection.size > 0 && (
                                            <span className="text-[9px] font-bold">{historySelection.size}</span>
                                        )}
                                    </button>
                                    <button
                                        onClick={() => setBatchModalOpen(true)}
                                        className={`p-1.5 rounded transition-colors ${theme === 'dark'
                                            ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                            : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                            }`}
                                        title={t('批量管理')}
                                    >
                                        <LayoutGrid size={14} />
                                    </button>
                                    {/* V3.4.12: 批量下载按钮 - 重做 */}
                                    <div className="relative">
                                        <button
                                            onClick={() => {
                                                // 如果有选中的历史项，直接下载选中项
                                                if (historySelection.size > 0) {
                                                    const selectedItems = [...historySelection].map(id => history.find(h => h.id === id)).filter(Boolean);
                                                    handleHistoryBatchDownload(selectedItems);
                                                } else {
                                                    setActiveDropdown(activeDropdown?.type === 'batch-download' ? null : { type: 'batch-download' });
                                                }
                                            }}
                                            className={`p-1.5 rounded transition-colors ${historySelection.size > 0
                                                ? 'text-blue-400 bg-blue-500/20'
                                                : theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                                }`}
                                            title={historySelection.size > 0 ? `${t('下载选中')} (${historySelection.size})` : t('批量下载')}
                                        >
                                            <Download size={14} />
                                        </button>
                                        {activeDropdown?.type === 'batch-download' && historySelection.size === 0 && (
                                            <div
                                                className={`absolute right-0 top-full mt-1 w-40 rounded-lg shadow-xl py-1 z-50 border ${theme === 'dark'
                                                    ? 'bg-[#18181b] border-zinc-700'
                                                    : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                    }`}
                                                onMouseLeave={() => setActiveDropdown(null)}
                                            >
                                                <button
                                                    onClick={() => {
                                                        setActiveDropdown(null);
                                                        // 本次生成：sessionStartTime 之后的记录
                                                        const sessionItems = history.filter(item => (item.startTime || 0) >= sessionStartTime);
                                                        handleHistoryBatchDownload(sessionItems);
                                                    }}
                                                    className={`w-full text-left px-3 py-2 text-xs transition-colors ${theme === 'dark'
                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                        : 'text-zinc-700 hover:bg-zinc-100'
                                                        }`}
                                                >
                                                    {t('本次生成')} ({history.filter(item => (item.startTime || 0) >= sessionStartTime).length})
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        setActiveDropdown(null);
                                                        handleHistoryBatchDownload(history);
                                                    }}
                                                    className={`w-full text-left px-3 py-2 text-xs transition-colors ${theme === 'dark'
                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                        : 'text-zinc-700 hover:bg-zinc-100'
                                                        }`}
                                                >
                                                    {t('全部资产')} ({history.length})
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={() => setHistoryOpen(false)}>
                                        <X
                                            size={12}
                                            className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}
                                        />
                                    </button>
                                </div>
                            </div>
                            {downloadDisplay.visible && (
                                <div className="w-full px-3 pb-2">
                                    <div className={`w-full h-1.5 rounded-full overflow-hidden ${theme === 'dark' ? 'bg-zinc-800' : 'bg-zinc-200'}`}>
                                        <div
                                            className="h-full bg-blue-500 transition-all duration-200"
                                            style={{ width: `${downloadDisplay.total > 0 ? (downloadDisplay.current / downloadDisplay.total) * 100 : 0}%` }}
                                        />
                                    </div>
                                </div>
                            )}
                            {localCacheEnabled && localCacheBannerVisible && (
                                <div className={`w-full border-b ${theme === 'dark' ? 'border-zinc-800' : theme === 'solarized' ? 'border-[#d7cfb2]' : 'border-zinc-200'}`}>
                                    <div className={`flex items-center justify-between gap-2 text-[10px] px-3 py-1.5 ${localCacheServerConnected
                                        ? theme === 'dark'
                                            ? 'bg-emerald-500/10 text-emerald-200'
                                            : 'bg-emerald-50 text-emerald-700'
                                        : theme === 'dark'
                                            ? 'bg-red-500/10 text-red-200'
                                            : 'bg-red-50 text-red-600'
                                        }`}>
                                        <div className="flex items-center gap-2">
                                            <span className={`inline-block w-2 h-2 rounded-full ${localCacheServerConnected ? 'bg-green-500' : 'bg-red-500'}`}></span>
                                            <span>{localCacheServerConnected ? t('本地缓存已连接 - 图片将优先从本地读取') : t('本地缓存未连接')}</span>
                                        </div>
                                        <button
                                            onClick={() => {
                                                setLocalCacheEnabled(false);
                                                setLocalCacheBannerVisible(false);
                                            }}
                                            className={`p-0.5 rounded ${theme === 'dark'
                                                ? 'text-zinc-300 hover:text-white hover:bg-zinc-800/60'
                                                : 'text-zinc-400 hover:text-zinc-600 hover:bg-zinc-200'
                                                }`}
                                            title={t('关闭本地缓存')}
                                        >
                                            <X size={10} />
                                        </button>
                                    </div>
                                </div>
                            )}
                            <div className="flex-1 overflow-y-auto custom-scrollbar p-3 space-y-3">
                                {(historyQueuePanelOpen || historyCachePanelOpen) && (
                                    <div
                                        className={`sticky top-0 z-20 space-y-3 pb-3 ${theme === 'dark'
                                            ? 'bg-[#121214]'
                                            : theme === 'solarized'
                                                ? 'bg-[#fdf6e3]'
                                                : 'bg-zinc-50'
                                            }`}
                                    >
                                {historyQueuePanelOpen && (
                                    <div className={`rounded-lg border p-3 space-y-3 ${theme === 'dark' ? 'bg-zinc-900/60 border-zinc-800' : 'bg-white border-zinc-200'}`}>
                                        <div className="flex items-center justify-between gap-2">
                                            <span className={`text-xs font-semibold ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-700'}`}>{t('全局队列')}</span>
                                            <div className="flex items-center gap-1">
                                                <button
                                                    onClick={() => setBatchQueueMode('pipeline')}
                                                    className={`text-[10px] px-2 py-1 rounded ${batchQueueMode === 'pipeline'
                                                        ? theme === 'dark'
                                                            ? 'bg-blue-600/30 text-blue-300'
                                                            : 'bg-blue-100 text-blue-600'
                                                        : theme === 'dark'
                                                            ? 'bg-zinc-800 text-zinc-400 hover:text-zinc-200'
                                                            : 'bg-zinc-100 text-zinc-500 hover:text-zinc-700'
                                                        }`}
                                                >
                                                    {t('管线')}
                                                </button>
                                                <button
                                                    onClick={() => setBatchQueueMode('parallel')}
                                                    className={`text-[10px] px-2 py-1 rounded ${batchQueueMode === 'parallel'
                                                        ? theme === 'dark'
                                                            ? 'bg-blue-600/30 text-blue-300'
                                                            : 'bg-blue-100 text-blue-600'
                                                        : theme === 'dark'
                                                            ? 'bg-zinc-800 text-zinc-400 hover:text-zinc-200'
                                                            : 'bg-zinc-100 text-zinc-500 hover:text-zinc-700'
                                                        }`}
                                                >
                                                    {t('并行')}
                                                </button>
                                            </div>
                                        </div>
                                        {(() => {
                                            const groupMap = new Map();
                                            batchGroups.forEach(group => {
                                                groupMap.set(group.id, { ...group, queued: [], running: [] });
                                            });

                                            const getFallbackGroup = (item) => {
                                                const node = nodesMap.get(item.nodeId);
                                                const projectTitle = node?.settings?.projectTitle || '未命名分镜';
                                                const fallbackId = item.batchId || `legacy-${item.nodeId}`;
                                                if (!groupMap.has(fallbackId)) {
                                                    groupMap.set(fallbackId, {
                                                        id: fallbackId,
                                                        nodeId: item.nodeId,
                                                        projectTitle,
                                                        total: 0,
                                                        concurrency: item.batchConcurrency || 1,
                                                        createdAt: Date.now(),
                                                        mode: item.mode,
                                                        taskIndex: item.taskIndex || 0,
                                                        shotIds: [],
                                                        queued: [],
                                                        running: []
                                                    });
                                                }
                                                return groupMap.get(fallbackId);
                                            };

                                            batchQueue.forEach(item => {
                                                const group = item.batchId && groupMap.has(item.batchId)
                                                    ? groupMap.get(item.batchId)
                                                    : getFallbackGroup(item);
                                                if (!group) return;
                                                if (!Array.isArray(group.queued)) group.queued = [];
                                                group.queued.push(item);
                                            });

                                            batchRunningItems.forEach(item => {
                                                const group = item.batchId && groupMap.has(item.batchId)
                                                    ? groupMap.get(item.batchId)
                                                    : getFallbackGroup(item);
                                                if (!group) return;
                                                if (!Array.isArray(group.running)) group.running = [];
                                                group.running.push(item);
                                            });

                                            const queueGroups = [...groupMap.values()]
                                                .filter(group => group.queued.length > 0 || group.running.length > 0)
                                                .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));

                                            const getShotLabel = (nodeId, shotId) => {
                                                const node = nodesMap.get(nodeId);
                                                const shot = node?.settings?.shots?.find(s => isSameShotId(s.id, shotId));
                                                return (shot?.description || shot?.prompt || '未命名镜头').trim();
                                            };

                                            return (
                                                <>
                                                    <div className={`text-[10px] ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>
                                                        运行 {batchRunningItems.length} · 排队 {batchQueue.length}
                                                    </div>
                                                    <div className="flex gap-2">
                                                        <button
                                                            onClick={() => {
                                                                if (batchQueue.length === 0) return;
                                                                if (confirm(t('确定清空排队任务吗？'))) clearBatchQueue(false);
                                                            }}
                                                            className={`text-[10px] px-2 py-1 rounded ${theme === 'dark'
                                                                ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                                : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'}`}
                                                        >
                                                            {t('清空排队')}
                                                        </button>
                                                        <button
                                                            onClick={() => {
                                                                if (batchRunningItems.length === 0 && batchQueue.length === 0) return;
                                                                if (confirm(t('确定终止所有生成并清空队列吗？'))) clearBatchQueue(true);
                                                            }}
                                                            className={`text-[10px] px-2 py-1 rounded ${theme === 'dark'
                                                                ? 'bg-red-900/40 text-red-300 hover:bg-red-900/60'
                                                                : 'bg-red-50 text-red-600 hover:bg-red-100'}`}
                                                        >
                                                            {t('终止全部')}
                                                        </button>
                                                    </div>
                                                    {queueGroups.length === 0 ? (
                                                        <div className={`text-xs text-center py-4 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                            队列为空
                                                        </div>
                                                    ) : (
                                                        <div className="space-y-3 max-h-64 overflow-y-auto custom-scrollbar pr-1">
                                                            {queueGroups.map(group => {
                                                                const concurrencyValue = Math.max(1, group.concurrency || 1);
                                                                const totalCount = group.total || (group.queued.length + group.running.length);
                                                                const totalRounds = Math.ceil(totalCount / concurrencyValue);
                                                                const pendingRounds = Math.ceil(group.queued.length / concurrencyValue);
                                                                const taskLabel = group.taskIndex ? `Task ${group.taskIndex}` : 'Task';
                                                                const combined = [
                                                                    ...group.running.map(item => ({ ...item, status: 'running' })),
                                                                    ...group.queued.map(item => ({ ...item, status: 'queued' }))
                                                                ].sort((a, b) => (a.batchOrder ?? 0) - (b.batchOrder ?? 0));

                                                                return (
                                                                    <div
                                                                        key={group.id}
                                                                        className={`rounded-lg border p-2 ${theme === 'dark'
                                                                            ? 'border-zinc-800 bg-zinc-900/60'
                                                                            : 'border-zinc-200 bg-zinc-50'}`}
                                                                    >
                                                                        <div className="flex items-start justify-between gap-2">
                                                                            <div>
                                                                                <div className={`text-[11px] font-semibold ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-700'}`}>
                                                                                    NODE - {group.projectTitle} · {taskLabel}
                                                                                </div>
                                                                                <div className={`text-[10px] mt-0.5 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>
                                                                                    {totalCount} 总生成 · {concurrencyValue} 每批 · {totalRounds} 批次（排队 {pendingRounds} 轮）
                                                                                </div>
                                                                            </div>
                                                                            {group.queued.length > 0 && (
                                                                                <button
                                                                                    onClick={() => {
                                                                                        if (confirm(t('确定移除该任务的排队内容吗？'))) removeQueuedBatchGroup(group.id);
                                                                                    }}
                                                                                    className={`p-1 rounded ${theme === 'dark'
                                                                                        ? 'text-zinc-500 hover:text-red-300'
                                                                                        : 'text-zinc-400 hover:text-red-500'}`}
                                                                                    title={t('移除任务排队')}
                                                                                >
                                                                                    <Trash2 size={12} />
                                                                                </button>
                                                                            )}
                                                                        </div>
                                                                        <div className="mt-2 space-y-1">
                                                                            {combined.map((item, idx) => {
                                                                                const batchIndex = Math.floor((item.batchOrder ?? 0) / concurrencyValue) + 1;
                                                                                const shortLabel = group.taskIndex ? `T${group.taskIndex}B${batchIndex}` : `B${batchIndex}`;
                                                                                const shotLabel = getShotLabel(item.nodeId, item.shotId);
                                                                                const statusLabel = item.status === 'running' ? '运行' : '排队';
                                                                                return (
                                                                                    <div
                                                                                        key={`${group.id}-${item.nodeId}-${item.shotId}-${idx}`}
                                                                                        className={`text-[10px] flex items-center justify-between gap-2 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-600'}`}
                                                                                    >
                                                                                        <span className="truncate">
                                                                                            {shortLabel} · {shotLabel || `镜头${item.sceneIndex || ''}`}
                                                                                        </span>
                                                                                        <div className="flex items-center gap-1 shrink-0">
                                                                                            <span className={item.status === 'running' ? 'text-green-500' : 'text-blue-400'}>
                                                                                                {statusLabel}
                                                                                            </span>
                                                                                            <button
                                                                                                onClick={() => {
                                                                                                    if (item.status === 'running') {
                                                                                                        if (confirm(t('确定终止该生成任务吗？'))) stopRunningShot(item.nodeId, item.shotId);
                                                                                                    } else {
                                                                                                        if (confirm(t('确定移除该排队任务吗？'))) removeQueuedBatchItem(item.nodeId, item.shotId);
                                                                                                    }
                                                                                                }}
                                                                                                className={`p-0.5 rounded ${theme === 'dark'
                                                                                                    ? 'text-zinc-500 hover:text-red-300'
                                                                                                    : 'text-zinc-400 hover:text-red-500'}`}
                                                                                                title={item.status === 'running' ? '终止任务' : '移除任务'}
                                                                                            >
                                                                                                <Trash2 size={10} />
                                                                                            </button>
                                                                                        </div>
                                                                                    </div>
                                                                                );
                                                                            })}
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    )}
                                                </>
                                            );
                                        })()}
                                    </div>
                                )}
                                {historyCachePanelOpen && (
                                    <div className={`rounded-lg border p-3 space-y-3 ${theme === 'dark' ? 'bg-zinc-900/60 border-zinc-800' : 'bg-white border-zinc-200'}`}>
                                        <div className="space-y-2">
                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">{t('图片保存路径')}</label>
                                                <div className="flex items-center gap-2">
                                                    <input
                                                        type="text"
                                                        value={localServerConfig.imageSavePath || ''}
                                                        onChange={(e) => {
                                                            const nextValue = normalizeLocalPath(e.target.value);
                                                            setLocalServerConfig(prev => ({ ...prev, imageSavePath: nextValue }));
                                                        }}
                                                        onBlur={(e) => updateLocalCacheServerConfig({ image_save_path: normalizeLocalPath(e.target.value || '') })}
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') {
                                                                e.currentTarget.blur();
                                                            }
                                                        }}
                                                        placeholder={t('默认使用 history')}
                                                        className={`flex-1 text-xs border rounded px-2 py-1.5 outline-none focus:border-blue-500 ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300 placeholder-zinc-600' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'}`}
                                                    />
                                                    <button
                                                        onClick={() => pickLocalCachePath('imageSavePath', 'image_save_path')}
                                                        className={`px-2 py-1.5 text-[10px] rounded border ${theme === 'dark' ? 'bg-zinc-800 text-zinc-300 border-zinc-700 hover:bg-zinc-700' : 'bg-zinc-100 text-zinc-700 border-zinc-300 hover:bg-zinc-200'}`}
                                                    >
                                                        {t('浏览')}
                                                    </button>
                                                </div>
                                            </div>
                                            <div>
                                                <label className="text-[10px] block mb-1 text-zinc-500">{t('视频保存路径')}</label>
                                                <div className="flex items-center gap-2">
                                                    <input
                                                        type="text"
                                                        value={localServerConfig.videoSavePath || ''}
                                                        onChange={(e) => {
                                                            const nextValue = normalizeLocalPath(e.target.value);
                                                            setLocalServerConfig(prev => ({ ...prev, videoSavePath: nextValue }));
                                                        }}
                                                        onBlur={(e) => updateLocalCacheServerConfig({ video_save_path: normalizeLocalPath(e.target.value || '') })}
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') {
                                                                e.currentTarget.blur();
                                                            }
                                                        }}
                                                        placeholder={t('默认使用 history')}
                                                        className={`flex-1 text-xs border rounded px-2 py-1.5 outline-none focus:border-blue-500 ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300 placeholder-zinc-600' : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'}`}
                                                    />
                                                    <button
                                                        onClick={() => pickLocalCachePath('videoSavePath', 'video_save_path')}
                                                        className={`px-2 py-1.5 text-[10px] rounded border ${theme === 'dark' ? 'bg-zinc-800 text-zinc-300 border-zinc-700 hover:bg-zinc-700' : 'bg-zinc-100 text-zinc-700 border-zinc-300 hover:bg-zinc-200'}`}
                                                    >
                                                        {t('浏览')}
                                                    </button>
                                                </div>
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <span className="text-[10px] text-zinc-500">{t('启用本地缓存')}</span>
                                                    <div className="text-[9px] text-zinc-500 mt-0.5">{t('关闭后不再使用本地缓存并隐藏提示条')}</div>
                                                </div>
                                                <button
                                                    className={`w-10 h-5 rounded-full relative transition-colors ${localCacheEnabled ? 'bg-green-600' : theme === 'solarized' ? 'bg-zinc-300' : 'bg-zinc-600'}`}
                                                    onClick={() => setLocalCacheEnabled(prev => !prev)}
                                                >
                                                    <div className={`absolute top-1 w-3 h-3 rounded-full bg-white transition-all ${localCacheEnabled ? 'left-6' : 'left-1'}`} />
                                                </button>
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <span className="text-[10px] text-zinc-500">{t('启用缓存时重新下载')}</span>
                                                    <div className="text-[9px] text-zinc-500 mt-0.5">{t('开启后会忽略已存在文件')}</div>
                                                </div>
                                                <button
                                                    className={`w-10 h-5 rounded-full relative transition-colors ${cacheRedownloadOnEnable ? 'bg-green-600' : theme === 'solarized' ? 'bg-zinc-300' : 'bg-zinc-600'}`}
                                                    onClick={() => setCacheRedownloadOnEnable(prev => !prev)}
                                                >
                                                    <div className={`absolute top-1 w-3 h-3 rounded-full bg-white transition-all ${cacheRedownloadOnEnable ? 'left-6' : 'left-1'}`} />
                                                </button>
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <span className="text-[10px] text-zinc-500">{t('PNG 转 JPG（省空间）')}</span>
                                                <button
                                                    className={`w-10 h-5 rounded-full relative transition-colors ${localServerConfig.convertPngToJpg ? 'bg-green-600' : theme === 'solarized' ? 'bg-zinc-300' : 'bg-zinc-600'} ${!localServerConfig.pilAvailable ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                    onClick={() => {
                                                        if (!localServerConfig.pilAvailable) return;
                                                        const nextValue = !localServerConfig.convertPngToJpg;
                                                        setLocalServerConfig(prev => ({ ...prev, convertPngToJpg: nextValue }));
                                                        updateLocalCacheServerConfig({ convert_png_to_jpg: nextValue }, { silent: true });
                                                    }}
                                                    disabled={!localServerConfig.pilAvailable}
                                                >
                                                    <div className={`absolute top-1 w-3 h-3 rounded-full bg-white transition-all ${localServerConfig.convertPngToJpg ? 'left-6' : 'left-1'}`} />
                                                </button>
                                            </div>
                                            {!localServerConfig.pilAvailable && (
                                                <div className="text-[9px] text-amber-400">{t('PIL 未安装，PNG 转 JPG 不可用')}</div>
                                            )}
                                            <button
                                                className={`w-full py-2 rounded text-[10px] font-medium transition-colors ${theme === 'dark'
                                                    ? 'bg-orange-600/30 text-orange-200 hover:bg-orange-600/40'
                                                    : 'bg-orange-100 text-orange-600 hover:bg-orange-200'
                                                    }`}
                                                onClick={refreshLocalCache}
                                            >
                                                {t('刷新缓存（重新下载到新路径）')}
                                            </button>
                                            <div className="text-[9px] text-zinc-500">
                                                {t('提示：设置路径后点击刷新缓存可将素材保存到新文件夹')}
                                            </div>
                                            <button
                                                className={`w-full py-2 rounded text-[10px] font-medium transition-colors ${theme === 'dark'
                                                    ? 'bg-blue-600/20 text-blue-200 hover:bg-blue-600/30'
                                                    : 'bg-blue-50 text-blue-600 hover:bg-blue-100'
                                                    }`}
                                                onClick={rebuildAllHistoryThumbnails}
                                            >
                                                {t('全部重建历史缩略图')}
                                            </button>
                                        </div>
                                    </div>
                                )}
                                </div>
                                )}
                                {/* V3.4.16: 历史列表添加本次生成分隔线 */}
                                {(() => {
                                    const sessionItems = history.filter(item => (item.startTime || 0) >= sessionStartTime);
                                    const previousItems = history.filter(item => (item.startTime || 0) < sessionStartTime);
                                    return (
                                        <>
                                            {sessionItems.length > 0 && (
                                                <>
                                                    <div className={`flex items-center gap-2 text-[10px] ${theme === 'dark' ? 'text-blue-400' : 'text-blue-600'}`}>
                                                        <div className="flex-1 h-px bg-blue-500/30"></div>
                                                        <span className="px-2 py-0.5 rounded-full bg-blue-500/10 font-medium">{t('本次生成')} ({sessionItems.length})</span>
                                                        <div className="flex-1 h-px bg-blue-500/30"></div>
                                                    </div>
                                                    {sessionItems.map((item) => (
                                                        <HistoryItem
                                                            key={item.id}
                                                            item={item}
                                                            theme={theme}
                                                            language={language}
                                                            lightboxItem={lightboxItem}
                                                            performanceMode={performanceMode}
                                                            providers={providers}
                                                            defaultProviders={DEFAULT_PROVIDERS}
                                                            localCacheActive={localCacheActive}
                                                            historyLocalCacheMap={historyLocalCacheMap}
                                                            onCacheMissing={handleHistoryCacheMissing}
                                                            onDelete={deleteHistoryItem}
                                                            getHistoryMeta={getHistoryMeta}
                                                            resolveHistoryUrl={resolveHistoryUrl}
                                                            isLocalCacheUrlAvailable={isLocalCacheUrlAvailable}
                                                            isSelected={historySelection.has(item.id)}
                                                            onSelect={(id) => {
                                                                setHistorySelection(prev => {
                                                                    const next = new Set(prev);
                                                                    if (next.has(id)) next.delete(id);
                                                                    else next.add(id);
                                                                    return next;
                                                                });
                                                            }}
                                                            onClick={() => {
                                                                setHistoryFocusId(item.id);
                                                                const multiImages = getHistoryMultiImages(item);
                                                                const maxIndex = multiImages
                                                                    ? multiImages.length - 1
                                                                    : 0;
                                                                const rawIndex = item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0;
                                                                const currentIndex = Math.max(0, Math.min(rawIndex, maxIndex));
                                                                const selectedUrl = multiImages
                                                                    ? multiImages[currentIndex]
                                                                    : null;
                                                                const displayUrl = selectedUrl
                                                                    ? resolveHistoryUrl(item, selectedUrl)
                                                                    : resolveHistoryUrl(item);
                                                                if (displayUrl) {
                                                                    const lightboxImages = multiImages || getLightboxNavImages(item);
                                                                    setLightboxItem({
                                                                        ...item,
                                                                        mjImages: lightboxImages || item.mjImages || null,
                                                                        url: displayUrl,
                                                                        selectedMjImageIndex: currentIndex,
                                                                        // V3.7.22: 明确清除 storyboardContext，避免与分镜导航冲突
                                                                        storyboardContext: null
                                                                    });
                                                                }
                                                            }}
                                                            onContextMenu={(e) => handleHistoryRightClick(e, item)}
                                                            onImageClick={(e, item, imgUrl, idx) => {
                                                                e.stopPropagation();
                                                                setHistoryFocusId(item.id);
                                                                setHistory((prev) => prev.map((hItem) =>
                                                                    hItem.id === item.id
                                                                        ? { ...hItem, url: imgUrl, selectedMjImageIndex: idx }
                                                                        : hItem
                                                                ));
                                                                const latestItem = historyMap.get(item.id) || item;
                                                                const resolvedUrl = resolveHistoryUrl(latestItem, imgUrl);
                                                                const lightboxImages = getHistoryMultiImages(latestItem) || getLightboxNavImages(latestItem);
                                                                const updatedItem = {
                                                                    ...latestItem,
                                                                    mjImages: lightboxImages || latestItem.mjImages || null,
                                                                    url: resolvedUrl,
                                                                    selectedMjImageIndex: idx,
                                                                    // V3.7.22: 明确清除 storyboardContext
                                                                    storyboardContext: null
                                                                };
                                                                setLightboxItem(updatedItem);
                                                            }}
                                                            onImageContextMenu={(e, item, imgUrl, idx) => handleHistoryRightClick(e, item, imgUrl, idx)}
                                                            onRebuildThumbnail={rebuildHistoryThumbnail}
                                                            onRefresh={(item) => {
                                                                if (item.apiConfig) {
                                                                    setHistory(prev => prev.map(h => h.id === item.id ? { ...h, status: 'generating', errorMsg: null, progress: 5 } : h));
                                                                    if (item.modelName.includes('veo')) pollVeoJob(item.remoteTaskId, item.id, item.apiConfig.baseUrl, item.apiConfig.apiKey, item.width, item.height);
                                                                    else pollSoraJob(item.remoteTaskId, item.id, item.apiConfig.baseUrl, item.apiConfig.apiKey, item.width, item.height, item.apiConfig.modelId || '');
                                                                }
                                                            }}
                                                            Loader2={Loader2}
                                                            Trash2={Trash2}
                                                            RefreshCw={RefreshCw}
                                                        />
                                                    ))}
                                                </>
                                            )}
                                            {previousItems.length > 0 && (
                                                <>
                                                    <div className={`flex items-center gap-2 text-[10px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                        <div className={`flex-1 h-px ${theme === 'dark' ? 'bg-zinc-700' : 'bg-zinc-300'}`}></div>
                                                        <span className="px-2 py-0.5 font-medium">{t('之前生成')} ({previousItems.length})</span>
                                                        <div className={`flex-1 h-px ${theme === 'dark' ? 'bg-zinc-700' : 'bg-zinc-300'}`}></div>
                                                    </div>
                                                    {previousItems.map((item) => (
                                                        <HistoryItem
                                                            key={item.id}
                                                            item={item}
                                                            theme={theme}
                                                            language={language}
                                                            lightboxItem={lightboxItem}
                                                            performanceMode={performanceMode}
                                                            providers={providers}
                                                            defaultProviders={DEFAULT_PROVIDERS}
                                                            localCacheActive={localCacheActive}
                                                            historyLocalCacheMap={historyLocalCacheMap}
                                                            onCacheMissing={handleHistoryCacheMissing}
                                                            onDelete={deleteHistoryItem}
                                                            getHistoryMeta={getHistoryMeta}
                                                            resolveHistoryUrl={resolveHistoryUrl}
                                                            isLocalCacheUrlAvailable={isLocalCacheUrlAvailable}
                                                            isSelected={historySelection.has(item.id)}
                                                            onSelect={(id) => {
                                                                setHistorySelection(prev => {
                                                                    const next = new Set(prev);
                                                                    if (next.has(id)) next.delete(id);
                                                                    else next.add(id);
                                                                    return next;
                                                                });
                                                            }}
                                                            onClick={() => {
                                                                setHistoryFocusId(item.id);
                                                                const multiImages = getHistoryMultiImages(item);
                                                                const maxIndex = multiImages
                                                                    ? multiImages.length - 1
                                                                    : 0;
                                                                const rawIndex = item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0;
                                                                const currentIndex = Math.max(0, Math.min(rawIndex, maxIndex));
                                                                const selectedUrl = multiImages
                                                                    ? multiImages[currentIndex]
                                                                    : null;
                                                                const displayUrl = selectedUrl
                                                                    ? resolveHistoryUrl(item, selectedUrl)
                                                                    : resolveHistoryUrl(item);
                                                                if (displayUrl) {
                                                                    const lightboxImages = multiImages || getLightboxNavImages(item);
                                                                    setLightboxItem({
                                                                        ...item,
                                                                        mjImages: lightboxImages || item.mjImages || null,
                                                                        url: displayUrl,
                                                                        selectedMjImageIndex: currentIndex,
                                                                        // V3.7.22: 明确清除 storyboardContext
                                                                        storyboardContext: null
                                                                    });
                                                                }
                                                            }}
                                                            onContextMenu={(e) => handleHistoryRightClick(e, item)}
                                                            onImageClick={(e, item, imgUrl, idx) => {
                                                                e.stopPropagation();
                                                                setHistoryFocusId(item.id);
                                                                setHistory((prev) => prev.map((hItem) =>
                                                                    hItem.id === item.id
                                                                        ? { ...hItem, url: imgUrl, selectedMjImageIndex: idx }
                                                                        : hItem
                                                                ));
                                                                const latestItem = historyMap.get(item.id) || item;
                                                                const resolvedUrl = resolveHistoryUrl(latestItem, imgUrl);
                                                                const lightboxImages = getHistoryMultiImages(latestItem) || getLightboxNavImages(latestItem);
                                                                const updatedItem = {
                                                                    ...latestItem,
                                                                    mjImages: lightboxImages || latestItem.mjImages || null,
                                                                    url: resolvedUrl,
                                                                    selectedMjImageIndex: idx,
                                                                    // V3.7.22: 明确清除 storyboardContext
                                                                    storyboardContext: null
                                                                };
                                                                setLightboxItem(updatedItem);
                                                            }}
                                                            onImageContextMenu={(e, item, imgUrl, idx) => handleHistoryRightClick(e, item, imgUrl, idx)}
                                                            onRebuildThumbnail={rebuildHistoryThumbnail}
                                                            onRefresh={(item) => {
                                                                if (item.apiConfig) {
                                                                    setHistory(prev => prev.map(h => h.id === item.id ? { ...h, status: 'generating', errorMsg: null, progress: 5 } : h));
                                                                    if (item.modelName.includes('veo')) pollVeoJob(item.remoteTaskId, item.id, item.apiConfig.baseUrl, item.apiConfig.apiKey, item.width, item.height);
                                                                    else pollSoraJob(item.remoteTaskId, item.id, item.apiConfig.baseUrl, item.apiConfig.apiKey, item.width, item.height, item.apiConfig.modelId || '');
                                                                }
                                                            }}
                                                            Loader2={Loader2}
                                                            Trash2={Trash2}
                                                            RefreshCw={RefreshCw}
                                                        />
                                                    ))}
                                                </>
                                            )}
                                        </>
                                    );
                                })()}
                            </div>
                        </div>
                    )}

                    {/* Characters Panel */}
                    {charactersOpen && (
                        <div
                            className={`w-72 z-30 flex flex-col animate-in slide-in-from-left border-r transition-colors duration-300 ${theme === 'dark'
                                ? 'bg-[#121214] border-zinc-800'
                                : theme === 'solarized'
                                    ? 'bg-[#eee8d5] border-[#d7cfb2]'
                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                }`}
                        >
                            <div
                                className={`p-3 border-b flex justify-between items-center ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}
                            >
                                <h3
                                    className={`font-bold text-xs ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                        }`}
                                >
                                    {t('Sora 角色库')}
                                </h3>
                                <div className="flex items-center gap-2">
                                    <button
                                        onClick={() => {
                                            // 自动计算默认 endpoint
                                            const soraConfig = apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'));
                                            if (soraConfig) {
                                                const baseUrl = (soraConfig.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                                                setCreateCharacterEndpoint(`${baseUrl}/sora/v1/characters`);
                                            } else {
                                                const baseUrl = DEFAULT_BASE_URL.replace(/\/+$/, '');
                                                setCreateCharacterEndpoint(`${baseUrl}/sora/v1/characters`);
                                            }
                                            setCreateCharacterOpen(true);
                                        }}
                                        className={`px-2 py-1 text-[10px] rounded transition-colors ${theme === 'dark'
                                            ? 'bg-blue-600 hover:bg-blue-500 text-white'
                                            : 'bg-blue-500 hover:bg-blue-600 text-white'
                                            }`}
                                    >
                                        {t('新建角色')}
                                    </button>
                                    <button onClick={() => setCharactersOpen(false)}>
                                        <X
                                            size={12}
                                            className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}
                                        />
                                    </button>
                                </div>
                            </div>
                            <div className="flex-1 overflow-y-auto custom-scrollbar p-3">
                                {characterLibrary.length === 0 ? (
                                    <div className={`text-center py-8 text-sm ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'
                                        }`}>
                                        暂无角色，点击"新建角色"开始创建
                                    </div>
                                ) : (
                                    <div className="grid grid-cols-2 gap-3">
                                        {characterLibrary.map((character) => (
                                            <div
                                                key={character.id}
                                                className={`group rounded-lg overflow-hidden border cursor-pointer hover:border-blue-500/50 transition-colors ${theme === 'dark' ? 'bg-zinc-900 border-zinc-800' : 'bg-white border-zinc-200'
                                                    }`}
                                                onClick={() => {
                                                    const tag = ` @${character.username} `;
                                                    // 尝试找到当前激活的输入框
                                                    const activeElement = document.activeElement;
                                                    if (activeElement && (activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'INPUT')) {
                                                        const textarea = activeElement;
                                                        const start = textarea.selectionStart || 0;
                                                        const end = textarea.selectionEnd || 0;
                                                        const text = textarea.value;
                                                        const newText = text.slice(0, start) + tag + text.slice(end);
                                                        textarea.value = newText;
                                                        const newCursorPos = start + tag.length;
                                                        textarea.setSelectionRange(newCursorPos, newCursorPos);
                                                        textarea.dispatchEvent(new Event('input', { bubbles: true }));
                                                        textarea.focus();
                                                    } else {
                                                        // 复制到剪贴板
                                                        navigator.clipboard.writeText(tag.trim()).then(() => {
                                                            alert(`已复制角色标签: ${tag.trim()}`);
                                                        });
                                                    }
                                                }}
                                            >
                                                <div className="aspect-square bg-zinc-800 relative group/char">
                                                    {(character.localCacheUrl || character.profile_picture_url) ? (
                                                        <LazyBase64Image
                                                            src={character.localCacheUrl || character.profile_picture_url}
                                                            alt={character.username}
                                                            className="w-full h-full object-cover"
                                                            onError={(e) => {
                                                                e.target.style.display = 'none';
                                                            }}
                                                        />
                                                    ) : (
                                                        <div className="w-full h-full flex items-center justify-center text-zinc-500">
                                                            <User size={24} />
                                                        </div>
                                                    )}
                                                    {/* 删除按钮 */}
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            if (confirm(`确定要删除角色 "${character.username}" 吗？`)) {
                                                                const updated = characterLibrary.filter(c => c.id !== character.id);
                                                                setCharacterLibrary(updated);
                                                                try {
                                                                    localStorage.setItem('tapnow_characters', JSON.stringify(updated));
                                                                } catch (err) {
                                                                    console.error('保存角色库失败:', err);
                                                                }
                                                            }
                                                        }}
                                                        className="absolute top-1 right-1 p-1.5 rounded-full bg-black/50 text-white opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600 z-10"
                                                        title={t('删除角色')}
                                                    >
                                                        <Trash2 size={12} />
                                                    </button>
                                                </div>
                                                <div className="p-2 relative">
                                                    <p className={`text-xs truncate flex items-center gap-1 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                                        }`}>
                                                        {character.username}
                                                        <LinkIcon
                                                            size={12}
                                                            className="text-green-500 shrink-0"
                                                            title={t('Sora 2 已同步')}
                                                        />
                                                    </p>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Create Character Modal */}
                    {createCharacterOpen && (
                        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center" onClick={() => setCreateCharacterOpen(false)}>
                            <div
                                className={`w-[500px] max-h-[90vh] overflow-y-auto rounded-lg shadow-2xl flex flex-col ${theme === 'dark'
                                    ? 'bg-[#121214] border-zinc-800'
                                    : theme === 'solarized'
                                        ? 'bg-[#eee8d5] border-[#d7cfb2]'
                                        : 'bg-white border-zinc-200'
                                    } border`}
                                onClick={(e) => e.stopPropagation()}
                            >
                                <div className={`p-4 border-b flex justify-between items-center ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}>
                                    <h3 className={`font-bold text-sm ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                        }`}>
                                        {t('新建角色')}
                                    </h3>
                                    <button onClick={() => setCreateCharacterOpen(false)}>
                                        <X size={16} className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'} />
                                    </button>
                                </div>
                                <div className="p-4 space-y-4">
                                    {/* 视频源选择 */}
                                    <div>
                                        <label className={`block text-xs mb-2 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                            }`}>
                                            视频源
                                        </label>
                                        <div className="flex gap-2 mb-2">
                                            <button
                                                onClick={() => {
                                                    setCreateCharacterVideoSourceType('url');
                                                    setCreateCharacterSelectedTaskId('');
                                                }}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors ${createCharacterVideoSourceType === 'url'
                                                    ? theme === 'dark'
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-blue-500 text-white'
                                                    : theme === 'dark'
                                                        ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                        : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                    }`}
                                            >
                                                输入视频 URL
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCreateCharacterVideoSourceType('history');
                                                    setCreateCharacterVideoUrl('');
                                                    setCreateCharacterVideoError(null);
                                                }}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors ${createCharacterVideoSourceType === 'history'
                                                    ? theme === 'dark'
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-blue-500 text-white'
                                                    : theme === 'dark'
                                                        ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                        : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                    }`}
                                            >
                                                从历史记录选择
                                            </button>
                                        </div>

                                        {createCharacterVideoSourceType === 'url' ? (
                                            <input
                                                type="text"
                                                value={createCharacterVideoUrl}
                                                onChange={(e) => setCreateCharacterVideoUrl(e.target.value)}
                                                placeholder={t('输入视频 URL...')}
                                                className={`w-full px-3 py-2 text-xs rounded border outline-none ${theme === 'dark'
                                                    ? 'bg-zinc-900 border-zinc-700 text-zinc-200 placeholder-zinc-600'
                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                    }`}
                                            />
                                        ) : (
                                            <select
                                                value={createCharacterSelectedTaskId}
                                                onChange={(e) => {
                                                    const taskId = e.target.value;
                                                    setCreateCharacterSelectedTaskId(taskId);
                                                    // 当选中历史视频时，自动获取视频URL并填充到URL输入框
                                                    if (taskId) {
                                                        const selectedHistoryItem = historyMap.get(taskId);
                                                        const resolvedUrl = resolveHistoryUrl(selectedHistoryItem);
                                                        if (resolvedUrl) {
                                                            // 切换到URL输入模式并填充URL
                                                            setCreateCharacterVideoSourceType('url');
                                                            setCreateCharacterVideoUrl(resolvedUrl);
                                                            setCreateCharacterSelectedTaskId(''); // 清空选择
                                                        }
                                                    }
                                                }}
                                                className={`w-full px-3 py-2 text-xs rounded border outline-none ${theme === 'dark'
                                                    ? 'bg-zinc-900 border-zinc-700 text-zinc-200'
                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                    }`}
                                            >
                                                <option value="">{t('选择历史记录中的视频...')}</option>
                                                {history.filter(h => h.type === 'video' && h.status === 'completed' && (h.url || h.localCacheUrl || h.originalUrl)).map(item => (
                                                    <option key={item.id} value={item.id}>
                                                        {item.prompt?.slice(0, 50) || 'Untitled'} - {item.time}
                                                    </option>
                                                ))}
                                            </select>
                                        )}

                                        {/* 视频预览区域 */}
                                        {(() => {
                                            let currentVideoUrl = null;
                                            if (createCharacterVideoSourceType === 'url' && createCharacterVideoUrl.trim()) {
                                                currentVideoUrl = createCharacterVideoUrl.trim();
                                            } else if (createCharacterVideoSourceType === 'history' && createCharacterSelectedTaskId) {
                                                const selectedHistoryItem = historyMap.get(createCharacterSelectedTaskId);
                                                const resolvedUrl = resolveHistoryUrl(selectedHistoryItem);
                                                if (resolvedUrl) {
                                                    currentVideoUrl = resolvedUrl;
                                                }
                                            }

                                            return currentVideoUrl ? (
                                                <div className="mt-2 mb-2">
                                                    <video
                                                        key={currentVideoUrl}
                                                        controls
                                                        crossOrigin="anonymous"
                                                        className="w-full h-40 object-contain bg-black rounded-lg"
                                                        src={currentVideoUrl}
                                                        onError={(e) => {
                                                            console.error('视频加载失败:', currentVideoUrl, e);
                                                            setCreateCharacterVideoError('无法加载视频预览，请检查链接有效性或跨域限制');
                                                        }}
                                                        onLoadStart={() => {
                                                            // 清除错误提示
                                                            setCreateCharacterVideoError(null);
                                                        }}
                                                        onLoadedData={() => {
                                                            // 视频加载成功，清除错误
                                                            setCreateCharacterVideoError(null);
                                                        }}
                                                    />
                                                    {createCharacterVideoError && (
                                                        <div className="text-red-500 text-xs mt-1 text-center">
                                                            {createCharacterVideoError}
                                                        </div>
                                                    )}
                                                </div>
                                            ) : null;
                                        })()}
                                    </div>

                                    {/* 时间范围 */}
                                    <div>
                                        <label className={`block text-xs mb-2 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                            }`}>
                                            {t('时间范围（秒，间隔需在 1-3 秒之间）')}
                                        </label>
                                        <div className="flex gap-2 items-center">
                                            <input
                                                type="number"
                                                min="0"
                                                step="0.1"
                                                value={createCharacterStartSecond}
                                                onChange={(e) => setCreateCharacterStartSecond(parseFloat(e.target.value) || 0)}
                                                className={`w-20 px-2 py-1.5 text-xs rounded border outline-none ${theme === 'dark'
                                                    ? 'bg-zinc-900 border-zinc-700 text-zinc-200'
                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                    }`}
                                            />
                                            <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>到</span>
                                            <input
                                                type="number"
                                                min="0"
                                                step="0.1"
                                                value={createCharacterEndSecond}
                                                onChange={(e) => setCreateCharacterEndSecond(parseFloat(e.target.value) || 0)}
                                                className={`w-20 px-2 py-1.5 text-xs rounded border outline-none ${theme === 'dark'
                                                    ? 'bg-zinc-900 border-zinc-700 text-zinc-200'
                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800' : 'bg-white border-zinc-300 text-zinc-800'
                                                    }`}
                                            />
                                            <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>
                                                秒（间隔: {(createCharacterEndSecond - createCharacterStartSecond).toFixed(1)}s）
                                            </span>
                                        </div>
                                    </div>

                                    {/* 高级设置：API 接口地址 */}
                                    <div>
                                        <label className={`block text-xs mb-2 ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                            }`}>
                                            API 接口地址 (API Endpoint)
                                        </label>
                                        <input
                                            type="text"
                                            value={createCharacterEndpoint}
                                            onChange={(e) => setCreateCharacterEndpoint(e.target.value)}
                                            placeholder={t('例如: https://your-domain.com/sora/v1/characters')}
                                            className={`w-full px-3 py-2 text-xs rounded border outline-none font-mono ${theme === 'dark'
                                                ? 'bg-zinc-900 border-zinc-700 text-zinc-200 placeholder-zinc-600'
                                                : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5] text-zinc-800 placeholder-zinc-400' : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                }`}
                                            onFocus={(e) => {
                                                // 如果为空，自动填充默认值
                                                if (!e.target.value) {
                                                    const soraConfig = apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'));
                                                    const baseUrl = soraConfig
                                                        ? (soraConfig.url || DEFAULT_BASE_URL).replace(/\/+$/, '')
                                                        : DEFAULT_BASE_URL.replace(/\/+$/, '');
                                                    setCreateCharacterEndpoint(`${baseUrl}/sora/v1/characters`);
                                                }
                                            }}
                                        />
                                        <p className={`text-[10px] mt-1 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'
                                            }`}>
                                            默认自动填充，可根据服务商要求修改路径
                                        </p>
                                    </div>

                                    {/* 提交按钮 */}
                                    <div className="flex justify-end gap-2 pt-2">
                                        <button
                                            onClick={() => setCreateCharacterOpen(false)}
                                            className={`px-4 py-2 text-xs rounded transition-colors ${theme === 'dark'
                                                ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200'
                                                }`}
                                        >
                                            {t('取消')}
                                        </button>
                                        <button
                                            onClick={async () => {
                                                if (createCharacterVideoSourceType === 'url' && !createCharacterVideoUrl.trim()) {
                                                    alert(t('请输入视频 URL'));
                                                    return;
                                                }
                                                if (createCharacterVideoSourceType === 'history' && !createCharacterSelectedTaskId) {
                                                    alert(t('请选择历史记录中的视频'));
                                                    return;
                                                }
                                                if (createCharacterEndSecond - createCharacterStartSecond < 1 || createCharacterEndSecond - createCharacterStartSecond > 3) {
                                                    alert(t('时间范围必须在 1-3 秒之间'));
                                                    return;
                                                }
                                                setCreateCharacterSubmitting(true);
                                                try {
                                                    // 优先使用用户手动输入的 API 地址，如果为空则使用默认地址
                                                    const endpointToUse = createCharacterEndpoint.trim() || null;

                                                    if (createCharacterVideoSourceType === 'url') {
                                                        await createCharacter(createCharacterVideoUrl, createCharacterStartSecond, createCharacterEndSecond, null, endpointToUse);
                                                    } else {
                                                        await createCharacter('', createCharacterStartSecond, createCharacterEndSecond, createCharacterSelectedTaskId, endpointToUse);
                                                    }
                                                } finally {
                                                    setCreateCharacterSubmitting(false);
                                                }
                                            }}
                                            disabled={createCharacterSubmitting}
                                            className={`px-4 py-2 text-xs rounded transition-colors ${createCharacterSubmitting
                                                ? 'bg-zinc-400 text-zinc-200 cursor-not-allowed'
                                                : theme === 'dark'
                                                    ? 'bg-blue-600 text-white hover:bg-blue-500'
                                                    : 'bg-blue-500 text-white hover:bg-blue-600'
                                                }`}
                                        >
                                            {createCharacterSubmitting ? '创建中...' : '创建角色'}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Main Canvas Area */}
                    <div className="flex-1 relative overflow-hidden flex">
                        <div ref={canvasRef} id="canvas-bg" className="flex-1 h-full cursor-default relative"
                            onMouseDown={handleMouseDown} onClick={handleBackgroundClick} onDoubleClick={handleDoubleClick} onContextMenu={handleCanvasContextMenu}
                            onDrop={handleCanvasDrop} onDragOver={handleCanvasDragOver}
                            style={{
                                backgroundColor: theme === 'dark' ? '#09090b' : (theme === 'solarized' ? '#fdf6e3' : '#f4f4f5'),
                                backgroundImage: (() => {
                                    const mergeThreshold = 0.6;
                                    const mergeScale = view.zoom < mergeThreshold ? 2 : 1;
                                    const gridSize = Math.max(12, Math.round(20 * view.zoom * mergeScale));
                                    const dotRadius = Math.max(0.55, Math.min(1.4, gridSize * 0.035));
                                    const haloRadius = dotRadius + 0.45;
                                    const dotColor = theme === 'dark'
                                        ? 'rgb(96, 96, 104)'
                                        : theme === 'solarized'
                                            ? 'rgb(212, 212, 216)'
                                            : 'rgb(212, 212, 216)';
                                    const haloColor = theme === 'dark'
                                        ? 'rgba(96, 96, 104, 0.22)'
                                        : theme === 'solarized'
                                            ? 'rgba(212, 212, 216, 0.16)'
                                            : 'rgba(212, 212, 216, 0.16)';
                                    return `radial-gradient(${dotColor} ${dotRadius}px, transparent ${dotRadius + 0.2}px), radial-gradient(${haloColor} ${haloRadius}px, transparent ${haloRadius + 0.2}px)`;
                                })(),
                                backgroundSize: `${Math.max(12, Math.round(20 * view.zoom * (view.zoom < 0.6 ? 2 : 1)))}px ${Math.max(12, Math.round(20 * view.zoom * (view.zoom < 0.6 ? 2 : 1)))}px`,
                                backgroundPosition: `${Math.round(view.x)}px ${Math.round(view.y)}px`,
                                backgroundRepeat: 'repeat',
                                WebkitFontSmoothing: 'antialiased',
                                MozOsxFontSmoothing: 'grayscale',
                                textRendering: 'optimizeLegibility',
                                transform: 'translateZ(0)',
                                backfaceVisibility: 'hidden'
                            }}>
                            <div className="absolute origin-top-left will-change-transform" style={{
                                transform: `translate3d(${view.x}px, ${view.y}px, 0) scale(${view.zoom})`,
                                width: VIRTUAL_CANVAS_WIDTH,
                                height: VIRTUAL_CANVAS_HEIGHT,
                                WebkitFontSmoothing: 'antialiased',
                                MozOsxFontSmoothing: 'grayscale',
                                textRendering: 'optimizeLegibility',
                                transformOrigin: 'top left',
                                imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges'
                            }}>
                                <ConnectionLayer
                                    connections={connections}
                                    nodesMap={nodesMap}
                                    connectionsByNode={connectionsByNode}
                                    connectingSource={connectingSource}
                                    connectingTarget={connectingTarget}
                                    connectingInputType={connectingInputType}
                                    mousePos={mousePos}
                                    apiConfigsMap={apiConfigsMap}
                                    selectedNodeId={selectedNodeId}
                                    onDisconnectConnection={disconnectConnection}
                                    visibleNodes={visibleNodes}
                                />
                                {visibleNodes.map((node) => renderNode(node))}
                            </div>

                            {/* 框选框 */}
                            {selectionBox && (
                                <div
                                    className="absolute border-2 border-blue-500 bg-blue-500/10 pointer-events-none z-50"
                                    style={{
                                        left: Math.min(selectionBox.startX, selectionBox.endX),
                                        top: Math.min(selectionBox.startY, selectionBox.endY),
                                        width: Math.abs(selectionBox.endX - selectionBox.startX),
                                        height: Math.abs(selectionBox.endY - selectionBox.startY),
                                    }}
                                />
                            )}
                        </div>

                        {/* Chat Sidebar Panel */}
                        <div
                            className={`fixed right-0 top-12 bottom-0 border-l shadow-2xl flex flex-col z-50 transition-transform duration-300 ease-in-out select-text ${theme === 'dark'
                                ? 'bg-[#121214] border-zinc-800'
                                : theme === 'solarized'
                                    ? 'bg-[#eee8d5] border-[#d7cfb2]'
                                    : 'bg-white border-zinc-200'
                                } ${isChatOpen ? 'translate-x-0' : 'translate-x-full'}`}
                            style={{
                                width: chatWidth,
                                pointerEvents: isChatOpen ? 'auto' : 'none'
                            }}
                            onMouseEnter={() => setIsChatHovered(true)}
                            onMouseLeave={() => setIsChatHovered(false)}
                            onMouseDown={() => markInteraction('chat')}
                            onDragOver={handleCanvasDragOver}
                            onDrop={handleChatDrop}
                        >
                            <div
                                className={`absolute left-0 top-0 bottom-0 w-1.5 cursor-ew-resize transition-colors z-50 flex items-center justify-center group ${theme === 'dark' ? 'hover:bg-blue-600/50' : 'hover:bg-blue-400/30'
                                    }`}
                                onMouseDown={handleChatResizeStart}
                            >
                                <div
                                    className={`h-8 w-1 rounded transition-colors ${theme === 'dark'
                                        ? 'bg-zinc-700 group-hover:bg-blue-500'
                                        : 'bg-zinc-300 group-hover:bg-blue-500'
                                        }`}
                                ></div>
                            </div>
                            <div
                                className={`h-12 flex items-center justify-between px-3 shrink-0 border-b ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}
                            >
                                <div className="flex items-center gap-2">
                                    <div className="relative z-50">
                                        {/* V3.7.24: 双层模型选择器 */}
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                setChatModelDropdownOpen(!chatModelDropdownOpen);
                                                setChatHoveredProvider(null);
                                            }}
                                            className={`flex items-center gap-2 text-xs border rounded px-2 py-1 outline-none focus:border-blue-500 cursor-pointer max-w-[200px] ${theme === 'dark'
                                                ? 'bg-zinc-800 text-zinc-300 border-zinc-700 hover:border-zinc-600'
                                                : 'bg-white text-zinc-800 border-zinc-300 hover:border-zinc-400'}`}
                                        >
                                            <span className="truncate font-mono">{getModelLabelWithProvider(chatModel)}</span>
                                            <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(resolveModelKey(chatModel))}`}></div>
                                            <ChevronDown size={12} className="shrink-0 opacity-50" />
                                        </button>
                                        {chatModelDropdownOpen && (
                                            <div
                                                className={`absolute top-full left-0 mt-1 w-72 rounded-lg shadow-xl p-1 z-[60] border flex ${theme === 'dark'
                                                    ? 'bg-[#18181b] border-zinc-700'
                                                    : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'}`}
                                                onMouseLeave={() => setChatHoveredProvider(null)}
                                            >
                                                {/* Provider 列表 */}
                                                <div className={`w-24 border-r pr-1 max-h-64 overflow-y-auto custom-scrollbar flex flex-col ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-200'}`}>
                                                    {Object.entries(groupedApiConfigs)
                                                        .filter(([, group]) => group.models.some(m => isChatModelType(m.type)))
                                                        .map(([providerKey, group]) => (
                                                            <button
                                                                key={providerKey}
                                                                onMouseEnter={() => setChatHoveredProvider(providerKey)}
                                                                className={`w-full text-left px-2 py-1.5 text-[10px] rounded transition-colors ${chatHoveredProvider === providerKey
                                                                    ? theme === 'dark' ? 'bg-zinc-800 text-white' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-zinc-100 text-zinc-900'
                                                                    : theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : theme === 'solarized' ? 'text-zinc-600 hover:text-zinc-700' : 'text-zinc-600 hover:text-zinc-800'}`}
                                                            >
                                                                {group.name || providerKey}
                                                            </button>
                                                        ))}
                                                </div>
                                                {/* Model 列表 */}
                                                <div className="flex-1 pl-1 max-h-64 overflow-y-auto custom-scrollbar">
                                                    {chatHoveredProvider && groupedApiConfigs[chatHoveredProvider]?.models
                                                        .filter(m => isChatModelType(m.type))
                                                        .map((m) => {
                                                            const modelKey = m._uid || m.id;
                                                            const currentModelKey = resolveModelKey(chatModel);
                                                            return (
                                                                <button
                                                                    key={modelKey}
                                                                    onClick={() => {
                                                                        setChatModel(modelKey);
                                                                        setChatModelDropdownOpen(false);
                                                                        setChatHoveredProvider(null);
                                                                    }}
                                                                    className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${currentModelKey === modelKey
                                                                        ? theme === 'dark' ? 'bg-blue-600/30 text-blue-300' : theme === 'solarized' ? 'bg-[#fdf6e3] text-zinc-800' : 'bg-blue-100 text-blue-700'
                                                                        : theme === 'dark' ? 'hover:bg-zinc-800 text-zinc-300' : theme === 'solarized' ? 'hover:bg-[#fdf6e3] text-zinc-700' : 'hover:bg-zinc-100 text-zinc-700'}`}
                                                                >
                                                                    <span className="text-[10px] font-medium truncate font-mono">{m.id}</span>
                                                                    <div className={`w-1.5 h-1.5 rounded-full shrink-0 ${getStatusColor(modelKey)}`}></div>
                                                                </button>
                                                            );
                                                        })}
                                                    {!chatHoveredProvider && (
                                                        <div className={`text-[10px] px-2 py-3 text-center ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>
                                                            ← 选择 Provider
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                                <div className="flex items-center gap-1">
                                    <button
                                        onClick={createNewChat}
                                        className={`p-1.5 rounded ${theme === 'dark'
                                            ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                            : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                            }`}
                                        title={t('新对话')}
                                    >
                                        <Plus size={16} />
                                    </button>
                                    {chatSessions.length > 1 && (
                                        <div className="relative">
                                            <button
                                                onClick={() => setChatSessionDropdownOpen(!chatSessionDropdownOpen)}
                                                className={`p-1.5 rounded ${theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                                    }`}
                                            >
                                                <History size={16} />
                                            </button>
                                            {chatSessionDropdownOpen && (
                                                <div
                                                    className={`absolute right-0 top-full mt-1 w-48 rounded-lg shadow-xl py-1 z-50 border ${theme === 'dark'
                                                        ? 'bg-[#18181b] border-zinc-700'
                                                        : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                        }`}
                                                    onMouseLeave={() => setChatSessionDropdownOpen(false)}
                                                >
                                                    {chatSessions.map(s => (
                                                        <div
                                                            key={s.id}
                                                            className={`flex items-center justify-between px-3 py-2 text-xs cursor-pointer ${currentChatId === s.id
                                                                ? theme === 'dark'
                                                                    ? 'bg-zinc-800 text-white'
                                                                    : 'bg-zinc-100 text-zinc-900'
                                                                : theme === 'dark'
                                                                    ? 'text-zinc-400 hover:bg-zinc-800/50'
                                                                    : 'text-zinc-500 hover:bg-zinc-100'
                                                                }`}
                                                            onClick={() => {
                                                                setCurrentChatId(s.id);
                                                                setChatSessionDropdownOpen(false);
                                                            }}
                                                        >
                                                            <span className="truncate flex-1">{s.title}</span>
                                                            <button
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    deleteChatSession(e, s.id);
                                                                }}
                                                                className={`p-1 ${theme === 'dark'
                                                                    ? 'text-zinc-600 hover:text-red-500'
                                                                    : 'text-zinc-400 hover:text-red-500'
                                                                    }`}
                                                            >
                                                                <X size={10} />
                                                            </button>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    )}
                                    <button
                                        onClick={() => setIsChatOpen(false)}
                                        className={`p-1.5 rounded ${theme === 'dark'
                                            ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                            : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                            }`}
                                    >
                                        <ChevronRight size={16} />
                                    </button>
                                </div>
                            </div>
                            <div className="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-4 select-text">
                                {currentSession?.messages.map((msg) => (
                                    <div key={msg.id || msg.timestamp || `msg-${Math.random()}`} className={`flex gap-3 select-text ${msg.role === 'user' ? 'flex-row-reverse' : ''}`}>
                                        <div className={`w-8 h-8 rounded-full flex items-center justify-center shrink-0 select-none ${msg.role === 'user' ? 'bg-blue-600' : 'bg-green-600'}`}>{msg.role === 'user' ? <User size={16} className="text-white" /> : <Bot size={16} className="text-white" />}</div>
                                        <div className={`flex flex-col gap-1 max-w-[85%] select-text ${msg.role === 'user' ? 'items-end' : 'items-start'}`}>
                                            {msg.files && msg.files.length > 0 && (
                                                <div className={`flex flex-wrap gap-2 mb-1 ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                    {msg.files.map((f, i) => (
                                                        <div
                                                            key={i}
                                                            className={`rounded p-1 border flex items-center gap-1 ${theme === 'dark'
                                                                ? 'bg-zinc-800 border-zinc-700'
                                                                : 'bg-zinc-100 border-zinc-300'
                                                                }`}
                                                        >
                                                            {f.isImage ? (
                                                                <LazyBase64Image src={f.content} className="w-16 h-16 object-cover rounded" alt={f.name} />
                                                            ) : f.isVideo ? (
                                                                <video
                                                                    src={f.content}
                                                                    controls
                                                                    className={`max-w-full rounded-lg bg-black max-h-[300px] border ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                                        }`}
                                                                    playsInline
                                                                />
                                                            ) : f.isAudio ? (
                                                                <div
                                                                    className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                                        ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                        : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                >
                                                                    <FileAudio size={16} />
                                                                    <span className="text-[8px] mt-1">音频</span>
                                                                </div>
                                                            ) : f.isPDF ? (
                                                                <div
                                                                    className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                                        ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                        : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                >
                                                                    <FileText size={16} />
                                                                    <span className="text-[8px] mt-1">PDF</span>
                                                                </div>
                                                            ) : f.isDoc ? (
                                                                <div
                                                                    className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                                        ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                        : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                >
                                                                    <FileText size={16} />
                                                                    <span className="text-[8px] mt-1">DOC</span>
                                                                </div>
                                                            ) : f.isExcel ? (
                                                                <div
                                                                    className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                                        ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                        : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                >
                                                                    <FileText size={16} />
                                                                    <span className="text-[8px] mt-1">XLS</span>
                                                                </div>
                                                            ) : (
                                                                <div
                                                                    className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                                        ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                        : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                >
                                                                    <FileText size={16} />
                                                                    <span className="text-[8px] mt-1 max-w-full truncate px-1">
                                                                        {f.fileExt || f.name.split('.').pop() || '文件'}
                                                                    </span>
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                            {msg.content && msg.content.trim() && (
                                                <div
                                                    className={`rounded-2xl px-4 py-2.5 text-sm select-text break-words ${msg.role === 'user'
                                                        ? theme === 'dark'
                                                            ? 'bg-zinc-800 text-white rounded-tr-none'
                                                            : 'bg-zinc-300 text-zinc-900 rounded-tr-none'
                                                        : theme === 'dark'
                                                            ? 'bg-zinc-800/50 text-zinc-300 rounded-tl-none border border-zinc-800'
                                                            : 'bg-zinc-100 text-zinc-800 rounded-tl-none border border-zinc-200'
                                                        }`}
                                                    style={{ userSelect: 'text', cursor: 'text' }}
                                                >
                                                    {msg.isError ? (
                                                        <span className="text-red-500 select-text cursor-text" style={{ userSelect: 'text', cursor: 'text' }}>{msg.content}</span>
                                                    ) : msg.content ? (
                                                        <div className="markdown-body" dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(marked.parse(msg.content)) }} style={{ userSelect: 'text', cursor: 'text' }}></div>
                                                    ) : null}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                ))}
                                {isChatSending && (
                                    <div className="flex gap-3">
                                        <div className="w-8 h-8 rounded-full bg-green-600 flex items-center justify-center shrink-0">
                                            <Bot size={16} className="text-white" />
                                        </div>
                                        <div
                                            className={`rounded-2xl rounded-tl-none px-4 py-2 border flex items-center ${theme === 'dark'
                                                ? 'bg-zinc-800/50 border-zinc-800'
                                                : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-100 border-zinc-200'
                                                }`}
                                        >
                                            <div className="flex gap-1">
                                                <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0s' }}></div>
                                                <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                                                <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }}></div>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                <div ref={chatEndRef} />
                            </div>
                            <div
                                className={`p-3 border-t ${theme === 'dark'
                                    ? 'border-zinc-800 bg-[#121214]'
                                    : theme === 'solarized'
                                        ? 'border-[#d7cfb2] bg-[#eee8d5]'
                                        : 'border-zinc-200 bg-zinc-50'
                                    }`}
                            >
                                {chatFiles.length > 0 && (
                                    <div className="flex gap-2 overflow-x-auto pb-2 mb-2 custom-scrollbar">
                                        {chatFiles.map((f, i) => (
                                            <div key={i} className="relative group shrink-0">
                                                {f.isImage ? (
                                                    <LazyBase64Image
                                                        src={f.content}
                                                        className={`w-12 h-12 object-cover rounded border ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                            }`}
                                                        alt={f.name}
                                                    />
                                                ) : f.isVideo ? (
                                                    <video
                                                        src={f.content}
                                                        className={`w-16 h-12 object-cover rounded border bg-black ${theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                            }`}
                                                        muted
                                                        playsInline
                                                    />
                                                ) : f.isAudio ? (
                                                    <div
                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                            ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                            : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                    >
                                                        <FileAudio size={16} />
                                                        <span className="text-[8px] mt-1">音频</span>
                                                    </div>
                                                ) : f.isPDF ? (
                                                    <div
                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                            ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                            : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                    >
                                                        <FileText size={16} />
                                                        <span className="text-[8px] mt-1">PDF</span>
                                                    </div>
                                                ) : f.isDoc ? (
                                                    <div
                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                            ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                            : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                    >
                                                        <FileText size={16} />
                                                        <span className="text-[8px] mt-1">DOC</span>
                                                    </div>
                                                ) : f.isExcel ? (
                                                    <div
                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                            ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                            : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                    >
                                                        <FileText size={16} />
                                                        <span className="text-[8px] mt-1">XLS</span>
                                                    </div>
                                                ) : (
                                                    <div
                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${theme === 'dark'
                                                            ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                            : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                    >
                                                        <FileText size={16} />
                                                        <span className="text-[8px] mt-1 max-w-full truncate px-1">
                                                            {f.fileExt || f.name.split('.').pop() || '文件'}
                                                        </span>
                                                    </div>
                                                )}
                                                <button
                                                    onClick={() => removeChatFile(i)}
                                                    className={`absolute -top-1 -right-1 rounded-full p-0.5 border opacity-0 group-hover:opacity-100 transition-opacity ${theme === 'dark'
                                                        ? 'bg-zinc-900 text-zinc-400 hover:text-white border-zinc-700'
                                                        : 'bg-white text-zinc-500 hover:text-zinc-900 border-zinc-300'
                                                        }`}
                                                >
                                                    <X size={10} />
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                )}
                                <div
                                    className={`relative rounded-xl flex items-end p-2 focus-within:border-blue-500/50 transition-colors border ${theme === 'dark'
                                        ? 'bg-zinc-800/50 border-zinc-700'
                                        : 'bg-white border-zinc-300'
                                        }`}
                                >
                                    <label
                                        className={`p-2 cursor-pointer transition-colors ${theme === 'dark'
                                            ? 'text-zinc-400 hover:text-white'
                                            : 'text-zinc-500 hover:text-zinc-900'
                                            }`}
                                        title={t('上传文件')}
                                    >
                                        <Paperclip size={18} />
                                        <input type="file" multiple className="hidden" onChange={handleChatFileUpload} accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.md,.js,.py,.html,.css,.json,.csv" />
                                    </label>
                                    <textarea
                                        ref={chatInputRef}
                                        value={chatInput}
                                        onChange={(e) => setChatInput(e.target.value)}
                                        onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); } }}
                                        onFocus={() => { setIsChatInputFocused(true); markInteraction('chat'); }}
                                        onBlur={() => setIsChatInputFocused(false)}
                                        placeholder={t('发送消息...')}
                                        className={`w-full bg-transparent text-sm resize-none outline-none max-h-32 py-2 px-1 custom-scrollbar ${theme === 'dark'
                                            ? 'text-white placeholder-zinc-500'
                                            : 'text-zinc-800 placeholder-zinc-400'
                                            }`}
                                        rows={1}
                                        style={{ minHeight: '36px' }}
                                    />
                                    <button
                                        onClick={sendChatMessage}
                                        disabled={(!chatInput.trim() && chatFiles.length === 0) || isChatSending}
                                        className={`p-2 rounded-lg transition-all mb-0.5 ${(!chatInput.trim() && chatFiles.length === 0) || isChatSending
                                            ? 'opacity-50 bg-transparent text-zinc-400'
                                            : 'bg-blue-600 text-white hover:bg-blue-500'
                                            }`}
                                    >
                                        <Send size={16} />
                                    </button>
                                </div>
                                <div className={`text-[10px] text-center mt-2 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                    支持 MP4/MP3/PDF/Doc/Excel/Code 等格式 • Enter 发送
                                </div>
                            </div>
                        </div>

                        {contextMenu.visible && (
                            <div
                                className={`fixed z-50 w-40 rounded-lg shadow-xl border ${theme === 'dark' ? 'bg-[#18181b] border-zinc-800' : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                    }`}
                                style={{ left: contextMenu.x, top: contextMenu.y, transform: 'translate(-50%, -50%)' }}
                                onMouseLeave={() => {
                                    setContextMenu(prev => ({ ...prev, visible: false }));
                                    setContextMenuExpanded(false);
                                }}
                            >
                                <div className="p-1">
                                    {[
                                        { type: 'input-image', label: t('图片输入') },
                                        { type: 'text-node', label: t('文字节点') },
                                        { type: 'novel-input', label: t('小说输入') },
                                        {
                                            type: 'extract-characters-scenes',
                                            label: t('提取角色和场景'),
                                            children: [
                                                { type: 'character-description', label: t('角色描述') },
                                                { type: 'scene-description', label: t('场景描述') },
                                                { type: 'generate-character-image', label: t('生成角色图片') },
                                                { type: 'generate-scene-image', label: t('生成场景图片') },
                                                { type: 'generate-character-video', label: t('生成角色视频') },
                                                { type: 'generate-scene-video', label: t('生成场景视频') },
                                                { type: 'create-character', label: t('创建角色') },
                                                { type: 'create-scene', label: t('创建场景') }
                                            ]
                                        },
                                        { type: 'video-input', label: t('视频输入 / 关键帧整理') },
                                        { type: 'video-analyze', label: t('视频拆解 / 提示词反推') },
                                        { type: 'storyboard-node', label: t('智能分镜表') },
                                        { type: 'gen-image', label: t('AI 绘图') },
                                        { type: 'gen-video', label: t('AI 视频') },
                                        { type: 'image-compare', label: t('图像对比') },
                                        { type: 'preview', label: t('预览窗口') },
                                        { type: 'local-save', label: t('保存到本地') }
                                    ].map(item => (
                                        <div key={item.type}>
                                            {item.children ? (
                                                <div className="relative">
                                                    <div
                                                        className="flex items-center"
                                                        onMouseEnter={() => setContextMenuExpanded(true)}
                                                    >
                                                        <button
                                                            className={`flex-1 text-left px-3 py-2 text-xs rounded transition-colors ${theme === 'dark'
                                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                                : 'text-zinc-700 hover:bg-zinc-100'
                                                                }`}
                                                            onClick={() => addNode(item.type, contextMenu.worldX, contextMenu.worldY, contextMenu.sourceNodeId, undefined, undefined, contextMenu.targetNodeId, contextMenu.inputType)}
                                                        >
                                                            {item.label}
                                                        </button>
                                                        <button
                                                            className={`px-2 py-2 rounded transition-colors ${theme === 'dark'
                                                                ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                                : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-100'
                                                                }`}
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                setContextMenuExpanded(prev => !prev);
                                                            }}
                                                            onMouseEnter={() => setContextMenuExpanded(true)}
                                                            title={t('展开子目录')}
                                                        >
                                                            <ChevronRight size={12} className="transition-transform" />
                                                        </button>
                                                    </div>
                                                    {contextMenuExpanded && (
                                                        <div
                                                            className={`absolute left-full top-0 ml-1 w-40 rounded-lg shadow-xl p-1 border ${theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                                }`}
                                                        >
                                                            {item.children.map(child => (
                                                                <button
                                                                    key={child.type}
                                                                    className={`w-full text-left px-3 py-2 text-[11px] rounded transition-colors ${theme === 'dark'
                                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                                        : 'text-zinc-700 hover:bg-zinc-100'
                                                                        }`}
                                                                    onClick={() => addNode(child.type, contextMenu.worldX, contextMenu.worldY, contextMenu.sourceNodeId, undefined, undefined, contextMenu.targetNodeId, contextMenu.inputType)}
                                                                >
                                                                    {child.label}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                            ) : (
                                                <button
                                                    className={`w-full text-left px-3 py-2 text-xs rounded transition-colors ${theme === 'dark'
                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                        : 'text-zinc-700 hover:bg-zinc-100'
                                                        }`}
                                                    onClick={() => addNode(item.type, contextMenu.worldX, contextMenu.worldY, contextMenu.sourceNodeId, undefined, undefined, contextMenu.targetNodeId, contextMenu.inputType)}
                                                >
                                                    {item.label}
                                                </button>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {historyContextMenu.visible && (
                            <div
                                className={`fixed z-[100] w-max rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                    }`}
                                style={{ left: historyContextMenu.x, top: historyContextMenu.y }}
                            >
                                <div
                                    className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                >
                                    操作
                                </div>
                                <div
                                    className="relative"
                                    onMouseEnter={openHistorySendMenu}
                                    onMouseLeave={scheduleHistorySendMenuClose}
                                >
                                    <button
                                        className={`w-full whitespace-nowrap text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                            ? 'text-zinc-300 hover:bg-zinc-800'
                                            : 'text-zinc-700 hover:bg-zinc-100'
                                            }`}
                                        onClick={sendHistorySmart}
                                    >
                                        <Send size={14} className="text-blue-500" /> 智能发送
                                    </button>
                                    <button
                                        className={`absolute right-2 top-2 p-1 rounded ${theme === 'dark'
                                            ? 'text-zinc-500 hover:text-zinc-200'
                                            : 'text-zinc-400 hover:text-zinc-700'
                                            }`}
                                        onMouseEnter={openHistorySendMenu}
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            setHistorySendMenuOpen(prev => !prev);
                                        }}
                                        title={t('展开发送到')}
                                    >
                                        <ChevronRight size={12} className={`transition-transform ${historySendMenuOpen ? 'rotate-90' : ''}`} />
                                    </button>
                                    {historySendMenuOpen && (
                                        <div
                                            className={`absolute left-full top-0 ml-1 w-max rounded-lg shadow-2xl py-1 border ${theme === 'dark'
                                                ? 'bg-[#18181b] border-zinc-700'
                                                : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                                }`}
                                            onMouseEnter={openHistorySendMenu}
                                            onMouseLeave={scheduleHistorySendMenuClose}
                                        >
                                            <button
                                                className={`w-full whitespace-nowrap text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                    : 'text-zinc-700 hover:bg-zinc-100'
                                                    }`}
                                                onClick={sendHistoryToChat}
                                            >
                                                <MessageSquare size={14} className="text-purple-500" /> {t('发送到对话')}
                                            </button>
                                            <button
                                                className={`w-full whitespace-nowrap text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                    : 'text-zinc-700 hover:bg-zinc-100'
                                                    }`}
                                                onClick={sendHistoryToPreview}
                                            >
                                                <Maximize2 size={14} className="text-emerald-500" /> 发送到预览
                                            </button>
                                            <button
                                                className={`w-full whitespace-nowrap text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                    : 'text-zinc-700 hover:bg-zinc-100'
                                                    }`}
                                                onClick={sendHistoryToCanvas}
                                            >
                                                <CopyPlus size={14} className="text-blue-500" /> {t('发送到画布')}
                                            </button>
                                        </div>
                                    )}
                                </div>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={() => {
                                        const item = historyContextMenu.item;
                                        const resolvedUrl = item?.url || item?.localCacheUrl || item?.originalUrl || item?.mjOriginalUrl;
                                        if (resolvedUrl) {
                                            // 将九宫格切割结果推到历史卡片右侧，避免遮挡列表
                                            const startX = (historyContextMenu.worldX || 0) + 340; // 侧边栏约 320px，再留 20px 间距
                                            const startY = historyContextMenu.worldY || 0;
                                            handleSplitGridFromUrl(resolvedUrl, { originX: startX, originY: startY });
                                        }
                                        setHistoryContextMenu({ visible: false, x: 0, y: 0, worldX: 0, worldY: 0, item: null });
                                    }}
                                >
                                    <Scissors size={14} className="text-blue-500" /> 九宫格裁切
                                </button>
                                {/* V3.5.8: 下载单个项目 */}
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={async () => {
                                        const item = historyContextMenu.item;
                                        const resolvedUrl = item?.url || item?.localCacheUrl || item?.originalUrl || item?.mjOriginalUrl;
                                        if (!resolvedUrl) return;
                                        try {
                                            const isVideo = item.type === 'video' || resolvedUrl.includes('/video/') || resolvedUrl.includes('video_mp4');
                                            const ext = isVideo ? 'mp4' : 'png';
                                            const promptSlug = (item.prompt || 'download').replace(/[\\/:*?"<>|]/g, '_').slice(0, 50);
                                            const filename = `${promptSlug}.${ext}`;

                                            const useProxy = getItemProxyPreference(item);
                                            const { blob } = await fetchCacheSource(resolvedUrl, { useProxy });
                                            const blobUrl = window.URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = blobUrl;
                                            a.download = filename;
                                            a.click();
                                            window.URL.revokeObjectURL(blobUrl);
                                        } catch (err) {
                                            console.error('下载失败:', err);
                                            alert(t('下载失败，请重试'));
                                        }
                                        setHistoryContextMenu({ visible: false, x: 0, y: 0, worldX: 0, worldY: 0, item: null });
                                    }}
                                >
                                    <Download size={14} className="text-green-500" /> {historyContextMenu.item?.type === 'video' ? '下载视频' : '下载图片'}
                                </button>
                            </div>
                        )}

                        {selectionContextMenu.visible && (
                            <div
                                className={`fixed z-[120] w-52 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                    }`}
                                style={{ left: selectionContextMenu.x, top: selectionContextMenu.y }}
                                onMouseLeave={() => setSelectionContextMenu({ visible: false, x: 0, y: 0 })}
                            >
                                <div
                                    className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                >
                                    选中 {selectedNodeIds.size > 0 ? selectedNodeIds.size : (selectedNodeId ? 1 : 0)} 个节点
                                </div>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={handleSaveSelectedWorkflow}
                                >
                                    <Save size={14} className="text-blue-500" /> 保存当前选取工作流
                                </button>
                            </div>
                        )}

                        {frameContextMenu.visible && (
                            <div
                                className={`fixed z-[110] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                    }`}
                                style={{ left: frameContextMenu.x, top: frameContextMenu.y }}
                            >
                                <div
                                    className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                >
                                    操作
                                </div>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={sendFrameToChat}
                                >
                                    <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                </button>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={sendFrameToCanvas}
                                >
                                    <CopyPlus size={14} className="text-blue-500" /> {t('发送到画布')}
                                </button>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={sendFrameToPreview}
                                >
                                    <Maximize2 size={14} className="text-emerald-500" /> 发送到预览窗口
                                </button>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={applyFrameToSelectedNode}
                                >
                                    <ArrowRightSquare size={14} className={selectedNodeId ? 'text-green-500' : 'text-zinc-400'} /> 应用到选中节点
                                </button>
                            </div>
                        )}

                        {previewContextMenu.visible && (
                            <div
                                className={`fixed z-[110] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                    }`}
                                style={{ left: previewContextMenu.x, top: previewContextMenu.y }}
                                onMouseLeave={closePreviewContextMenu}
                            >
                                <div
                                    className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                >
                                    操作
                                </div>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={sendPreviewToChat}
                                >
                                    <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                </button>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={sendPreviewToCanvas}
                                >
                                    <CopyPlus size={14} className="text-blue-500" /> {t('发送到画布')}
                                </button>
                                {/* V3.7.27: 预览原图选项 */}
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={() => {
                                        const item = previewContextMenu.item;
                                        if (item?.url) {
                                            setLightboxItem({
                                                url: item.url,
                                                type: item.type || 'image',
                                                prompt: item.prompt || '',
                                                mjImages: getLightboxNavImages(item),
                                                output_images: item.output_images,
                                                selectedMjImageIndex: item.selectedMjImageIndex || 0
                                            });
                                        }
                                        closePreviewContextMenu();
                                    }}
                                >
                                    <Maximize2 size={14} className="text-green-500" /> {t('预览原图')}
                                </button>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={() => {
                                        const item = previewContextMenu.item;
                                        if (item?.url) {
                                            // 检查是否有框选的节点，且数量正好是9个
                                            const currentSelectedIds = selectedNodeIdsRef.current;
                                            const hasSelectedNodes = currentSelectedIds && currentSelectedIds.size === 9;

                                            if (hasSelectedNodes) {
                                                // 替换模式：直接替换已选中的9个节点
                                                handleSplitGridFromUrl(item.url, { replaceSelected: true });
                                            } else {
                                                // 创建新节点模式：在源节点旁边创建
                                                const source = item.sourceNode;
                                                const originX = source ? source.x + source.width + 20 : undefined;
                                                const originY = source ? source.y : undefined;
                                                handleSplitGridFromUrl(item.url, { originX, originY });
                                            }
                                        }
                                        closePreviewContextMenu();
                                    }}
                                >
                                    <Scissors size={14} className="text-blue-500" /> 九宫格裁切
                                </button>
                                {/* V3.7.29: 下载按钮 */}
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={async () => {
                                        const item = previewContextMenu.item;
                                        if (!item?.url) {
                                            closePreviewContextMenu();
                                            return;
                                        }
                                        try {
                                            const isVideo = item.type === 'video' || item.url.includes('/video/') || item.url.includes('video_mp4');
                                            const ext = isVideo ? 'mp4' : 'png';
                                            const promptSlug = (item.prompt || 'download').replace(/[\\/:*?"<>|]/g, '_').slice(0, 50);
                                            const filename = `${promptSlug}_${Date.now()}.${ext}`;

                                            const useProxy = getItemProxyPreference(item);
                                            const { blob } = await fetchCacheSource(item.url, { useProxy });
                                            const blobUrl = window.URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = blobUrl;
                                            a.download = filename;
                                            a.click();
                                            window.URL.revokeObjectURL(blobUrl);
                                        } catch (err) {
                                            console.error('下载失败:', err);
                                            showToast('下载失败，请重试', 'error');
                                        }
                                        closePreviewContextMenu();
                                    }}
                                >
                                    <Download size={14} className="text-cyan-500" /> {t('下载')}
                                </button>
                            </div>
                        )}

                        {inputImageContextMenu.visible && (
                            <div
                                className={`fixed z-[110] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : theme === 'solarized' ? 'bg-[#eee8d5] border-[#d7cfb2]' : 'bg-white border-zinc-200'
                                    }`}
                                style={{ left: inputImageContextMenu.x, top: inputImageContextMenu.y }}
                                onMouseLeave={closeInputImageContextMenu}
                            >
                                <div
                                    className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                >
                                    操作
                                </div>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={sendInputImageToChat}
                                >
                                    <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                </button>
                                <button
                                    className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${theme === 'dark'
                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                    onClick={() => {
                                        const nodeId = inputImageContextMenu.nodeId;
                                        const node = nodesMap.get(nodeId);
                                        if (!node || !node.content) return;

                                        // 检查是否有框选的节点，且数量正好是9个
                                        const currentSelectedIds = selectedNodeIdsRef.current;
                                        const hasSelectedNodes = currentSelectedIds && currentSelectedIds.size === 9;

                                        if (hasSelectedNodes) {
                                            // 替换模式：直接替换已选中的9个节点
                                            handleSplitGridFromUrl(node.content, { replaceSelected: true });
                                        } else {
                                            // 创建新节点模式：在源节点旁边创建
                                            const originX = node.x + node.width + 20;
                                            const originY = node.y;
                                            handleSplitGridFromUrl(node.content, { originX, originY });
                                        }
                                        closeInputImageContextMenu();
                                    }}
                                >
                                    <Scissors size={14} className="text-blue-500" /> 九宫格裁切
                                </button>
                            </div>
                        )}

                        <Lightbox
                            item={lightboxItem}
                            onClose={() => setLightboxItem(null)}
                            onNavigate={(newIndex) => {
                                // V3.7.22: 使用 ref 获取最新的 lightboxItem，避免闭包过时
                                const currentItem = lightboxItemRef.current;
                                const currentImages = getHistoryMultiImages(currentItem) || getLightboxNavImages(currentItem);
                                if (currentItem && currentImages && currentImages.length > newIndex && newIndex >= 0) {
                                    // 确保newIndex在有效范围内
                                    const validIndex = Math.max(0, Math.min(newIndex, currentImages.length - 1));
                                    const selectedUrl = currentImages[validIndex];
                                    const resolvedUrl = resolveHistoryUrl(currentItem, selectedUrl);

                                    // V3.7.22: 只有历史记录项（有 id 字段且无 storyboardContext）才更新历史记录
                                    if (currentItem.id && !currentItem.storyboardContext) {
                                        setHistory((prev) => prev.map((hItem) =>
                                            hItem.id === currentItem.id
                                                ? { ...hItem, url: selectedUrl, selectedMjImageIndex: validIndex }
                                                : hItem
                                        ));
                                    }

                                    // 更新lightboxItem显示，保持 storyboardContext 状态
                                    setLightboxItem({
                                        ...currentItem,
                                        mjImages: currentImages,
                                        url: resolvedUrl,
                                        selectedMjImageIndex: validIndex
                                    });
                                }
                            }}
                            onShotNavigate={(newShotIndex, allShots) => {
                                // V3.7.22: 使用 ref 获取最新的 lightboxItem
                                const currentItem = lightboxItemRef.current;
                                if (!currentItem?.storyboardContext || !allShots) return;

                                const currentIndex = currentItem.storyboardContext.shotIndex;
                                const direction = newShotIndex > currentIndex ? 1 : -1;

                                // V3.7.29: 跳过没有图片的镜头，找到下一个有图片的镜头
                                let targetIndex = newShotIndex;
                                let targetShot = null;

                                while (targetIndex >= 0 && targetIndex < allShots.length) {
                                    const candidateShot = allShots[targetIndex];
                                    const outputImages = candidateShot?.output_images || [];
                                    if (outputImages.length > 0) {
                                        targetShot = candidateShot;
                                        break;
                                    }
                                    targetIndex += direction;
                                }

                                if (!targetShot) return; // 找不到有图片的镜头

                                const outputImages = targetShot.output_images || [];
                                const imgIndex = 0; // 切换到新镜头时从第一张开始
                                setLightboxItem({
                                    url: outputImages[imgIndex],
                                    type: 'image',
                                    mjImages: outputImages,
                                    selectedMjImageIndex: imgIndex,
                                    prompt: targetShot.prompt,
                                    storyboardContext: {
                                        ...currentItem.storyboardContext,
                                        shotId: targetShot.id,
                                        shotIndex: targetIndex
                                    }
                                });
                            }}
                            onHistoryNavigate={(direction) => {
                                // V3.7.29: 历史项导航功能 (direction: -1=上一项, 1=下一项)
                                const currentItem = lightboxItemRef.current;
                                const debugNav = (stage, extra = {}) => {
                                    console.log('[Lightbox][history_nav]', {
                                        stage,
                                        direction,
                                        currentId: currentItem?.id || null,
                                        ...extra
                                    });
                                };
                                if (!currentItem || currentItem.storyboardContext) {
                                    debugNav('blocked', { reason: !currentItem ? 'no_current_item' : 'storyboard_context' });
                                    return; // 分镜模式不使用历史导航
                                }

                                const snapshotIds = lightboxHistorySnapshotRef.current;
                                const baseItems = historyNavItems;
                                let items = snapshotIds && snapshotIds.length > 1
                                    ? snapshotIds.map(id => historyMap.get(id)).filter(Boolean)
                                    : baseItems;
                                if (!items.length || items.length <= 1) {
                                    items = baseItems;
                                }
                                if (!items.length) {
                                    debugNav('blocked', { reason: 'no_items', snapshotCount: snapshotIds?.length || 0, baseCount: baseItems.length });
                                    return;
                                }

                                let currentIndex = getHistoryNavAnchorIndex(currentItem, items);
                                if (currentIndex === -1) {
                                    items = baseItems;
                                    currentIndex = getHistoryNavAnchorIndex(currentItem, items);
                                }
                                if (currentIndex === -1) {
                                    debugNav('blocked', { reason: 'anchor_not_found', itemCount: items.length, snapshotCount: snapshotIds?.length || 0 });
                                    return;
                                }
                                if (!snapshotIds || snapshotIds.length === 0) {
                                    lightboxHistorySnapshotRef.current = items.map(h => h.id);
                                }

                                let nextIndex = findHistoryNavIndex(items, currentIndex, direction);
                                if (nextIndex < 0 && items !== baseItems) {
                                    items = baseItems;
                                    currentIndex = getHistoryNavAnchorIndex(currentItem, items);
                                    if (currentIndex < 0) {
                                        debugNav('blocked', { reason: 'fallback_anchor_not_found', baseCount: baseItems.length });
                                        return;
                                    }
                                    nextIndex = findHistoryNavIndex(items, currentIndex, direction);
                                }
                                if (nextIndex < 0) {
                                    debugNav('blocked', { reason: 'next_index_not_found', currentIndex, itemCount: items.length });
                                    return;
                                }
                                let candidate = items[nextIndex];
                                if (candidate?.id === currentItem.id) {
                                    const retryIndex = findHistoryNavIndex(items, nextIndex, direction);
                                    if (retryIndex < 0) {
                                        debugNav('blocked', { reason: 'retry_index_not_found', nextIndex, itemCount: items.length });
                                        return;
                                    }
                                    nextIndex = retryIndex;
                                    candidate = items[nextIndex];
                                }
                                if (!candidate) {
                                    debugNav('blocked', { reason: 'candidate_missing', nextIndex });
                                    return;
                                }
                                // 纵向切组时强制落在组内第 1 张，避免跨组索引污染导致跳图
                                const preview = getHistoryNavPreview(candidate, { forceFirstImage: true });
                                const resolvedUrl = preview.url;
                                const selectedIndex = preview.index;
                                if (!candidate || candidate.id === currentItem.id) {
                                    debugNav('blocked', { reason: 'candidate_same_as_current', candidateId: candidate?.id || null });
                                    return;
                                }
                                if (!resolvedUrl) {
                                    debugNav('blocked', { reason: 'empty_preview_url', candidateId: candidate.id, selectedIndex });
                                    return;
                                }

                                lightboxHistoryIndexRef.current = nextIndex;
                                setHistoryFocusId(candidate.id);
                                setHistoryFocusIndex(nextIndex);
                                const candidateImages = getHistoryMultiImages(candidate) || getLightboxNavImages(candidate);
                                debugNav('navigate', {
                                    fromIndex: currentIndex,
                                    toIndex: nextIndex,
                                    candidateId: candidate.id,
                                    itemCount: items.length,
                                    snapshotCount: snapshotIds?.length || 0
                                });
                                setLightboxItem({
                                    ...candidate,
                                    mjImages: candidateImages || candidate.mjImages || null,
                                    url: resolvedUrl,
                                    selectedMjImageIndex: selectedIndex,
                                    storyboardContext: null
                                });
                            }}
                        />

                        <Modal isOpen={settingsOpen} onClose={() => setSettingsOpen(false)} title={t('模型接口配置')} theme={theme}>
                            <div className="px-4 pt-3">
                                <div className={`inline-flex rounded-md border ${theme === 'dark'
                                    ? 'border-zinc-800 bg-[#18181b]'
                                    : theme === 'solarized'
                                        ? 'border-[#d7cfb2] bg-[#eee8d5]'
                                        : 'border-zinc-200 bg-zinc-50'
                                    } p-1`}>
                                    <button
                                        onClick={() => setSettingsTab('providers')}
                                        className={`px-3 py-1 text-xs rounded ${settingsTab === 'providers'
                                            ? theme === 'dark'
                                                ? 'bg-zinc-800 text-zinc-100'
                                                : theme === 'solarized'
                                                    ? 'bg-[#fdf6e3] text-zinc-800'
                                                    : 'bg-white text-zinc-800'
                                            : theme === 'dark'
                                                ? 'text-zinc-400 hover:text-zinc-200'
                                                : theme === 'solarized'
                                                    ? 'text-[#586e75] hover:text-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-700'
                                            }`}
                                    >
                                        {t('接口配置')}
                                    </button>
                                    <button
                                        onClick={() => setSettingsTab('library')}
                                        className={`px-3 py-1 text-xs rounded ${settingsTab === 'library'
                                            ? theme === 'dark'
                                                ? 'bg-zinc-800 text-zinc-100'
                                                : theme === 'solarized'
                                                    ? 'bg-[#fdf6e3] text-zinc-800'
                                                    : 'bg-white text-zinc-800'
                                            : theme === 'dark'
                                                ? 'text-zinc-400 hover:text-zinc-200'
                                                : theme === 'solarized'
                                                    ? 'text-[#586e75] hover:text-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-700'
                                            }`}
                                    >
                                        {t('模型库')}
                                    </button>
                                </div>
                            </div>
                            {settingsTab === 'providers' && (
                                <>
                                    <details className={`mx-4 mt-3 rounded-md border ${theme === 'dark'
                                        ? 'border-zinc-800 bg-[#18181b]'
                                        : theme === 'solarized'
                                            ? 'border-[#d7cfb2] bg-[#eee8d5]'
                                            : 'border-zinc-200 bg-white'
                                        }`}>
                                        <summary className={`cursor-pointer select-none px-3 py-2 text-xs font-medium ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                            {t('基础设置')}
                                        </summary>
                                        <div className="px-3 pb-3 pt-2 space-y-4">
                                            <div className="space-y-2">
                                                <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('全局 API Key（可选，全局默认 Key）')}</label>
                                                <input
                                                    type="password"
                                                    value={globalApiKey}
                                                    onChange={(e) => setGlobalApiKey(e.target.value)}
                                                    className={`w-full rounded px-2 py-1 text-xs outline-none focus:border-blue-600/50 border ${theme === 'dark'
                                                        ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                        : 'bg-white border-zinc-300 text-zinc-900'
                                                        }`}
                                                    placeholder={t('如果不想每个模型单独填 Key，可以在这里填一个全局 Key')}
                                                />
                                            </div>

                                            <div className="border-t pt-3 border-zinc-700/50">
                                                <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('实验室功能')}</label>
                                                <div className="grid grid-cols-2 gap-3 mt-2">
                                                    <div>
                                                        <div className="flex items-center justify-between mb-1">
                                                            <span className={`text-xs ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>{t('保存资产包（Zip）')}</span>
                                                            <button
                                                                className={`w-10 h-5 rounded-full relative transition-colors ${saveHistoryAssets ? 'bg-blue-600' : theme === 'dark' ? 'bg-zinc-700' : 'bg-zinc-300'}`}
                                                                onClick={() => setSaveHistoryAssets(prev => !prev)}
                                                            >
                                                                <div className={`absolute top-1 w-3 h-3 rounded-full bg-white transition-all ${saveHistoryAssets ? 'left-6' : 'left-1'}`} />
                                                            </button>
                                                        </div>
                                                        <p className="text-[9px] text-zinc-500">{t('导出时打包历史图片/视频与项目文件，便于离线恢复。')}</p>
                                                        <div className="mt-2 flex items-center justify-between gap-2">
                                                            <span className={`text-xs ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>{t('历史保存上限')}</span>
                                                            <div className="flex items-center gap-2">
                                                                <input
                                                                    type="number"
                                                                    min={HISTORY_SAVE_LIMIT_MIN}
                                                                    max={HISTORY_SAVE_LIMIT_MAX}
                                                                    step="10"
                                                                    value={historySaveLimitInput}
                                                                    onChange={(e) => {
                                                                        const raw = e.target.value;
                                                                        setHistorySaveLimitInput(raw);
                                                                        if (historySaveLimitTimerRef.current) {
                                                                            clearTimeout(historySaveLimitTimerRef.current);
                                                                        }
                                                                        historySaveLimitTimerRef.current = setTimeout(() => {
                                                                            applyHistorySaveLimitInput(raw);
                                                                        }, 1000);
                                                                    }}
                                                                    onBlur={() => {
                                                                        if (historySaveLimitTimerRef.current) {
                                                                            clearTimeout(historySaveLimitTimerRef.current);
                                                                            historySaveLimitTimerRef.current = null;
                                                                        }
                                                                        applyHistorySaveLimitInput(historySaveLimitInput);
                                                                        if (!historySaveLimitInput || Number.isNaN(Number.parseInt(historySaveLimitInput, 10))) {
                                                                            setHistorySaveLimitInput(String(historySaveLimit));
                                                                        }
                                                                    }}
                                                                    className={`w-20 text-xs rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                        ? 'bg-zinc-800 border-zinc-700 text-zinc-300'
                                                                        : 'bg-white border-zinc-300 text-zinc-800'
                                                                        }`}
                                                                />
                                                                <span className="text-[10px] text-zinc-500">条</span>
                                                            </div>
                                                        </div>
                                                        <p className="text-[9px] text-zinc-500">{t('影响历史持久化与打包范围，最大160条。')}</p>
                                                    </div>
                                                    <div>
                                                        <div className="flex flex-col gap-1">
                                                            <span className={`text-xs ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>{t('本地服务地址')}</span>
                                                            <input
                                                                type="text"
                                                                value={localServerUrl}
                                                                onChange={(e) => {
                                                                    const url = e.target.value;
                                                                    setLocalServerUrl(url);
                                                                    localStorage.setItem('tapnow_local_server_url', url);
                                                                }}
                                                                placeholder="http://127.0.0.1:9527"
                                                                className={`w-full text-xs rounded px-2 py-1 border outline-none ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300' : 'bg-white border-zinc-300'}`}
                                                            />
                                                            <div className="flex items-center gap-1.5 text-[10px] text-zinc-500">
                                                                <span className={`inline-block w-2 h-2 rounded-full ${localCacheEnabled ? (localCacheServerConnected ? 'bg-green-500' : 'bg-red-500') : 'bg-zinc-400'}`} />
                                                                <span>
                                                                    {localCacheEnabled
                                                                        ? (localCacheServerConnected ? t('本地缓存已连接') : t('本地缓存未连接'))
                                                                        : t('本地缓存已关闭')}
                                                                </span>
                                                            </div>
                                                        </div>
                                                        <p className="text-[9px] text-zinc-500 mt-1">{t('用于连接本地后端服务，支持大文件保存和处理。')}</p>
                                                    </div>
                                                </div>
                                            </div>

                                            <div className="border-t pt-3 border-zinc-700/50 space-y-2">
                                                <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('其他设置')}</label>
                                                <div className="mb-2">
                                                    <div className="flex items-center justify-between">
                                                        <div className="flex-1">
                                                            <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                {t('界面语言')}
                                                            </label>
                                                            <p className={`text-[10px] mt-0.5 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                                                {t('切换中文/英文')}
                                                            </p>
                                                        </div>
                                                        <div className="flex items-center gap-1 ml-3">
                                                            <button
                                                                onClick={() => setLanguage('zh')}
                                                                className={`px-2 py-1 text-[10px] rounded border transition-colors ${language === 'zh'
                                                                    ? 'bg-blue-600 text-white border-blue-500'
                                                                    : theme === 'dark'
                                                                        ? 'bg-zinc-800 text-zinc-400 border-zinc-700 hover:text-zinc-200'
                                                                        : 'bg-white text-zinc-600 border-zinc-300 hover:text-zinc-800'
                                                                    }`}
                                                            >
                                                                {t('中文')}
                                                            </button>
                                                            <button
                                                                onClick={() => setLanguage('en')}
                                                                className={`px-2 py-1 text-[10px] rounded border transition-colors ${language === 'en'
                                                                    ? 'bg-blue-600 text-white border-blue-500'
                                                                    : theme === 'dark'
                                                                        ? 'bg-zinc-800 text-zinc-400 border-zinc-700 hover:text-zinc-200'
                                                                        : 'bg-white text-zinc-600 border-zinc-300 hover:text-zinc-800'
                                                                    }`}
                                                            >
                                                                {t('英文')}
                                                            </button>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div className="mb-2">
                                                    <div className="flex items-center justify-between">
                                                        <div className="flex-1">
                                                            <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                {t('撤销/重做步数')}
                                                            </label>
                                                            <p className={`text-[10px] mt-0.5 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                                                设置可撤销的最大步数 (粘贴图片、删除节点等操作)
                                                            </p>
                                                        </div>
                                                        <div className="flex items-center gap-2 ml-3">
                                                            <input
                                                                type="range"
                                                                min="1"
                                                                max="30"
                                                                value={maxUndoSteps}
                                                                onChange={(e) => {
                                                                    const newValue = parseInt(e.target.value) || 5;
                                                                    setMaxUndoSteps(newValue);
                                                                    localStorage.setItem('tapnow_max_undo_steps', String(newValue));
                                                                }}
                                                                className="w-20"
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            />
                                                            <span className={`text-xs font-mono w-6 text-center ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                {maxUndoSteps}
                                                            </span>
                                                        </div>
                                                    </div>
                                                </div>

                                                <div className="mb-2">
                                                    <div className="flex items-center justify-between">
                                                        <div className="flex-1">
                                                            <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                {t('即梦图生图使用本地文件')}
                                                            </label>
                                                            <p className={`text-[10px] mt-0.5 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                                                {t('启用后，即梦模型的图生图功能将强制使用本地文件（FormData），URL图片会自动下载转换为本地文件')}
                                                            </p>
                                                        </div>
                                                        <label className="relative inline-flex items-center cursor-pointer ml-3">
                                                            <input
                                                                type="checkbox"
                                                                checked={jimengUseLocalFile}
                                                                onChange={(e) => {
                                                                    const newValue = e.target.checked;
                                                                    setJimengUseLocalFile(newValue);
                                                                    localStorage.setItem('tapnow_jimeng_use_local_file', String(newValue));
                                                                }}
                                                                className="sr-only peer"
                                                            />
                                                            <div className={`w-11 h-6 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500/50 ${jimengUseLocalFile
                                                                ? 'bg-blue-600'
                                                                : theme === 'dark'
                                                                    ? 'bg-zinc-700'
                                                                    : 'bg-zinc-300'
                                                                } peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all`}></div>
                                                        </label>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </details>

                                    <div className={`mx-4 mt-3 rounded-md border ${theme === 'dark'
                                        ? 'border-zinc-800 bg-[#18181b]'
                                        : theme === 'solarized'
                                            ? 'border-[#d7cfb2] bg-[#eee8d5]'
                                            : 'border-zinc-200 bg-white'
                                        }`}>
                                        <div className="px-3 py-3">
                                            <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('API 配置备份')}</label>
                                            <div className="flex gap-2 mt-2">
                                                <button
                                                    onClick={() => {
                                                        const exportData = {
                                                            version: '3.4.23',
                                                            exportTime: new Date().toISOString(),
                                                            globalApiKey,
                                                            providers,
                                                            modelLibrary,
                                                            modelLibraryCollapsed: Array.from(collapsedLibraryModels),
                                                            // V3.4.23: 导出时移除模型级别的 key/url，只保留纯净的配置
                                                            apiConfigs: apiConfigs.map(({ key, url, ...c }) => c),
                                                        };
                                                        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                                                        const url = URL.createObjectURL(blob);
                                                        const a = document.createElement('a');
                                                        a.href = url;
                                                        const now = new Date();
                                                        const yy = now.getFullYear().toString().slice(2);
                                                        const mm = (now.getMonth() + 1).toString().padStart(2, '0');
                                                        const dd = now.getDate().toString().padStart(2, '0');
                                                        const hh = now.getHours().toString().padStart(2, '0');
                                                        const min = now.getMinutes().toString().padStart(2, '0');
                                                        a.download = `tapnow-api-keys-${yy}${mm}${dd}-${hh}${min}.json`;
                                                        a.click();
                                                        URL.revokeObjectURL(url);
                                                    }}
                                                    className={`flex-1 px-3 py-2 text-xs rounded flex items-center justify-center gap-2 transition-colors ${theme === 'dark'
                                                        ? 'bg-blue-600/20 text-blue-400 hover:bg-blue-600/30 border border-blue-500/30'
                                                        : 'bg-blue-50 text-blue-600 hover:bg-blue-100 border border-blue-200'
                                                        }`}
                                                >
                                                    <Download size={14} />
                                                    {t('导出 API Keys')}
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        const input = document.createElement('input');
                                                        input.type = 'file';
                                                        input.accept = '.json';
                                                        input.onchange = async (e) => {
                                                            const file = e.target.files[0];
                                                            if (!file) return;
                                                            try {
                                                                const text = await file.text();
                                                                const data = JSON.parse(text);
                                                                if (data.globalApiKey) {
                                                                    setGlobalApiKey(data.globalApiKey);
                                                                    localStorage.setItem('tapnow_global_key', data.globalApiKey);
                                                                }
                                                                if (data.providers) {
                                                                    const normalized = Object.fromEntries(
                                                                        Object.entries(data.providers).map(([key, config]) => [key, normalizeProviderConfig(key, config)])
                                                                    );
                                                                    setProviders(prev => ({ ...prev, ...normalized }));
                                                                }
                                                                if (data.modelLibrary && Array.isArray(data.modelLibrary)) {
                                                                    const normalizedLibrary = data.modelLibrary
                                                                        .map((entry) => ({
                                                                            id: entry.id,
                                                                            displayName: entry.displayName || entry.modelName || entry.id,
                                                                            modelName: entry.modelName || entry.displayName || entry.id,
                                                                            type: entry.type || 'Chat',
                                                                            apiType: entry.apiType || 'openai',
                                                                            ratioLimits: Array.isArray(entry.ratioLimits) ? entry.ratioLimits : null,
                                                                            ratioNotes: normalizeValueNotes(entry.ratioNotes),
                                                                            ratioNotesEnabled: !!entry.ratioNotesEnabled,
                                                                            resolutionLimits: Array.isArray(entry.resolutionLimits) ? entry.resolutionLimits : null,
                                                                            resolutionNotes: normalizeResolutionNotes(entry.resolutionNotes),
                                                                            resolutionNotesEnabled: !!entry.resolutionNotesEnabled,
                                                                            durations: Array.isArray(entry.durations) ? entry.durations : null,
                                                                            durationNotes: normalizeValueNotes(entry.durationNotes),
                                                                            durationNotesEnabled: !!entry.durationNotesEnabled,
                                                                            videoResolutions: Array.isArray(entry.videoResolutions) ? entry.videoResolutions : null,
                                                                            videoResolutionNotes: normalizeValueNotes(entry.videoResolutionNotes),
                                                                            videoResolutionNotesEnabled: !!entry.videoResolutionNotesEnabled,
                                                                            supportsFirstLastFrame: !!entry.supportsFirstLastFrame,
                                                                            supportsHD: !!entry.supportsHD,
                                                                            omitRatioOnSubmit: !!entry.omitRatioOnSubmit,
                                                                            omitResolutionOnSubmit: !!entry.omitResolutionOnSubmit,
                                                                            customParams: normalizeCustomParams(entry.customParams),
                                                                            asyncConfig: entry.asyncConfig && typeof entry.asyncConfig === 'object' ? entry.asyncConfig : null,
                                                                            previewOverrideEnabled: !!entry.previewOverrideEnabled,
                                                                            previewOverridePatch: normalizePreviewOverridePatch(entry.previewOverridePatch),
                                                                            requestTemplate: normalizeRequestTemplate(entry.requestTemplate || getDefaultRequestTemplateForEntry(entry)),
                                                                            requestOverrideEnabled: !!entry.requestOverrideEnabled,
                                                                            requestOverridePatch: normalizeRequestOverridePatch(entry.requestOverridePatch)
                                                                        }))
                                                                        .filter((entry) => entry.id);
                                                                    setModelLibrary(normalizedLibrary);
                                                                }
                                                                if (Array.isArray(data.modelLibraryCollapsed)) {
                                                                    const collapsedSet = new Set(data.modelLibraryCollapsed.filter(Boolean));
                                                                    collapsedLibraryStateLoadedRef.current = true;
                                                                    setCollapsedLibraryModels(collapsedSet);
                                                                    try {
                                                                        localStorage.setItem('tapnow_model_library_collapsed', JSON.stringify(Array.from(collapsedSet)));
                                                                    } catch (e) {
                                                                        console.error('保存模型库折叠状态失败:', e);
                                                                    }
                                                                }
                                                                if (data.apiConfigs && Array.isArray(data.apiConfigs)) {
                                                                    // V3.6.0: 迁移导入的旧格式配置
                                                                    const migratedConfigs = data.apiConfigs.map(config => {
                                                                        const normalized = {
                                                                            ...config,
                                                                            id: config.id || config.modelName,
                                                                            provider: config.provider,
                                                                            type: config.type || 'Chat',
                                                                            modelName: config.modelName || config.id,
                                                                            displayName: config.displayName || config.modelName || config.id,
                                                                            _uid: config._uid || `uid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                                                                            ...(config.durations ? { durations: config.durations } : {})
                                                                        };
                                                                        const { key, url, isCustom, ...rest } = normalized;
                                                                        return rest;
                                                                    });
                                                                    // 直接替换，不合并
                                                                    setApiConfigs(migratedConfigs);
                                                                }
                                                                alert(t('API 配置导入成功！'));
                                                            } catch (err) {
                                                                alert('导入失败: ' + err.message);
                                                            }
                                                        };
                                                        input.click();
                                                    }}
                                                    className={`flex-1 px-3 py-2 text-xs rounded flex items-center justify-center gap-2 transition-colors ${theme === 'dark'
                                                        ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700 border border-zinc-700'
                                                        : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200 border border-zinc-300'
                                                        }`}
                                                >
                                                    <FolderOpen size={14} />
                                                    {t('导入 API Keys')}
                                                </button>
                                            </div>
                                            <p className="text-[9px] text-zinc-500 mt-1">{t('导出包含：全局 Key、Provider 配置、模型库、所有模型配置（含 Key）')}</p>
                                        </div>
                                    </div>

                                    <div className={`mx-4 mt-3 rounded-md border ${theme === 'dark'
                                        ? 'border-zinc-800 bg-[#18181b]'
                                        : theme === 'solarized'
                                            ? 'border-[#d7cfb2] bg-[#eee8d5]'
                                            : 'border-zinc-200 bg-white'
                                        }`}>
                                        <div className="px-3 py-3">
                                            <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('API 运行状态管理')}</label>
                                            <div className="grid grid-cols-3 gap-2 mt-2">
                                                <button
                                                    onClick={() => {
                                                        setApiBlacklist({});
                                                        apiBlacklistRef.current = {};
                                                        alert(t('黑名单已清空'));
                                                    }}
                                                    className={`px-2 py-1.5 text-[10px] rounded flex items-center justify-center gap-1 transition-colors ${theme === 'dark'
                                                        ? 'bg-red-600/20 text-red-400 hover:bg-red-600/30 border border-red-500/30'
                                                        : 'bg-red-50 text-red-600 hover:bg-red-100 border border-red-200'}`}
                                                >
                                                    <Ban size={12} />{t('清空黑名单')}
                                                    {Object.keys(apiBlacklist).length > 0 && <span className="ml-1 px-1 rounded bg-red-500/30 text-[9px]">{Object.keys(apiBlacklist).length}</span>}
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        setApiSuspendList({});
                                                        alert(t('暂停列表已清空'));
                                                    }}
                                                    className={`px-2 py-1.5 text-[10px] rounded flex items-center justify-center gap-1 transition-colors ${theme === 'dark'
                                                        ? 'bg-amber-600/20 text-amber-400 hover:bg-amber-600/30 border border-amber-500/30'
                                                        : 'bg-amber-50 text-amber-600 hover:bg-amber-100 border border-amber-200'}`}
                                                >
                                                    <Clock size={12} />{t('清空暂停')}
                                                    {Object.keys(apiSuspendList).length > 0 && <span className="ml-1 px-1 rounded bg-amber-500/30 text-[9px]">{Object.keys(apiSuspendList).length}</span>}
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        error1006WindowRef.current = [];
                                                        alert(t('熔断已重置'));
                                                    }}
                                                    className={`px-2 py-1.5 text-[10px] rounded flex items-center justify-center gap-1 transition-colors ${theme === 'dark'
                                                        ? 'bg-blue-600/20 text-blue-400 hover:bg-blue-600/30 border border-blue-500/30'
                                                        : 'bg-blue-50 text-blue-600 hover:bg-blue-100 border border-blue-200'}`}
                                                >
                                                    <Zap size={12} />{t('重置熔断')}
                                                </button>
                                            </div>
                                            <p className="text-[9px] text-zinc-500 mt-1">{t('黑名单 = 积分耗尽，暂停 = 临时错误（60分钟后自动恢复），熔断 = 短时大量1006错误保护')}</p>
                                        </div>
                                    </div>

                                    <div className={`mx-4 mt-3 rounded-md border ${theme === 'dark'
                                        ? 'border-zinc-800 bg-[#18181b]'
                                        : theme === 'solarized'
                                            ? 'border-[#d7cfb2] bg-[#eee8d5]'
                                            : 'border-zinc-200 bg-white'
                                        }`}>
                                        <div className={`px-3 py-2 text-xs font-medium ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                            {t('接口与模型列表')}
                                        </div>
                                        <div className="px-3 pb-3 pt-2">
                            <div className="flex justify-between items-center mb-2">
                                <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>{t('管理您的第三方模型接口。')}</span>
                                <div className="flex items-center gap-2">
                                    <button
                                        onClick={() => {
                                            // Toggle all: if any expanded, collapse all; otherwise expand all
                                            const hasExpanded = Object.values(expandedProviders).some(v => v);
                                            const newExpanded = {};
                                            if (!hasExpanded) {
                                                Object.keys(groupedApiConfigs).forEach(key => newExpanded[key] = true);
                                            }
                                            setExpandedProviders(newExpanded);
                                        }}
                                        className={`p-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}
                                        title={Object.values(expandedProviders).some(v => v) ? "折叠所有" : "展开所有"}
                                    >
                                        <ChevronsUp size={14} className={`transition-transform ${!Object.values(expandedProviders).some(v => v) ? 'rotate-180' : ''}`} />
                                    </button>
                                    <Button className="h-7 text-xs px-3 bg-blue-600 hover:bg-blue-500" onClick={() => {
                                        // V3.4.7: 添加供应商 - 自动创建并进入编辑模式
                                        const newKey = `custom-${Date.now()}`;
                                        const newName = 'New Provider';
                                        setProviders(prev => ({ ...prev, [newKey]: normalizeProviderConfig(newKey, { key: '', url: '', enabled: true }) }));
                                        setExpandedProviders(prev => ({ ...prev, [newKey]: true }));
                                        setEditingProvider({ key: newKey, tempName: newName });
                                    }}><Plus size={14} className="mr-1" /> {t('添加供应商')}</Button>
                                </div>
                            </div>
                                    <div className="space-y-2 max-h-[50vh] overflow-y-auto custom-scrollbar pr-1">
                                        {/* V3.4.7: 按 Provider 分组显示模型 */}
                                        {Object.entries(groupedApiConfigs).map(([providerKey, group]) => (
                                            <div key={providerKey} className={`group rounded-lg border ${theme === 'dark'
                                                ? 'bg-[#18181b] border-zinc-800'
                                                : theme === 'solarized'
                                                    ? 'bg-[#fdf6e3] border-[#d7cfb2]'
                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                                }`}>
                                        {/* Provider 标题行 (可折叠) */}
                                        <button
                                            onClick={() => setExpandedProviders(prev => ({ ...prev, [providerKey]: !prev[providerKey] }))}
                                            className={`w-full flex items-center justify-between px-3 py-2.5 text-left transition-colors ${theme === 'dark'
                                                ? 'hover:bg-zinc-800/50'
                                                : theme === 'solarized'
                                                    ? 'hover:bg-[#eee8d5]'
                                                    : 'hover:bg-zinc-100'
                                                }`}
                                        >
                                            {deletingProviderKey === providerKey ? (
                                                <div className="flex items-center justify-between w-full">
                                                    <span className={`text-sm font-semibold ${theme === 'dark' ? 'text-zinc-100' : 'text-zinc-800'}`}>
                                                        确定删除 {group.name}?
                                                    </span>
                                                    <div className="flex items-center gap-2">
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                // Delete provider
                                                                setProviders(prev => {
                                                                    const next = { ...prev };
                                                                    delete next[providerKey];
                                                                    return next;
                                                                });
                                                                setDeletingProviderKey(null);
                                                            }}
                                                            className="text-xs px-2 py-1 bg-red-600 hover:bg-red-700 text-white rounded"
                                                        >
                                                            {t('删除')}
                                                        </button>
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                setDeletingProviderKey(null);
                                                            }}
                                                            className={`text-xs px-2 py-1 rounded ${theme === 'dark' ? 'bg-zinc-700 hover:bg-zinc-600 text-zinc-300' : 'bg-zinc-200 hover:bg-zinc-300 text-zinc-700'}`}
                                                        >
                                                            {t('取消')}
                                                        </button>
                                                    </div>
                                                </div>
                                            ) : (
                                                <>
                                                    <div className="flex items-center gap-2 flex-1">
                                                        <div className={`w-2 h-2 rounded-full ${providers[providerKey]?.enabled !== false ? 'bg-green-500' : 'bg-zinc-500'}`}></div>
                                                        {editingProvider?.key === providerKey ? (
                                                            <input
                                                                type="text"
                                                                value={editingProvider.tempName}
                                                                onChange={(e) => setEditingProvider(prev => ({ ...prev, tempName: e.target.value }))}
                                                                onBlur={() => {
                                                                    const newKey = editingProvider.tempName.trim();
                                                                    const oldKey = providerKey;
                                                                    if (newKey && newKey !== oldKey) {
                                                                        // V3.6.0: 重命名 provider key（不用 name 字段）
                                                                        setProviders(prev => {
                                                                            const { [oldKey]: oldConfig, ...rest } = prev;
                                                                            return { ...rest, [newKey]: oldConfig };
                                                                        });
                                                                        // 同步更新所有引用该 provider 的模型
                                                                        setApiConfigs(prev => prev.map(c =>
                                                                            c.provider === oldKey ? { ...c, provider: newKey } : c
                                                                        ));
                                                                    }
                                                                    setEditingProvider(null);
                                                                }}
                                                                onKeyDown={(e) => {
                                                                    if (e.key === 'Enter') {
                                                                        e.target.blur();
                                                                    }
                                                                    e.stopPropagation();
                                                                }}
                                                                onClick={(e) => e.stopPropagation()}
                                                                autoFocus
                                                                className={`text-sm font-semibold bg-transparent border-b border-blue-500 outline-none w-full ${theme === 'dark' ? 'text-zinc-100' : 'text-zinc-800'}`}
                                                            />
                                                        ) : (
                                                            <span className={`text-sm font-semibold ${theme === 'dark' ? 'text-zinc-100' : 'text-zinc-800'}`}>{group.name}</span>
                                                        )}
                                                        <span className={`text-[10px] px-1.5 py-0.5 rounded ${theme === 'dark'
                                                            ? 'bg-zinc-800 text-zinc-500'
                                                            : theme === 'solarized'
                                                                ? 'bg-[#eee8d5] text-zinc-600'
                                                                : 'bg-zinc-200 text-zinc-500'}`}>
                                                            {group.models.length} 模型
                                                        </span>
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        {!editingProvider && (
                                                            <>
                                                                <button
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        setEditingProvider({ key: providerKey, tempName: group.name });
                                                                    }}
                                                                    className={`p-1 rounded-full hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors opacity-0 group-hover:opacity-100`}
                                                                    title={t('修改名称')}
                                                                >
                                                                    <Edit2 size={12} className={theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'} />
                                                                </button>
                                                                <button
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        setDeletingProviderKey(providerKey);
                                                                    }}
                                                                    className={`p-1 rounded-full hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors opacity-0 group-hover:opacity-100`}
                                                                    title={t('删除供应商')}
                                                                >
                                                                    <Trash2 size={12} className={theme === 'dark' ? 'text-zinc-400 hover:text-red-400' : 'text-zinc-500 hover:text-red-500'} />
                                                                </button>
                                                            </>
                                                        )}
                                                        <ChevronDown size={16} className={`transition-transform ${expandedProviders[providerKey] ? 'rotate-180' : ''} ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`} />
                                                    </div>
                                                </>
                                            )}
                                        </button>

                                        {/* Provider 展开内容 */}
                                        {expandedProviders[providerKey] && (
                                            <div className={`px-3 pb-3 border-t ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'}`}>
                                                {/* Provider 级别设置 */}
                                                <div className="pt-3 pb-2 space-y-2">
                                                    <div className="grid grid-cols-4 items-center gap-2">
                                                        <label className={`text-[10px] font-medium uppercase tracking-wider text-right ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('接口类型')}</label>
                                                        <select
                                                            value={providers[providerKey]?.apiType || 'openai'}
                                                            onChange={(e) => setProviders(prev => ({ ...prev, [providerKey]: { ...prev[providerKey], apiType: e.target.value } }))}
                                                            className={`col-span-3 w-full rounded px-2 py-1 text-xs outline-none focus:border-blue-600/50 border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-800 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-900'}`}
                                                        >
                                                            <option value="openai">OpenAI</option>
                                                            <option value="gemini">Gemini</option>
                                                            <option value="modelscope">ModelScope</option>
                                                        </select>
                                                    </div>
                                                    <div className="grid grid-cols-4 items-center gap-2">
                                                        <label className={`text-[10px] font-medium uppercase tracking-wider text-right ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('本地代理')}</label>
                                                        <div className="col-span-3 flex items-center gap-2">
                                                            <label className="relative inline-flex items-center cursor-pointer">
                                                                <input
                                                                    type="checkbox"
                                                                    checked={!!providers[providerKey]?.useProxy}
                                                                    onChange={(e) => setProviders(prev => ({ ...prev, [providerKey]: { ...prev[providerKey], useProxy: e.target.checked } }))}
                                                                    className="sr-only peer"
                                                                />
                                                                <div className={`w-9 h-5 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500/50 ${providers[providerKey]?.useProxy
                                                                    ? 'bg-blue-600'
                                                                    : theme === 'dark'
                                                                        ? 'bg-zinc-700'
                                                                        : 'bg-zinc-300'
                                                                    } peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all`}></div>
                                                            </label>
                                                            <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>使用 {localServerUrl || 'http://127.0.0.1:9527'}/proxy</span>
                                                        </div>
                                                    </div>
                                                    <div className="grid grid-cols-4 items-center gap-2">
                                                        <label className={`text-[10px] font-medium uppercase tracking-wider text-right ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('异步模式')}</label>
                                                        <div className="col-span-3 flex items-center gap-2">
                                                            <label className="relative inline-flex items-center cursor-pointer">
                                                                <input
                                                                    type="checkbox"
                                                                    checked={!!providers[providerKey]?.forceAsync}
                                                                    onChange={(e) => setProviders(prev => ({ ...prev, [providerKey]: { ...prev[providerKey], forceAsync: e.target.checked } }))}
                                                                    className="sr-only peer"
                                                                />
                                                                <div className={`w-9 h-5 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500/50 ${providers[providerKey]?.forceAsync
                                                                    ? 'bg-blue-600'
                                                                    : theme === 'dark'
                                                                        ? 'bg-zinc-700'
                                                                        : 'bg-zinc-300'
                                                                    } peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all`}></div>
                                                            </label>
                                                            <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('ModelScope 建议开启')}</span>
                                                        </div>
                                                    </div>
                                                    <div className="grid grid-cols-4 items-center gap-2">
                                                        <label className={`text-[10px] font-medium uppercase tracking-wider text-right ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>API Key</label>
                                                        <input
                                                            type="password"
                                                            value={providers[providerKey]?.key || ''}
                                                            onChange={(e) => setProviders(prev => ({ ...prev, [providerKey]: { ...prev[providerKey], key: e.target.value } }))}
                                                            className={`col-span-3 w-full rounded px-2 py-1 text-xs outline-none focus:border-blue-600/50 border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-800 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-900'}`}
                                                            placeholder="sk-..."
                                                        />
                                                    </div>
                                                    <div className="grid grid-cols-4 items-center gap-2">
                                                        <label className={`text-[10px] font-medium uppercase tracking-wider text-right ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>Base URL</label>
                                                        <input
                                                            type="text"
                                                            value={providers[providerKey]?.url || ''}
                                                            onChange={(e) => setProviders(prev => ({ ...prev, [providerKey]: { ...prev[providerKey], url: e.target.value } }))}
                                                            className={`col-span-3 w-full rounded px-2 py-1 text-xs outline-none focus:border-blue-600/50 border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-800 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-900'}`}
                                                            placeholder="https://..."
                                                        />
                                                    </div>
                                                </div>

                                                {/* 该 Provider 下的模型列表 */}
                                                <div className={`mt-2 pt-2 border-t ${theme === 'dark' ? 'border-zinc-800/50' : 'border-zinc-200'}`}>

                                                    <div className="flex items-center justify-between mb-2">
                                                        <div className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('模型')}</div>
                                                        <div className="flex items-center gap-2">
                                                            <button
                                                                onClick={() => importApiModelConfigs(providerKey)}
                                                                className={`text-[9px] px-1.5 py-0.5 rounded flex items-center gap-1 ${theme === 'dark' ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700' : 'bg-zinc-200 text-zinc-600 hover:bg-zinc-300'}`}
                                                            >
                                                                <UploadCloud size={10} /> {t('导入模型')}
                                                            </button>
                                                            <button
                                                                onClick={() => {
                                                                    const newId = `${providerKey}-${Date.now()}`;
                                                                    const uid = `uid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                                                    setApiConfigs(prev => [...prev, {
                                                                        id: newId,
                                                                        provider: providerKey,
                                                                        type: 'Chat',
                                                                        _uid: uid
                                                                    }]);
                                                                    setApiModelEditing(uid, true);
                                                                }}
                                                                className={`text-[9px] px-1.5 py-0.5 rounded flex items-center gap-1 ${theme === 'dark' ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700' : 'bg-zinc-200 text-zinc-600 hover:bg-zinc-300'}`}
                                                            >
                                                                <Plus size={10} /> {t('添加模型')}
                                                            </button>
                                                        </div>
                                                    </div>
                                                    <div className="space-y-1.5">
                                                        {group.models.map(api => {
                                                            const isEditing = editingApiModels.has(api._uid);
                                                            const libraryLabel = api.libraryId
                                                                ? (modelLibraryMap.get(api.libraryId)?.displayName
                                                                    || modelLibraryMap.get(api.libraryId)?.modelName
                                                                    || api.libraryId)
                                                                : '';
                                                            const resolvedApiType = api.apiType || providers[providerKey]?.apiType || 'openai';
                                                            const statusKey = api._uid || api.id;
                                                            return (
                                                                <div key={api._uid} className={`flex flex-col gap-2 px-2 py-2 rounded ${theme === 'dark'
                                                                    ? 'bg-zinc-900/50 hover:bg-zinc-800/50'
                                                                    : theme === 'solarized'
                                                                        ? 'bg-[#fdf6e3] hover:bg-[#eee8d5]'
                                                                        : 'bg-white hover:bg-zinc-100'
                                                                    }`}>
                                                                    <div className="flex items-start justify-between gap-2">
                                                                        <div className="flex flex-wrap items-center gap-2 flex-1">
                                                                            <div className={`w-1.5 h-1.5 rounded-full ${getStatusColor(api._uid)}`}></div>
                                                                            <input
                                                                                type="text"
                                                                                value={api.id || ''}
                                                                                onChange={(e) => updateApiConfig(api._uid, { id: e.target.value })}
                                                                                onKeyDown={(e) => e.stopPropagation()}
                                                                                onClick={(e) => e.stopPropagation()}
                                                                                className={`text-xs bg-transparent border-b border-transparent hover:border-zinc-600 focus:border-blue-500 outline-none flex-1 min-w-[120px] font-mono ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}
                                                                                placeholder="model-id"
                                                                                title={`模型 ID: ${api.id}`}
                                                                                disabled={!isEditing}
                                                                            />
                                                                            <select
                                                                                value={api.type || 'Chat'}
                                                                                onChange={(e) => updateApiConfig(api._uid, { type: e.target.value })}
                                                                                className={`text-[9px] px-1 py-0.5 rounded cursor-pointer outline-none ${theme === 'dark' ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700' : 'bg-zinc-200 text-zinc-500 hover:bg-zinc-300'}`}
                                                                                disabled={!isEditing || !!api.libraryId}
                                                                            >
                                                                                <option value="Chat">Chat</option>
                                                                                <option value="Image">Image</option>
                                                                                <option value="ChatImage">Chat Image</option>
                                                                                <option value="Video">Video</option>
                                                                            </select>
                                                                            <select
                                                                                value={api.libraryId || ''}
                                                                                onChange={(e) => {
                                                                                    const selectedId = e.target.value || null;
                                                                                    const selected = selectedId ? modelLibraryMap.get(selectedId) : null;
                                                                                    const updates = { libraryId: selectedId };
                                                                                    if (selected) {
                                                                                        updates.modelName = selected.modelName;
                                                                                        updates.displayName = selected.displayName;
                                                                                        updates.type = selected.type || api.type;
                                                                                        updates.apiType = selected.apiType || api.apiType;
                                                                                        updates.ratioLimits = Array.isArray(selected.ratioLimits) ? selected.ratioLimits : null;
                                                                                        updates.resolutionLimits = Array.isArray(selected.resolutionLimits) ? selected.resolutionLimits : null;
                                                                                        updates.durations = Array.isArray(selected.durations) ? selected.durations : null;
                                                                                        updates.videoResolutions = Array.isArray(selected.videoResolutions) ? selected.videoResolutions : null;
                                                                                    }
                                                                                    updateApiConfig(api._uid, updates);
                                                                                }}
                                                                                className={`text-[9px] px-1 py-0.5 rounded cursor-pointer outline-none min-w-[120px] ${theme === 'dark' ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700' : 'bg-zinc-200 text-zinc-500 hover:bg-zinc-300'}`}
                                                                                disabled={!isEditing}
                                                                            >
                                                                                <option value="">{t('不引用模型库')}</option>
                                                                                {modelLibrary.map((entry) => (
                                                                                    <option key={entry.id} value={entry.id}>{entry.displayName || entry.modelName || entry.id}</option>
                                                                                ))}
                                                                            </select>
                                                                            <select
                                                                                value={api.apiType || ''}
                                                                                onChange={(e) => updateApiConfig(api._uid, { apiType: e.target.value || null })}
                                                                                className={`text-[9px] px-1 py-0.5 rounded cursor-pointer outline-none ${theme === 'dark' ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700' : 'bg-zinc-200 text-zinc-500 hover:bg-zinc-300'}`}
                                                                                disabled={!isEditing || !!api.libraryId}
                                                                            >
                                                                                <option value="">{t('跟随 Provider')}</option>
                                                                                <option value="openai">OpenAI</option>
                                                                                <option value="gemini">Gemini</option>
                                                                                <option value="modelscope">ModelScope</option>
                                                                            </select>
                                                                        </div>
                                                                        <div className="flex items-center gap-1">
                                                                            <button
                                                                                onClick={() => exportApiModelConfig(api)}
                                                                                className={`px-1.5 py-0.5 rounded text-[9px] ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                title={t('导出该模型')}
                                                                            >
                                                                                <Download size={10} />
                                                                            </button>
                                                                            <button
                                                                                onClick={() => setApiModelEditing(api._uid, !isEditing)}
                                                                                className={`px-1.5 py-0.5 rounded text-[9px] ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                title={isEditing ? t('完成编辑') : t('编辑')}
                                                                            >
                                                                                {isEditing ? <Check size={10} /> : <Pencil size={10} />}
                                                                            </button>
                                                                            <button
                                                                                onClick={() => testApiConnection(statusKey)}
                                                                                disabled={apiTesting === statusKey}
                                                                                className={`px-1.5 py-0.5 rounded text-[9px] ${apiStatus[statusKey] === 'success' ? 'text-green-500' : theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                            >
                                                                                {apiTesting === statusKey ? <Loader2 size={10} className="animate-spin" /> : apiStatus[statusKey] === 'success' ? <CheckCircle2 size={10} /> : <LinkIcon size={10} />}
                                                                            </button>
                                                                            <button onClick={() => deleteApiConfig(api._uid)} className={`px-1 ${theme === 'dark' ? 'text-zinc-600 hover:text-red-500' : 'text-zinc-400 hover:text-red-500'}`}>
                                                                                <Trash2 size={10} />
                                                                            </button>
                                                                        </div>
                                                                    </div>
                                                                    <div className={`flex flex-wrap items-center gap-2 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>
                                                                        <span>{t('模型库：')}{api.libraryId ? libraryLabel : t('未引用')}</span>
                                                                        <span>{t('API模型：')}{api.modelName || api.id}</span>
                                                                        <span>{t('接口：')}{resolvedApiType}</span>
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                ))}
                            </div>
                                        </div>
                                    </div>
                                </>
                            )}

                            {settingsTab === 'library' && (
                                <div className="p-4 space-y-3">
                                    <div className="flex items-center justify-between">
                                        <div>
                                            <div className={`text-xs font-medium ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>{t('模型库')}</div>
                                            <p className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>{t('统一维护模型能力与限制，供应商模型可直接引用。')}</p>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <button
                                                onClick={() => importModelLibraryEntries()}
                                                className={`text-[10px] px-2 py-1 rounded flex items-center gap-1 ${theme === 'dark' ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700' : 'bg-zinc-200 text-zinc-600 hover:bg-zinc-300'}`}
                                            >
                                                <UploadCloud size={10} /> {t('导入模型')}
                                            </button>
                                            <button
                                                onClick={() => {
                                                    if (hasExpandedLibraryModels) {
                                                        setCollapsedLibraryModels(new Set(modelLibrary.map(entry => entry.id)));
                                                    } else {
                                                        setCollapsedLibraryModels(new Set());
                                                    }
                                                }}
                                                className={`p-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}
                                                title={hasExpandedLibraryModels ? t('全部折叠') : t('全部展开')}
                                            >
                                                <ChevronsUp size={14} className={`transition-transform ${!hasExpandedLibraryModels ? 'rotate-180' : ''}`} />
                                            </button>
                                            <button
                                                onClick={addModelLibraryEntry}
                                                className={`text-[10px] px-2 py-1 rounded flex items-center gap-1 ${theme === 'dark' ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700' : 'bg-zinc-200 text-zinc-600 hover:bg-zinc-300'}`}
                                            >
                                                <Plus size={10} /> {t('添加模型')}
                                            </button>
                                        </div>
                                    </div>
                                    <div className="space-y-2 max-h-[60vh] overflow-y-auto custom-scrollbar pr-1">
                                        {modelLibrary.map((entry) => {
                                            const isEditing = editingLibraryModels.has(entry.id);
                                            const isCollapsed = collapsedLibraryModels.has(entry.id);
                                            const isPreviewOpen = libraryPreviewModels.has(entry.id);
                                            const ratioAll = entry.ratioLimits === null;
                                            const ratioValues = Array.isArray(entry.ratioLimits) ? entry.ratioLimits : [];
                                            const ratioNotes = entry.ratioNotes || {};
                                            const ratioNotesEnabled = !!entry.ratioNotesEnabled;
                                            const resolutionValues = Array.isArray(entry.resolutionLimits) ? entry.resolutionLimits : [];
                                            const resolutionNotes = normalizeResolutionNotes(entry.resolutionNotes);
                                            const resolutionNotesEnabled = !!entry.resolutionNotesEnabled;
                                            const durationValues = Array.isArray(entry.durations) ? entry.durations : [];
                                            const durationNotes = entry.durationNotes || {};
                                            const durationNotesEnabled = !!entry.durationNotesEnabled;
                                            const videoResolutionValues = Array.isArray(entry.videoResolutions) ? entry.videoResolutions : [];
                                            const videoResolutionNotes = entry.videoResolutionNotes || {};
                                            const videoResolutionNotesEnabled = !!entry.videoResolutionNotesEnabled;
                                            const customParams = Array.isArray(entry.customParams) ? entry.customParams : [];
                                            const requestTemplateValue = normalizeRequestTemplate(entry.requestTemplate || getDefaultRequestTemplateForEntry(entry));
                                            const requestTemplateEnabled = requestTemplateValue?.enabled !== false;
                                            const requestOverridePatch = normalizeRequestOverridePatch(entry.requestOverridePatch);
                                            const previewBase = {
                                                model: entry.modelName || entry.id,
                                                type: entry.type || 'Chat',
                                                apiType: entry.apiType || 'openai'
                                            };
                                            if (isImageModelType(entry.type)) {
                                                previewBase.ratio = ratioValues[0] || '1:1';
                                                previewBase.size = resolutionValues[0] || '2K';
                                            }
                                            if (entry.type === 'Video') {
                                                previewBase.ratio = ratioValues[0] || '16:9';
                                                previewBase.duration = durationValues[0] || '5s';
                                                previewBase.resolution = videoResolutionValues[0] || '720P';
                                            }
                                            const previewPayloadBase = buildCustomParamPreviewPayload(previewBase, customParams);
                                            const previewOverridePatch = normalizePreviewOverridePatch(entry.previewOverridePatch);
                                            const previewPayload = entry.previewOverrideEnabled && previewOverridePatch
                                                ? applyPreviewOverridePatch({ ...previewPayloadBase }, previewOverridePatch)
                                                : previewPayloadBase;
                                            const previewEndpoint = getModelLibraryPreviewEndpoint(entry);
                                            const previewPython = buildPythonPreviewSnippet(previewEndpoint, previewPayload);
                                            const isPreviewEditing = libraryPreviewEditing.has(entry.id);
                                            const previewDraft = libraryPreviewDrafts[entry.id] || '';
                                            const requestPreviewVars = (() => {
                                                const vars = {
                                                    modelName: entry.modelName || entry.id,
                                                    prompt: '示例提示词',
                                                    ratio: previewBase.ratio || '1:1',
                                                    resolution: previewBase.resolution || previewBase.size || '2K',
                                                    size: previewBase.size || previewBase.resolution || '2K',
                                                    duration: previewBase.duration || '5',
                                                    durationNumber: normalizeDurationValue(previewBase.duration || '5', 5),
                                                    provider: {
                                                        key: 'API_KEY',
                                                        baseUrl: 'https://api.example.com'
                                                    },
                                                    imageUrl: 'https://example.com/image.png',
                                                    imageDataUrl: 'data:image/png;base64,PLACEHOLDER'
                                                };
                                                vars.imageUrl1 = vars.imageUrl;
                                                vars.imageUrl2 = vars.imageUrl;
                                                vars.image1Url = vars.imageUrl;
                                                vars.image2Url = vars.imageUrl;
                                                vars.imageUrls = [vars.imageUrl];
                                                vars.imagesUrl = vars.imageUrls;
                                                vars.imagesUrls = vars.imageUrls;
                                                if (customParams.length > 0) {
                                                    customParams.forEach((param) => {
                                                        const name = String(param?.name || '').trim();
                                                        if (!name) return;
                                                        const value = Array.isArray(param.values) && param.values.length > 0 ? param.values[0] : '';
                                                        if (!value) return;
                                                        vars[name] = value;
                                                    });
                                                }
                                                return vars;
                                            })();
                                            const requestPreviewBase = requestTemplateValue
                                                ? buildRequestFromTemplate(requestTemplateValue, requestPreviewVars, { bodyType: requestTemplateValue.bodyType })
                                                : null;
                                            const requestPreviewFinal = requestPreviewBase && entry.requestOverrideEnabled && requestOverridePatch
                                                ? applyRequestOverridePatch({ ...requestPreviewBase }, requestOverridePatch)
                                                : requestPreviewBase;
                                            const requestPreviewDisplay = formatRequestPreview(requestPreviewFinal);
                                            const isRequestPreviewEditing = libraryRequestPreviewEditing.has(entry.id);
                                            const requestPreviewDraft = libraryRequestPreviewDrafts[entry.id]
                                                || (requestPreviewDisplay ? JSON.stringify(requestPreviewDisplay, null, 2) : '');
                                            const requestTemplateDraft = libraryRequestTemplateDrafts[entry.id] || {
                                                headers: JSON.stringify(requestTemplateValue?.headers || {}, null, 2),
                                                body: requestTemplateValue?.bodyType === 'raw'
                                                    ? String(requestTemplateValue?.body ?? '')
                                                    : JSON.stringify(requestTemplateValue?.body || {}, null, 2),
                                                query: JSON.stringify(requestTemplateValue?.query || {}, null, 2),
                                                files: JSON.stringify(requestTemplateValue?.files || {}, null, 2),
                                                timeoutMs: requestTemplateValue?.timeoutMs ?? '',
                                                responseParser: requestTemplateValue?.responseParser || ''
                                            };
                                            const asyncConfigValue = normalizeAsyncConfig(entry.asyncConfig);
                                            const asyncConfigEnabled = !!asyncConfigValue?.enabled;
                                            const asyncConfigDraft = libraryAsyncConfigDrafts[entry.id] || (
                                                asyncConfigValue
                                                    ? JSON.stringify(asyncConfigValue, null, 2)
                                                    : ASYNC_CONFIG_TEMPLATE_TEXT
                                            );
                                            const isAsyncPreviewOpen = libraryAsyncPreviewModels.has(entry.id);
                                            const isRequestTemplateCollapsed = isLibrarySectionCollapsed(entry.id, 'request-template');
                                            const isAsyncSectionCollapsed = isLibrarySectionCollapsed(entry.id, 'async-task');
                                            const asyncPreviewVars = {
                                                requestId: 'REQUEST_ID',
                                                prompt: '示例提示词',
                                                provider: { key: 'API_KEY', baseUrl: 'https://api.example.com' }
                                            };
                                            const asyncStatusPreviewRaw = asyncConfigValue?.statusRequest
                                                ? buildRequestFromTemplate(asyncConfigValue.statusRequest, asyncPreviewVars, { bodyType: asyncConfigValue.statusRequest.bodyType })
                                                : null;
                                            const asyncStatusPreview = formatRequestPreview(asyncStatusPreviewRaw);
                                            const asyncOutputsPreviewRaw = asyncConfigValue?.outputsRequest
                                                ? buildRequestFromTemplate(asyncConfigValue.outputsRequest, asyncPreviewVars, { bodyType: asyncConfigValue.outputsRequest.bodyType })
                                                : null;
                                            const asyncOutputsPreview = formatRequestPreview(asyncOutputsPreviewRaw);
                                            const updateRequestTemplate = (updates) => {
                                                const nextTemplate = normalizeRequestTemplate({
                                                    ...(requestTemplateValue || getDefaultRequestTemplateForEntry(entry)),
                                                    ...updates
                                                });
                                                updateModelLibraryEntry(entry.id, { requestTemplate: nextTemplate });
                                            };
                                            return (
                                                <div key={entry.id} className={`rounded-lg border p-3 space-y-3 ${theme === 'dark'
                                                    ? 'bg-[#18181b] border-zinc-800'
                                                    : theme === 'solarized'
                                                        ? 'bg-[#fdf6e3] border-[#d7cfb2]'
                                                        : 'bg-white border-zinc-200'
                                                    }`}>
                                                    <div className="flex items-start justify-between gap-2">
                                                        <div className="flex flex-col gap-1 flex-1">
                                                            <div className="flex items-center gap-2 w-full">
                                                                <div className={`text-xs font-medium ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}>
                                                                    {entry.displayName || entry.modelName || entry.id}
                                                                </div>
                                                                <div className="ml-auto flex items-center justify-end">
                                                                    {isEditing ? (
                                                                        <select
                                                                            value={entry.type || 'Chat'}
                                                                            onChange={(e) => updateModelLibraryEntry(entry.id, { type: e.target.value })}
                                                                            className={`text-[9px] px-1 py-0.5 rounded border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-700 text-zinc-300'
                                                                                : 'bg-white border-zinc-300 text-zinc-700'
                                                                                }`}
                                                                            disabled={!isEditing}
                                                                        >
                                                                            <option value="Chat">Chat</option>
                                                                            <option value="Image">Image</option>
                                                                            <option value="ChatImage">Chat Image</option>
                                                                            <option value="Video">Video</option>
                                                                        </select>
                                                                    ) : (
                                                                        <span className={`text-[9px] px-1.5 py-0.5 rounded ${theme === 'dark'
                                                                            ? 'bg-zinc-800 text-zinc-300'
                                                                            : theme === 'solarized'
                                                                                ? 'bg-[#eee8d5] text-zinc-600'
                                                                                : 'bg-zinc-100 text-zinc-600'
                                                                            }`}>
                                                                            {entry.type || 'Chat'}
                                                                        </span>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>
                                                                {t('系统调用模型ID：')}{entry.modelName || entry.id}
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-1">
                                                            <button
                                                                onClick={() => toggleLibraryPreview(entry.id)}
                                                                className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                title={isPreviewOpen ? t('隐藏请求预览') : t('查看请求预览')}
                                                            >
                                                                <Code size={12} className={isPreviewOpen ? 'text-blue-500' : ''} />
                                                            </button>
                                                            <button
                                                                onClick={() => duplicateModelLibraryEntry(entry.id)}
                                                                className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                title={t('复制模型')}
                                                            >
                                                                <CopyPlus size={12} />
                                                            </button>
                                                            <button
                                                                onClick={() => toggleLibraryModelCollapse(entry.id)}
                                                                className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                title={isCollapsed ? t('展开') : t('折叠')}
                                                            >
                                                                <ChevronDown size={12} className={`transition-transform ${isCollapsed ? '' : 'rotate-180'}`} />
                                                            </button>
                                                            <button
                                                                onClick={() => exportModelLibraryEntry(entry)}
                                                                className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                title={t('导出该模型')}
                                                            >
                                                                <Download size={12} />
                                                            </button>
                                                            <button
                                                                onClick={() => setLibraryModelEditing(entry.id, !isEditing)}
                                                                className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                title={isEditing ? t('完成编辑') : t('编辑')}
                                                            >
                                                                {isEditing ? <Check size={12} /> : <Pencil size={12} />}
                                                            </button>
                                                            <button
                                                                onClick={() => deleteModelLibraryEntry(entry.id)}
                                                                className={`p-1 ${theme === 'dark' ? 'text-zinc-500 hover:text-red-400' : 'text-zinc-400 hover:text-red-500'}`}
                                                                title={t('删除')}
                                                            >
                                                                <Trash2 size={12} />
                                                            </button>
                                                        </div>
                                                    </div>

                                                    {!isCollapsed && (
                                                        <>
                                                            <div className="grid grid-cols-12 gap-2 items-end">
                                                                <div className="col-span-5 space-y-1">
                                                                    <label className={`text-[9px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('显示名（仅展示）')}</label>
                                                                    <input
                                                                        className={`w-full text-xs rounded px-2 py-1 border outline-none ${theme === 'dark' ? 'bg-zinc-900 border-zinc-800 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-900'}`}
                                                                        value={entry.displayName || ''}
                                                                        onChange={(e) => updateModelLibraryEntry(entry.id, { displayName: e.target.value })}
                                                                        placeholder={t('例如：香蕉')}
                                                                        disabled={!isEditing}
                                                                    />
                                                                </div>
                                                                <div className="col-span-5 space-y-1">
                                                                    <label className={`text-[9px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('模型ID（系统调用）')}</label>
                                                                    <input
                                                                        className={`w-full text-xs rounded px-2 py-1 border outline-none ${theme === 'dark' ? 'bg-zinc-900 border-zinc-800 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-900'}`}
                                                                        value={entry.modelName || ''}
                                                                        onChange={(e) => updateModelLibraryEntry(entry.id, { modelName: e.target.value })}
                                                                        placeholder={t('例如：gemini-3-pro-image-preview')}
                                                                        disabled={!isEditing}
                                                                    />
                                                                </div>
                                                                <div className="col-span-2 space-y-1">
                                                                    <label className={`text-[9px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('接口类型')}</label>
                                                                    <select
                                                                        value={entry.apiType || 'openai'}
                                                                        onChange={(e) => updateModelLibraryEntry(entry.id, { apiType: e.target.value })}
                                                                        className={`w-full text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark' ? 'bg-zinc-900 border-zinc-800 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-900'}`}
                                                                        disabled={!isEditing}
                                                                    >
                                                                        <option value="openai">OpenAI</option>
                                                                        <option value="gemini">Gemini</option>
                                                                        <option value="modelscope">ModelScope</option>
                                                                    </select>
                                                                </div>
                                                            </div>

                                                            {isImageModelType(entry.type) && (
                                                                <>
                                                                <div className="grid grid-cols-12 gap-2">
                                                                    <div className="col-span-6">
                                                                        <TagListEditor
                                                                            label={t('图片比例')}
                                                                            values={ratioValues}
                                                                            onChange={(values) => {
                                                                                const nextNotes = { ...ratioNotes };
                                                                                Object.keys(nextNotes).forEach((key) => {
                                                                                    if (!values.includes(key)) delete nextNotes[key];
                                                                                });
                                                                                updateModelLibraryEntry(entry.id, { ratioLimits: values, ratioNotes: nextNotes });
                                                                            }}
                                                                            placeholder={t('例：1:1,16:9')}
                                                                            disabled={!isEditing}
                                                                            inputDisabled={!isEditing || ratioAll}
                                                                            theme={theme}
                                                                            allowAllLabel={t('全比例')}
                                                                            allowAll={ratioAll}
                                                                            onToggleAll={(checked) => updateModelLibraryEntry(entry.id, { ratioLimits: checked ? null : [] })}
                                                                            formatItem={(value) => getValueLabelWithNotes(value, ratioNotesEnabled, ratioNotes)}
                                                                        />
                                                                        {ratioValues.length > 0 && (
                                                                            <div className="mt-1 space-y-1">
                                                                                <div className="flex items-center gap-2">
                                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('映射提示名')}</div>
                                                                                    <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                        <input
                                                                                            type="checkbox"
                                                                                            checked={ratioNotesEnabled}
                                                                                            onChange={(e) => updateModelLibraryEntry(entry.id, { ratioNotesEnabled: e.target.checked })}
                                                                                            disabled={!isEditing}
                                                                                        />
                                                                                        <span>{t('启用')}</span>
                                                                                    </label>
                                                                                    <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>{t('仅用于辅助选择')}</span>
                                                                                    <button
                                                                                        onClick={() => toggleLibraryNotesCollapsed(entry.id, 'ratio')}
                                                                                        className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                        title={isLibraryNotesCollapsed(entry.id, 'ratio') ? t('展开提示') : t('折叠提示')}
                                                                                    >
                                                                                        <ChevronDown size={12} className={`transition-transform ${isLibraryNotesCollapsed(entry.id, 'ratio') ? '' : 'rotate-180'}`} />
                                                                                    </button>
                                                                                </div>
                                                                                {ratioNotesEnabled && !isLibraryNotesCollapsed(entry.id, 'ratio') && ratioValues.map((value) => (
                                                                                    <div key={value} className="flex items-center gap-2">
                                                                                        <span className={`text-[9px] w-24 truncate ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`} title={value}>{value}</span>
                                                                                        <input
                                                                                            value={ratioNotes[value] || ''}
                                                                                            onChange={(e) => {
                                                                                                const nextNotes = { ...ratioNotes };
                                                                                                const noteValue = e.target.value;
                                                                                                if (noteValue) {
                                                                                                    nextNotes[value] = noteValue;
                                                                                                } else {
                                                                                                    delete nextNotes[value];
                                                                                                }
                                                                                                updateModelLibraryEntry(entry.id, { ratioNotes: nextNotes });
                                                                                            }}
                                                                                            placeholder={t('例：1:1 / 竖屏')}
                                                                                            disabled={!isEditing}
                                                                                            className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                                : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                                }`}
                                                                                        />
                                                                                    </div>
                                                                                ))}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    <div className="col-span-6">
                                                                        <TagListEditor
                                                                            label={t('图片分辨率')}
                                                                            values={resolutionValues}
                                                                            onChange={(values) => {
                                                                                const nextNotes = { ...resolutionNotes };
                                                                                Object.keys(nextNotes).forEach((key) => {
                                                                                    if (!values.includes(key)) delete nextNotes[key];
                                                                                });
                                                                                updateModelLibraryEntry(entry.id, { resolutionLimits: values, resolutionNotes: nextNotes });
                                                                            }}
                                                                            placeholder={t('例：1K,2K,4K')}
                                                                            disabled={!isEditing}
                                                                            theme={theme}
                                                                            normalizeItem={(value) => normalizeResolutionOption(value)}
                                                                            formatItem={(value) => getValueLabelWithNotes(value, resolutionNotesEnabled, resolutionNotes)}
                                                                        />
                                                                        {resolutionValues.length > 0 && (
                                                                            <div className="mt-1 space-y-1">
                                                                                <div className="flex items-center gap-2">
                                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('映射提示名')}</div>
                                                                                    <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                        <input
                                                                                            type="checkbox"
                                                                                            checked={resolutionNotesEnabled}
                                                                                            onChange={(e) => updateModelLibraryEntry(entry.id, { resolutionNotesEnabled: e.target.checked })}
                                                                                            disabled={!isEditing}
                                                                                        />
                                                                                        <span>{t('启用')}</span>
                                                                                    </label>
                                                                                    <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>{t('仅用于辅助选择')}</span>
                                                                                    <button
                                                                                        onClick={() => toggleLibraryNotesCollapsed(entry.id, 'resolution')}
                                                                                        className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                        title={isLibraryNotesCollapsed(entry.id, 'resolution') ? t('展开提示') : t('折叠提示')}
                                                                                    >
                                                                                        <ChevronDown size={12} className={`transition-transform ${isLibraryNotesCollapsed(entry.id, 'resolution') ? '' : 'rotate-180'}`} />
                                                                                    </button>
                                                                                </div>
                                                                                {resolutionNotesEnabled && !isLibraryNotesCollapsed(entry.id, 'resolution') && resolutionValues.map((value) => (
                                                                                    <div key={value} className="flex items-center gap-2">
                                                                                        <span className={`text-[9px] w-24 truncate ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`} title={value}>{value}</span>
                                                                                        <input
                                                                                            value={resolutionNotes[value] || ''}
                                                                                            onChange={(e) => {
                                                                                                const nextNotes = { ...resolutionNotes };
                                                                                                const noteValue = e.target.value;
                                                                                                if (noteValue) {
                                                                                                    nextNotes[value] = noteValue;
                                                                                                } else {
                                                                                                    delete nextNotes[value];
                                                                                                }
                                                                                                updateModelLibraryEntry(entry.id, { resolutionNotes: nextNotes });
                                                                                            }}
                                                                                            placeholder={t('例：1:1 / 高清')}
                                                                                            disabled={!isEditing}
                                                                                            className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                                : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                                }`}
                                                                                        />
                                                                                    </div>
                                                                                ))}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                                <div className="mt-2 flex items-center gap-4">
                                                                    <label className={`flex items-center gap-1 text-[10px] ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={!!entry.omitRatioOnSubmit}
                                                                            onChange={(e) => updateModelLibraryEntry(entry.id, { omitRatioOnSubmit: e.target.checked })}
                                                                            disabled={!isEditing}
                                                                        />
                                                                        <span>{t('提交时不注入比例')}</span>
                                                                    </label>
                                                                    <label className={`flex items-center gap-1 text-[10px] ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={!!entry.omitResolutionOnSubmit}
                                                                            onChange={(e) => updateModelLibraryEntry(entry.id, { omitResolutionOnSubmit: e.target.checked })}
                                                                            disabled={!isEditing}
                                                                        />
                                                                        <span>{t('提交时不注入分辨率')}</span>
                                                                    </label>
                                                                </div>
                                                                </>
                                                            )}

                                                            {entry.type === 'Video' && (
                                                                <div className="grid grid-cols-12 gap-2">
                                                                    <div className="col-span-4">
                                                                        <TagListEditor
                                                                            label={t('视频比例')}
                                                                            values={ratioValues}
                                                                            onChange={(values) => {
                                                                                const nextNotes = { ...ratioNotes };
                                                                                Object.keys(nextNotes).forEach((key) => {
                                                                                    if (!values.includes(key)) delete nextNotes[key];
                                                                                });
                                                                                updateModelLibraryEntry(entry.id, { ratioLimits: values, ratioNotes: nextNotes });
                                                                            }}
                                                                            placeholder={t('例：16:9,9:16')}
                                                                            disabled={!isEditing}
                                                                            inputDisabled={!isEditing || ratioAll}
                                                                            theme={theme}
                                                                            allowAllLabel={t('全比例')}
                                                                            allowAll={ratioAll}
                                                                            onToggleAll={(checked) => updateModelLibraryEntry(entry.id, { ratioLimits: checked ? null : [] })}
                                                                            formatItem={(value) => getValueLabelWithNotes(value, ratioNotesEnabled, ratioNotes)}
                                                                        />
                                                                        {ratioValues.length > 0 && (
                                                                            <div className="mt-1 space-y-1">
                                                                                <div className="flex items-center gap-2">
                                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('映射提示名')}</div>
                                                                                    <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                        <input
                                                                                            type="checkbox"
                                                                                            checked={ratioNotesEnabled}
                                                                                            onChange={(e) => updateModelLibraryEntry(entry.id, { ratioNotesEnabled: e.target.checked })}
                                                                                            disabled={!isEditing}
                                                                                        />
                                                                                        <span>{t('启用')}</span>
                                                                                    </label>
                                                                                    <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>{t('仅用于辅助选择')}</span>
                                                                                    <button
                                                                                        onClick={() => toggleLibraryNotesCollapsed(entry.id, 'ratio')}
                                                                                        className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                        title={isLibraryNotesCollapsed(entry.id, 'ratio') ? t('展开提示') : t('折叠提示')}
                                                                                    >
                                                                                        <ChevronDown size={12} className={`transition-transform ${isLibraryNotesCollapsed(entry.id, 'ratio') ? '' : 'rotate-180'}`} />
                                                                                    </button>
                                                                                </div>
                                                                                {ratioNotesEnabled && !isLibraryNotesCollapsed(entry.id, 'ratio') && ratioValues.map((value) => (
                                                                                    <div key={value} className="flex items-center gap-2">
                                                                                        <span className={`text-[9px] w-24 truncate ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`} title={value}>{value}</span>
                                                                                        <input
                                                                                            value={ratioNotes[value] || ''}
                                                                                            onChange={(e) => {
                                                                                                const nextNotes = { ...ratioNotes };
                                                                                                const noteValue = e.target.value;
                                                                                                if (noteValue) {
                                                                                                    nextNotes[value] = noteValue;
                                                                                                } else {
                                                                                                    delete nextNotes[value];
                                                                                                }
                                                                                                updateModelLibraryEntry(entry.id, { ratioNotes: nextNotes });
                                                                                            }}
                                                                                            placeholder={t('例：16:9 / 横屏')}
                                                                                            disabled={!isEditing}
                                                                                            className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                                : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                                }`}
                                                                                        />
                                                                                    </div>
                                                                                ))}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    <div className="col-span-4">
                                                                        <TagListEditor
                                                                            label={t('视频时长')}
                                                                            values={durationValues}
                                                                            onChange={(values) => {
                                                                                const nextNotes = { ...durationNotes };
                                                                                Object.keys(nextNotes).forEach((key) => {
                                                                                    if (!values.includes(key)) delete nextNotes[key];
                                                                                });
                                                                                updateModelLibraryEntry(entry.id, { durations: values, durationNotes: nextNotes });
                                                                            }}
                                                                            placeholder={t('例：5s,10s')}
                                                                            disabled={!isEditing}
                                                                            theme={theme}
                                                                            normalizeItem={(value) => {
                                                                                const trimmed = String(value).trim();
                                                                                return trimmed.endsWith('s') ? trimmed : `${trimmed}s`;
                                                                            }}
                                                                            formatItem={(value) => getValueLabelWithNotes(value, durationNotesEnabled, durationNotes)}
                                                                        />
                                                                        {durationValues.length > 0 && (
                                                                            <div className="mt-1 space-y-1">
                                                                                <div className="flex items-center gap-2">
                                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('映射提示名')}</div>
                                                                                    <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                        <input
                                                                                            type="checkbox"
                                                                                            checked={durationNotesEnabled}
                                                                                            onChange={(e) => updateModelLibraryEntry(entry.id, { durationNotesEnabled: e.target.checked })}
                                                                                            disabled={!isEditing}
                                                                                        />
                                                                                        <span>{t('启用')}</span>
                                                                                    </label>
                                                                                    <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>{t('仅用于辅助选择')}</span>
                                                                                    <button
                                                                                        onClick={() => toggleLibraryNotesCollapsed(entry.id, 'duration')}
                                                                                        className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                        title={isLibraryNotesCollapsed(entry.id, 'duration') ? t('展开提示') : t('折叠提示')}
                                                                                    >
                                                                                        <ChevronDown size={12} className={`transition-transform ${isLibraryNotesCollapsed(entry.id, 'duration') ? '' : 'rotate-180'}`} />
                                                                                    </button>
                                                                                </div>
                                                                                {durationNotesEnabled && !isLibraryNotesCollapsed(entry.id, 'duration') && durationValues.map((value) => (
                                                                                    <div key={value} className="flex items-center gap-2">
                                                                                        <span className={`text-[9px] w-24 truncate ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`} title={value}>{value}</span>
                                                                                        <input
                                                                                            value={durationNotes[value] || ''}
                                                                                            onChange={(e) => {
                                                                                                const nextNotes = { ...durationNotes };
                                                                                                const noteValue = e.target.value;
                                                                                                if (noteValue) {
                                                                                                    nextNotes[value] = noteValue;
                                                                                                } else {
                                                                                                    delete nextNotes[value];
                                                                                                }
                                                                                                updateModelLibraryEntry(entry.id, { durationNotes: nextNotes });
                                                                                            }}
                                                                                            placeholder={t('例：5s / 快速')}
                                                                                            disabled={!isEditing}
                                                                                            className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                                : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                                }`}
                                                                                        />
                                                                                    </div>
                                                                                ))}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    <div className="col-span-4">
                                                                        <TagListEditor
                                                                            label={t('视频分辨率')}
                                                                            values={videoResolutionValues}
                                                                            onChange={(values) => {
                                                                                const nextNotes = { ...videoResolutionNotes };
                                                                                Object.keys(nextNotes).forEach((key) => {
                                                                                    if (!values.includes(key)) delete nextNotes[key];
                                                                                });
                                                                                updateModelLibraryEntry(entry.id, { videoResolutions: values, videoResolutionNotes: nextNotes });
                                                                            }}
                                                                            placeholder={t('例：720P,1080P')}
                                                                            disabled={!isEditing}
                                                                            theme={theme}
                                                                            normalizeItem={(value) => normalizeVideoResolution(value)}
                                                                            formatItem={(value) => getValueLabelWithNotes(value, videoResolutionNotesEnabled, videoResolutionNotes)}
                                                                        />
                                                                        {videoResolutionValues.length > 0 && (
                                                                            <div className="mt-1 space-y-1">
                                                                                <div className="flex items-center gap-2">
                                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('映射提示名')}</div>
                                                                                    <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                        <input
                                                                                            type="checkbox"
                                                                                            checked={videoResolutionNotesEnabled}
                                                                                            onChange={(e) => updateModelLibraryEntry(entry.id, { videoResolutionNotesEnabled: e.target.checked })}
                                                                                            disabled={!isEditing}
                                                                                        />
                                                                                        <span>{t('启用')}</span>
                                                                                    </label>
                                                                                    <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>{t('仅用于辅助选择')}</span>
                                                                                    <button
                                                                                        onClick={() => toggleLibraryNotesCollapsed(entry.id, 'video-resolution')}
                                                                                        className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                        title={isLibraryNotesCollapsed(entry.id, 'video-resolution') ? t('展开提示') : t('折叠提示')}
                                                                                    >
                                                                                        <ChevronDown size={12} className={`transition-transform ${isLibraryNotesCollapsed(entry.id, 'video-resolution') ? '' : 'rotate-180'}`} />
                                                                                    </button>
                                                                                </div>
                                                                                {videoResolutionNotesEnabled && !isLibraryNotesCollapsed(entry.id, 'video-resolution') && videoResolutionValues.map((value) => (
                                                                                    <div key={value} className="flex items-center gap-2">
                                                                                        <span className={`text-[9px] w-24 truncate ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`} title={value}>{value}</span>
                                                                                        <input
                                                                                            value={videoResolutionNotes[value] || ''}
                                                                                            onChange={(e) => {
                                                                                                const nextNotes = { ...videoResolutionNotes };
                                                                                                const noteValue = e.target.value;
                                                                                                if (noteValue) {
                                                                                                    nextNotes[value] = noteValue;
                                                                                                } else {
                                                                                                    delete nextNotes[value];
                                                                                                }
                                                                                                updateModelLibraryEntry(entry.id, { videoResolutionNotes: nextNotes });
                                                                                            }}
                                                                                            placeholder={t('例：16:9 / 竖屏')}
                                                                                            disabled={!isEditing}
                                                                                            className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                                : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                                }`}
                                                                                        />
                                                                                    </div>
                                                                                ))}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    <div className="col-span-12 flex items-center gap-3 pt-1">
                                                                        <label className={`flex items-center gap-1 text-[10px] ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>
                                                                            <input
                                                                                type="checkbox"
                                                                                checked={!!entry.supportsFirstLastFrame}
                                                                                onChange={(e) => updateModelLibraryEntry(entry.id, { supportsFirstLastFrame: e.target.checked })}
                                                                                className="w-3 h-3 cursor-pointer"
                                                                                disabled={!isEditing}
                                                                            />
                                                                            <span>{t('首尾帧')}</span>
                                                                        </label>
                                                                        <label className={`flex items-center gap-1 text-[10px] ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>
                                                                            <input
                                                                                type="checkbox"
                                                                                checked={!!entry.supportsHD}
                                                                                onChange={(e) => updateModelLibraryEntry(entry.id, { supportsHD: e.target.checked })}
                                                                                className="w-3 h-3 cursor-pointer"
                                                                                disabled={!isEditing}
                                                                            />
                                                                            <span>HD</span>
                                                                        </label>
                                                                    </div>
                                                                </div>
                                                            )}
                                                            <div className="space-y-2">
                                                                <div className="flex items-center justify-between">
                                                                    <label className={`text-[9px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('自定义参数')}</label>
                                                                    <button
                                                                        onClick={() => addModelLibraryCustomParam(entry.id)}
                                                                        disabled={!isEditing || customParams.length >= MAX_CUSTOM_PARAMS}
                                                                        className={`text-[9px] px-1.5 py-0.5 rounded ${theme === 'dark'
                                                                            ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                                            : 'bg-zinc-200 text-zinc-600 hover:bg-zinc-300'
                                                                            } ${(!isEditing || customParams.length >= MAX_CUSTOM_PARAMS) ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                    >
                                                                        + 添加参数 ({customParams.length}/{MAX_CUSTOM_PARAMS})
                                                                    </button>
                                                                </div>
                                                                {customParams.length > 0 ? (
                                                                    <div className="space-y-2">
                                                                        {customParams.map((param) => (
                                                                            <div key={param.id} className={`rounded-md border p-2 space-y-2 ${theme === 'dark'
                                                                                ? 'bg-zinc-900/60 border-zinc-800'
                                                                                : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                                                                }`}>
                                                                                {(() => {
                                                                                    const paramValues = Array.isArray(param.values) ? param.values : [];
                                                                                    const paramNotes = param.valueNotes || {};
                                                                                    const notesEnabled = !!param.notesEnabled;
                                                                                    const paramDefaultValue = typeof param.defaultValue === 'string' ? param.defaultValue : '';
                                                                                    return (
                                                                                        <>
                                                                                <div className="flex items-center gap-2">
                                                                                    <input
                                                                                        value={param.name || ''}
                                                                                        onChange={(e) => updateModelLibraryCustomParam(entry.id, param.id, { name: e.target.value })}
                                                                                        placeholder={t('参数名（如 size / quality / model）')}
                                                                                        disabled={!isEditing}
                                                                                        className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                            ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                            : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                            }`}
                                                                                    />
                                                                                    <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                        <input
                                                                                            type="checkbox"
                                                                                            checked={!!param.override}
                                                                                            onChange={(e) => updateModelLibraryCustomParam(entry.id, param.id, { override: e.target.checked })}
                                                                                            disabled={!isEditing}
                                                                                        />
                                                                                        <span>{t('覆盖同名参数')}</span>
                                                                                    </label>
                                                                                    <button
                                                                                        onClick={() => deleteModelLibraryCustomParam(entry.id, param.id)}
                                                                                        disabled={!isEditing}
                                                                                        className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-red-400' : 'text-zinc-400 hover:text-red-500'} ${!isEditing ? 'opacity-40 cursor-not-allowed' : ''}`}
                                                                                        title={t('删除参数')}
                                                                                    >
                                                                                        <Trash2 size={12} />
                                                                                    </button>
                                                                                </div>
                                                                                <TagListEditor
                                                                                    label={t('参数值')}
                                                                                    values={paramValues}
                                                                                    onChange={(values) => {
                                                                                        const nextNotes = { ...paramNotes };
                                                                                        Object.keys(nextNotes).forEach((key) => {
                                                                                            if (!values.includes(key)) delete nextNotes[key];
                                                                                        });
                                                                                        const nextUpdates = { values, valueNotes: nextNotes };
                                                                                        if (paramDefaultValue && values.length > 0 && !values.includes(paramDefaultValue)) {
                                                                                            nextUpdates.defaultValue = '';
                                                                                        }
                                                                                        updateModelLibraryCustomParam(entry.id, param.id, nextUpdates);
                                                                                    }}
                                                                                    placeholder={t('例：1024x1024,2K,low,high')}
                                                                                    disabled={!isEditing}
                                                                                    theme={theme}
                                                                                    formatItem={(value) => getCustomParamValueLabel(param, value)}
                                                                                    maxItems={MAX_CUSTOM_PARAM_VALUES}
                                                                                />
                                                                                <div className="flex items-center gap-2">
                                                                                    <div className={`text-[9px] min-w-[72px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('默认值')}</div>
                                                                                    {paramValues.length > 0 ? (
                                                                                        <select
                                                                                            value={paramDefaultValue}
                                                                                            onChange={(e) => updateModelLibraryCustomParam(entry.id, param.id, { defaultValue: e.target.value })}
                                                                                            disabled={!isEditing}
                                                                                            className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                                                                : 'bg-white border-zinc-300 text-zinc-900'
                                                                                                }`}
                                                                                        >
                                                                                            <option value="">{t('不设置')}</option>
                                                                                            {paramValues.map((value) => (
                                                                                                <option key={value} value={value}>{getCustomParamValueLabel(param, value)}</option>
                                                                                            ))}
                                                                                        </select>
                                                                                    ) : (
                                                                                        <input
                                                                                            value={paramDefaultValue}
                                                                                            onChange={(e) => updateModelLibraryCustomParam(entry.id, param.id, { defaultValue: e.target.value })}
                                                                                            placeholder={t('不设置')}
                                                                                            disabled={!isEditing}
                                                                                            className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                                : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                                }`}
                                                                                        />
                                                                                    )}
                                                                                </div>
                                                                                {paramValues.length > 0 && (
                                                                                    <div className="space-y-1">
                                                                                        <div className="flex items-center gap-2">
                                                                                            <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('映射提示名')}</div>
                                                                                            <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                                <input
                                                                                                    type="checkbox"
                                                                                                    checked={notesEnabled}
                                                                                                    onChange={(e) => updateModelLibraryCustomParam(entry.id, param.id, { notesEnabled: e.target.checked })}
                                                                                                    disabled={!isEditing}
                                                                                                />
                                                                                                <span>{t('启用')}</span>
                                                                                            </label>
                                                                                            <span className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>{t('仅用于辅助选择')}</span>
                                                                                            <button
                                                                                                onClick={() => toggleLibraryNotesCollapsed(entry.id, `param-${param.id}`)}
                                                                                                className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                                title={isLibraryNotesCollapsed(entry.id, `param-${param.id}`) ? t('展开提示') : t('折叠提示')}
                                                                                            >
                                                                                                <ChevronDown size={12} className={`transition-transform ${isLibraryNotesCollapsed(entry.id, `param-${param.id}`) ? '' : 'rotate-180'}`} />
                                                                                            </button>
                                                                                        </div>
                                                                                        {notesEnabled && !isLibraryNotesCollapsed(entry.id, `param-${param.id}`) && paramValues.map((value) => (
                                                                                            <div key={value} className="flex items-center gap-2">
                                                                                                <span className={`text-[9px] w-24 truncate ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`} title={value}>{value}</span>
                                                                                                <input
                                                                                                    value={paramNotes[value] || ''}
                                                                                                    onChange={(e) => {
                                                                                                        const nextNotes = { ...paramNotes };
                                                                                                        const noteValue = e.target.value;
                                                                                                        if (noteValue) {
                                                                                                            nextNotes[value] = noteValue;
                                                                                                        } else {
                                                                                                            delete nextNotes[value];
                                                                                                        }
                                                                                                        updateModelLibraryCustomParam(entry.id, param.id, { valueNotes: nextNotes });
                                                                                                    }}
                                                                                                    placeholder={t('例：1:1 / 高清')}
                                                                                                    disabled={!isEditing}
                                                                                                    className={`flex-1 text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                                        ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                                        : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                                        }`}
                                                                                                />
                                                                                            </div>
                                                                                        ))}
                                                                                    </div>
                                                                                )}
                                                                                    </>
                                                                                );
                                                                            })()}
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                ) : (
                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'}`}>{t('未设置自定义参数')}</div>
                                                                )}
                                                            </div>
                                                            <div className={`rounded-md border p-2 ${theme === 'dark'
                                                                ? 'bg-zinc-950/60 border-zinc-800'
                                                                : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                                                }`}>
                                                                <div className="flex items-center justify-between mb-2">
                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('请求模板')}</div>
                                                                    <div className="flex items-center gap-2">
                                                                        <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                            <input
                                                                                type="checkbox"
                                                                                checked={requestTemplateEnabled}
                                                                                onChange={(e) => updateRequestTemplate({ enabled: e.target.checked })}
                                                                                disabled={!isEditing}
                                                                            />
                                                                            <span>{t('启用')}</span>
                                                                        </label>
                                                                        <button
                                                                            onClick={() => {
                                                                                if (isRequestTemplateCollapsed) {
                                                                                    toggleLibrarySectionCollapsed(entry.id, 'request-template');
                                                                                }
                                                                                toggleLibraryPreview(entry.id);
                                                                            }}
                                                                            className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                            title={isPreviewOpen ? t('隐藏请求预览') : t('查看请求预览')}
                                                                        >
                                                                            <Code size={12} className={isPreviewOpen ? 'text-blue-500' : ''} />
                                                                        </button>
                                                                        <button
                                                                            onClick={() => toggleLibrarySectionCollapsed(entry.id, 'request-template')}
                                                                            className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                            title={isRequestTemplateCollapsed ? t('展开') : t('折叠')}
                                                                        >
                                                                            <ChevronDown size={12} className={`transition-transform ${isRequestTemplateCollapsed ? '' : 'rotate-180'}`} />
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                                {!isRequestTemplateCollapsed && (
                                                                <>
                                                                <div className="grid grid-cols-12 gap-2">
                                                                    <div className="col-span-7 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('请求路径')}</label>
                                                                        <input
                                                                            value={requestTemplateValue?.endpoint || ''}
                                                                            onChange={(e) => updateRequestTemplate({ endpoint: e.target.value })}
                                                                            placeholder="/v1/images/generations"
                                                                            disabled={!isEditing}
                                                                            className={`w-full text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                }`}
                                                                        />
                                                                    </div>
                                                                    <div className="col-span-2 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('方法')}</label>
                                                                        <select
                                                                            value={requestTemplateValue?.method || 'POST'}
                                                                            onChange={(e) => updateRequestTemplate({ method: e.target.value })}
                                                                            disabled={!isEditing}
                                                                            className={`w-full text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                                                : 'bg-white border-zinc-300 text-zinc-900'
                                                                                }`}
                                                                        >
                                                                            <option value="POST">POST</option>
                                                                            <option value="GET">GET</option>
                                                                            <option value="PUT">PUT</option>
                                                                            <option value="PATCH">PATCH</option>
                                                                            <option value="DELETE">DELETE</option>
                                                                        </select>
                                                                    </div>
                                                                    <div className="col-span-3 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>BodyType</label>
                                                                        <select
                                                                            value={requestTemplateValue?.bodyType || 'json'}
                                                                            onChange={(e) => {
                                                                                updateRequestTemplate({ bodyType: e.target.value });
                                                                                setLibraryRequestTemplateDrafts(prev => {
                                                                                    if (!prev[entry.id]) return prev;
                                                                                    const { [entry.id]: _removed, ...rest } = prev;
                                                                                    return rest;
                                                                                });
                                                                            }}
                                                                            disabled={!isEditing}
                                                                            className={`w-full text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                                                : 'bg-white border-zinc-300 text-zinc-900'
                                                                                }`}
                                                                        >
                                                                            <option value="auto">{t('自动')}</option>
                                                                            <option value="json">json</option>
                                                                            <option value="multipart">multipart</option>
                                                                            <option value="raw">raw</option>
                                                                        </select>
                                                                    </div>
                                                                </div>
                                                                <div className="grid grid-cols-12 gap-2 mt-2">
                                                                    <div className="col-span-6 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('请求头（JSON）')}</label>
                                                                        <textarea
                                                                            value={requestTemplateDraft.headers}
                                                                            onChange={(e) => setLibraryRequestTemplateDrafts(prev => ({
                                                                                ...prev,
                                                                                [entry.id]: { ...requestTemplateDraft, headers: e.target.value }
                                                                            }))}
                                                                            disabled={!isEditing}
                                                                            className={`w-full h-24 text-[9px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-200'
                                                                                : 'bg-white border-zinc-300 text-zinc-800'
                                                                                }`}
                                                                        />
                                                                    </div>
                                                                    <div className="col-span-6 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('请求体（JSON / Raw）')}</label>
                                                                        <textarea
                                                                            value={requestTemplateDraft.body}
                                                                            onChange={(e) => setLibraryRequestTemplateDrafts(prev => ({
                                                                                ...prev,
                                                                                [entry.id]: { ...requestTemplateDraft, body: e.target.value }
                                                                            }))}
                                                                            disabled={!isEditing}
                                                                            className={`w-full h-24 text-[9px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-200'
                                                                                : 'bg-white border-zinc-300 text-zinc-800'
                                                                                }`}
                                                                        />
                                                                    </div>
                                                                </div>
                                                                <div className="grid grid-cols-12 gap-2 mt-2">
                                                                    <div className="col-span-6 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>Query（JSON）</label>
                                                                        <textarea
                                                                            value={requestTemplateDraft.query}
                                                                            onChange={(e) => setLibraryRequestTemplateDrafts(prev => ({
                                                                                ...prev,
                                                                                [entry.id]: { ...requestTemplateDraft, query: e.target.value }
                                                                            }))}
                                                                            disabled={!isEditing}
                                                                            className={`w-full h-20 text-[9px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-200'
                                                                                : 'bg-white border-zinc-300 text-zinc-800'
                                                                                }`}
                                                                        />
                                                                    </div>
                                                                    <div className="col-span-6 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>Files（JSON）</label>
                                                                        <textarea
                                                                            value={requestTemplateDraft.files}
                                                                            onChange={(e) => setLibraryRequestTemplateDrafts(prev => ({
                                                                                ...prev,
                                                                                [entry.id]: { ...requestTemplateDraft, files: e.target.value }
                                                                            }))}
                                                                            disabled={!isEditing}
                                                                            className={`w-full h-20 text-[9px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-200'
                                                                                : 'bg-white border-zinc-300 text-zinc-800'
                                                                                }`}
                                                                        />
                                                                    </div>
                                                                </div>
                                                                <div className="grid grid-cols-12 gap-2 mt-2">
                                                                    <div className="col-span-4 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('超时（ms）')}</label>
                                                                        <input
                                                                            type="number"
                                                                            min="0"
                                                                            value={requestTemplateDraft.timeoutMs}
                                                                            onChange={(e) => setLibraryRequestTemplateDrafts(prev => ({
                                                                                ...prev,
                                                                                [entry.id]: { ...requestTemplateDraft, timeoutMs: e.target.value }
                                                                            }))}
                                                                            disabled={!isEditing}
                                                                            className={`w-full text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                                                : 'bg-white border-zinc-300 text-zinc-900'
                                                                                }`}
                                                                        />
                                                                    </div>
                                                                    <div className="col-span-8 space-y-1">
                                                                        <label className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('响应解析器')}</label>
                                                                        <input
                                                                            value={requestTemplateDraft.responseParser}
                                                                            onChange={(e) => setLibraryRequestTemplateDrafts(prev => ({
                                                                                ...prev,
                                                                                [entry.id]: { ...requestTemplateDraft, responseParser: e.target.value }
                                                                            }))}
                                                                            disabled={!isEditing}
                                                                            placeholder={t('例如：openai.image / jimeng.video')}
                                                                            className={`w-full text-[10px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-300 placeholder-zinc-600'
                                                                                : 'bg-white border-zinc-300 text-zinc-900 placeholder-zinc-400'
                                                                                }`}
                                                                        />
                                                                    </div>
                                                                </div>
                                                                <div className="flex items-center justify-between mt-2">
                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>
                                                                        变量示例：{'{{prompt}}'}, {'{{duration:number}}'}, {'{{image:blob}}'}, {'{{size}}'}
                                                                    </div>
                                                                    <div className="flex items-center gap-2">
                                                                        <button
                                                                            onClick={() => {
                                                                                try {
                                                                                    const headersText = requestTemplateDraft.headers?.trim() || '{}';
                                                                                    const bodyText = requestTemplateDraft.body ?? '';
                                                                                    const queryText = requestTemplateDraft.query?.trim() || '{}';
                                                                                    const filesText = requestTemplateDraft.files?.trim() || '{}';
                                                                                    const parsedHeaders = headersText ? JSON.parse(headersText) : {};
                                                                                    if (!parsedHeaders || typeof parsedHeaders !== 'object' || Array.isArray(parsedHeaders)) {
                                                                                        throw new Error('请求头必须是对象');
                                                                                    }
                                                                                    const parsedQuery = queryText ? JSON.parse(queryText) : {};
                                                                                    if (!parsedQuery || typeof parsedQuery !== 'object' || Array.isArray(parsedQuery)) {
                                                                                        throw new Error('Query 必须是对象');
                                                                                    }
                                                                                    const parsedFiles = filesText ? JSON.parse(filesText) : {};
                                                                                    if (!parsedFiles || typeof parsedFiles !== 'object' || Array.isArray(parsedFiles)) {
                                                                                        throw new Error('Files 必须是对象');
                                                                                    }
                                                                                    let parsedBody = bodyText;
                                                                                    if ((requestTemplateValue?.bodyType || 'json') !== 'raw') {
                                                                                        const rawBodyText = bodyText?.trim() || '{}';
                                                                                        parsedBody = rawBodyText ? JSON.parse(rawBodyText) : {};
                                                                                        if (!parsedBody || typeof parsedBody !== 'object') {
                                                                                            throw new Error('请求体必须是对象');
                                                                                        }
                                                                                    }
                                                                                    const timeoutRaw = requestTemplateDraft.timeoutMs;
                                                                                    const timeoutMs = timeoutRaw === '' || timeoutRaw === null || timeoutRaw === undefined
                                                                                        ? null
                                                                                        : Number(timeoutRaw);
                                                                                    if (timeoutMs !== null && (!Number.isFinite(timeoutMs) || timeoutMs < 0)) {
                                                                                        throw new Error('超时必须是非负数字');
                                                                                    }
                                                                                    const responseParser = (requestTemplateDraft.responseParser || '').trim();
                                                                                    updateRequestTemplate({
                                                                                        headers: parsedHeaders,
                                                                                        body: parsedBody,
                                                                                        query: parsedQuery,
                                                                                        files: parsedFiles,
                                                                                        timeoutMs,
                                                                                        responseParser
                                                                                    });
                                                                                    setLibraryRequestTemplateDrafts(prev => {
                                                                                        const { [entry.id]: _removed, ...rest } = prev;
                                                                                        return rest;
                                                                                    });
                                                                                    showToast('请求模板已保存', 'success', 2000);
                                                                                } catch (e) {
                                                                                    showToast('请求模板 JSON 格式无效', 'error', 2000);
                                                                                }
                                                                            }}
                                                                            disabled={!isEditing}
                                                                            className={`px-2 py-1 rounded text-[9px] ${theme === 'dark'
                                                                                ? 'bg-zinc-700 text-zinc-200 hover:bg-zinc-600'
                                                                                : 'bg-zinc-200 text-zinc-700 hover:bg-zinc-300'
                                                                                } ${!isEditing ? 'opacity-60 cursor-not-allowed' : ''}`}
                                                                        >
                                                                            {t('保存模板')}
                                                                        </button>
                                                                        <button
                                                                            onClick={() => {
                                                                                updateModelLibraryEntry(entry.id, { requestTemplate: getDefaultRequestTemplateForEntry(entry) });
                                                                                setLibraryRequestTemplateDrafts(prev => {
                                                                                    const { [entry.id]: _removed, ...rest } = prev;
                                                                                    return rest;
                                                                                });
                                                                            }}
                                                                            disabled={!isEditing}
                                                                            className={`px-2 py-1 rounded text-[9px] ${theme === 'dark'
                                                                                ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                                                : 'bg-zinc-100 text-zinc-500 hover:bg-zinc-200'
                                                                                } ${!isEditing ? 'opacity-60 cursor-not-allowed' : ''}`}
                                                                        >
                                                                            {t('重置')}
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                                </>
                                                                )}
                                                            </div>
                                                            <div className={`rounded-md border p-2 mt-3 ${theme === 'dark'
                                                                ? 'bg-zinc-950/60 border-zinc-800'
                                                                : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                                                }`}>
                                                                <div className="flex items-center justify-between mb-2">
                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('异步任务（通用轮询）')}</div>
                                                                    <div className="flex items-center gap-2">
                                                                        <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                            <input
                                                                                type="checkbox"
                                                                                checked={asyncConfigEnabled}
                                                                                onChange={(e) => {
                                                                                    const enabled = e.target.checked;
                                                                                    const baseConfig = asyncConfigValue || buildEmptyAsyncConfig();
                                                                                    updateModelLibraryEntry(entry.id, { asyncConfig: { ...baseConfig, enabled } });
                                                                                }}
                                                                                disabled={!isEditing}
                                                                            />
                                                                            <span>{t('启用')}</span>
                                                                        </label>
                                                                        <button
                                                                            onClick={() => {
                                                                                if (isAsyncSectionCollapsed) {
                                                                                    toggleLibrarySectionCollapsed(entry.id, 'async-task');
                                                                                }
                                                                                toggleLibraryAsyncPreview(entry.id);
                                                                            }}
                                                                            className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                            title={isAsyncPreviewOpen ? t('隐藏预览') : t('查看预览')}
                                                                        >
                                                                            <Code size={12} className={isAsyncPreviewOpen ? 'text-blue-500' : ''} />
                                                                        </button>
                                                                        <button
                                                                            onClick={() => toggleLibrarySectionCollapsed(entry.id, 'async-task')}
                                                                            className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                            title={isAsyncSectionCollapsed ? t('展开') : t('折叠')}
                                                                        >
                                                                            <ChevronDown size={12} className={`transition-transform ${isAsyncSectionCollapsed ? '' : 'rotate-180'}`} />
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                                {!isAsyncSectionCollapsed && (
                                                                    <>
                                                                        <textarea
                                                                            value={asyncConfigDraft}
                                                                            onChange={(e) => setLibraryAsyncConfigDrafts(prev => ({ ...prev, [entry.id]: e.target.value }))}
                                                                            disabled={!isEditing}
                                                                            className={`w-full h-48 text-[9px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                ? 'bg-zinc-900 border-zinc-800 text-zinc-200'
                                                                                : 'bg-white border-zinc-300 text-zinc-800'
                                                                                }`}
                                                                        />
                                                                        <div className="flex items-center justify-between mt-2">
                                                                            <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}`}>
                                                                                变量示例：{'{{requestId}}'}, {'{{provider.key}}'}, {'{{provider.baseUrl}}'}
                                                                            </div>
                                                                            <div className="flex items-center gap-2">
                                                                                <button
                                                                                    onClick={() => {
                                                                                        try {
                                                                                            const parsed = asyncConfigDraft ? JSON.parse(asyncConfigDraft) : {};
                                                                                            if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
                                                                                                throw new Error('异步配置必须是对象');
                                                                                            }
                                                                                            updateModelLibraryEntry(entry.id, { asyncConfig: parsed });
                                                                                            setLibraryAsyncConfigDrafts(prev => {
                                                                                                const { [entry.id]: _removed, ...rest } = prev;
                                                                                                return rest;
                                                                                            });
                                                                                            showToast('异步配置已保存', 'success', 2000);
                                                                                        } catch (e) {
                                                                                            showToast('异步配置 JSON 格式无效', 'error', 2000);
                                                                                        }
                                                                                    }}
                                                                                    disabled={!isEditing}
                                                                                    className={`px-2 py-1 rounded text-[9px] ${theme === 'dark'
                                                                                        ? 'bg-zinc-700 text-zinc-200 hover:bg-zinc-600'
                                                                                        : 'bg-zinc-200 text-zinc-700 hover:bg-zinc-300'
                                                                                        } ${!isEditing ? 'opacity-60 cursor-not-allowed' : ''}`}
                                                                                >
                                                                                    {t('保存异步配置')}
                                                                                </button>
                                                                                <button
                                                                                    onClick={() => {
                                                                                        updateModelLibraryEntry(entry.id, { asyncConfig: null });
                                                                                        setLibraryAsyncConfigDrafts(prev => {
                                                                                            const { [entry.id]: _removed, ...rest } = prev;
                                                                                            return rest;
                                                                                        });
                                                                                    }}
                                                                                    disabled={!isEditing}
                                                                                    className={`px-2 py-1 rounded text-[9px] ${theme === 'dark'
                                                                                        ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                                                        : 'bg-zinc-100 text-zinc-500 hover:bg-zinc-200'
                                                                                        } ${!isEditing ? 'opacity-60 cursor-not-allowed' : ''}`}
                                                                                >
                                                                                    {t('重置')}
                                                                                </button>
                                                                            </div>
                                                                        </div>
                                                                        {isAsyncPreviewOpen && (
                                                                            <div className={`mt-2 rounded-md border p-2 ${theme === 'dark'
                                                                                ? 'bg-zinc-950/60 border-zinc-800'
                                                                                : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                                                                }`}>
                                                                                <div className={`text-[9px] mb-1 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('状态请求预览')}</div>
                                                                                {asyncStatusPreview ? (
                                                                                    <pre className={`text-[9px] whitespace-pre-wrap ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                                        {JSON.stringify(asyncStatusPreview, null, 2)}
                                                                                    </pre>
                                                                                ) : (
                                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>{t('未配置')}</div>
                                                                                )}
                                                                                <div className={`text-[9px] mt-2 mb-1 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('结果请求预览')}</div>
                                                                                {asyncOutputsPreview ? (
                                                                                    <pre className={`text-[9px] whitespace-pre-wrap ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                                        {JSON.stringify(asyncOutputsPreview, null, 2)}
                                                                                    </pre>
                                                                                ) : (
                                                                                    <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>{t('未配置')}</div>
                                                                                )}
                                                                            </div>
                                                                        )}
                                                                    </>
                                                                )}
                                                            </div>
                                                            {isPreviewOpen && (
                                                                <div className={`rounded-md border p-2 ${theme === 'dark'
                                                                    ? 'bg-zinc-950/60 border-zinc-800'
                                                                    : theme === 'solarized' ? 'bg-[#fdf6e3] border-[#eee8d5]' : 'bg-zinc-50 border-zinc-200'
                                                                    }`}>
                                                                    <div className="flex items-center justify-between mb-1">
                                                                        <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('请求预览（JSON）')}</div>
                                                                        <div className="flex items-center gap-2">
                                                                            <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                <input
                                                                                    type="checkbox"
                                                                                    checked={!!entry.previewOverrideEnabled}
                                                                                    onChange={(e) => updateModelLibraryEntry(entry.id, { previewOverrideEnabled: e.target.checked })}
                                                                                />
                                                                                <span>{t('修改覆盖')}</span>
                                                                            </label>
                                                                            <button
                                                                                onClick={() => {
                                                                                    if (isPreviewEditing) {
                                                                                        setLibraryPreviewEditing(prev => {
                                                                                            const next = new Set(prev);
                                                                                            next.delete(entry.id);
                                                                                            return next;
                                                                                        });
                                                                                        setLibraryPreviewDrafts(prev => {
                                                                                            const { [entry.id]: _removed, ...rest } = prev;
                                                                                            return rest;
                                                                                        });
                                                                                    } else {
                                                                                        setLibraryPreviewEditing(prev => {
                                                                                            const next = new Set(prev);
                                                                                            next.add(entry.id);
                                                                                            return next;
                                                                                        });
                                                                                        setLibraryPreviewDrafts(prev => ({
                                                                                            ...prev,
                                                                                            [entry.id]: JSON.stringify(previewPayload, null, 2)
                                                                                        }));
                                                                                    }
                                                                                }}
                                                                                className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                title={isPreviewEditing ? t('取消编辑') : t('编辑预览')}
                                                                            >
                                                                                <Edit3 size={12} className={isPreviewEditing ? 'text-blue-500' : ''} />
                                                                            </button>
                                                                        </div>
                                                                    </div>
                                                                    <div className={`text-[9px] mb-1 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>Endpoint: {previewEndpoint}</div>
                                                                    {isPreviewEditing ? (
                                                                        <div className="space-y-2">
                                                                            <textarea
                                                                                value={previewDraft}
                                                                                onChange={(e) => setLibraryPreviewDrafts(prev => ({ ...prev, [entry.id]: e.target.value }))}
                                                                                className={`w-full h-40 text-[9px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                    ? 'bg-zinc-900 border-zinc-800 text-zinc-200'
                                                                                    : 'bg-white border-zinc-300 text-zinc-800'
                                                                                    }`}
                                                                            />
                                                                            <div className="flex items-center justify-end gap-2">
                                                                                <button
                                                                                    onClick={() => {
                                                                                        try {
                                                                                            const parsed = previewDraft ? JSON.parse(previewDraft) : {};
                                                                                            if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
                                                                                                throw new Error('预览 JSON 必须是对象');
                                                                                            }
                                                                                            const patch = buildPreviewOverridePatch(previewPayloadBase, parsed);
                                                                                            updateModelLibraryEntry(entry.id, { previewOverridePatch: patch });
                                                                                            setLibraryPreviewEditing(prev => {
                                                                                                const next = new Set(prev);
                                                                                                next.delete(entry.id);
                                                                                                return next;
                                                                                            });
                                                                                            setLibraryPreviewDrafts(prev => {
                                                                                                const { [entry.id]: _removed, ...rest } = prev;
                                                                                                return rest;
                                                                                            });
                                                                                            showToast('预览参数已更新', 'success', 2000);
                                                                                        } catch (e) {
                                                                                            showToast('JSON 格式无效，请检查后再保存', 'error', 2000);
                                                                                        }
                                                                                    }}
                                                                                    className={`px-2 py-1 rounded text-[9px] ${theme === 'dark'
                                                                                        ? 'bg-zinc-700 text-zinc-200 hover:bg-zinc-600'
                                                                                        : 'bg-zinc-200 text-zinc-700 hover:bg-zinc-300'
                                                                                        }`}
                                                                                >
                                                                                    {t('保存')}
                                                                                </button>
                                                                                <button
                                                                                    onClick={() => {
                                                                                        setLibraryPreviewEditing(prev => {
                                                                                            const next = new Set(prev);
                                                                                            next.delete(entry.id);
                                                                                            return next;
                                                                                        });
                                                                                        setLibraryPreviewDrafts(prev => {
                                                                                            const { [entry.id]: _removed, ...rest } = prev;
                                                                                            return rest;
                                                                                        });
                                                                                    }}
                                                                                    className={`px-2 py-1 rounded text-[9px] ${theme === 'dark'
                                                                                        ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                                                        : 'bg-zinc-100 text-zinc-500 hover:bg-zinc-200'
                                                                                        }`}
                                                                                >
                                                                                    {t('取消')}
                                                                                </button>
                                                                            </div>
                                                                        </div>
                                                                    ) : (
                                                                        <pre className={`text-[9px] whitespace-pre-wrap ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                            {JSON.stringify(previewPayload, null, 2)}
                                                                        </pre>
                                                                    )}
                                                                    <div className={`text-[9px] mt-2 mb-1 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('Python 示例')}</div>
                                                                    <pre className={`text-[9px] whitespace-pre-wrap ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                        {previewPython}
                                                                    </pre>
                                                                    <div className="mt-3 pt-2 border-t border-dashed border-zinc-400/30">
                                                                        <div className="flex items-center justify-between mb-1">
                                                                            <div className={`text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>{t('最终请求预览')}</div>
                                                                            <div className="flex items-center gap-2">
                                                                                <label className={`flex items-center gap-1 text-[9px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                                    <input
                                                                                        type="checkbox"
                                                                                        checked={!!entry.requestOverrideEnabled}
                                                                                        onChange={(e) => updateModelLibraryEntry(entry.id, { requestOverrideEnabled: e.target.checked })}
                                                                                    />
                                                                                    <span>{t('修改覆盖')}</span>
                                                                                </label>
                                                                                <button
                                                                                    onClick={() => {
                                                                                        if (isRequestPreviewEditing) {
                                                                                            setLibraryRequestPreviewEditing(prev => {
                                                                                                const next = new Set(prev);
                                                                                                next.delete(entry.id);
                                                                                                return next;
                                                                                            });
                                                                                            setLibraryRequestPreviewDrafts(prev => {
                                                                                                const { [entry.id]: _removed, ...rest } = prev;
                                                                                                return rest;
                                                                                            });
                                                                                        } else {
                                                                                            setLibraryRequestPreviewEditing(prev => {
                                                                                                const next = new Set(prev);
                                                                                                next.add(entry.id);
                                                                                                return next;
                                                                                            });
                                                                                            setLibraryRequestPreviewDrafts(prev => ({
                                                                                                ...prev,
                                                                                                [entry.id]: requestPreviewDisplay ? JSON.stringify(requestPreviewDisplay, null, 2) : ''
                                                                                            }));
                                                                                        }
                                                                                    }}
                                                                                    className={`p-1 rounded ${theme === 'dark' ? 'text-zinc-500 hover:text-zinc-300' : 'text-zinc-400 hover:text-zinc-600'}`}
                                                                                    title={isRequestPreviewEditing ? t('取消编辑') : t('编辑请求')}
                                                                                >
                                                                                    <Edit3 size={12} className={isRequestPreviewEditing ? 'text-blue-500' : ''} />
                                                                                </button>
                                                                            </div>
                                                                        </div>
                                                                        <div className={`text-[9px] mb-1 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                                                            模板状态：{requestTemplateEnabled ? t('已启用') : t('未启用')} · BodyType: {requestTemplateValue?.bodyType || 'json'}
                                                                        </div>
                                                                        {isRequestPreviewEditing ? (
                                                                            <div className="space-y-2">
                                                                                <textarea
                                                                                    value={requestPreviewDraft}
                                                                                    onChange={(e) => setLibraryRequestPreviewDrafts(prev => ({ ...prev, [entry.id]: e.target.value }))}
                                                                                    className={`w-full h-40 text-[9px] rounded px-2 py-1 border outline-none ${theme === 'dark'
                                                                                        ? 'bg-zinc-900 border-zinc-800 text-zinc-200'
                                                                                        : 'bg-white border-zinc-300 text-zinc-800'
                                                                                        }`}
                                                                                />
                                                                                <div className="flex items-center justify-end gap-2">
                                                                                    <button
                                                                                        onClick={() => {
                                                                                            try {
                                                                                                const parsed = requestPreviewDraft ? JSON.parse(requestPreviewDraft) : {};
                                                                                                if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
                                                                                                    throw new Error('请求预览必须是对象');
                                                                                                }
                                                                                                const patch = buildPreviewOverridePatch(requestPreviewDisplay || {}, parsed);
                                                                                                updateModelLibraryEntry(entry.id, { requestOverridePatch: patch });
                                                                                                setLibraryRequestPreviewEditing(prev => {
                                                                                                    const next = new Set(prev);
                                                                                                    next.delete(entry.id);
                                                                                                    return next;
                                                                                                });
                                                                                                setLibraryRequestPreviewDrafts(prev => {
                                                                                                    const { [entry.id]: _removed, ...rest } = prev;
                                                                                                    return rest;
                                                                                                });
                                                                                                showToast('请求覆盖已更新', 'success', 2000);
                                                                                            } catch (e) {
                                                                                                showToast('请求预览 JSON 无效', 'error', 2000);
                                                                                            }
                                                                                        }}
                                                                                        className={`px-2 py-1 rounded text-[9px] ${theme === 'dark'
                                                                                            ? 'bg-zinc-700 text-zinc-200 hover:bg-zinc-600'
                                                                                            : 'bg-zinc-200 text-zinc-700 hover:bg-zinc-300'
                                                                                            }`}
                                                                                    >
                                                                                        {t('保存')}
                                                                                    </button>
                                                                                    <button
                                                                                        onClick={() => {
                                                                                            setLibraryRequestPreviewEditing(prev => {
                                                                                                const next = new Set(prev);
                                                                                                next.delete(entry.id);
                                                                                                return next;
                                                                                            });
                                                                                            setLibraryRequestPreviewDrafts(prev => {
                                                                                                const { [entry.id]: _removed, ...rest } = prev;
                                                                                                return rest;
                                                                                            });
                                                                                        }}
                                                                                        className={`px-2 py-1 rounded text-[9px] ${theme === 'dark'
                                                                                            ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                                                            : 'bg-zinc-100 text-zinc-500 hover:bg-zinc-200'
                                                                                            }`}
                                                                                    >
                                                                                        {t('取消')}
                                                                                    </button>
                                                                                </div>
                                                                            </div>
                                                                        ) : (
                                                                            <pre className={`text-[9px] whitespace-pre-wrap ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                                {requestPreviewDisplay ? JSON.stringify(requestPreviewDisplay, null, 2) : '请求模板为空'}
                                                                            </pre>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                            )}
                                                        </>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                    <p className="text-[9px] text-zinc-500">提示：映射提示名仅用于展示，模型ID用于真实调用；不填写列表将使用默认限制。</p>
                                </div>
                            )}

                            <div className={`pt-2 flex justify-end gap-2 border-t mt-3 ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'}`}>
                                <Button variant="secondary" onClick={() => setSettingsOpen(false)}>{t('关闭')}</Button>
                            </div>


                        </Modal>

                        {/* 批量素材管理模态框 */}
                        {batchModalOpen && (
                            <div className="fixed inset-0 z-50 flex items-center justify-center">
                                <div
                                    className="absolute inset-0 bg-black/50 backdrop-blur-sm"
                                    onClick={() => {
                                        setBatchModalOpen(false);
                                        setBatchSelectedIds(new Set());
                                    }}
                                />
                                <div className={`relative w-[90vw] h-[85vh] max-w-7xl rounded-lg shadow-2xl flex flex-col ${theme === 'dark'
                                    ? 'bg-[#121214] border border-zinc-800'
                                    : theme === 'solarized'
                                        ? 'bg-[#eee8d5] border border-[#d7cfb2]'
                                        : 'bg-white border border-zinc-200'
                                    }`}>
                                    {/* 顶部栏 */}
                                    <div className={`p-4 border-b flex items-center justify-between ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                        }`}>
                                        <div className="flex items-center gap-4">
                                            <h2 className={`text-lg font-bold ${theme === 'dark' ? 'text-zinc-100' : 'text-zinc-900'
                                                }`}>
                                                {t('批量素材管理')}
                                            </h2>
                                            <span className={`text-sm ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'
                                                }`}>
                                                已选中 {batchSelectedIds.size} 项
                                            </span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <button
                                                onClick={() => {
                                                    if (batchSelectedIds.size === history.length) {
                                                        setBatchSelectedIds(new Set());
                                                    } else {
                                                        setBatchSelectedIds(new Set(history.map(item => item.id)));
                                                    }
                                                }}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors ${theme === 'dark'
                                                    ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                    : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200'
                                                    }`}
                                            >
                                                {batchSelectedIds.size === history.length ? t('取消全选') : t('全选')}
                                            </button>
                                            <button
                                                onClick={() => {
                                                    if (batchSelectedIds.size === 0) return;
                                                    if (confirm(`确定要删除选中的 ${batchSelectedIds.size} 项吗？`)) {
                                                        setHistory(prev => {
                                                            const filtered = prev.filter(item => !batchSelectedIds.has(item.id));
                                                            // 立即保存到 localStorage，不等待防抖
                                                            try {
                                                                localStorage.setItem('tapnow_history', JSON.stringify(filtered));
                                                            } catch (e) {
                                                                console.error('立即保存历史记录失败:', e);
                                                            }
                                                            return filtered;
                                                        });
                                                        setBatchSelectedIds(new Set());
                                                    }
                                                }}
                                                disabled={batchSelectedIds.size === 0}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors flex items-center gap-1.5 ${batchSelectedIds.size === 0
                                                    ? theme === 'dark'
                                                        ? 'bg-zinc-800/50 text-zinc-600 cursor-not-allowed'
                                                        : 'bg-zinc-100 text-zinc-400 cursor-not-allowed'
                                                    : 'bg-red-600 text-white hover:bg-red-700'
                                                    }`}
                                            >
                                                <Trash2 size={14} />
                                                {t('批量删除')}
                                            </button>
                                            <button
                                                onClick={async () => {
                                                    if (batchSelectedIds.size === 0) return;
                                                    const baseUrl = (localServerUrl || '').replace(/\/+$/, '');
                                                    if (!baseUrl) {
                                                        showToast('本地服务地址为空', 'error');
                                                        return;
                                                    }
                                                    const selectedItems = history.filter(item => batchSelectedIds.has(item.id));
                                                    const files = selectedItems
                                                        .map(item => item.localFilePath || item.localCacheUrl)
                                                        .filter(Boolean);
                                                    if (files.length === 0) {
                                                        showToast('选中项没有本地缓存可清理', 'warning');
                                                        return;
                                                    }
                                                    try {
                                                        const res = await fetch(`${baseUrl}/delete-batch`, {
                                                            method: 'POST',
                                                            headers: { 'Content-Type': 'application/json' },
                                                            body: JSON.stringify({ files })
                                                        });
                                                        if (!res.ok) {
                                                            const errText = await res.text();
                                                            throw new Error(errText || '清理缓存失败');
                                                        }
                                                        const data = await res.json();
                                                        setHistory(prev => prev.map(item =>
                                                            batchSelectedIds.has(item.id)
                                                                ? { ...item, localCacheUrl: null, localFilePath: null }
                                                                : item
                                                        ));
                                                        showToast(data?.message || `已清理 ${files.length} 个缓存文件`, 'success');
                                                    } catch (err) {
                                                        showToast(`清理缓存失败: ${err.message || '网络错误'}`, 'error');
                                                    }
                                                }}
                                                disabled={batchSelectedIds.size === 0}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors flex items-center gap-1.5 ${batchSelectedIds.size === 0
                                                    ? theme === 'dark'
                                                        ? 'bg-zinc-800/50 text-zinc-600 cursor-not-allowed'
                                                        : 'bg-zinc-100 text-zinc-400 cursor-not-allowed'
                                                    : theme === 'dark'
                                                        ? 'bg-amber-600/30 text-amber-200 hover:bg-amber-600/40'
                                                        : 'bg-amber-100 text-amber-600 hover:bg-amber-200'
                                                    }`}
                                            >
                                                <Trash2 size={14} />
                                                {t('清理缓存')}
                                            </button>
                                            <button
                                                onClick={async () => {
                                                    if (batchSelectedIds.size === 0) return;
                                                    const selectedItems = history.filter(item =>
                                                        batchSelectedIds.has(item.id) && (item.url || item.localCacheUrl || item.originalUrl || item.mjOriginalUrl)
                                                    );
                                                    if (selectedItems.length === 0) {
                                                        alert(t('选中的项目中没有有效的素材'));
                                                        return;
                                                    }

                                                    // 获取画布中心坐标
                                                    const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);

                                                    // 计算起始位置（稍微偏移，避免重叠）
                                                    const startX = world.x;
                                                    const startY = world.y;

                                                    // 批量添加到画布
                                                    selectedItems.forEach((item, index) => {
                                                        const offsetX = (index % 5) * 20; // 每行5个，横向偏移
                                                        const offsetY = Math.floor(index / 5) * 20; // 纵向偏移

                                                        let content = item.localCacheUrl || item.url || item.originalUrl || item.mjOriginalUrl;
                                                        if (item.type === 'video' && !isVideoUrl(content)) {
                                                            content += (content.includes('?') ? '&' : '?') + 'force_video_display=true';
                                                        }

                                                        // 根据类型添加节点
                                                        if (item.type === 'image') {
                                                            // 尝试获取图片尺寸
                                                            (async () => {
                                                                try {
                                                                    const dims = await getImageDimensions(content);
                                                                    addNode('input-image', startX + offsetX, startY + offsetY, null, content, dims);
                                                                } catch (e) {
                                                                    addNode('input-image', startX + offsetX, startY + offsetY, null, content);
                                                                }
                                                            })();
                                                        } else if (item.type === 'video') {
                                                            addNode('video-input', startX + offsetX, startY + offsetY, null, content);
                                                        }
                                                    });

                                                    setBatchModalOpen(false);
                                                    setBatchSelectedIds(new Set());
                                                }}
                                                disabled={batchSelectedIds.size === 0}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors flex items-center gap-1.5 ${batchSelectedIds.size === 0
                                                    ? theme === 'dark'
                                                        ? 'bg-zinc-800/50 text-zinc-600 cursor-not-allowed'
                                                        : 'bg-zinc-100 text-zinc-400 cursor-not-allowed'
                                                    : 'bg-blue-600 text-white hover:bg-blue-700'
                                                    }`}
                                            >
                                                <ArrowRightSquare size={14} />
                                                {t('发送到画布')}
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setBatchModalOpen(false);
                                                    setBatchSelectedIds(new Set());
                                                }}
                                                className={`p-1.5 rounded transition-colors ${theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                                    }`}
                                            >
                                                <X size={18} />
                                            </button>
                                        </div>
                                    </div>

                                    {/* 内容区 - 网格布局 */}
                                    <div className="flex-1 overflow-y-auto custom-scrollbar p-4">
                                        <div className="grid grid-cols-4 gap-4">
                                            {history.map((item) => {
                                                const isSelected = batchSelectedIds.has(item.id);
                                                const fullModelName = item.modelName || item.apiConfig?.modelId || item.apiConfig?.model || item.apiConfig?.modelName || item.model || '未知模型';
                                                const modelDisplay = fullModelName.length > 12 ? `${fullModelName.slice(0, 9)}...` : fullModelName;
                                                const baseUrl = (localCacheActive ? (item.localCacheUrl || (item.localCacheMap ? Object.values(item.localCacheMap)[0] : null)) : null) || item.url || item.originalUrl || item.mjOriginalUrl;
                                                const previewImages = item.mjImages && item.mjImages.length > 0
                                                    ? item.mjImages
                                                    : (item.output_images && item.output_images.length > 0 ? item.output_images : null);
                                                const mappedPreviewImages = previewImages
                                                    ? previewImages.map((url) => (localCacheActive && item.localCacheMap && item.localCacheMap[url]) ? item.localCacheMap[url] : url)
                                                    : null;
                                                const selectedIndex = typeof item.selectedMjImageIndex === 'number' ? item.selectedMjImageIndex : 0;
                                                const safeIndex = mappedPreviewImages ? Math.min(selectedIndex, mappedPreviewImages.length - 1) : 0;
                                                const gridImages = mappedPreviewImages && mappedPreviewImages.length >= 4
                                                    ? mappedPreviewImages.slice(0, 4)
                                                    : null;
                                                const gridSelectedIndex = gridImages ? Math.min(safeIndex, gridImages.length - 1) : 0;
                                                const displayUrl = mappedPreviewImages
                                                    ? (mappedPreviewImages[safeIndex] || mappedPreviewImages[0])
                                                    : baseUrl;
                                                const resolvedDisplayUrl = resolveHistoryUrl(item, displayUrl);
                                                const resolvedGridImages = gridImages
                                                    ? gridImages.map((img) => resolveHistoryUrl(item, img)).filter(Boolean)
                                                    : null;
                                                const hasBackendCache = !!(localCacheActive && (item.localCacheUrl || item.localFilePath || (item.localCacheMap && Object.keys(item.localCacheMap).length > 0)));
                                                const isVideoItem = item.type === 'video' || (resolvedDisplayUrl ? isVideoUrl(resolvedDisplayUrl) : false);
                                                const ratioValue = item.ratio || item.mjRatio || '';
                                                const rawResolution = item.resolution || (item.width && item.height ? `${item.width}x${item.height}` : '');
                                                const resolutionValue = rawResolution ? rawResolution.replace(/p$/i, '') : '';
                                                const durationValue = isVideoItem && item.duration ? `${String(item.duration).replace(/s$/i, '')}s` : '';
                                                const specParts = [ratioValue, resolutionValue].filter(Boolean);
                                                if (isVideoItem && durationValue) specParts.push(durationValue);
                                                const specText = specParts.join('/');
                                                const timeLabel = item.startTime
                                                    ? new Date(item.startTime).toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' })
                                                    : (item.time || '');
                                                const costLabel = typeof item.durationMs === 'number' && item.durationMs > 0
                                                    ? `${(item.durationMs / 60000).toFixed(1)}m`
                                                    : '';
                                                const genTypeLabel = isVideoItem
                                                    ? (item.hasInputImages ? '图→视' : '文→视')
                                                    : (item.hasInputImages ? '图→图' : '文→图');

                                                return (
                                                    <div
                                                        key={item.id}
                                                        className={`relative rounded-lg overflow-hidden border-2 transition-all ${isSelected
                                                            ? 'border-blue-500 shadow-lg shadow-blue-500/20'
                                                            : theme === 'dark'
                                                                ? 'border-zinc-800 hover:border-zinc-700'
                                                                : 'border-zinc-200 hover:border-zinc-300'
                                                            }`}
                                                    >
                                                        {/* 选中标记和查看按钮 */}
                                                        <div className="absolute top-2 right-2 z-10 flex items-center gap-1.5">
                                                            {isSelected && (
                                                                <div className="bg-blue-500 rounded-full p-1">
                                                                    <Check size={16} className="text-white" />
                                                                </div>
                                                            )}
                                                            {item.status === 'completed' && resolvedDisplayUrl && (
                                                                <button
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        // 准备要显示的item，确保包含正确的url和selectedMjImageIndex
                                                                        const displayItem = {
                                                                            ...item,
                                                                            mjImages: previewImages || getLightboxNavImages(item),
                                                                            url: resolvedDisplayUrl,
                                                                            selectedMjImageIndex: previewImages && previewImages.length > 1
                                                                                ? safeIndex
                                                                                : undefined
                                                                        };
                                                                        setLightboxItem(displayItem);
                                                                    }}
                                                                    className={`p-1.5 rounded-full transition-colors backdrop-blur-sm ${theme === 'dark'
                                                                        ? 'bg-black/60 text-white hover:bg-black/80'
                                                                        : 'bg-white/80 text-zinc-700 hover:bg-white'
                                                                        }`}
                                                                    title={t('查看大图 (双击也可查看)')}
                                                                >
                                                                    <Maximize2 size={14} />
                                                                </button>
                                                            )}
                                                        </div>

                                                        {/* 缩略图 */}
                                                        <div className={`relative ${((previewImages && previewImages.length > 1) || (item.mjNeedsSplit && item.apiConfig?.modelId?.includes('mj')))
                                                            ? (() => {
                                                                const ratio = item.mjRatio || '1:1';
                                                                if (ratio === '16:9') return 'aspect-video';
                                                                if (ratio === '9:16') return 'aspect-[9/16]';
                                                                if (ratio === '4:3') return 'aspect-[4/3]';
                                                                if (ratio === '3:4') return 'aspect-[3/4]';
                                                                if (ratio === '21:9') return 'aspect-[21/9]';
                                                                return 'aspect-square';
                                                            })()
                                                            : 'aspect-video'
                                                            } ${theme === 'dark' ? 'bg-zinc-900' : 'bg-zinc-100'}`}>
                                                            {hasBackendCache && (
                                                                <div className="absolute top-2 left-2 z-10 text-[9px] px-2 py-0.5 rounded bg-orange-500 text-white shadow">
                                                                    后端缓存
                                                                </div>
                                                            )}
                                                            {item.status === 'completed' && (resolvedDisplayUrl || (resolvedGridImages && resolvedGridImages.length > 0)) ? (
                                                                isVideoItem ? (
                                                                    <ResolvedVideo
                                                                        src={resolvedDisplayUrl}
                                                                        className="w-full h-full object-contain"
                                                                        controls
                                                                        playsInline
                                                                        preload="metadata"
                                                                    />
                                                                ) : resolvedGridImages && resolvedGridImages.length > 0 ? (
                                                                    <div className="grid grid-cols-2 grid-rows-2 w-full h-full">
                                                                        {resolvedGridImages.map((img, idx) => {
                                                                            const isActive = gridSelectedIndex === idx;
                                                                            return (
                                                                                <div
                                                                                    key={`${item.id}-${idx}`}
                                                                                    className={`relative w-full h-full cursor-pointer ${isActive ? 'ring-2 ring-blue-400' : ''}`}
                                                                                    onClick={(e) => {
                                                                                        e.stopPropagation();
                                                                                        setHistory(prev => prev.map(h =>
                                                                                            h.id === item.id ? { ...h, selectedMjImageIndex: idx } : h
                                                                                        ));
                                                                                    }}
                                                                                    onDoubleClick={(e) => {
                                                                                        e.preventDefault();
                                                                                        e.stopPropagation();
                                                                                        setLightboxItem({
                                                                                            ...item,
                                                                                            mjImages: previewImages || getLightboxNavImages(item),
                                                                                            url: img,
                                                                                            selectedMjImageIndex: idx
                                                                                        });
                                                                                    }}
                                                                                >
                                                                                    <LazyBase64Image
                                                                                        src={img}
                                                                                        className={`w-full h-full object-cover ${isActive ? 'opacity-80' : ''}`}
                                                                                        alt={`生成图-${idx + 1}`}
                                                                                    />
                                                                                    {isActive && (
                                                                                        <div className="absolute inset-0 bg-black/20 pointer-events-none"></div>
                                                                                    )}
                                                                                    <div className="absolute bottom-1 left-1 bg-black/60 text-white text-[9px] px-1.5 py-0.5 rounded">
                                                                                        {idx + 1}
                                                                                    </div>
                                                                                </div>
                                                                            );
                                                                        })}
                                                                    </div>
                                                                ) : (
                                                                    <LazyBase64Image
                                                                        src={resolvedDisplayUrl}
                                                                        className="w-full h-full object-contain"
                                                                        alt={t('生成图')}
                                                                        onError={(e) => {
                                                                            e.target.style.display = 'none';
                                                                        }}
                                                                    />
                                                                )
                                                            ) : (
                                                                <div className={`w-full h-full flex items-center justify-center ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'
                                                                    }`}>
                                                                    {item.status === 'generating' ? (
                                                                        <Loader2 size={24} className="animate-spin" />
                                                                    ) : (
                                                                        <FileImage size={24} />
                                                                    )}
                                                                </div>
                                                            )}
                                                        </div>

                                                        {/* 底部信息 */}
                                                        <div
                                                            onClick={() => {
                                                                const newSet = new Set(batchSelectedIds);
                                                                if (isSelected) {
                                                                    newSet.delete(item.id);
                                                                } else {
                                                                    newSet.add(item.id);
                                                                }
                                                                setBatchSelectedIds(newSet);
                                                            }}
                                                            className={`p-2 text-xs cursor-pointer ${theme === 'dark' ? 'bg-zinc-900 text-zinc-300' : 'bg-zinc-50 text-zinc-700'
                                                                }`}
                                                        >
                                                            <div className="truncate font-medium">{item.prompt || '未命名'}</div>
                                                            <div className="text-[10px] opacity-70 mt-0.5">
                                                                <span>{genTypeLabel} </span>
                                                                <span title={fullModelName}>{modelDisplay}</span>
                                                                {specText && <span> · {specText}</span>}
                                                                {timeLabel && <span> · {timeLabel}</span>}
                                                                {costLabel && <span> · {costLabel}</span>}
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>

                </div>
            </div >

            {/* V3.7.27: Toast 通知容器 */}
            < div className="fixed top-20 left-1/2 -translate-x-1/2 z-[9999] flex flex-col gap-2 pointer-events-none" >
                {
                    toasts.map(toast => (
                        <div
                            key={toast.id}
                            className={`px-4 py-2 rounded-lg shadow-lg text-sm font-medium pointer-events-auto animate-pulse ${toast.type === 'success' ? 'bg-green-600 text-white' :
                                toast.type === 'error' ? 'bg-red-600 text-white' :
                                    toast.type === 'warning' ? 'bg-yellow-500 text-black' :
                                        'bg-zinc-800 text-white'
                                }`}
                        >
                            {toast.message}
                        </div>
                    ))
                }
            </div >
        </>
    );
}

export default TapnowApp;




